{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Books \u00b6 Deep Learning Speech and Language Processing Probabilistic Machine Learning: An Introduction Probabilistic Machine Learning: Advanced Topics \u5e38\u7528\u7684\u547d\u4ee4 \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy - update and deploy","title":"\u4ecb\u7ecd"},{"location":"#books","text":"Deep Learning Speech and Language Processing Probabilistic Machine Learning: An Introduction Probabilistic Machine Learning: Advanced Topics","title":"Books"},{"location":"#_1","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy - update and deploy","title":"\u5e38\u7528\u7684\u547d\u4ee4"},{"location":"algo/back-tracking/","text":"\u5b9a\u4e49 \u00b6 \u56de\u6eaf\u662f\u4e00\u79cd\u8ba1\u7b97\u673a\u7b97\u6cd5\uff0c\u4e5f\u53eb\u8bd5\u63a2\u6cd5\uff0c\u4ece\u521d\u59cb\u72b6\u6001\u5f00\u59cb\u8bbf\u95ee\u6240\u6709\u72b6\u6001\uff0c\u5f53\u65e0\u6cd5\u6cbf\u7740\u67d0\u4e00\u8def\u5f84\u7ee7\u7eed\u8bbf\u95ee\u65f6\uff0c\u8fd4\u56de\u5230\u4e0a\u4e00\u4e2a\u5206\u53c9\u8def\u53e3\u3002\u901a\u5e38\u4ee5\u9012\u5f52\u7684\u65b9\u5f0f\u5b9e\u73b0\u3002 \u9898\u76ee \u00b6 \u5355\u8bcd\u5206\u62c6 I \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u4e32\u5217\u8868 wordDict \u4f5c\u4e3a\u5b57\u5178\u3002\u8bf7\u4f60\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5229\u7528\u5b57\u5178\u4e2d\u51fa\u73b0\u7684\u5355\u8bcd\u62fc\u63a5\u51fa s \u3002\u6ce8\u610f\uff1a\u4e0d\u8981\u6c42\u5b57\u5178\u4e2d\u51fa\u73b0\u7684\u5355\u8bcd\u5168\u90e8\u90fd\u4f7f\u7528\uff0c\u5e76\u4e14\u5b57\u5178\u4e2d\u7684\u5355\u8bcd\u53ef\u4ee5\u91cd\u590d\u4f7f\u7528\u3002\u8f93\u5165: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\uff0c\u8f93\u51fa: true\u3002\u89e3\u91ca: \u8fd4\u56de true \u56e0\u4e3a \"leetcode\" \u53ef\u4ee5\u7531 \"leet\" \u548c \"code\" \u62fc\u63a5\u6210\u3002 \u300c\u5206\u6790\u300d \u300c\u56de\u6eaf + \u8bb0\u5fc6\u5316dp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : unordered_map < string , bool > M ; unordered_set < string > W ; bool wordBreak ( string s , vector < string >& wordDict ) { for ( const string & w : wordDict ) { W . emplace ( w ); } return dfs ( s ); } bool dfs ( string s ) { if ( M . count ( s )) { return M [ s ]; } bool ans = false ; for ( auto w : W ) { const string & s1 = s . substr ( 0 , w . length ()); if ( s1 != w ) { continue ; } M [ s1 ] = true ; string s2 = s . substr ( w . length (), s . length () - w . length ()); if ( s2 . empty ()) { return true ; } if ( dfs ( s2 )) { M [ s2 ] = true ; return true ; } } M [ s ] = ans ; return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0cn \u662f\u5355\u8bcd\u7684\u957f\u5ea6\u3002 \u5355\u8bcd\u5206\u62c6 II \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u4e32\u5b57\u5178 wordDict \uff0c\u5728\u5b57\u7b26\u4e32 s \u4e2d\u589e\u52a0\u7a7a\u683c\u6765\u6784\u5efa\u4e00\u4e2a\u53e5\u5b50\uff0c\u4f7f\u5f97\u53e5\u5b50\u4e2d\u6240\u6709\u7684\u5355\u8bcd\u90fd\u5728\u8bcd\u5178\u4e2d\u3002\u4ee5\u4efb\u610f\u987a\u5e8f \u8fd4\u56de\u6240\u6709\u8fd9\u4e9b\u53ef\u80fd\u7684\u53e5\u5b50\u3002\u6ce8\u610f\uff1a\u8bcd\u5178\u4e2d\u7684\u540c\u4e00\u4e2a\u5355\u8bcd\u53ef\u80fd\u5728\u5206\u6bb5\u4e2d\u88ab\u91cd\u590d\u4f7f\u7528\u591a\u6b21\u3002\u4f8b\u5982\uff0c\u8f93\u5165:s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\uff0c\u8f93\u51fa:[\"cats and dog\",\"cat sand dog\"]\u3002 \u300c\u5206\u6790\u300d \u300c\u56de\u6eaf + \u8bb0\u5fc6\u5316dp\u300d \u904d\u5386 wordDict \u7684\u5355\u8bcd\uff0c\u5e76\u4e0e s \u7684\u524d\u7f00\u5bf9\u6bd4\uff0c\u5982\u679c\u5339\u914d\uff0c\u9012\u5f52\u5730\u5904\u7406 s \u7684\u5269\u4f59\u90e8\u5206\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : unordered_map < string , vector < string >> M ; unordered_set < string > words ; vector < string > wordBreak ( string s , vector < string >& wordDict ) { for ( const string & w : wordDict ) { words . emplace ( w ); } return dfs ( s ); } vector < string > dfs ( string s ) { vector < string > ans ; if ( s . empty ()) { return ans ; } if ( M . count ( s )) { return M [ s ]; } for ( auto w : words ) { if ( s . substr ( 0 , w . length ()) == w ) { string s2 = s . substr ( w . length (), s . length () - w . length ()); //printf(\"%s %s\\n\", w.c_str(), s2.c_str()); if ( s2 . empty ()) { ans . emplace_back ( w ); continue ; } vector < string > t2 = dfs ( s2 ); for ( const string & t : t2 ) { ans . emplace_back ( w + \" \" + t ); //printf(\"%s\\n\", ans.back().c_str()); } } } M [ s ] = ans ; return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0cn \u662f\u5355\u8bcd\u7684\u957f\u5ea6\u3002 \u5403\u6389 N \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570 \u00b6 \u53a8\u623f\u91cc\u603b\u5171\u6709 n \u4e2a\u6a58\u5b50\uff0c\u4f60\u51b3\u5b9a\u6bcf\u4e00\u5929\u9009\u62e9\u5982\u4e0b\u65b9\u5f0f\u4e4b\u4e00\u5403\u8fd9\u4e9b\u6a58\u5b50\uff1a 1\uff09\u5403\u6389\u4e00\u4e2a\u6a58\u5b50\u3002 2\uff09\u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 2 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 n/2 \u4e2a\u6a58\u5b50\u3002 3\uff09\u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 3 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 2*(n/3) \u4e2a\u6a58\u5b50\u3002 \u6bcf\u5929\u4f60\u53ea\u80fd\u4ece\u4ee5\u4e0a 3 \u79cd\u65b9\u6848\u4e2d\u9009\u62e9\u4e00\u79cd\u65b9\u6848\u3002\u8bf7\u4f60\u8fd4\u56de\u5403\u6389\u6240\u6709 n \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1an = 10 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u4f60\u603b\u5171\u6709 10 \u4e2a\u6a58\u5b50\u3002 \u7b2c 1 \u5929\uff1a\u5403 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 10 - 1 = 9\u3002 \u7b2c 2 \u5929\uff1a\u5403 6 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 9 - 2*(9/3) = 9 - 6 = 3\u3002\uff089 \u53ef\u4ee5\u88ab 3 \u6574\u9664\uff09 \u7b2c 3 \u5929\uff1a\u5403 2 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 3 - 2*(3/3) = 3 - 2 = 1\u3002 \u7b2c 4 \u5929\uff1a\u5403\u6389\u6700\u540e 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 1 - 1 = 0\u3002 \u4f60\u9700\u8981\u81f3\u5c11 4 \u5929\u5403\u6389 10 \u4e2a\u6a58\u5b50\u3002 \u300c\u5206\u6790\u300d \u300c\u8bb0\u5fc6\u5316\u52a8\u6001\u89c4\u5212\u300d\u4f18\u5148\u8003\u8651\u4f7f\u7528\u7b2c 2 \u79cd\u548c\u7b2c 3 \u79cd\u65b9\u6848\uff0c\u56e0\u4e3a\u6709\u5927\u91cf\u91cd\u590d\u5b50\u95ee\u9898\uff0c\u6240\u4ee5\u9700\u8981\u7528\u54c8\u5e0c\u8868\u5c06\u4e2d\u95f4\u7ed3\u679c\u4fdd\u5b58\u4e0b\u6765\uff0c\u907f\u514d\u91cd\u590d\u8ba1\u7b97\u3002 1 2 3 4 5 6 7 8 9 10 11 12 unordered_map < int , int > dict ; int minDays ( int n ) { if ( n <= 1 ) { return 1 ; } if ( dict . count ( n )) { return dict [ n ]; } int ans = min ( n % 2 + 1 + minDays ( n / 2 ), n % 3 + 1 + minDays ( n / 3 )); dict [ n ] = ans ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 N \u7687\u540e \u00b6 \u6309\u7167\u56fd\u9645\u8c61\u68cb\u7684\u89c4\u5219\uff0c\u7687\u540e\u53ef\u4ee5\u653b\u51fb\u4e0e\u4e4b\u5904\u5728\u540c\u4e00\u884c\u6216\u540c\u4e00\u5217\u6216\u540c\u4e00\u659c\u7ebf\u4e0a\u7684\u68cb\u5b50\u3002n \u7687\u540e\u95ee\u9898 \u7814\u7a76\u7684\u662f\u5982\u4f55\u5c06 n \u4e2a\u7687\u540e\u653e\u7f6e\u5728 n\u00d7n \u7684\u68cb\u76d8\u4e0a\uff0c\u5e76\u4e14\u4f7f\u7687\u540e\u5f7c\u6b64\u4e4b\u95f4\u4e0d\u80fd\u76f8\u4e92\u653b\u51fb\u3002\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 n \uff0c\u8fd4\u56de\u6240\u6709\u4e0d\u540c\u7684 n \u7687\u540e\u95ee\u9898 \u7684\u89e3\u51b3\u65b9\u6848\u3002\u6bcf\u4e00\u79cd\u89e3\u6cd5\u5305\u542b\u4e00\u4e2a\u4e0d\u540c\u7684 n \u7687\u540e\u95ee\u9898 \u7684\u68cb\u5b50\u653e\u7f6e\u65b9\u6848\uff0c\u8be5\u65b9\u6848\u4e2d 'Q' \u548c '.' \u5206\u522b\u4ee3\u8868\u4e86\u7687\u540e\u548c\u7a7a\u4f4d\u3002\u4f8b\u5982\uff0cn = 4\uff0c\u8fd4\u56de [ [\".Q..\", \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", \"Q...\", \"...Q\", \".Q..\"] ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; string str = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { str += \".\" ; } vector < string > res ( n , str ); unordered_set < int > col , diag1 , diag2 ; DFS ( col , diag1 , diag2 , n , 0 , ans , res ); return ans ; } void DFS ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int n , int i , vector < vector < string >> & ans , vector < string > & res ) { if ( i == n ) { ans . emplace_back ( res ); return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkPos ( col , diag1 , diag2 , i , j )) { res [ i ][ j ] = 'Q' ; col . insert ( j ); diag1 . insert ( i - j ); diag2 . insert ( i + j ); DFS ( col , diag1 , diag2 , n , i + 1 , ans , res ); res [ i ][ j ] = '.' ; col . erase ( j ); diag1 . erase ( i - j ); diag2 . erase ( i + j ); } } } bool isOkPos ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int i , int j ) { if ( col . find ( j ) != col . end () || diag1 . find ( i - j ) != diag1 . end () || diag2 . find ( i + j ) != diag2 . end ()) { return false ; } return true ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3002 \u89e3\u6570\u72ec \u00b6 \u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u901a\u8fc7\u586b\u5145\u7a7a\u683c\u6765\u89e3\u51b3\u6570\u72ec\u95ee\u9898\u3002\u6570\u72ec\u7684\u89e3\u6cd5\u9700 \u9075\u5faa\u5982\u4e0b\u89c4\u5219\uff1a \u6570\u5b57 1-9 \u5728\u6bcf\u4e00\u884c\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21\u3002 \u6570\u5b57 1-9 \u5728\u6bcf\u4e00\u5217\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21\u3002 \u6570\u5b57 1-9 \u5728\u6bcf\u4e00\u4e2a\u4ee5\u7c97\u5b9e\u7ebf\u5206\u9694\u7684 3x3 \u5bab\u5185\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21\u3002\uff08\u8bf7\u53c2\u8003\u793a\u4f8b\u56fe\uff09 \u6570\u72ec\u90e8\u5206\u7a7a\u683c\u5185\u5df2\u586b\u5165\u4e86\u6570\u5b57\uff0c\u7a7a\u767d\u683c\u7528 '.' \u8868\u793a\u3002 \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\\\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\\\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\\\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\\\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\\\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\\\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\\\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\\\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\\\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\\\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\\\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\\\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\\\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\\\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\\\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\\\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { isSolver ( board ); } bool isSolver ( vector < vector < char >> & board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { for ( char c = '1' ; c <= '9' ; c ++ ) { if ( isFeasible ( board , i , j , c )) { board [ i ][ j ] = c ; if ( isSolver ( board )) { return true ; } else { board [ i ][ j ] = '.' ; } } } // No feasible number return false ; } } } return true ; } bool isFeasible ( vector < vector < char >> board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ row ][ i ] == c ) { return false ; } if ( board [ i ][ col ] == c ) { return false ; } if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) { return false ; } } return true ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}2^{n}) O(n^{2}2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{3}) O(n^{3}) \u3002 \u6458\u6a31\u6843 \u00b6 \u7ed9\u4f60\u4e00\u4e2a n x n \u7684\u7f51\u683c grid \uff0c\u4ee3\u8868\u4e00\u5757\u6a31\u6843\u5730\uff0c\u6bcf\u4e2a\u683c\u5b50\u7531\u4ee5\u4e0b\u4e09\u79cd\u6570\u5b57\u7684\u4e00\u79cd\u6765\u8868\u793a\uff1a 0 \u8868\u793a\u8fd9\u4e2a\u683c\u5b50\u662f\u7a7a\u7684\uff0c\u6240\u4ee5\u4f60\u53ef\u4ee5\u7a7f\u8fc7\u5b83\u3002 1 \u8868\u793a\u8fd9\u4e2a\u683c\u5b50\u91cc\u88c5\u7740\u4e00\u4e2a\u6a31\u6843\uff0c\u4f60\u53ef\u4ee5\u6458\u5230\u6a31\u6843\u7136\u540e\u7a7f\u8fc7\u5b83\u3002 -1 \u8868\u793a\u8fd9\u4e2a\u683c\u5b50\u91cc\u6709\u8346\u68d8\uff0c\u6321\u7740\u4f60\u7684\u8def\u3002 \u8bf7\u4f60\u7edf\u8ba1\u5e76\u8fd4\u56de\uff1a\u5728\u9075\u5b88\u4e0b\u5217\u89c4\u5219\u7684\u60c5\u51b5\u4e0b\uff0c\u80fd\u6458\u5230\u7684\u6700\u591a\u6a31\u6843\u6570\uff1a \u4ece\u4f4d\u7f6e (0, 0) \u51fa\u53d1\uff0c\u6700\u540e\u5230\u8fbe (n - 1, n - 1) \uff0c\u53ea\u80fd\u5411\u4e0b\u6216\u5411\u53f3\u8d70\uff0c\u5e76\u4e14\u53ea\u80fd\u7a7f\u8d8a\u6709\u6548\u7684\u683c\u5b50\uff08\u5373\u53ea\u53ef\u4ee5\u7a7f\u8fc7\u503c\u4e3a 0 \u6216\u8005 1 \u7684\u683c\u5b50\uff09\uff1b\u5f53\u5230\u8fbe (n - 1, n - 1) \u540e\uff0c\u4f60\u8981\u7ee7\u7eed\u8d70\uff0c\u76f4\u5230\u8fd4\u56de\u5230 (0, 0) \uff0c\u53ea\u80fd\u5411\u4e0a\u6216\u5411\u5de6\u8d70\uff0c\u5e76\u4e14\u53ea\u80fd\u7a7f\u8d8a\u6709\u6548\u7684\u683c\u5b50\uff1b\u5f53\u4f60\u7ecf\u8fc7\u4e00\u4e2a\u683c\u5b50\u4e14\u8fd9\u4e2a\u683c\u5b50\u5305\u542b\u4e00\u4e2a\u6a31\u6843\u65f6\uff0c\u4f60\u5c06\u6458\u5230\u6a31\u6843\u5e76\u4e14\u8fd9\u4e2a\u683c\u5b50\u4f1a\u53d8\u6210\u7a7a\u7684\uff08\u503c\u53d8\u4e3a 0 \uff09\uff1b\u5982\u679c\u5728 (0, 0) \u548c (n - 1, n - 1) \u4e4b\u95f4\u4e0d\u5b58\u5728\u4e00\u6761\u53ef\u7ecf\u8fc7\u7684\u8def\u5f84\uff0c\u5219\u65e0\u6cd5\u6458\u5230\u4efb\u4f55\u4e00\u4e2a\u6a31\u6843\u3002 \u300c\u5206\u6790\u300d \u300cDFS\u300d\u4ece\u8d77\u70b9\u5230\u7ec8\u70b9\u540c\u65f6\u8d70\u4e24\u6761\u8def\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 */ class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { int n = int ( grid . size ()); if ( n == 0 ) { return 0 ; } vector < vector < vector < int >>> dp ( n , vector < vector < int >> ( n , vector < int > ( n , - 1 ))); int ans = move ( dp , grid , 0 , 0 , 0 , n ); return max ( 0 , ans ); } int move ( vector < vector < vector < int >>> & dp , vector < vector < int >> & grid , int r1 , int c1 , int c2 , int n ) { int r2 = r1 + c1 - c2 ; if ( r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid [ r1 ][ c1 ] == - 1 || grid [ r2 ][ c2 ] == - 1 ) { return - 2 ; } if ( r1 == n - 1 && c1 == n - 1 ) { return grid [ r1 ][ c1 ]; } if ( dp [ r1 ][ c1 ][ c2 ] != - 1 ) { return dp [ r1 ][ c1 ][ c2 ]; } int ans = move ( dp , grid , r1 , c1 + 1 , c2 + 1 , n ); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 + 1 , n )); ans = max ( ans , move ( dp , grid , r1 , c1 + 1 , c2 , n )); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 , n )); if ( ans >= 0 ) { ans += grid [ r1 ][ c1 ] + ( c1 != c2 || r1 != r2 ) * grid [ r2 ][ c2 ]; } dp [ r1 ][ c1 ][ c2 ] = ans ; return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \u3002","title":"\u56de\u6eaf"},{"location":"algo/back-tracking/#_1","text":"\u56de\u6eaf\u662f\u4e00\u79cd\u8ba1\u7b97\u673a\u7b97\u6cd5\uff0c\u4e5f\u53eb\u8bd5\u63a2\u6cd5\uff0c\u4ece\u521d\u59cb\u72b6\u6001\u5f00\u59cb\u8bbf\u95ee\u6240\u6709\u72b6\u6001\uff0c\u5f53\u65e0\u6cd5\u6cbf\u7740\u67d0\u4e00\u8def\u5f84\u7ee7\u7eed\u8bbf\u95ee\u65f6\uff0c\u8fd4\u56de\u5230\u4e0a\u4e00\u4e2a\u5206\u53c9\u8def\u53e3\u3002\u901a\u5e38\u4ee5\u9012\u5f52\u7684\u65b9\u5f0f\u5b9e\u73b0\u3002","title":"\u5b9a\u4e49"},{"location":"algo/back-tracking/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/back-tracking/#i","text":"\u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u4e32\u5217\u8868 wordDict \u4f5c\u4e3a\u5b57\u5178\u3002\u8bf7\u4f60\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5229\u7528\u5b57\u5178\u4e2d\u51fa\u73b0\u7684\u5355\u8bcd\u62fc\u63a5\u51fa s \u3002\u6ce8\u610f\uff1a\u4e0d\u8981\u6c42\u5b57\u5178\u4e2d\u51fa\u73b0\u7684\u5355\u8bcd\u5168\u90e8\u90fd\u4f7f\u7528\uff0c\u5e76\u4e14\u5b57\u5178\u4e2d\u7684\u5355\u8bcd\u53ef\u4ee5\u91cd\u590d\u4f7f\u7528\u3002\u8f93\u5165: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\uff0c\u8f93\u51fa: true\u3002\u89e3\u91ca: \u8fd4\u56de true \u56e0\u4e3a \"leetcode\" \u53ef\u4ee5\u7531 \"leet\" \u548c \"code\" \u62fc\u63a5\u6210\u3002 \u300c\u5206\u6790\u300d \u300c\u56de\u6eaf + \u8bb0\u5fc6\u5316dp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : unordered_map < string , bool > M ; unordered_set < string > W ; bool wordBreak ( string s , vector < string >& wordDict ) { for ( const string & w : wordDict ) { W . emplace ( w ); } return dfs ( s ); } bool dfs ( string s ) { if ( M . count ( s )) { return M [ s ]; } bool ans = false ; for ( auto w : W ) { const string & s1 = s . substr ( 0 , w . length ()); if ( s1 != w ) { continue ; } M [ s1 ] = true ; string s2 = s . substr ( w . length (), s . length () - w . length ()); if ( s2 . empty ()) { return true ; } if ( dfs ( s2 )) { M [ s2 ] = true ; return true ; } } M [ s ] = ans ; return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0cn \u662f\u5355\u8bcd\u7684\u957f\u5ea6\u3002","title":"\u5355\u8bcd\u5206\u62c6 I"},{"location":"algo/back-tracking/#ii","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u4e32\u5b57\u5178 wordDict \uff0c\u5728\u5b57\u7b26\u4e32 s \u4e2d\u589e\u52a0\u7a7a\u683c\u6765\u6784\u5efa\u4e00\u4e2a\u53e5\u5b50\uff0c\u4f7f\u5f97\u53e5\u5b50\u4e2d\u6240\u6709\u7684\u5355\u8bcd\u90fd\u5728\u8bcd\u5178\u4e2d\u3002\u4ee5\u4efb\u610f\u987a\u5e8f \u8fd4\u56de\u6240\u6709\u8fd9\u4e9b\u53ef\u80fd\u7684\u53e5\u5b50\u3002\u6ce8\u610f\uff1a\u8bcd\u5178\u4e2d\u7684\u540c\u4e00\u4e2a\u5355\u8bcd\u53ef\u80fd\u5728\u5206\u6bb5\u4e2d\u88ab\u91cd\u590d\u4f7f\u7528\u591a\u6b21\u3002\u4f8b\u5982\uff0c\u8f93\u5165:s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\uff0c\u8f93\u51fa:[\"cats and dog\",\"cat sand dog\"]\u3002 \u300c\u5206\u6790\u300d \u300c\u56de\u6eaf + \u8bb0\u5fc6\u5316dp\u300d \u904d\u5386 wordDict \u7684\u5355\u8bcd\uff0c\u5e76\u4e0e s \u7684\u524d\u7f00\u5bf9\u6bd4\uff0c\u5982\u679c\u5339\u914d\uff0c\u9012\u5f52\u5730\u5904\u7406 s \u7684\u5269\u4f59\u90e8\u5206\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : unordered_map < string , vector < string >> M ; unordered_set < string > words ; vector < string > wordBreak ( string s , vector < string >& wordDict ) { for ( const string & w : wordDict ) { words . emplace ( w ); } return dfs ( s ); } vector < string > dfs ( string s ) { vector < string > ans ; if ( s . empty ()) { return ans ; } if ( M . count ( s )) { return M [ s ]; } for ( auto w : words ) { if ( s . substr ( 0 , w . length ()) == w ) { string s2 = s . substr ( w . length (), s . length () - w . length ()); //printf(\"%s %s\\n\", w.c_str(), s2.c_str()); if ( s2 . empty ()) { ans . emplace_back ( w ); continue ; } vector < string > t2 = dfs ( s2 ); for ( const string & t : t2 ) { ans . emplace_back ( w + \" \" + t ); //printf(\"%s\\n\", ans.back().c_str()); } } } M [ s ] = ans ; return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n 2^{n}) O(n 2^{n}) \uff0cn \u662f\u5355\u8bcd\u7684\u957f\u5ea6\u3002","title":"\u5355\u8bcd\u5206\u62c6 II"},{"location":"algo/back-tracking/#n","text":"\u53a8\u623f\u91cc\u603b\u5171\u6709 n \u4e2a\u6a58\u5b50\uff0c\u4f60\u51b3\u5b9a\u6bcf\u4e00\u5929\u9009\u62e9\u5982\u4e0b\u65b9\u5f0f\u4e4b\u4e00\u5403\u8fd9\u4e9b\u6a58\u5b50\uff1a 1\uff09\u5403\u6389\u4e00\u4e2a\u6a58\u5b50\u3002 2\uff09\u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 2 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 n/2 \u4e2a\u6a58\u5b50\u3002 3\uff09\u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 3 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 2*(n/3) \u4e2a\u6a58\u5b50\u3002 \u6bcf\u5929\u4f60\u53ea\u80fd\u4ece\u4ee5\u4e0a 3 \u79cd\u65b9\u6848\u4e2d\u9009\u62e9\u4e00\u79cd\u65b9\u6848\u3002\u8bf7\u4f60\u8fd4\u56de\u5403\u6389\u6240\u6709 n \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1an = 10 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u4f60\u603b\u5171\u6709 10 \u4e2a\u6a58\u5b50\u3002 \u7b2c 1 \u5929\uff1a\u5403 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 10 - 1 = 9\u3002 \u7b2c 2 \u5929\uff1a\u5403 6 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 9 - 2*(9/3) = 9 - 6 = 3\u3002\uff089 \u53ef\u4ee5\u88ab 3 \u6574\u9664\uff09 \u7b2c 3 \u5929\uff1a\u5403 2 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 3 - 2*(3/3) = 3 - 2 = 1\u3002 \u7b2c 4 \u5929\uff1a\u5403\u6389\u6700\u540e 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 1 - 1 = 0\u3002 \u4f60\u9700\u8981\u81f3\u5c11 4 \u5929\u5403\u6389 10 \u4e2a\u6a58\u5b50\u3002 \u300c\u5206\u6790\u300d \u300c\u8bb0\u5fc6\u5316\u52a8\u6001\u89c4\u5212\u300d\u4f18\u5148\u8003\u8651\u4f7f\u7528\u7b2c 2 \u79cd\u548c\u7b2c 3 \u79cd\u65b9\u6848\uff0c\u56e0\u4e3a\u6709\u5927\u91cf\u91cd\u590d\u5b50\u95ee\u9898\uff0c\u6240\u4ee5\u9700\u8981\u7528\u54c8\u5e0c\u8868\u5c06\u4e2d\u95f4\u7ed3\u679c\u4fdd\u5b58\u4e0b\u6765\uff0c\u907f\u514d\u91cd\u590d\u8ba1\u7b97\u3002 1 2 3 4 5 6 7 8 9 10 11 12 unordered_map < int , int > dict ; int minDays ( int n ) { if ( n <= 1 ) { return 1 ; } if ( dict . count ( n )) { return dict [ n ]; } int ans = min ( n % 2 + 1 + minDays ( n / 2 ), n % 3 + 1 + minDays ( n / 3 )); dict [ n ] = ans ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002","title":"\u5403\u6389 N \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570"},{"location":"algo/back-tracking/#n_1","text":"\u6309\u7167\u56fd\u9645\u8c61\u68cb\u7684\u89c4\u5219\uff0c\u7687\u540e\u53ef\u4ee5\u653b\u51fb\u4e0e\u4e4b\u5904\u5728\u540c\u4e00\u884c\u6216\u540c\u4e00\u5217\u6216\u540c\u4e00\u659c\u7ebf\u4e0a\u7684\u68cb\u5b50\u3002n \u7687\u540e\u95ee\u9898 \u7814\u7a76\u7684\u662f\u5982\u4f55\u5c06 n \u4e2a\u7687\u540e\u653e\u7f6e\u5728 n\u00d7n \u7684\u68cb\u76d8\u4e0a\uff0c\u5e76\u4e14\u4f7f\u7687\u540e\u5f7c\u6b64\u4e4b\u95f4\u4e0d\u80fd\u76f8\u4e92\u653b\u51fb\u3002\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 n \uff0c\u8fd4\u56de\u6240\u6709\u4e0d\u540c\u7684 n \u7687\u540e\u95ee\u9898 \u7684\u89e3\u51b3\u65b9\u6848\u3002\u6bcf\u4e00\u79cd\u89e3\u6cd5\u5305\u542b\u4e00\u4e2a\u4e0d\u540c\u7684 n \u7687\u540e\u95ee\u9898 \u7684\u68cb\u5b50\u653e\u7f6e\u65b9\u6848\uff0c\u8be5\u65b9\u6848\u4e2d 'Q' \u548c '.' \u5206\u522b\u4ee3\u8868\u4e86\u7687\u540e\u548c\u7a7a\u4f4d\u3002\u4f8b\u5982\uff0cn = 4\uff0c\u8fd4\u56de [ [\".Q..\", \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", \"Q...\", \"...Q\", \".Q..\"] ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; string str = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { str += \".\" ; } vector < string > res ( n , str ); unordered_set < int > col , diag1 , diag2 ; DFS ( col , diag1 , diag2 , n , 0 , ans , res ); return ans ; } void DFS ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int n , int i , vector < vector < string >> & ans , vector < string > & res ) { if ( i == n ) { ans . emplace_back ( res ); return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkPos ( col , diag1 , diag2 , i , j )) { res [ i ][ j ] = 'Q' ; col . insert ( j ); diag1 . insert ( i - j ); diag2 . insert ( i + j ); DFS ( col , diag1 , diag2 , n , i + 1 , ans , res ); res [ i ][ j ] = '.' ; col . erase ( j ); diag1 . erase ( i - j ); diag2 . erase ( i + j ); } } } bool isOkPos ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int i , int j ) { if ( col . find ( j ) != col . end () || diag1 . find ( i - j ) != diag1 . end () || diag2 . find ( i + j ) != diag2 . end ()) { return false ; } return true ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3002","title":"N \u7687\u540e"},{"location":"algo/back-tracking/#_3","text":"\u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u901a\u8fc7\u586b\u5145\u7a7a\u683c\u6765\u89e3\u51b3\u6570\u72ec\u95ee\u9898\u3002\u6570\u72ec\u7684\u89e3\u6cd5\u9700 \u9075\u5faa\u5982\u4e0b\u89c4\u5219\uff1a \u6570\u5b57 1-9 \u5728\u6bcf\u4e00\u884c\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21\u3002 \u6570\u5b57 1-9 \u5728\u6bcf\u4e00\u5217\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21\u3002 \u6570\u5b57 1-9 \u5728\u6bcf\u4e00\u4e2a\u4ee5\u7c97\u5b9e\u7ebf\u5206\u9694\u7684 3x3 \u5bab\u5185\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21\u3002\uff08\u8bf7\u53c2\u8003\u793a\u4f8b\u56fe\uff09 \u6570\u72ec\u90e8\u5206\u7a7a\u683c\u5185\u5df2\u586b\u5165\u4e86\u6570\u5b57\uff0c\u7a7a\u767d\u683c\u7528 '.' \u8868\u793a\u3002 \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\\\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\\\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\\\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\\\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\\\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\\\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\\\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\\\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\\\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\\\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\\\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\\\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\\\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\\\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\\\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\\\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { isSolver ( board ); } bool isSolver ( vector < vector < char >> & board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { for ( char c = '1' ; c <= '9' ; c ++ ) { if ( isFeasible ( board , i , j , c )) { board [ i ][ j ] = c ; if ( isSolver ( board )) { return true ; } else { board [ i ][ j ] = '.' ; } } } // No feasible number return false ; } } } return true ; } bool isFeasible ( vector < vector < char >> board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ row ][ i ] == c ) { return false ; } if ( board [ i ][ col ] == c ) { return false ; } if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) { return false ; } } return true ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}2^{n}) O(n^{2}2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{3}) O(n^{3}) \u3002","title":"\u89e3\u6570\u72ec"},{"location":"algo/back-tracking/#_4","text":"\u7ed9\u4f60\u4e00\u4e2a n x n \u7684\u7f51\u683c grid \uff0c\u4ee3\u8868\u4e00\u5757\u6a31\u6843\u5730\uff0c\u6bcf\u4e2a\u683c\u5b50\u7531\u4ee5\u4e0b\u4e09\u79cd\u6570\u5b57\u7684\u4e00\u79cd\u6765\u8868\u793a\uff1a 0 \u8868\u793a\u8fd9\u4e2a\u683c\u5b50\u662f\u7a7a\u7684\uff0c\u6240\u4ee5\u4f60\u53ef\u4ee5\u7a7f\u8fc7\u5b83\u3002 1 \u8868\u793a\u8fd9\u4e2a\u683c\u5b50\u91cc\u88c5\u7740\u4e00\u4e2a\u6a31\u6843\uff0c\u4f60\u53ef\u4ee5\u6458\u5230\u6a31\u6843\u7136\u540e\u7a7f\u8fc7\u5b83\u3002 -1 \u8868\u793a\u8fd9\u4e2a\u683c\u5b50\u91cc\u6709\u8346\u68d8\uff0c\u6321\u7740\u4f60\u7684\u8def\u3002 \u8bf7\u4f60\u7edf\u8ba1\u5e76\u8fd4\u56de\uff1a\u5728\u9075\u5b88\u4e0b\u5217\u89c4\u5219\u7684\u60c5\u51b5\u4e0b\uff0c\u80fd\u6458\u5230\u7684\u6700\u591a\u6a31\u6843\u6570\uff1a \u4ece\u4f4d\u7f6e (0, 0) \u51fa\u53d1\uff0c\u6700\u540e\u5230\u8fbe (n - 1, n - 1) \uff0c\u53ea\u80fd\u5411\u4e0b\u6216\u5411\u53f3\u8d70\uff0c\u5e76\u4e14\u53ea\u80fd\u7a7f\u8d8a\u6709\u6548\u7684\u683c\u5b50\uff08\u5373\u53ea\u53ef\u4ee5\u7a7f\u8fc7\u503c\u4e3a 0 \u6216\u8005 1 \u7684\u683c\u5b50\uff09\uff1b\u5f53\u5230\u8fbe (n - 1, n - 1) \u540e\uff0c\u4f60\u8981\u7ee7\u7eed\u8d70\uff0c\u76f4\u5230\u8fd4\u56de\u5230 (0, 0) \uff0c\u53ea\u80fd\u5411\u4e0a\u6216\u5411\u5de6\u8d70\uff0c\u5e76\u4e14\u53ea\u80fd\u7a7f\u8d8a\u6709\u6548\u7684\u683c\u5b50\uff1b\u5f53\u4f60\u7ecf\u8fc7\u4e00\u4e2a\u683c\u5b50\u4e14\u8fd9\u4e2a\u683c\u5b50\u5305\u542b\u4e00\u4e2a\u6a31\u6843\u65f6\uff0c\u4f60\u5c06\u6458\u5230\u6a31\u6843\u5e76\u4e14\u8fd9\u4e2a\u683c\u5b50\u4f1a\u53d8\u6210\u7a7a\u7684\uff08\u503c\u53d8\u4e3a 0 \uff09\uff1b\u5982\u679c\u5728 (0, 0) \u548c (n - 1, n - 1) \u4e4b\u95f4\u4e0d\u5b58\u5728\u4e00\u6761\u53ef\u7ecf\u8fc7\u7684\u8def\u5f84\uff0c\u5219\u65e0\u6cd5\u6458\u5230\u4efb\u4f55\u4e00\u4e2a\u6a31\u6843\u3002 \u300c\u5206\u6790\u300d \u300cDFS\u300d\u4ece\u8d77\u70b9\u5230\u7ec8\u70b9\u540c\u65f6\u8d70\u4e24\u6761\u8def\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 */ class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { int n = int ( grid . size ()); if ( n == 0 ) { return 0 ; } vector < vector < vector < int >>> dp ( n , vector < vector < int >> ( n , vector < int > ( n , - 1 ))); int ans = move ( dp , grid , 0 , 0 , 0 , n ); return max ( 0 , ans ); } int move ( vector < vector < vector < int >>> & dp , vector < vector < int >> & grid , int r1 , int c1 , int c2 , int n ) { int r2 = r1 + c1 - c2 ; if ( r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid [ r1 ][ c1 ] == - 1 || grid [ r2 ][ c2 ] == - 1 ) { return - 2 ; } if ( r1 == n - 1 && c1 == n - 1 ) { return grid [ r1 ][ c1 ]; } if ( dp [ r1 ][ c1 ][ c2 ] != - 1 ) { return dp [ r1 ][ c1 ][ c2 ]; } int ans = move ( dp , grid , r1 , c1 + 1 , c2 + 1 , n ); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 + 1 , n )); ans = max ( ans , move ( dp , grid , r1 , c1 + 1 , c2 , n )); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 , n )); if ( ans >= 0 ) { ans += grid [ r1 ][ c1 ] + ( c1 != c2 || r1 != r2 ) * grid [ r2 ][ c2 ]; } dp [ r1 ][ c1 ][ c2 ] = ans ; return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \u3002","title":"\u6458\u6a31\u6843"},{"location":"algo/binary-search/","text":"\u57fa\u672c\u6982\u5ff5 \u00b6 \u4e8c\u5206\u67e5\u627e\u65f6\u4e00\u79cd\u9ad8\u6548\u7684\u67e5\u627e\u7b97\u6cd5\uff0c\u5b83\u8981\u6c42\u67e5\u627e\u7684\u6570\u7ec4\u662f\uff08\u5c40\u90e8\uff09\u6709\u5e8f\u7684\uff0c\u6bcf\u6b21\u53ef\u4ee5\u67e5\u627e\u540e\uff0c\u5229\u7528\u5355\u8c03\u6027\uff0c\u7f29\u5c0f\u4e00\u534a\u7684\u67e5\u627e\u8303\u56f4\u3002 \u6a21\u677f \u00b6 lower_bound \u00b6 lower_bound() \u67e5\u627e nums \u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e target \u7684\u4e0b\u6807\uff08\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u8fd4\u56de\u4e0b\u6807\u4e3a n\uff0c\u5373\u6570\u7ec4\u7684\u957f\u5ea6\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int lower_bound ( vector < int > & nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m ; } } return l ; } upper_bound \u00b6 upper_bound(nums, target) \u67e5\u627e nums \u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u5927\u4e8e target \u7684\u6570\u503c\u4e0b\u6807\uff08\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u540c\u4e0a\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int upper_bound ( vector < int > & nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] <= target ) { l = m + 1 ; } else { r = m ; } } return l ; } \u9898\u76ee \u00b6 \u7edd\u5bf9\u503c\u4e4b\u548c \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 nums1 = [1, 28, 21] \u548c nums2 = [9, 21, 20]\uff0c\u53ef\u4ee5\u5c06 nums1 \u4e2d\u7684\u67d0\u4e00\u4e2a\u503c\u7528\u53e6\u4e00\u4e2a\u503c\u66ff\u6362\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u7528\u66ff\u6362\uff0c\u6c42\u4e24\u4e2a\u6570\u7ec4\u76f8\u5bf9\u4f4d\u7f6e\u7684\u5dee\u7684\u7edd\u5bf9\u503c\u4e4b\u548c\u3002\u4e0a\u8ff0\u4f8b\u5b50\u7684\u7ed3\u679c\u662f 9\u3002 \u300c\u5206\u6790\u300d \u5dee\u7684\u7edd\u5bf9\u503c\u4e4b\u548c\u8ba1\u7b97\u65b9\u5f0f\u5982\u4e0b\uff1a \\text{sum} = \\sum_{i = 0}^{n-1} \\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| \\text{sum} = \\sum_{i = 0}^{n-1} \\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| \u5047\u8bbe\u6211\u4eec\u5728 i \u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\u53d1\u751f\u53d8\u52a8 \\arg \\min_{i \\in [0, n)} -\\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| + \\left \\| \\text{nums1[ j ] - nums2[ i ]} \\right \\| \\arg \\min_{i \\in [0, n)} -\\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| + \\left \\| \\text{nums1[ j ] - nums2[ i ]} \\right \\| \u8fd9\u91cc\uff0cj \u662f [0, n) \u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u503c\u3002\u6211\u4eec\u5e0c\u671b\u627e\u5230\u4e00\u4e2a i \u4f7f\u5f97\u4e0a\u5f0f\u6700\u5c0f\u3002\u6211\u4eec\u4f7f\u7528\u4e8c\u5206\u67e5\u627e\u7684\u65b9\u5f0f\uff0c\u627e\u5230\u6700\u9760\u8fd1 nums2[ i ] \u7684 j\uff0c\u9700\u8981\u5c06 nums1 \u6392\u5e8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int minAbsoluteSumDiff ( vector < int >& nums1 , vector < int >& nums2 ) { const int mod = 1000000007 ; int n = ( int ) nums1 . size (), ans = 0 , diff = 0 ; if ( n == 0 ) { return 0 ; } vector < int > arr = nums1 ; sort ( arr . begin (), arr . end ()); for ( int i = 0 ; i < n ; i ++ ) { ans += abs ( nums1 [ i ] - nums2 [ i ]); ans %= mod ; int chut = - abs ( nums1 [ i ] - nums2 [ i ]); size_t a = distance ( arr . begin (), lower_bound ( arr . begin (), arr . end (), nums2 [ i ])); if ( a < n ) { diff = min ( diff , chut + arr [ a ] - nums2 [ i ]); } if ( a > 0 ) { diff = min ( diff , chut + nums2 [ i ] - arr [ a - 1 ]); } } return ( ans + diff + mod ) % mod ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u627e\u5230\u4e58\u6cd5\u8868\u4e2d\u7b2c k \u5c0f\u7684\u6570 \u00b6 \u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570 m\u3001n\u3001k \u8868\u793a\u4e58\u6cd5\u53e3\u8bc0 m \\times n m \\times n \u4e2d\u7b2c k \u5c0f\u7684\u6570\u5b57\u3002\u4f8b\u5982\uff0cm = 3\uff0cn = 2\uff0ck = 2 \u5219\u8fd4\u56de 2\u3002 \u300c\u5206\u6790\u300d \u3010\u4e8c\u5206\u6cd5\u3011\u3002\u4e8c\u5206\u67e5\u627e\u662f\u786e\u5b9a\u6700\u7ec8\u7684\u8fd4\u56de\u503c\uff0c\u5185\u5c42\u904d\u5386\u6bcf\u4e00\u5217\u786e\u5b9a\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int findKthNumber ( int m , int n , int k ) { int l = 1 , r = m * n + 1 ; if ( m < n ) { swap ( m , n ); } while ( l < r ) { int t = ( l + r ) >> 1 ; int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cnt += min ( t / i , m ); } if ( cnt < k ) { l = t + 1 ; } else { r = t ; } } return l ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log (mn)) O(n \\log (mn)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4e0d\u7528\u9664\u6cd5\u6c42\u5546 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN ) { if ( divisor == - 1 ) { return INT_MAX ; } if ( divisor == 1 ) { return INT_MIN ; } } int m = dividend , n = divisor , quo = 0 ; if ( m > 0 ) { m = - m ; } if ( n > 0 ) { n = - n ; } while ( m <= n ) { long s = n , incre = 1 ; while (( s << 1 ) >= m ) { s <<= 1 ; incre <<= 1 ; } quo += incre ; m -= s ; } if (( dividend < 0 ) ^ ( divisor < 0 )) { quo *= - 1 ; } return quo ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log (m)) O(n \\log (m)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d m \u662f\u88ab\u9664\u6570 \u641c\u7d22\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 */ int search ( vector < int >& nums , int target ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return m ; } if ( nums [ l ] <= nums [ r ]) { if ( nums [ m ] < target ) { l = m + 1 ; } else if ( nums [ m ] > target ) { r = m - 1 ; } } else { if ( target >= nums [ l ] && nums [ m ] >= nums [ l ]) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else if ( target >= nums [ l ] && nums [ m ] <= nums [ r ]) { r = m - 1 ; } else if ( target <= nums [ r ] && nums [ m ] <= nums [ r ]) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else if ( target <= nums [ r ] && nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { if ( nums [ m ] < target ) { r = m - 1 ; } else { l = m + 1 ; } } } } return - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u641c\u7d22\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true */ bool search ( vector < int >& nums , int target ) { int n = int ( nums . size ()); if ( n == 0 ) { return false ; } int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return true ; } if ( nums [ l ] < nums [ r ]) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else { if ( nums [ m ] == nums [ l ] && nums [ m ] == nums [ r ]) { l ++ ; r -- ; } else if (( target >= nums [ l ] && nums [ m ] >= nums [ l ]) || ( target <= nums [ r ] && nums [ m ] <= nums [ r ])) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else if ( target >= nums [ l ] && nums [ m ] <= nums [ r ]) { r = m - 1 ; } else if ( target <= nums [ r ] && nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { if ( nums [ m ] > target ) { l = m + 1 ; } else { r = m - 1 ; } } } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u641c\u7d22\u4e8c\u7ef4\u77e9\u9635 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* \u7f16\u5199\u4e00\u4e2a\u9ad8\u6548\u7684\u7b97\u6cd5\u6765\u5224\u65ad m x n \u77e9\u9635\u4e2d\uff0c\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u76ee\u6807\u503c\u3002\u8be5\u77e9\u9635\u5177\u6709\u5982\u4e0b\u7279\u6027\uff1a \u6bcf\u884c\u4e2d\u7684\u6574\u6570\u4ece\u5de6\u5230\u53f3\u6309\u5347\u5e8f\u6392\u5217\u3002 \u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u5927\u4e8e\u524d\u4e00\u884c\u7684\u6700\u540e\u4e00\u4e2a\u6574\u6570\u3002 1 3 5 7 10 11 16 20 23 30 34 60 */ bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return false ; } int nCol = int ( matrix [ 0 ]. size ()); if ( nCol == 0 ) { return false ; } int l = 0 , r = nRow * nCol - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; int i = m / nCol , j = m % nCol ; if ( matrix [ i ][ j ] < target ) { l = m + 1 ; } else if ( matrix [ i ][ j ] > target ) { r = m - 1 ; } else { return true ; } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log(nm)) O(\\log(nm)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u5728 D \u5929\u5185\u9001\u8fbe\u5305\u88f9\u7684\u80fd\u529b \u00b6 \u4f20\u9001\u5e26\u4e0a\u7684\u5305\u88f9\u5fc5\u987b\u5728 D \u5929\u5185\u4ece\u4e00\u4e2a\u6e2f\u53e3\u8fd0\u9001\u5230\u53e6\u4e00\u4e2a\u6e2f\u53e3\u3002\u4f20\u9001\u5e26\u4e0a\u7684\u7b2c i \u4e2a\u5305\u88f9\u7684\u91cd\u91cf\u4e3a weights[i]\u3002\u6bcf\u4e00\u5929\uff0c\u6211\u4eec\u90fd\u4f1a\u6309\u7ed9\u51fa\u91cd\u91cf\u7684\u987a\u5e8f\u5f80\u4f20\u9001\u5e26\u4e0a\u88c5\u8f7d\u5305\u88f9\u3002\u6211\u4eec\u88c5\u8f7d\u7684\u91cd\u91cf\u4e0d\u4f1a\u8d85\u8fc7\u8239\u7684\u6700\u5927\u8fd0\u8f7d\u91cd\u91cf\u3002\u8fd4\u56de\u80fd\u5728 D \u5929\u5185\u5c06\u4f20\u9001\u5e26\u4e0a\u7684\u6240\u6709\u5305\u88f9\u9001\u8fbe\u7684\u8239\u7684\u6700\u4f4e\u8fd0\u8f7d\u80fd\u529b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aweights = [1,2,3,4,5,6,7,8,9,10], D = 5 \u8f93\u51fa\uff1a15 \u89e3\u91ca\uff1a \u8239\u8236\u6700\u4f4e\u8f7d\u91cd 15 \u5c31\u80fd\u591f\u5728 5 \u5929\u5185\u9001\u8fbe\u6240\u6709\u5305\u88f9\uff0c\u5982\u4e0b\u6240\u793a\uff1a \u7b2c 1 \u5929\uff1a1, 2, 3, 4, 5 \u7b2c 2 \u5929\uff1a6, 7 \u7b2c 3 \u5929\uff1a8 \u7b2c 4 \u5929\uff1a9 \u7b2c 5 \u5929\uff1a10 \u8bf7\u6ce8\u610f\uff0c\u8d27\u7269\u5fc5\u987b\u6309\u7167\u7ed9\u5b9a\u7684\u987a\u5e8f\u88c5\u8fd0\uff0c\u56e0\u6b64\u4f7f\u7528\u8f7d\u91cd\u80fd\u529b\u4e3a 14 \u7684\u8239\u8236\u5e76\u5c06\u5305\u88c5 \u5206\u6210 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) \u662f\u4e0d\u5141\u8bb8\u7684\u3002 */ class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = 0 , r = 0 ; for ( int weight : weights ) { if ( l < weight ) { l = weight ; } r += weight ; } while ( l < r ) { int m = ( l + r ) >> 1 ; int days = 1 , weightSum = 0 ; for ( int weight : weights ) { if ( weightSum + weight > m ) { days ++ ; weightSum = 0 ; } weightSum += weight ; } if ( days > D ) { l = m + 1 ; } else { r = m ; } } return l ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log(W)) O(n \\log(W)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0cn \u662f\u5305\u88f9\u4e2a\u6570\uff0cW \u662f\u5305\u88f9\u603b\u91cd\u91cf\u3002 \u5236\u4f5c m \u675f\u82b1\u6240\u9700\u7684\u6700\u5c11\u5929\u6570 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 bloomDay\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6574\u6570 m \u548c k \u3002\u73b0\u9700\u8981\u5236\u4f5c m \u675f\u82b1\u3002\u5236\u4f5c\u82b1\u675f\u65f6\uff0c\u9700\u8981\u4f7f\u7528\u82b1\u56ed\u4e2d \u76f8\u90bb\u7684 k \u6735\u82b1\u3002\u82b1\u56ed\u4e2d\u6709 n \u6735\u82b1\uff0c\u7b2c i \u6735\u82b1\u4f1a\u5728 bloomDay[i] \u65f6\u76db\u5f00\uff0c\u6070\u597d\u53ef\u4ee5\u7528\u4e8e\u4e00\u675f\u82b1\u4e2d\u3002\u8bf7\u4f60\u8fd4\u56de\u4ece\u82b1\u56ed\u4e2d\u6458 m \u675f\u82b1\u9700\u8981\u7b49\u5f85\u7684\u6700\u5c11\u7684\u5929\u6570\u3002\u5982\u679c\u4e0d\u80fd\u6458\u5230 m \u675f\u82b1\u5219\u8fd4\u56de -1 \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1abloomDay = [1,10,3,10,2], m = 3, k = 1 \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u8ba9\u6211\u4eec\u4e00\u8d77\u89c2\u5bdf\u8fd9\u4e09\u5929\u7684\u82b1\u5f00\u8fc7\u7a0b\uff0cx \u8868\u793a\u82b1\u5f00\uff0c\u800c _ \u8868\u793a\u82b1\u8fd8\u672a\u5f00\u3002 \u73b0\u5728\u9700\u8981\u5236\u4f5c 3 \u675f\u82b1\uff0c\u6bcf\u675f\u53ea\u9700\u8981 1 \u6735\u3002 1 \u5929\u540e\uff1a[x, _, _, _, _] // \u53ea\u80fd\u5236\u4f5c 1 \u675f\u82b1 2 \u5929\u540e\uff1a[x, _, _, _, x] // \u53ea\u80fd\u5236\u4f5c 2 \u675f\u82b1 3 \u5929\u540e\uff1a[x, _, x, _, x] // \u53ef\u4ee5\u5236\u4f5c 3 \u675f\u82b1\uff0c\u7b54\u6848\u4e3a 3 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1abloomDay = [1,10,3,10,2], m = 3, k = 2 \u8f93\u51fa\uff1a-1 \u89e3\u91ca\uff1a\u8981\u5236\u4f5c 3 \u675f\u82b1\uff0c\u6bcf\u675f\u9700\u8981 2 \u6735\u82b1\uff0c\u4e5f\u5c31\u662f\u4e00\u5171\u9700\u8981 6 \u6735\u82b1\u3002\u800c\u82b1\u56ed\u4e2d\u53ea\u6709 5 \u6735\u82b1\uff0c\u65e0\u6cd5\u6ee1\u8db3\u5236\u4f5c\u8981\u6c42\uff0c\u8fd4\u56de -1 \u3002 */ class Solution { public : int minDays ( vector < int >& bloomDay , int m , int k ) { int n = ( int ) bloomDay . size (); if ( n < m * k ) { return - 1 ; } int minDay = INT_MAX , maxDay = 0 ; for ( int day : bloomDay ) { minDay = min ( minDay , day ); maxDay = max ( maxDay , day ); } while ( minDay < maxDay ) { int midDay = ( minDay + maxDay ) >> 1 ; if ( canMake ( bloomDay , m , k , midDay )) { maxDay = midDay ; } else { minDay = midDay + 1 ; } } return maxDay ; } bool canMake ( vector < int > & bloomDay , int m , int k , int days ) { int bouquets = 0 , flowers = 0 ; for ( int bd : bloomDay ) { if ( bd <= days ) { flowers ++ ; if ( flowers == k ) { bouquets ++ ; flowers = 0 ; } } else { flowers = 0 ; } } return bouquets >= m ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log(Tot)) O(n \\log(Tot)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0cn \u662f\u82b1\u6570\uff0cTot \u662f bloomDay \u7684\u603b\u548c\u3002 \u5c0f\u5f20\u5237\u9898\u8ba1\u5212 \u00b6 \u4e3a\u4e86\u63d0\u9ad8\u81ea\u5df1\u7684\u4ee3\u7801\u80fd\u529b\uff0c\u5c0f\u5f20\u5236\u5b9a\u4e86 LeetCode \u5237\u9898\u8ba1\u5212\uff0c\u4ed6\u9009\u4e2d\u4e86 LeetCode \u9898\u5e93\u4e2d\u7684 n \u9053\u9898\uff0c\u7f16\u53f7\u4ece 0 \u5230 n-1\uff0c\u5e76\u8ba1\u5212\u5728 m \u5929\u5185\u6309\u7167\u9898\u76ee\u7f16\u53f7\u987a\u5e8f\u5237\u5b8c\u6240\u6709\u7684\u9898\u76ee\uff08\u6ce8\u610f\uff0c\u5c0f\u5f20\u4e0d\u80fd\u7528\u591a\u5929\u5b8c\u6210\u540c\u4e00\u9898\uff09\u3002\u5728\u5c0f\u5f20\u5237\u9898\u8ba1\u5212\u4e2d\uff0c\u5c0f\u5f20\u9700\u8981\u7528 time[i] \u7684\u65f6\u95f4\u5b8c\u6210\u7f16\u53f7 i \u7684\u9898\u76ee\u3002\u6b64\u5916\uff0c\u5c0f\u5f20\u8fd8\u53ef\u4ee5\u4f7f\u7528\u573a\u5916\u6c42\u52a9\u529f\u80fd\uff0c\u901a\u8fc7\u8be2\u95ee\u4ed6\u7684\u597d\u670b\u53cb\u5c0f\u6768\u9898\u76ee\u7684\u89e3\u6cd5\uff0c\u53ef\u4ee5\u7701\u53bb\u8be5\u9898\u7684\u505a\u9898\u65f6\u95f4\u3002\u4e3a\u4e86\u9632\u6b62\u201c\u5c0f\u5f20\u5237\u9898\u8ba1\u5212\u201d\u53d8\u6210\u201c\u5c0f\u6768\u5237\u9898\u8ba1\u5212\u201d\uff0c\u5c0f\u5f20\u6bcf\u5929\u6700\u591a\u4f7f\u7528\u4e00\u6b21\u6c42\u52a9\u3002\u6211\u4eec\u5b9a\u4e49 m \u5929\u4e2d\u505a\u9898\u65f6\u95f4\u6700\u591a\u7684\u4e00\u5929\u8017\u65f6\u4e3a T\uff08\u5c0f\u6768\u5b8c\u6210\u7684\u9898\u76ee\u4e0d\u8ba1\u5165\u505a\u9898\u603b\u65f6\u95f4\uff09\u3002\u8bf7\u4f60\u5e2e\u5c0f\u5f20\u6c42\u51fa\u6700\u5c0f\u7684 T\u662f\u591a\u5c11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* \u793a\u4f8b\uff1a \u8f93\u5165\uff1atime = [1,2,3,3], m = 2 \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u7b2c\u4e00\u5929\u5c0f\u5f20\u5b8c\u6210\u524d\u4e09\u9898\uff0c\u5176\u4e2d\u7b2c\u4e09\u9898\u627e\u5c0f\u6768\u5e2e\u5fd9\uff1b\u7b2c\u4e8c\u5929\u5b8c\u6210\u7b2c\u56db\u9898\uff0c\u5e76\u4e14\u627e\u5c0f\u6768\u5e2e\u5fd9\u3002\u8fd9\u6837 \u505a\u9898\u65f6\u95f4\u6700\u591a\u7684\u4e00\u5929\u82b1\u8d39\u4e86 3 \u7684\u65f6\u95f4\uff0c\u5e76\u4e14\u8fd9\u4e2a\u503c\u662f\u6700\u5c0f\u7684\u3002 */ int minTime ( vector < int >& time , int m ) { int n = int ( time . size ()), tot = 0 , minT = INT_MAX ; if ( n == 0 || n <= m ) { return 0 ; } for ( int t : time ) { tot += t ; minT = min ( minT , t ); } int l = minT , r = tot ; while ( l < r ) { int mid = ( l + r ) >> 1 ; int days = 1 , curSum = 0 , maxT = 0 ; for ( int t : time ) { if ( t > maxT ) { curSum += maxT ; maxT = t ; } else { curSum += t ; } if ( curSum > mid ) { days ++ ; curSum = 0 ; maxT = t ; } } if ( days > m ) { l = mid + 1 ; } else { r = mid ; } } return r ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log(Tot)) O(n \\log(Tot)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0cn \u662f\u5929\u6570\uff0cTot \u662f time \u7684\u603b\u548c\u3002 \u5e73\u65b9\u6839 \u00b6 \u7ed9\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 x\uff0c\u8ba1\u7b97 x \u7684\u5e73\u65b9\u6839\uff08\u4e0d\u4fdd\u7559\u5c0f\u6570\uff09\u3002\u4f8b\u5982 x = 8\uff0c\u8fd4\u56de 2\u3002 \u300c\u5206\u6790\u300d \u300c\u4e8c\u5206\u300d\u6ce8\u610f\u8fb9\u754c 1 2 3 4 5 6 7 8 9 10 11 int mySqrt ( int x ) { // Binary search long lo = 1 , hi = x ; while ( lo <= hi ) { long mi = ( lo + hi ) / 2 ; if ( mi * mi < x ) { lo = mi + 1 ; } else if ( mi * mi > x ) { hi = mi - 1 ; } else { return int ( mi ); } } return int ( hi ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u5b9e\u73b0\u5e42\u6307\u6570 \u00b6 \u5b9e\u73b0 pow(x, n)\uff0c\u5373\u8ba1\u7b97 x \u7684\u6574\u6570 n \u6b21\u5e42\u51fd\u6570\u5373 x^{n} x^{n} \u3002 \u300c\u5206\u6790\u300d \u300c\u5feb\u901f\u5e42\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 double myPow ( double x , int n ) { double ans = 1.0 ; bool isNeg = true ; if ( n > 0 ) { isNeg = false ; n = - n ; } while ( n < 0 ) { if ( n % 2 != 0 ) { ans *= x ; } x *= x ; n /= 2 ; } if ( isNeg ) { ans = 1.0 / ans ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u5bfb\u627e\u4e24\u4e2a\u6b63\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u5927\u5c0f\u5206\u522b\u4e3a m \u548c n \u7684\u6b63\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\u6570\u7ec4 nums1 \u548c nums2\u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u8fd9\u4e24\u4e2a\u6b63\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570 \u3002\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u8be5\u4e3a O(log (m+n)) \u3002\u4f8b\u5982\uff0cnums1 = [1,2], nums2 = [3,4]\uff0c\u8fd4\u56de 2.50000\u3002 \u300c\u5206\u6790\u300d \u300c\u4e8c\u5206\u6cd5\u300d\u5207\u5272\u4e24\u4e2a\u6570\u7ec4 \u4e00\u4e2a\u6570\u7ec4\u6839\u636e\u81ea\u8eab\u7684\u957f\u5ea6\u7684\u5947\u5076\u884c\uff0c\u4e2d\u4f4d\u6570\u6709\u4e24\u79cd\u60c5\u51b5\uff1a \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \u4e3a\u4e86\u7edf\u4e00\u5947\u5076\u884c\uff0c\u8fd9\u91cc\u5bf9\u6570\u7ec4\u91cc\u7684\u6bcf\u4e2a\u5143\u7d20\u4e24\u4fa7\u5b89\u63d2\u4e00\u4e2a\u5360\u4f4d\u7b26 \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = int ( nums1 . size ()), n2 = int ( nums2 . size ()); if ( n1 == 0 ) { return ( nums2 [( n2 - 1 ) / 2 ] + nums2 [ n2 / 2 ]) / 2.0 ; } if ( n2 == 0 ) { return ( nums1 [( n1 - 1 ) / 2 ] + nums1 [ n1 / 2 ]) / 2.0 ; } int MAX = nums1 [ n1 - 1 ] > nums2 [ n2 - 1 ] ? nums1 [ n1 - 1 ] : nums2 [ n2 - 1 ]; int MIN = nums1 [ 0 ] < nums2 [ 0 ] ? nums1 [ 0 ] : nums2 [ 0 ]; if ( n1 < n2 ) { return findK ( nums1 , nums2 , 0 , 2 * n1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums2 , nums1 , 0 , 2 * n2 , n2 , n1 , MAX , MIN ); } } double findK ( vector < int > nums1 , vector < int > nums2 , int b , int e , int n1 , int n2 , int MAX , int MIN ) { int l1 = 0 , l2 = 0 , r1 = 0 , r2 = 0 ; int k1 = ( b + e ) / 2 , k2 = ( n1 + n2 - k1 ); if ( k1 == 0 ) { l1 = MIN ; r1 = nums1 [ 0 ]; } else if ( k1 >= 2 * n1 ) { l1 = nums1 [ n1 - 1 ]; r1 = MAX ; } else { l1 = nums1 [( k1 - 1 ) / 2 ]; r1 = nums1 [ k1 / 2 ]; } if ( k2 == 0 ) { l2 = MIN ; r2 = nums2 [ 0 ]; } else if ( k2 >= 2 * n2 ) { l2 = nums2 [ n2 - 1 ]; r2 = MAX ; } else { l2 = nums2 [( k2 - 1 ) / 2 ]; r2 = nums2 [ k2 / 2 ]; } if ( l1 <= r2 && l2 <= r1 ) { return (( l1 > l2 ? l1 : l2 ) + ( r1 < r2 ? r1 : r2 )) / 2.0 ; } else if ( l1 > r2 ) { return findK ( nums1 , nums2 , b , k1 - 1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums1 , nums2 , k1 + 1 , e , n1 , n2 , MAX , MIN ); } } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log(n + m)) O(\\log(n + m)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u5bfb\u627e\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4\u4e2d\u7684\u6700\u5c0f\u503c \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u5143\u7d20\u503c\u7684\u65cb\u8f6c\u6570\u7ec4 nums\u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u6570\u7ec4\u4e2d\u7684\u6700\u5c0f\u5143\u7d20\u3002 \u300c\u5206\u6790\u300d \u300c\u4e8c\u5206\u6cd5\u300d\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u5448\u7ebf\u5f62\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: nums = [2,2,2,0,1] Output: 0 */ class Solution { public : int findMin ( vector < int >& nums ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ l ] == nums [ r ]) { while ( l < r && nums [ l ] == nums [ l + 1 ]) { l ++ ; } while ( l < r && nums [ r ] == nums [ r - 1 ]) { r -- ; } if (( l + 1 <= r && nums [ l ] < nums [ l + 1 ] && nums [ r ] < nums [ r - 1 ]) || l == r ) { return nums [ l ]; } l ++ ; } else { if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } } return nums [ r ]; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u4e8c\u5206"},{"location":"algo/binary-search/#_1","text":"\u4e8c\u5206\u67e5\u627e\u65f6\u4e00\u79cd\u9ad8\u6548\u7684\u67e5\u627e\u7b97\u6cd5\uff0c\u5b83\u8981\u6c42\u67e5\u627e\u7684\u6570\u7ec4\u662f\uff08\u5c40\u90e8\uff09\u6709\u5e8f\u7684\uff0c\u6bcf\u6b21\u53ef\u4ee5\u67e5\u627e\u540e\uff0c\u5229\u7528\u5355\u8c03\u6027\uff0c\u7f29\u5c0f\u4e00\u534a\u7684\u67e5\u627e\u8303\u56f4\u3002","title":"\u57fa\u672c\u6982\u5ff5"},{"location":"algo/binary-search/#_2","text":"","title":"\u6a21\u677f"},{"location":"algo/binary-search/#lower_bound","text":"lower_bound() \u67e5\u627e nums \u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e target \u7684\u4e0b\u6807\uff08\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u8fd4\u56de\u4e0b\u6807\u4e3a n\uff0c\u5373\u6570\u7ec4\u7684\u957f\u5ea6\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int lower_bound ( vector < int > & nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m ; } } return l ; }","title":"lower_bound"},{"location":"algo/binary-search/#upper_bound","text":"upper_bound(nums, target) \u67e5\u627e nums \u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u5927\u4e8e target \u7684\u6570\u503c\u4e0b\u6807\uff08\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u540c\u4e0a\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int upper_bound ( vector < int > & nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] <= target ) { l = m + 1 ; } else { r = m ; } } return l ; }","title":"upper_bound"},{"location":"algo/binary-search/#_3","text":"","title":"\u9898\u76ee"},{"location":"algo/binary-search/#_4","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 nums1 = [1, 28, 21] \u548c nums2 = [9, 21, 20]\uff0c\u53ef\u4ee5\u5c06 nums1 \u4e2d\u7684\u67d0\u4e00\u4e2a\u503c\u7528\u53e6\u4e00\u4e2a\u503c\u66ff\u6362\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u7528\u66ff\u6362\uff0c\u6c42\u4e24\u4e2a\u6570\u7ec4\u76f8\u5bf9\u4f4d\u7f6e\u7684\u5dee\u7684\u7edd\u5bf9\u503c\u4e4b\u548c\u3002\u4e0a\u8ff0\u4f8b\u5b50\u7684\u7ed3\u679c\u662f 9\u3002 \u300c\u5206\u6790\u300d \u5dee\u7684\u7edd\u5bf9\u503c\u4e4b\u548c\u8ba1\u7b97\u65b9\u5f0f\u5982\u4e0b\uff1a \\text{sum} = \\sum_{i = 0}^{n-1} \\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| \\text{sum} = \\sum_{i = 0}^{n-1} \\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| \u5047\u8bbe\u6211\u4eec\u5728 i \u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\u53d1\u751f\u53d8\u52a8 \\arg \\min_{i \\in [0, n)} -\\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| + \\left \\| \\text{nums1[ j ] - nums2[ i ]} \\right \\| \\arg \\min_{i \\in [0, n)} -\\left \\| \\text{nums1[ i ] - nums2[ i ]} \\right \\| + \\left \\| \\text{nums1[ j ] - nums2[ i ]} \\right \\| \u8fd9\u91cc\uff0cj \u662f [0, n) \u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u503c\u3002\u6211\u4eec\u5e0c\u671b\u627e\u5230\u4e00\u4e2a i \u4f7f\u5f97\u4e0a\u5f0f\u6700\u5c0f\u3002\u6211\u4eec\u4f7f\u7528\u4e8c\u5206\u67e5\u627e\u7684\u65b9\u5f0f\uff0c\u627e\u5230\u6700\u9760\u8fd1 nums2[ i ] \u7684 j\uff0c\u9700\u8981\u5c06 nums1 \u6392\u5e8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int minAbsoluteSumDiff ( vector < int >& nums1 , vector < int >& nums2 ) { const int mod = 1000000007 ; int n = ( int ) nums1 . size (), ans = 0 , diff = 0 ; if ( n == 0 ) { return 0 ; } vector < int > arr = nums1 ; sort ( arr . begin (), arr . end ()); for ( int i = 0 ; i < n ; i ++ ) { ans += abs ( nums1 [ i ] - nums2 [ i ]); ans %= mod ; int chut = - abs ( nums1 [ i ] - nums2 [ i ]); size_t a = distance ( arr . begin (), lower_bound ( arr . begin (), arr . end (), nums2 [ i ])); if ( a < n ) { diff = min ( diff , chut + arr [ a ] - nums2 [ i ]); } if ( a > 0 ) { diff = min ( diff , chut + nums2 [ i ] - arr [ a - 1 ]); } } return ( ans + diff + mod ) % mod ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u7edd\u5bf9\u503c\u4e4b\u548c"},{"location":"algo/binary-search/#k","text":"\u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570 m\u3001n\u3001k \u8868\u793a\u4e58\u6cd5\u53e3\u8bc0 m \\times n m \\times n \u4e2d\u7b2c k \u5c0f\u7684\u6570\u5b57\u3002\u4f8b\u5982\uff0cm = 3\uff0cn = 2\uff0ck = 2 \u5219\u8fd4\u56de 2\u3002 \u300c\u5206\u6790\u300d \u3010\u4e8c\u5206\u6cd5\u3011\u3002\u4e8c\u5206\u67e5\u627e\u662f\u786e\u5b9a\u6700\u7ec8\u7684\u8fd4\u56de\u503c\uff0c\u5185\u5c42\u904d\u5386\u6bcf\u4e00\u5217\u786e\u5b9a\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int findKthNumber ( int m , int n , int k ) { int l = 1 , r = m * n + 1 ; if ( m < n ) { swap ( m , n ); } while ( l < r ) { int t = ( l + r ) >> 1 ; int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cnt += min ( t / i , m ); } if ( cnt < k ) { l = t + 1 ; } else { r = t ; } } return l ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log (mn)) O(n \\log (mn)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u627e\u5230\u4e58\u6cd5\u8868\u4e2d\u7b2c k \u5c0f\u7684\u6570"},{"location":"algo/binary-search/#_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN ) { if ( divisor == - 1 ) { return INT_MAX ; } if ( divisor == 1 ) { return INT_MIN ; } } int m = dividend , n = divisor , quo = 0 ; if ( m > 0 ) { m = - m ; } if ( n > 0 ) { n = - n ; } while ( m <= n ) { long s = n , incre = 1 ; while (( s << 1 ) >= m ) { s <<= 1 ; incre <<= 1 ; } quo += incre ; m -= s ; } if (( dividend < 0 ) ^ ( divisor < 0 )) { quo *= - 1 ; } return quo ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log (m)) O(n \\log (m)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d m \u662f\u88ab\u9664\u6570","title":"\u4e0d\u7528\u9664\u6cd5\u6c42\u5546"},{"location":"algo/binary-search/#_6","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 */ int search ( vector < int >& nums , int target ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return m ; } if ( nums [ l ] <= nums [ r ]) { if ( nums [ m ] < target ) { l = m + 1 ; } else if ( nums [ m ] > target ) { r = m - 1 ; } } else { if ( target >= nums [ l ] && nums [ m ] >= nums [ l ]) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else if ( target >= nums [ l ] && nums [ m ] <= nums [ r ]) { r = m - 1 ; } else if ( target <= nums [ r ] && nums [ m ] <= nums [ r ]) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else if ( target <= nums [ r ] && nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { if ( nums [ m ] < target ) { r = m - 1 ; } else { l = m + 1 ; } } } } return - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u641c\u7d22\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4"},{"location":"algo/binary-search/#ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true */ bool search ( vector < int >& nums , int target ) { int n = int ( nums . size ()); if ( n == 0 ) { return false ; } int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return true ; } if ( nums [ l ] < nums [ r ]) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else { if ( nums [ m ] == nums [ l ] && nums [ m ] == nums [ r ]) { l ++ ; r -- ; } else if (( target >= nums [ l ] && nums [ m ] >= nums [ l ]) || ( target <= nums [ r ] && nums [ m ] <= nums [ r ])) { if ( nums [ m ] > target ) { r = m - 1 ; } else { l = m + 1 ; } } else if ( target >= nums [ l ] && nums [ m ] <= nums [ r ]) { r = m - 1 ; } else if ( target <= nums [ r ] && nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { if ( nums [ m ] > target ) { l = m + 1 ; } else { r = m - 1 ; } } } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u641c\u7d22\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4II"},{"location":"algo/binary-search/#_7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* \u7f16\u5199\u4e00\u4e2a\u9ad8\u6548\u7684\u7b97\u6cd5\u6765\u5224\u65ad m x n \u77e9\u9635\u4e2d\uff0c\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u76ee\u6807\u503c\u3002\u8be5\u77e9\u9635\u5177\u6709\u5982\u4e0b\u7279\u6027\uff1a \u6bcf\u884c\u4e2d\u7684\u6574\u6570\u4ece\u5de6\u5230\u53f3\u6309\u5347\u5e8f\u6392\u5217\u3002 \u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u5927\u4e8e\u524d\u4e00\u884c\u7684\u6700\u540e\u4e00\u4e2a\u6574\u6570\u3002 1 3 5 7 10 11 16 20 23 30 34 60 */ bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return false ; } int nCol = int ( matrix [ 0 ]. size ()); if ( nCol == 0 ) { return false ; } int l = 0 , r = nRow * nCol - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; int i = m / nCol , j = m % nCol ; if ( matrix [ i ][ j ] < target ) { l = m + 1 ; } else if ( matrix [ i ][ j ] > target ) { r = m - 1 ; } else { return true ; } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log(nm)) O(\\log(nm)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u641c\u7d22\u4e8c\u7ef4\u77e9\u9635"},{"location":"algo/binary-search/#d","text":"\u4f20\u9001\u5e26\u4e0a\u7684\u5305\u88f9\u5fc5\u987b\u5728 D \u5929\u5185\u4ece\u4e00\u4e2a\u6e2f\u53e3\u8fd0\u9001\u5230\u53e6\u4e00\u4e2a\u6e2f\u53e3\u3002\u4f20\u9001\u5e26\u4e0a\u7684\u7b2c i \u4e2a\u5305\u88f9\u7684\u91cd\u91cf\u4e3a weights[i]\u3002\u6bcf\u4e00\u5929\uff0c\u6211\u4eec\u90fd\u4f1a\u6309\u7ed9\u51fa\u91cd\u91cf\u7684\u987a\u5e8f\u5f80\u4f20\u9001\u5e26\u4e0a\u88c5\u8f7d\u5305\u88f9\u3002\u6211\u4eec\u88c5\u8f7d\u7684\u91cd\u91cf\u4e0d\u4f1a\u8d85\u8fc7\u8239\u7684\u6700\u5927\u8fd0\u8f7d\u91cd\u91cf\u3002\u8fd4\u56de\u80fd\u5728 D \u5929\u5185\u5c06\u4f20\u9001\u5e26\u4e0a\u7684\u6240\u6709\u5305\u88f9\u9001\u8fbe\u7684\u8239\u7684\u6700\u4f4e\u8fd0\u8f7d\u80fd\u529b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aweights = [1,2,3,4,5,6,7,8,9,10], D = 5 \u8f93\u51fa\uff1a15 \u89e3\u91ca\uff1a \u8239\u8236\u6700\u4f4e\u8f7d\u91cd 15 \u5c31\u80fd\u591f\u5728 5 \u5929\u5185\u9001\u8fbe\u6240\u6709\u5305\u88f9\uff0c\u5982\u4e0b\u6240\u793a\uff1a \u7b2c 1 \u5929\uff1a1, 2, 3, 4, 5 \u7b2c 2 \u5929\uff1a6, 7 \u7b2c 3 \u5929\uff1a8 \u7b2c 4 \u5929\uff1a9 \u7b2c 5 \u5929\uff1a10 \u8bf7\u6ce8\u610f\uff0c\u8d27\u7269\u5fc5\u987b\u6309\u7167\u7ed9\u5b9a\u7684\u987a\u5e8f\u88c5\u8fd0\uff0c\u56e0\u6b64\u4f7f\u7528\u8f7d\u91cd\u80fd\u529b\u4e3a 14 \u7684\u8239\u8236\u5e76\u5c06\u5305\u88c5 \u5206\u6210 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) \u662f\u4e0d\u5141\u8bb8\u7684\u3002 */ class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = 0 , r = 0 ; for ( int weight : weights ) { if ( l < weight ) { l = weight ; } r += weight ; } while ( l < r ) { int m = ( l + r ) >> 1 ; int days = 1 , weightSum = 0 ; for ( int weight : weights ) { if ( weightSum + weight > m ) { days ++ ; weightSum = 0 ; } weightSum += weight ; } if ( days > D ) { l = m + 1 ; } else { r = m ; } } return l ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log(W)) O(n \\log(W)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0cn \u662f\u5305\u88f9\u4e2a\u6570\uff0cW \u662f\u5305\u88f9\u603b\u91cd\u91cf\u3002","title":"\u5728 D \u5929\u5185\u9001\u8fbe\u5305\u88f9\u7684\u80fd\u529b"},{"location":"algo/binary-search/#m","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 bloomDay\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6574\u6570 m \u548c k \u3002\u73b0\u9700\u8981\u5236\u4f5c m \u675f\u82b1\u3002\u5236\u4f5c\u82b1\u675f\u65f6\uff0c\u9700\u8981\u4f7f\u7528\u82b1\u56ed\u4e2d \u76f8\u90bb\u7684 k \u6735\u82b1\u3002\u82b1\u56ed\u4e2d\u6709 n \u6735\u82b1\uff0c\u7b2c i \u6735\u82b1\u4f1a\u5728 bloomDay[i] \u65f6\u76db\u5f00\uff0c\u6070\u597d\u53ef\u4ee5\u7528\u4e8e\u4e00\u675f\u82b1\u4e2d\u3002\u8bf7\u4f60\u8fd4\u56de\u4ece\u82b1\u56ed\u4e2d\u6458 m \u675f\u82b1\u9700\u8981\u7b49\u5f85\u7684\u6700\u5c11\u7684\u5929\u6570\u3002\u5982\u679c\u4e0d\u80fd\u6458\u5230 m \u675f\u82b1\u5219\u8fd4\u56de -1 \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1abloomDay = [1,10,3,10,2], m = 3, k = 1 \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u8ba9\u6211\u4eec\u4e00\u8d77\u89c2\u5bdf\u8fd9\u4e09\u5929\u7684\u82b1\u5f00\u8fc7\u7a0b\uff0cx \u8868\u793a\u82b1\u5f00\uff0c\u800c _ \u8868\u793a\u82b1\u8fd8\u672a\u5f00\u3002 \u73b0\u5728\u9700\u8981\u5236\u4f5c 3 \u675f\u82b1\uff0c\u6bcf\u675f\u53ea\u9700\u8981 1 \u6735\u3002 1 \u5929\u540e\uff1a[x, _, _, _, _] // \u53ea\u80fd\u5236\u4f5c 1 \u675f\u82b1 2 \u5929\u540e\uff1a[x, _, _, _, x] // \u53ea\u80fd\u5236\u4f5c 2 \u675f\u82b1 3 \u5929\u540e\uff1a[x, _, x, _, x] // \u53ef\u4ee5\u5236\u4f5c 3 \u675f\u82b1\uff0c\u7b54\u6848\u4e3a 3 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1abloomDay = [1,10,3,10,2], m = 3, k = 2 \u8f93\u51fa\uff1a-1 \u89e3\u91ca\uff1a\u8981\u5236\u4f5c 3 \u675f\u82b1\uff0c\u6bcf\u675f\u9700\u8981 2 \u6735\u82b1\uff0c\u4e5f\u5c31\u662f\u4e00\u5171\u9700\u8981 6 \u6735\u82b1\u3002\u800c\u82b1\u56ed\u4e2d\u53ea\u6709 5 \u6735\u82b1\uff0c\u65e0\u6cd5\u6ee1\u8db3\u5236\u4f5c\u8981\u6c42\uff0c\u8fd4\u56de -1 \u3002 */ class Solution { public : int minDays ( vector < int >& bloomDay , int m , int k ) { int n = ( int ) bloomDay . size (); if ( n < m * k ) { return - 1 ; } int minDay = INT_MAX , maxDay = 0 ; for ( int day : bloomDay ) { minDay = min ( minDay , day ); maxDay = max ( maxDay , day ); } while ( minDay < maxDay ) { int midDay = ( minDay + maxDay ) >> 1 ; if ( canMake ( bloomDay , m , k , midDay )) { maxDay = midDay ; } else { minDay = midDay + 1 ; } } return maxDay ; } bool canMake ( vector < int > & bloomDay , int m , int k , int days ) { int bouquets = 0 , flowers = 0 ; for ( int bd : bloomDay ) { if ( bd <= days ) { flowers ++ ; if ( flowers == k ) { bouquets ++ ; flowers = 0 ; } } else { flowers = 0 ; } } return bouquets >= m ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log(Tot)) O(n \\log(Tot)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0cn \u662f\u82b1\u6570\uff0cTot \u662f bloomDay \u7684\u603b\u548c\u3002","title":"\u5236\u4f5c m \u675f\u82b1\u6240\u9700\u7684\u6700\u5c11\u5929\u6570"},{"location":"algo/binary-search/#_8","text":"\u4e3a\u4e86\u63d0\u9ad8\u81ea\u5df1\u7684\u4ee3\u7801\u80fd\u529b\uff0c\u5c0f\u5f20\u5236\u5b9a\u4e86 LeetCode \u5237\u9898\u8ba1\u5212\uff0c\u4ed6\u9009\u4e2d\u4e86 LeetCode \u9898\u5e93\u4e2d\u7684 n \u9053\u9898\uff0c\u7f16\u53f7\u4ece 0 \u5230 n-1\uff0c\u5e76\u8ba1\u5212\u5728 m \u5929\u5185\u6309\u7167\u9898\u76ee\u7f16\u53f7\u987a\u5e8f\u5237\u5b8c\u6240\u6709\u7684\u9898\u76ee\uff08\u6ce8\u610f\uff0c\u5c0f\u5f20\u4e0d\u80fd\u7528\u591a\u5929\u5b8c\u6210\u540c\u4e00\u9898\uff09\u3002\u5728\u5c0f\u5f20\u5237\u9898\u8ba1\u5212\u4e2d\uff0c\u5c0f\u5f20\u9700\u8981\u7528 time[i] \u7684\u65f6\u95f4\u5b8c\u6210\u7f16\u53f7 i \u7684\u9898\u76ee\u3002\u6b64\u5916\uff0c\u5c0f\u5f20\u8fd8\u53ef\u4ee5\u4f7f\u7528\u573a\u5916\u6c42\u52a9\u529f\u80fd\uff0c\u901a\u8fc7\u8be2\u95ee\u4ed6\u7684\u597d\u670b\u53cb\u5c0f\u6768\u9898\u76ee\u7684\u89e3\u6cd5\uff0c\u53ef\u4ee5\u7701\u53bb\u8be5\u9898\u7684\u505a\u9898\u65f6\u95f4\u3002\u4e3a\u4e86\u9632\u6b62\u201c\u5c0f\u5f20\u5237\u9898\u8ba1\u5212\u201d\u53d8\u6210\u201c\u5c0f\u6768\u5237\u9898\u8ba1\u5212\u201d\uff0c\u5c0f\u5f20\u6bcf\u5929\u6700\u591a\u4f7f\u7528\u4e00\u6b21\u6c42\u52a9\u3002\u6211\u4eec\u5b9a\u4e49 m \u5929\u4e2d\u505a\u9898\u65f6\u95f4\u6700\u591a\u7684\u4e00\u5929\u8017\u65f6\u4e3a T\uff08\u5c0f\u6768\u5b8c\u6210\u7684\u9898\u76ee\u4e0d\u8ba1\u5165\u505a\u9898\u603b\u65f6\u95f4\uff09\u3002\u8bf7\u4f60\u5e2e\u5c0f\u5f20\u6c42\u51fa\u6700\u5c0f\u7684 T\u662f\u591a\u5c11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* \u793a\u4f8b\uff1a \u8f93\u5165\uff1atime = [1,2,3,3], m = 2 \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u7b2c\u4e00\u5929\u5c0f\u5f20\u5b8c\u6210\u524d\u4e09\u9898\uff0c\u5176\u4e2d\u7b2c\u4e09\u9898\u627e\u5c0f\u6768\u5e2e\u5fd9\uff1b\u7b2c\u4e8c\u5929\u5b8c\u6210\u7b2c\u56db\u9898\uff0c\u5e76\u4e14\u627e\u5c0f\u6768\u5e2e\u5fd9\u3002\u8fd9\u6837 \u505a\u9898\u65f6\u95f4\u6700\u591a\u7684\u4e00\u5929\u82b1\u8d39\u4e86 3 \u7684\u65f6\u95f4\uff0c\u5e76\u4e14\u8fd9\u4e2a\u503c\u662f\u6700\u5c0f\u7684\u3002 */ int minTime ( vector < int >& time , int m ) { int n = int ( time . size ()), tot = 0 , minT = INT_MAX ; if ( n == 0 || n <= m ) { return 0 ; } for ( int t : time ) { tot += t ; minT = min ( minT , t ); } int l = minT , r = tot ; while ( l < r ) { int mid = ( l + r ) >> 1 ; int days = 1 , curSum = 0 , maxT = 0 ; for ( int t : time ) { if ( t > maxT ) { curSum += maxT ; maxT = t ; } else { curSum += t ; } if ( curSum > mid ) { days ++ ; curSum = 0 ; maxT = t ; } } if ( days > m ) { l = mid + 1 ; } else { r = mid ; } } return r ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log(Tot)) O(n \\log(Tot)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0cn \u662f\u5929\u6570\uff0cTot \u662f time \u7684\u603b\u548c\u3002","title":"\u5c0f\u5f20\u5237\u9898\u8ba1\u5212"},{"location":"algo/binary-search/#_9","text":"\u7ed9\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 x\uff0c\u8ba1\u7b97 x \u7684\u5e73\u65b9\u6839\uff08\u4e0d\u4fdd\u7559\u5c0f\u6570\uff09\u3002\u4f8b\u5982 x = 8\uff0c\u8fd4\u56de 2\u3002 \u300c\u5206\u6790\u300d \u300c\u4e8c\u5206\u300d\u6ce8\u610f\u8fb9\u754c 1 2 3 4 5 6 7 8 9 10 11 int mySqrt ( int x ) { // Binary search long lo = 1 , hi = x ; while ( lo <= hi ) { long mi = ( lo + hi ) / 2 ; if ( mi * mi < x ) { lo = mi + 1 ; } else if ( mi * mi > x ) { hi = mi - 1 ; } else { return int ( mi ); } } return int ( hi ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5e73\u65b9\u6839"},{"location":"algo/binary-search/#_10","text":"\u5b9e\u73b0 pow(x, n)\uff0c\u5373\u8ba1\u7b97 x \u7684\u6574\u6570 n \u6b21\u5e42\u51fd\u6570\u5373 x^{n} x^{n} \u3002 \u300c\u5206\u6790\u300d \u300c\u5feb\u901f\u5e42\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 double myPow ( double x , int n ) { double ans = 1.0 ; bool isNeg = true ; if ( n > 0 ) { isNeg = false ; n = - n ; } while ( n < 0 ) { if ( n % 2 != 0 ) { ans *= x ; } x *= x ; n /= 2 ; } if ( isNeg ) { ans = 1.0 / ans ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5b9e\u73b0\u5e42\u6307\u6570"},{"location":"algo/binary-search/#_11","text":"\u7ed9\u5b9a\u4e24\u4e2a\u5927\u5c0f\u5206\u522b\u4e3a m \u548c n \u7684\u6b63\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\u6570\u7ec4 nums1 \u548c nums2\u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u8fd9\u4e24\u4e2a\u6b63\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570 \u3002\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u8be5\u4e3a O(log (m+n)) \u3002\u4f8b\u5982\uff0cnums1 = [1,2], nums2 = [3,4]\uff0c\u8fd4\u56de 2.50000\u3002 \u300c\u5206\u6790\u300d \u300c\u4e8c\u5206\u6cd5\u300d\u5207\u5272\u4e24\u4e2a\u6570\u7ec4 \u4e00\u4e2a\u6570\u7ec4\u6839\u636e\u81ea\u8eab\u7684\u957f\u5ea6\u7684\u5947\u5076\u884c\uff0c\u4e2d\u4f4d\u6570\u6709\u4e24\u79cd\u60c5\u51b5\uff1a \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \u4e3a\u4e86\u7edf\u4e00\u5947\u5076\u884c\uff0c\u8fd9\u91cc\u5bf9\u6570\u7ec4\u91cc\u7684\u6bcf\u4e2a\u5143\u7d20\u4e24\u4fa7\u5b89\u63d2\u4e00\u4e2a\u5360\u4f4d\u7b26 \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = int ( nums1 . size ()), n2 = int ( nums2 . size ()); if ( n1 == 0 ) { return ( nums2 [( n2 - 1 ) / 2 ] + nums2 [ n2 / 2 ]) / 2.0 ; } if ( n2 == 0 ) { return ( nums1 [( n1 - 1 ) / 2 ] + nums1 [ n1 / 2 ]) / 2.0 ; } int MAX = nums1 [ n1 - 1 ] > nums2 [ n2 - 1 ] ? nums1 [ n1 - 1 ] : nums2 [ n2 - 1 ]; int MIN = nums1 [ 0 ] < nums2 [ 0 ] ? nums1 [ 0 ] : nums2 [ 0 ]; if ( n1 < n2 ) { return findK ( nums1 , nums2 , 0 , 2 * n1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums2 , nums1 , 0 , 2 * n2 , n2 , n1 , MAX , MIN ); } } double findK ( vector < int > nums1 , vector < int > nums2 , int b , int e , int n1 , int n2 , int MAX , int MIN ) { int l1 = 0 , l2 = 0 , r1 = 0 , r2 = 0 ; int k1 = ( b + e ) / 2 , k2 = ( n1 + n2 - k1 ); if ( k1 == 0 ) { l1 = MIN ; r1 = nums1 [ 0 ]; } else if ( k1 >= 2 * n1 ) { l1 = nums1 [ n1 - 1 ]; r1 = MAX ; } else { l1 = nums1 [( k1 - 1 ) / 2 ]; r1 = nums1 [ k1 / 2 ]; } if ( k2 == 0 ) { l2 = MIN ; r2 = nums2 [ 0 ]; } else if ( k2 >= 2 * n2 ) { l2 = nums2 [ n2 - 1 ]; r2 = MAX ; } else { l2 = nums2 [( k2 - 1 ) / 2 ]; r2 = nums2 [ k2 / 2 ]; } if ( l1 <= r2 && l2 <= r1 ) { return (( l1 > l2 ? l1 : l2 ) + ( r1 < r2 ? r1 : r2 )) / 2.0 ; } else if ( l1 > r2 ) { return findK ( nums1 , nums2 , b , k1 - 1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums1 , nums2 , k1 + 1 , e , n1 , n2 , MAX , MIN ); } } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log(n + m)) O(\\log(n + m)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5bfb\u627e\u4e24\u4e2a\u6b63\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570"},{"location":"algo/binary-search/#_12","text":"\u7ed9\u4f60\u4e00\u4e2a\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u5143\u7d20\u503c\u7684\u65cb\u8f6c\u6570\u7ec4 nums\u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u6570\u7ec4\u4e2d\u7684\u6700\u5c0f\u5143\u7d20\u3002 \u300c\u5206\u6790\u300d \u300c\u4e8c\u5206\u6cd5\u300d\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u5448\u7ebf\u5f62\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: nums = [2,2,2,0,1] Output: 0 */ class Solution { public : int findMin ( vector < int >& nums ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ l ] == nums [ r ]) { while ( l < r && nums [ l ] == nums [ l + 1 ]) { l ++ ; } while ( l < r && nums [ r ] == nums [ r - 1 ]) { r -- ; } if (( l + 1 <= r && nums [ l ] < nums [ l + 1 ] && nums [ r ] < nums [ r - 1 ]) || l == r ) { return nums [ l ]; } l ++ ; } else { if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } } return nums [ r ]; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5bfb\u627e\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4\u4e2d\u7684\u6700\u5c0f\u503c"},{"location":"algo/divide-conquer/","text":"\u5206\u6cbb Divider and Conquer \u00b6 \u6570\u7ec4\u6c42\u548c \u00b6 1 2 3 4 5 int sum ( int A [], int lo , int hi ) { if ( lo == hi ) { return A [ lo ]; } int mi = ( lo + hi ) >> 1 ; return sum ( A , lo , mi ) + sum ( A , mi + 1 , hi ); } \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790 \\begin{aligned} T(n) &= 2T(\\frac{n}{2}) \\\\ &= 2 \\cdot 2 T(\\frac{n}{4}) \\\\ &= 2^{\\log_{2}n} \\cdot T(1) \\\\ &= n \\end{aligned} \\begin{aligned} T(n) &= 2T(\\frac{n}{2}) \\\\ &= 2 \\cdot 2 T(\\frac{n}{4}) \\\\ &= 2^{\\log_{2}n} \\cdot T(1) \\\\ &= n \\end{aligned} \u65f6\u95f4\u590d\u6742\u5ea6 O(hi - lo) O(hi - lo) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(hi - lo) O(hi - lo) \u3002 \u51cf\u6cbb Decrease and Conquer \u00b6 \u53cd\u8f6c\u6570\u7ec4 \u00b6 1 2 3 4 5 6 void reverse ( int * A , int lo , int hi ) { if ( lo < hi ) { swap ( A [ lo ], A [ hi ]); reverse ( A , lo + 1 , hi - 1 ); } } \u641c\u7d22\u4e8c\u7ef4\u77e9\u9635 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\uff0c\u5217\u65b9\u5411\u4ece\u5c0f\u5230\u5927\uff0c\u884c\u65b9\u5411\u4ece\u5c0f\u5230\u5927\uff0c\u53c8\u7ed9\u5b9a\u4e00\u4e2a\u6570\u5b57\uff0c\u8bd5\u67e5\u8be2\u6b64\u6570\u5b57\u662f\u5426\u5b58\u5728\u8fd9\u4e2a\u4e8c\u7ef4\u6570\u7ec4\u4e2d\u3002 \\begin{matrix} 1 & 4 & 7 \\\\ 2 & 5 & 8 \\\\ 3 & 6 & 9 \\end{matrix} \\begin{matrix} 1 & 4 & 7 \\\\ 2 & 5 & 8 \\\\ 3 & 6 & 9 \\end{matrix} \u67e5\u8be2 5 \uff0c\u8fd4\u56de true 1 2 3 4 5 6 7 8 9 10 11 12 13 bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int nRow = ( int ) matrix . size (); if ( nRow == 0 ) { return false ; } int nCol = ( int ) matrix [ 0 ]. size (); if ( nCol == 0 ) { return false ; } int row = nRow - 1 , col = 0 ; while ( row >= 0 && col < nCol ) { if ( matrix [ row ][ col ] == target ) { return true ; } else if ( matrix [ row ][ col ] > target ) { row -- ; } else { col ++ ; } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(row + col) O(row + col) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u5206\u6cbb"},{"location":"algo/divide-conquer/#divider-and-conquer","text":"","title":"\u5206\u6cbb Divider and Conquer"},{"location":"algo/divide-conquer/#_1","text":"1 2 3 4 5 int sum ( int A [], int lo , int hi ) { if ( lo == hi ) { return A [ lo ]; } int mi = ( lo + hi ) >> 1 ; return sum ( A , lo , mi ) + sum ( A , mi + 1 , hi ); } \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790 \\begin{aligned} T(n) &= 2T(\\frac{n}{2}) \\\\ &= 2 \\cdot 2 T(\\frac{n}{4}) \\\\ &= 2^{\\log_{2}n} \\cdot T(1) \\\\ &= n \\end{aligned} \\begin{aligned} T(n) &= 2T(\\frac{n}{2}) \\\\ &= 2 \\cdot 2 T(\\frac{n}{4}) \\\\ &= 2^{\\log_{2}n} \\cdot T(1) \\\\ &= n \\end{aligned} \u65f6\u95f4\u590d\u6742\u5ea6 O(hi - lo) O(hi - lo) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(hi - lo) O(hi - lo) \u3002","title":"\u6570\u7ec4\u6c42\u548c"},{"location":"algo/divide-conquer/#decrease-and-conquer","text":"","title":"\u51cf\u6cbb Decrease and Conquer"},{"location":"algo/divide-conquer/#_2","text":"1 2 3 4 5 6 void reverse ( int * A , int lo , int hi ) { if ( lo < hi ) { swap ( A [ lo ], A [ hi ]); reverse ( A , lo + 1 , hi - 1 ); } }","title":"\u53cd\u8f6c\u6570\u7ec4"},{"location":"algo/divide-conquer/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\uff0c\u5217\u65b9\u5411\u4ece\u5c0f\u5230\u5927\uff0c\u884c\u65b9\u5411\u4ece\u5c0f\u5230\u5927\uff0c\u53c8\u7ed9\u5b9a\u4e00\u4e2a\u6570\u5b57\uff0c\u8bd5\u67e5\u8be2\u6b64\u6570\u5b57\u662f\u5426\u5b58\u5728\u8fd9\u4e2a\u4e8c\u7ef4\u6570\u7ec4\u4e2d\u3002 \\begin{matrix} 1 & 4 & 7 \\\\ 2 & 5 & 8 \\\\ 3 & 6 & 9 \\end{matrix} \\begin{matrix} 1 & 4 & 7 \\\\ 2 & 5 & 8 \\\\ 3 & 6 & 9 \\end{matrix} \u67e5\u8be2 5 \uff0c\u8fd4\u56de true 1 2 3 4 5 6 7 8 9 10 11 12 13 bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int nRow = ( int ) matrix . size (); if ( nRow == 0 ) { return false ; } int nCol = ( int ) matrix [ 0 ]. size (); if ( nCol == 0 ) { return false ; } int row = nRow - 1 , col = 0 ; while ( row >= 0 && col < nCol ) { if ( matrix [ row ][ col ] == target ) { return true ; } else if ( matrix [ row ][ col ] > target ) { row -- ; } else { col ++ ; } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(row + col) O(row + col) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u641c\u7d22\u4e8c\u7ef4\u77e9\u9635"},{"location":"algo/greedy/","text":"\u4ecb\u7ecd \u00b6 \u8d2a\u5fc3\u7b97\u6cd5\uff08greedy algorithm\uff09\u662f\u8ba1\u7b97\u673a\u6a21\u62df\u4eba\u7c7b\u51b3\u7b56\u7684\u4e00\u79cd\u7b97\u6cd5\uff0c\u8868\u73b0\u4e3a\u8ffd\u6c42\u5f53\u524d\u6700\u4f18\u89e3\uff0c\u800c\u4e0d\u987e\u53ca\u5168\u5c40\u6700\u4f18\u89e3\uff0c\u5177\u6709\u300c\u77ed\u89c6\u300d\u7279\u70b9\uff0c\u5373\u4f18\u5148\u9009\u62e9\u5f53\u524d\u6700\u6709\u5229\u7684\u65b9\u6848\u3002 \u4f7f\u7528\u573a\u666f \u00b6 \u8d2a\u5fc3\u7b97\u6cd5\u9002\u7528\u4e8e\u5177\u6709\u6700\u6709\u5b50\u7ed3\u6784\u7684\u95ee\u9898\uff0c\u53ca\u5b50\u95ee\u9898\u7684\u89e3\u53ef\u4ee5\u9012\u63a8\u5230\u539f\u95ee\u9898\u7684\u89e3\u3002 \u8bc1\u660e \u00b6 \\star \\star \u53cd\u8bc1\u6cd5\uff1a\u5047\u8bbe\u5f53\u524d\u89e3\u4e0d\u662f\u6700\u4f18\u89e3\uff0c\u5982\u679c\u4e0d\u80fd\u627e\u5230\u4e00\u7ec4\u65b0\u7684\u89e3\u8868\u73b0\u7684\u6bd4\u5f53\u524d\u89e3\u8981\u597d\uff0c\u90a3\u4e48\u5f53\u524d\u89e3\u5373\u4e3a\u6700\u4f18\u89e3 \\star \\star \u5f52\u7eb3\u6cd5\uff1a\u8ba1\u7b97n=1\u65f6\u7684\u6700\u4f18\u89e3 F_{1} F_{1} \uff0c\u8bc1\u660e\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u89e3 F_{n} F_{n} \u53ef\u4ee5\u7531\u524d\u4e00\u4e2a\u5bfc\u51fa \u533a\u522b \u00b6 \u8d2a\u5fc3\u7b97\u6cd5\u4e0e\u52a8\u6001\u89c4\u5212\u7684\u533a\u522b\u4e3a\uff0c\u8d2a\u5fc3\u95ee\u9898\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0\u3002 \u9898\u76ee \u00b6 \u5206\u914d\u4eba\u5458 \u00b6 \u516c\u53f8\u6709 2n \u4e2a\u5e94\u8058\u8005\u53c2\u52a0\u9762\u8bd5\uff0c\u53ef\u4ee5\u9009\u62e9A\u3001B\u5176\u4e2d\u4e00\u5904\uff0c\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 costs =[[259, 770], [448, 54], [926, 667], [184, 139], [840, 118], [577, 469]] \u8868\u793a\u5e94\u8058\u8005\u53bbA\u3001B\u4e24\u5904\u7684\u8d39\u7528\uff0c\u73b0\u5728\u9700\u8981\u5e73\u5747\u5206\u522b 2n \u4e2a\u4eba\u5230 A\u3001B \u4e24\u5904\uff0c\u8bd5\u95ee\uff0c\u6700\u5c0f\u7684\u6210\u672c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u8003\u8651 2n \u4e2a\u4eba\u90fd\u53bb B \u65f6\uff0c\u603b\u7684\u8d39\u7528\u662f \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \u3002\u6b64\u65f6\uff0c\u6211\u4eec\u9700\u8981\u9009\u62e9 n \u4e2a\u4eba\u653e\u5230 A \u5904\uff0c\u90a3\u4e48\u5982\u4f55\u9009\u62e9\u5462\uff1f\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u5982\u679c\u5c06\u4e00\u4e2a\u4eba\u4ece B \u653e\u5230 A\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u603b\u6210\u672c\u53d8\u5316\u91cf\u662f \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \uff0c\u521a\u597d\u5bf9\u5e94\u7740\u6210\u672cA - B\uff0c\u90a3\u4e48\u5bf9\u4e8e n \u4e2a\u4eba\uff0c\u6211\u4eec\u5e0c\u671b\u9009\u62e9\u524d n \u4e2a\u6700\u5c0f\u5dee\u503c\u3002\u5047\u8bbe\u8bf4\uff0c\u6211\u4eec\u6709\u4e00\u4e2a\u89e3\uff0c\u4e0d\u662f\u5dee\u503c\u7684\u524d n \u4e2a\uff0c\u90a3\u4e48\u6211\u4eec\u603b\u53ef\u4ee5\u627e\u5230\u4e00\u4e2a\u66f4\u5c0f\u7684\u5dee\u503c\uff0c\u4f7f\u5f97\u603b\u7684\u8d39\u7528\u53d8\u5c0f\uff0c\u8fd9\u5c31\u662f\u8d2a\u5fc3\u7684\u601d\u60f3\u3002 \u8fd9\u91cc\uff0c\u6211\u4eec\u7528\u4e86\u6392\u5e8f\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u4e2d\u95f4\u7684\u67d0\u4e00\u4e2a\u503c\uff0c\u4f7f\u5f97\u524d n \u4e2a\u5dee\u503c\u5747\u5c0f\u96e8\u540e n \u4e2a\u5dee\u503c\u3002\u6539\u8fdb\u7684\u5feb\u6392\u80fd\u591f\u5b9e\u73b0\u6b64\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int twoCitySchedCost ( vector < vector < int >>& costs ) { int ans = 0 , n = ( int ) costs . size (); int l = 0 , r = n - 1 ; while ( true ) { while ( l < r ) { while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { r -- ; } swap ( costs [ l ], costs [ r ]); while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { l ++ ; } swap ( costs [ l ], costs [ r ]); } if ( 2 * l == n - 2 ) { break ; } if ( 2 * l > n - 2 ) { r = l - 1 ; l = 0 ; } else { l ++ ; r = n - 1 ; } } for ( int i = 0 ; i < n / 2 ; i ++ ) { ans += costs [ i ][ 0 ] + costs [ n - 1 - i ][ 1 ]; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u5e94\u8058\u8005\u7684\u603b\u4eba\u6570\u3002 \u4e70\u96ea\u7cd5 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4 costs = [1, 3, 2, 4, 1] \u8868\u793a\u96ea\u7cd5\u7684\u4ef7\u683c\uff0c\u4ee5\u53ca\u4e00\u4e2a\u6574\u6570 coins = 7 \u8868\u793a\u6301\u6709\u7684\u91d1\u989d\uff0c\u8bd5\u95ee\uff0c\u6211\u4eec\u53ef\u4ee5\u4e70\u591a\u5c11\u652f\u96ea\u7cd5\uff1f \u300c\u5206\u6790\u300d \u5c06\u96ea\u7cd5\u7684\u4ef7\u683c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u6c42\u7d2f\u8ba1\u82b1\u8d39\u4e0d\u8d85\u8fc7\u7ed9\u5b9a\u91d1\u989d\u7684\u96ea\u7cd5\u6570\u76ee\u3002\u4e3a\u4ec0\u4e48\u8fd9\u6837\u662f\u6b63\u786e\u7684\uff1f\u6392\u5e8f\u540e\u7684\u96ea\u7cd5\u4ef7\u683c\uff1a c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} \u7ecf\u8fc7\u8ba1\u7b97\uff0c\u53d1\u73b0\u524d k \u652f\u96ea\u7cd5\u662f\u80fd\u591f\u4e70\u4e0b\u7684\uff0c\u7b2c k + 1 \u652f\u96ea\u7cd5\u662f\u4e0d\u80fd\u4e70\u4e0b\u3002\u6b64\u65f6\u662f\u6700\u4f18\u89e3\u3002\u5f53\u7136\uff0c\u4f1a\u5b58\u5728\u53e6\u4e00\u79cd\u60c5\u51b5\uff0c\u67d0\u652f\u96ea\u7cd5\u4e0d\u662f\u4ef7\u683c\u524d k \u5c0f\u7684\uff0c\u4f46\u662f\u5df2\u7136\u80fd\u591f\u4e70\u4e0b\uff0c\u6b64\u65f6\u5bf9\u5e94\u7684\u7ed9\u5b9a\u7684\u94b1\u6ca1\u6709\u90fd\u82b1\u5b8c\u3002\u5373\u4fbf\u5982\u6b64\uff0c\u96ea\u7cd5\u7684\u603b\u6570\u5df2\u7136\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 int maxIceCream ( vector < int >& costs , int coins ) { int ans = 0 ; sort ( costs . begin (), costs . end ()); for ( int cost : costs ) { if ( cost > coins ) { return ans ; } coins -= cost ; ans ++ ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u96ea\u7cd5\u7684\u6570\u76ee\u3002 \u7531 X \u5230 Y \u7684\u6700\u5c11\u64cd\u4f5c\u6570 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6b63\u6570 X \u548c Y\uff0c\u53ea\u80fd\u5c06 X \u52a0\u500d\u6216\u8005\u5c06 X \u51cf\u53bb\u4e00\uff0c\u8bd5\u95ee\u7ecf\u8fc7\u591a\u5c11\u6b21\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u53ef\u4ee5\u628a X \u53d8\u6210 Y\uff1f \u300c\u5206\u6790\u300d \u5982\u679c X >= Y\uff0c\u90a3\u4e48\u53ea\u80fd\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\uff1b\u53cd\u4e4b\uff0c\u6267\u884c\u52a0\u500d\u64cd\u4f5c\u5feb\u901f\u903c\u8fd1 Y \uff0c\u5728\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\u3002\u4f46\u662f\u5728\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\uff0c\u8003\u8651\u5230\u6570\u636e\u8303\u56f4\u95ee\u9898\uff0c\u6211\u4eec\u503e\u5411\u4f7f\u7528\u9006\u5411\u601d\u7ef4\uff0c\u5373\u5c06 Y \u51cf\u534a\u6216\u8005\u52a0\u4e00\u53d8\u6210 X\u3002\u6ce8\u610f\u5230\uff0c\u5f53 Y \u4e3a\u5947\u6570\u65f6\uff0c\u53ea\u80fd\u6267\u884c\u52a0\u4e00\u64cd\u4f5c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int brokenCalc ( int x , int y ) { if ( x >= y ) { return x - y ; } int ans = 0 ; while ( x < y ) { if ( y % 2 != 0 ) { y ++ ; } else { y >>= 1 ; } ans ++ ; } return ans + x - y ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log y) O(\\log y) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u589e\u52a0 k \u540e\u9ad8\u9891\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 2, 4] \u548c\u4e00\u4e2a\u6574\u6570 k = 5\uff0c\u6bcf\u6b21\u5141\u8bb8\u9009\u6570\u7ec4\u4e2d\u7684\u4e00\u4e2a\u6570\u52a0\u4e00\uff0c\u6700\u591a\u6267\u884c k \u6b21\u3002\u8bd5\u95ee\uff0c\u8fd9\u6837\u7684\u64cd\u4f5c\u540e\uff0c\u6570\u7ec4\u4e2d\u7684\u6700\u9ad8\u9891\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570\u662f\u591a\u5c11\uff1f\u4e0a\u8ff0\u4f8b\u5b50\u7684\u7ed3\u679c\u662f 3\u3002 \u300c\u5206\u6790\u300d \u3010\u52a0\u4e00\u3011\u64cd\u4f5c\u662f\u5355\u5411\u884c\u4e3a\uff0c\u5373\u53ea\u6709\u5c06\u8f83\u5c0f\u7684\u6570\u3010\u52a0\u4e00\u3011\u624d\u6709\u610f\u4e49\uff0c\u5e76\u4e14\uff0c\u8d8a\u9760\u8fd1\u76ee\u6807\u7684\u6570\u3010\u52a0\u4e00\u3011\u7684\u6b21\u6570\u8d8a\u5c11\uff0c\u8fd9\u7b26\u5408\u4e86\u3010\u8d2a\u5fc3\u3011\u7684\u601d\u60f3\u3002\u56e0\u6b64\uff0c\u89e3\u9898\u529e\u6cd5\u662f\u3010\u6392\u5e8f\u3011+\u3010\u4e8c\u5206\u67e5\u627e\u3011+\u3010\u524d\u7f00\u548c\u3011\uff0c\u6211\u4eec\u5c06\u6570\u7ec4\u6392\u5e8f\u540e\uff0c\u76f8\u540c\u7684\u503c\u9760\u5728\u4e00\u8d77\u3002\u4efb\u610f\u4e00\u4e2a\u53ef\u884c\u89e3\u5fc5\u7136\u6ee1\u8db3\u8fd9\u6837\u4e00\u4e2a\u7279\u5f81\uff1a\u5b83\u662f\u4e00\u4e2a\u533a\u95f4 [l, r] \u8fd9\u4e2a\u533a\u95f4\u7684\u6240\u6709\u503c\u90fd\u4f1a\u53d8\u6210 nums[ r ]\uff0c\u6211\u4eec\u60f3\u627e\u6700\u9ad8\u9891\u7684\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u4e5f\u5c31\u662f [l, r] \u8fd9\u4e2a\u533a\u95f4\u7684\u957f\u5ea6\uff0c\u81ea\u7136\u5730\u5e0c\u671b\u8fd9\u4e2a\u533a\u95f4\u8d8a\u957f\u8d8a\u597d\u3002\u4f46\u662f\uff0c\u8fd9\u4e2a\u533a\u95f4\u9700\u8981\u6ee1\u8db3\u4e00\u4e2a\u8981\u6c42\uff0c\u3010\u52a0\u4e00\u3011\u7684\u64cd\u4f5c\u6b21\u6570\u4e0d\u8d85\u8fc7 k\uff0c\u90a3\u4e48\u5982\u4f55\u8ba1\u7b97\u3010\u52a0\u4e00\u3011\u64cd\u4f5c\u6570\u5462\uff1f\u7b54\u6848\u662f\u3010\u524d\u7f00\u548c\u3011\uff0c\u5373\u3010\u52a0\u4e00\u3011\u64cd\u4f5c\u6570\u7b49\u4e8e\u3010\u64cd\u4f5c\u540e\u7684\u533a\u95f4\u548c\u3011\u51cf\u53bb\u3010\u64cd\u4f5c\u524d\u7684\u533a\u95f4\u548c\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int maxFrequency ( vector < int >& nums , int k ) { int n = ( int ) nums . size (), ans = 0 ; if ( n == 0 ) { return 0 ; } sort ( nums . begin (), nums . end ()); vector < long > sum ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { sum [ i + 1 ] = sum [ i ] + nums [ i ]; int l = 0 , r = i ; while ( l < r ) { int m = ( l + r ) >> 1 ; if (( long )( i + 1 - m ) * nums [ i ] - ( sum [ i + 1 ] - sum [ m ]) > k ) { l = m + 1 ; } else { r = m ; } } ans = max ( ans , i - l + 1 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u4e24\u6570\u548c\u7684\u6700\u5c0f\u503c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4f4d\u5076\u6570\u7684\u6570\u7ec4 nums = [3, 5, 4, 2, 4, 6]\uff0c\u5c06\u6570\u7ec4\u5185\u7684\u5143\u7d20\u4e24\u4e24\u914d\u5bf9\uff0c\u5e76\u8ba1\u7b97\u4e24\u8005\u548c\uff0c\u8bd5\u95ee\u6240\u6709\u7684\u914d\u5bf9\u548c\u7684\u6700\u5c0f\u503c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u6211\u4eec\u5e0c\u671b\u5f97\u5230\u6700\u5c0f\u548c\uff0c\u90a3\u4e48\u4f18\u5148\u9009\u62e9\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u914d\u5bf9\uff0c\u8fd9\u7b26\u5408\u3010\u8d2a\u5fc3\u3011\u7684\u60f3\u6cd5\u3002\u5e76\u4e14\u6211\u4eec\u53ef\u4ee5\u8bc1\u660e\uff0c\u6709\u5e8f\u7684\u56db\u4e2a\u6570\uff1aa\u3001b\u3001c\u3001d\uff0c\u53ea\u6709 \uff08a + d\uff09\u3001(b + c) \u8fd9\u6837\u7684\u7ec4\u5408\u5177\u6709\u6700\u5c0f\u548c\u3002\u90a3\u4e48\uff0c\u5bf9\u4e8e 2n \u4e2a\u5143\u7d20\uff0c\u6700\u4f18\u914d\u5bf9\u5982\u4e0b s = \\min \\{x_{1}+x_{2n}, x_{2}+x_{xn-1}, \\cdots, x_{n}+x_{n+1}\\} s = \\min \\{x_{1}+x_{2n}, x_{2}+x_{xn-1}, \\cdots, x_{n}+x_{n+1}\\} \u5047\u8bbe\u6211\u4eec\u8c03\u6574\u4e24\u4e2a\u503c x_{i} x_{i} , x_{j} x_{j} \u7684\u4f4d\u7f6e\uff0c\u5f97\u5230\u4e00\u4e2a\u65b0\u7684\u89e3 s\u2018\uff0c\u5229\u7528\u4e0a\u9762\u7684 a\u3001b\u3001c\u3001d \u7684\u8bc1\u660e\u59d0\u7ed3\u679c\uff0c\u53ef\u77e5\u65b0\u89e3 s' \u4e00\u5b9a\u662f\u4e0d\u4f18\u4e8e s \u7684\u3002 1 2 3 4 5 6 7 8 int minPairSum ( vector < int >& nums ) { int ans = INT_MIN , n = ( int ) nums . size (); sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n / 2 ; i ++ ) { ans = max ( ans , nums [ i ] + nums [ n - 1 - i ]); } return ans ; } \u6700\u5c0f\u7684\u8239\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4eba\u5458\u4f53\u91cd\u7684\u5217\u8868 people = [3, 5, 3, 4] \u548c\u4e00\u4e2a\u6574\u6570 limit = 5\uff0c\u4e00\u8258\u8239\u4e00\u6b21\u6700\u591a\u8f7d\u4e24\u4e2a\u4eba\uff0c\u5e76\u4e14\u91cd\u91cf\u548c\u4e0d\u8d85\u8fc7 limit\uff0c\u8bd5\u95ee\u6700\u5c0f\u9700\u8981\u591a\u5c11\u8258\u8239\uff1f \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u5c3d\u53ef\u80fd\u7684\u8ba9\u4e00\u8258\u8239\u8f7d\u4e24\u4e2a\u4eba\uff0c\u4ece\u4f53\u91cd\u5927\u7684\u4eba\u5f00\u59cb\u904d\u5386\uff0c\u5982\u679c\u80fd\u9047\u5230\u4e00\u4e2a\u8f7b\u7684\u4eba\uff0c\u5c31\u628a\u4ed6\u52a0\u5165\u5230\u8239\u4e0a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int numRescueBoats ( vector < int >& people , int limit ) { int ans = 0 , l = 0 , r = ( int ) people . size () - 1 ; sort ( people . begin (), people . end ()); while ( l < r ) { if ( people [ l ] + people [ r ] <= limit ) { l ++ ; } ans ++ ; r -- ; } return ans + ( l == r ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u5747\u5206\u6570\u5b57 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 nums = [1, 0, 5]\uff0c\u6bcf\u6b21\u53ef\u4ee5\u9009\u82e5\u5e72\u4e2a\u4f4d\u7f6e\uff0c\u5c06\u6570\u5b57\u51cf\u4e00\uff0c\u7136\u540e\u5bf9\u76f8\u90bb\u7684\u4e00\u4e2a\u4f4d\u7f6e\u52a0\u4e00\uff0c\u5982\u4e0b \\begin{matrix} \\text{1st: } & 1 & & 0 & \\leftarrow & 5 & & \\Rightarrow & & 1 & & 1 & & 4 \\\\ \\text{2nd: } & 1 & \\leftarrow & 1 & \\leftarrow & 4 & & \\Rightarrow & & 2 & & 1 & & 3 \\\\ \\text{3rd: } & 2 & \\leftarrow & 1 & \\leftarrow & 3 & & \\Rightarrow & & 2 & & 2 & & 2 \\\\ \\end{matrix} \\begin{matrix} \\text{1st: } & 1 & & 0 & \\leftarrow & 5 & & \\Rightarrow & & 1 & & 1 & & 4 \\\\ \\text{2nd: } & 1 & \\leftarrow & 1 & \\leftarrow & 4 & & \\Rightarrow & & 2 & & 1 & & 3 \\\\ \\text{3rd: } & 2 & \\leftarrow & 1 & \\leftarrow & 3 & & \\Rightarrow & & 2 & & 2 & & 2 \\\\ \\end{matrix} \u300c\u5206\u6790\u300d \u3010\u8d2a\u5fc3\u3011\u5148\u5224\u65ad\u6570\u503c\u4e4b\u548c\u80fd\u5426\u88ab\u6570\u7ec4\u957f\u5ea6\u6574\u9664\u3002\u5982\u679c\u53ef\u4ee5\u7684\u8bdd\uff0c\u6bcf\u4e00\u4e2a\u6570\u51cf\u53bb\u5e73\u5747\u503c\uff0c\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5982\u679c\u662f\u6b63\u6570 k\uff0c\u90a3\u4e48\u610f\u5473\u7740\uff0c\u6700\u5c11 k \u6b21\u3010\u51cf\u4e00\u3011\uff0c\u5982\u679c\u662f\u8d1f\u6570\uff0c\u6700\u5c11 k \u6b21\u3010\u52a0\u4e00\u3011\uff0c\u5e76\u4e14\u5982\u679c\u51fa\u73b0\u8fde\u7eed\u51e0\u4e2a\u6b63\u6570\u6216\u8005\u8d1f\u6570\uff0c\u8fd9\u610f\u5473\u7740\uff0c\u3010\u51cf\u4e00\u3011\u6216\u8005\u3010\u52a0\u4e00\u3011\u9700\u8981\u4f20\u9012\u5230\u540e\u9762\u7684\u4f4d\u7f6e\uff0c\u4f8b\u5982 [1, 1, -1, -1] \u548c [1, -1, -1, 1] \u662f\u4e0d\u540c\u7684\uff0c\u524d\u8005\u9700\u8981 2 \u6b21\uff0c\u800c\u540e\u8005\u9700\u8981 1 \u6b21\uff0c\u8fd9\u662f\u56e0\u4e3a [1, 1] \u6bd7\u90bb\u51fa\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int findMinMoves ( vector < int >& machines ) { int sum = 0 , cnt = 0 ; for ( int m : machines ) { sum += m ; cnt ++ ; } if ( sum % cnt != 0 ) { return - 1 ; } int ans = 0 , avg = sum / cnt ; for ( int & m : machines ) { m -= avg ; } int presum = 0 ; for ( int m : machines ) { presum += m ; ans = max ( ans , max ( abs ( presum ), m )); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) IPO \u00b6 \u7ed9\u4f60 n \u4e2a\u9879\u76ee\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u9879\u76ee i \uff0c\u5b83\u90fd\u6709\u4e00\u4e2a\u7eaf\u5229\u6da6 profits[i] \uff0c\u548c\u542f\u52a8\u8be5\u9879\u76ee\u9700\u8981\u7684\u6700\u5c0f\u8d44\u672c capital[i] \u3002\u6700\u521d\uff0c\u4f60\u7684\u8d44\u672c\u4e3a w \u3002\u5f53\u4f60\u5b8c\u6210\u4e00\u4e2a\u9879\u76ee\u65f6\uff0c\u4f60\u5c06\u83b7\u5f97\u7eaf\u5229\u6da6\uff0c\u4e14\u5229\u6da6\u5c06\u88ab\u6dfb\u52a0\u5230\u4f60\u7684\u603b\u8d44\u672c\u4e2d\u3002\u603b\u800c\u8a00\u4e4b\uff0c\u4ece\u7ed9\u5b9a\u9879\u76ee\u4e2d\u9009\u62e9 \u6700\u591a k \u4e2a\u4e0d\u540c\u9879\u76ee\u7684\u5217\u8868\uff0c\u4ee5 \u6700\u5927\u5316\u6700\u7ec8\u8d44\u672c \uff0c\u5e76\u8f93\u51fa\u6700\u7ec8\u53ef\u83b7\u5f97\u7684\u6700\u591a\u8d44\u672c\u3002 \u5982k = 2, w = 0, profits = [1,2,3], capital = [0,1,1] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u7531\u4e8e\u4f60\u7684\u521d\u59cb\u8d44\u672c\u4e3a 0\uff0c\u4f60\u4ec5\u53ef\u4ee5\u4ece 0 \u53f7\u9879\u76ee\u5f00\u59cb\u3002\u5728\u5b8c\u6210\u540e\uff0c\u4f60\u5c06\u83b7\u5f97 1 \u7684\u5229\u6da6\uff0c\u4f60\u7684\u603b\u8d44\u672c\u5c06\u53d8\u4e3a 1\u3002\u6b64\u65f6\u4f60\u53ef\u4ee5\u9009\u62e9\u5f00\u59cb 1 \u53f7\u6216 2 \u53f7\u9879\u76ee\u3002\u7531\u4e8e\u4f60\u6700\u591a\u53ef\u4ee5\u9009\u62e9\u4e24\u4e2a\u9879\u76ee\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u5b8c\u6210 2 \u53f7\u9879\u76ee\u4ee5\u83b7\u5f97\u6700\u5927\u7684\u8d44\u672c\u3002\u56e0\u6b64\uff0c\u8f93\u51fa\u6700\u540e\u6700\u5927\u5316\u7684\u8d44\u672c\uff0c\u4e3a 0 + 1 + 3 = 4\u3002 \u300c\u5206\u6790\u300d \u3010\u8d2a\u5fc3 + \u5927\u9876\u5806\u3011\u56e0\u4e3a w \u4e00\u76f4\u5728\u53d8\u6362\uff0c\u6211\u95e8\u6392\u9664\u4e86\u52a8\u6001\u89c4\u5212\u7684\u53ef\u80fd\u6027\u3002\u9898\u76ee\u7684\u610f\u601d\u662f\uff0c\u6bcf\u6b21\u4ece\u6240\u6709\u4e0d\u8d85\u8fc7 w \u7684\u9879\u76ee\u4e2d\u9009\u62e9\u6700\u5927\u7684\u6536\u76ca\u7684\u90a3\u4e2a\uff0c\u7136\u540e\u66f4\u65b0 w\uff0c\u8fd9\u5c31\u662f\u3010\u8d2a\u5fc3\u3011\u7684\u601d\u60f3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int findMaximizedCapital ( int k , int w , vector < int >& profits , vector < int >& capital ) { priority_queue < int , vector < int > , less < int >> pq ; vector < vector < int >> cp ; int n = ( int ) profits . size (); for ( int i = 0 ; i < n ; i ++ ) { cp . emplace_back ( vector < int > { capital [ i ], profits [ i ]}); } sort ( cp . begin (), cp . end ()); for ( int i = 0 , j = 0 ; i < k ; i ++ ) { for (; j < n && cp [ j ][ 0 ] <= w ; j ++ ) { pq . push ( cp [ j ][ 1 ]); } if ( pq . empty ()) { break ; } w += pq . top (); pq . pop (); } return w ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u5b8c\u6210\u4efb\u52a1\u7684\u6700\u5c0f\u521d\u59cb\u80fd\u91cf \u00b6 \u7ed9\u51fa\u4e00\u4e2a\u4efb\u52a1\u5217\u8868 tasks = [[1, 2],[2, 4],[4, 8]]\uff0c\u8868\u793a\u4e00\u4e2a\u4efb\u52a1\u7684\u6240\u9700\u8981\u7684\u80fd\u91cf\u548c\u5f00\u542f\u8fd9\u9879\u4efb\u52a1\u7684\u80fd\u91cf\uff0c\u5982\u4efb\u52a11\u9700\u8981\u80fd\u91cf\u503c 2 \u624d\u80fd\u542f\u52a8\uff0c\u5b8c\u6210\u540e\uff0c\u6263\u9664\u80fd\u91cf\u503c 1.\u8bd5\u95ee\uff0c\u6700\u5c11\u8981\u51c6\u5907\u591a\u5c11\u80fd\u91cf\u503c\uff0c\u624d\u80fd\u5b8c\u6210\u6240\u6709\u4efb\u52a1\uff08\u53ef\u4ee5\u65e0\u5e8f\uff09\uff1f \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u4efb\u610f\u4e24\u4e2a\u4efb\u52a1\uff0ct1 \u548c t2\uff0ct1[ 1 ] - t1[ 0 ] > t2[ 1 ] - t2[ 0 ]\uff0c\u5982\u679c\u5148\u5b8c\u6210 t1 \u540e\u5b8c\u6210 t2\uff0c\u90a3\u4e48 t1 \u7684\u5dee\u503c\u6709\u4e00\u90e8\u53ef\u4ee5\u7ed9 t2[ 1 ]\uff0c\u53cd\u8fc7\u6765\uff0c\u5148\u5b8c\u6210 t2\uff0c\u5bf9 t1 \u989d\u5916\u8865\u5145\u66f4\u591a\u7684\u80fd\u91cf\u3002\u56e0\u6b64\u6211\u4eec\u9009\u62e9\u5bf9 tasks \u6309\u7167\u3010\u6240\u9700\u80fd\u91cf\u503c - \u6d88\u8017\u80fd\u91cf\u503c\u3011\u6392\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int minimumEffort ( vector < vector < int >>& tasks ) { int ans = 0 ; sort ( tasks . begin (), tasks . end (), []( const vector < int > a , const vector < int > b ){ return a [ 1 ] - a [ 0 ] < b [ 1 ] - b [ 0 ]; }); for ( auto task : tasks ) { if ( ans + task [ 0 ] < task [ 1 ]) { ans = task [ 1 ]; } else { ans += task [ 0 ]; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u6700\u5c0f\u5dee\u503c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 3, 6] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0c\u5bf9\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u3010\u52a0k\u3011\u6216\u8005\u3010\u51cfk\u3011\uff0c\u8bd5\u95ee\uff0c\u6700\u7ec8\u7684\u65b0\u6570\u7ec4\u7684\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c\u4e4b\u5dee\u7684\u6700\u5c0f\u662f\u591a\u5c11\uff1f\u4f8b\u5b50\u5bf9\u5e94\u7684\u7ed3\u679c\u662f 3 \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u5bf9\u6570\u7ec4\u8fdb\u884c\u6392\u5e8f\u540e\uff0c\u6709\u4e00\u4e2a\u4f4d\u7f6e i \u6ee1\u8db3\uff0ci \u53ca\u5176\u5de6\u4fa7\u7684\u6570\u503c\u3010\u52a0k\u3011\uff0ci \u53f3\u4fa7\u7684\u6570\u3010\u51cfk\u3011\u3002\u5e76\u4e14\uff0cmin(nums[ 0 ] + k, nums[i + 1] - k) \u5f62\u6210\u4e0b\u754c\uff0cmax(nums[ i ] + k, nums[n - 1] - k) \u5f62\u6210\u4e0b\u754c 1 2 3 4 5 6 7 8 9 10 11 int smallestRangeII ( vector < int >& nums , int k ) { int n = ( int ) nums . size (); sort ( nums . begin (), nums . end ()); int ans = nums [ n - 1 ] - nums [ 0 ]; for ( int i = 0 ; i < n - 1 ; i ++ ) { int hi = max ( nums [ i ] + k , nums [ n - 1 ] - k ); int lo = min ( nums [ 0 ] + k , nums [ i + 1 ] - k ); ans = min ( ans , hi - lo ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u65e0\u91cd\u590d\u533a\u95f4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 interval = [[1, 2], [2, 3], [3, 4], [1, 3]]\uff0c\u5220\u9664\u67d0\u4e9b\u533a\u95f4\u540e\uff0c\u5269\u4f59\u7684\u533a\u95f4\u4e92\u4e0d\u91cd\u53e0\uff0c\u6c42\u6700\u5c11\u5220\u9664\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u6309\u7167\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u6392\u5e8f\uff0c\u7136\u540e\u4ece\u7b2c\u4e00\u4e2a\u533a\u95f4\u5f00\u59cb\u8d2a\u5fc3\u5730\u627e\u5230\u6240\u6709\u65e0\u91cd\u53e0\u7684\u533a\u95f4\u3002\u6211\u4eec\u7684\u76ee\u7684\u662f\u627e\u5230\u6700\u591a\u7684\u533a\u95f4\uff0c\u90a3\u4e48\u5355\u4e2a\u533a\u95f4\u8de8\u5ea6\u5e94\u5f53\u5c3d\u53ef\u80fd\u5c0f\u3002\u8003\u8651\u6392\u5e8f\u540e\u7684\u4e24\u4e2a\u76f8\u90bb\u533a\u95f4 v1\u3001v2\uff0c\u4ed6\u4eec\u7684\u91cd\u53e0\u5173\u7cfb\u6709\u4e09\u79cd\uff1a\uff081\uff09v1 \u5b8c\u5168\u5305\u542b\u4e8e v2\uff0c\uff082\uff09v1 \u4e0e v2 \u90e8\u5206\u91cd\u53e0\uff0c\uff083\uff09v1 \u4e0e v2 \u4e0d\u91cd\u53e0\u3002\u60c5\u51b5\uff081\uff09\u548c\uff082\uff09\u90fd\u662f\u4e0d\u7b26\u5408\u7684\uff0c\u9700\u8981\u53bb\u6389\u5176\u4e2d\u4e00\u4e2a\uff0c\u663e\u7136\u53bb\u6389 v2 \u66f4\u80fd\u4fdd\u8bc1\u540e\u7eed\u7684\u533a\u95f4\u51fa\u73b0\u66f4\u591a\u7684\u672a\u91cd\u53e0\u533a\u95f4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int eraseOverlapIntervals ( vector < vector < int >>& intervals ) { int n = ( int ) intervals . size (), cnt = 1 ; sort ( intervals . begin (), intervals . end (), []( const auto & v1 , const auto & v2 ){ return v1 [ 1 ] < v2 [ 1 ]; }); int right = intervals [ 0 ][ 1 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( right <= intervals [ i ][ 0 ]) { right = intervals [ i ][ 1 ]; cnt ++ ; } } return n - cnt ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u8df3\u8dc3\u6e38\u620f \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \uff0c\u4f60\u6700\u521d\u4f4d\u4e8e\u6570\u7ec4\u7684 \u7b2c\u4e00\u4e2a\u4e0b\u6807 \u3002\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u4f60\u5728\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u7684\u6700\u5927\u957f\u5ea6\u3002\u5224\u65ad\u4f60\u662f\u5426\u80fd\u591f\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4e0b\u6807\u3002\u4f8b\u5982\uff0cnums = [2,3,1,1,4]\uff0c\u8fd4\u56de true\uff0c\u56e0\u4e3a\u53ef\u4ee5\u5148\u8df3 1 \u6b65\uff0c\u4ece\u4e0b\u6807 0 \u5230\u8fbe\u4e0b\u6807 1, \u7136\u540e\u518d\u4ece\u4e0b\u6807 1 \u8df3 3 \u6b65\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4e0b\u6807\u3002 1 2 3 4 5 6 7 8 9 10 bool canJump ( vector < int >& nums ) { int n = ( int ) nums . size (), farestPositon = 0 , end = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { farestPositon = max ( farestPositon , nums [ i ] + i ); if ( i == end ) { end = farestPositon ; } } return end >= n - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u8df3\u8dc3\u6e38\u620f II \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0c\u4f60\u6700\u521d\u4f4d\u4e8e\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u3002\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u4f60\u5728\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u7684\u6700\u5927\u957f\u5ea6\u3002\u4f60\u7684\u76ee\u6807\u662f\u4f7f\u7528\u6700\u5c11\u7684\u8df3\u8dc3\u6b21\u6570\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002 \u5047\u8bbe\u4f60\u603b\u662f\u53ef\u4ee5\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002\u4f8b\u5982\uff0cnums = [2,3,1,1,4]\uff0c\u8fd4\u56de 2\u3002\u56e0\u4e3a\u4ece\u4e0b\u6807\u4e3a 0 \u8df3\u5230\u4e0b\u6807\u4e3a 1 \u7684\u4f4d\u7f6e\uff0c\u8df3 1 \u6b65\uff0c\u7136\u540e\u8df3 3 \u6b65\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 int jump ( vector < int >& nums ) { int n = ( int ) nums . size (), farestPositon = 0 , end = 0 , ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { farestPositon = max ( farestPositon , nums [ i ] + i ); if ( i == end ) { end = farestPositon ; ans ++ ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u8d2a\u5fc3"},{"location":"algo/greedy/#_1","text":"\u8d2a\u5fc3\u7b97\u6cd5\uff08greedy algorithm\uff09\u662f\u8ba1\u7b97\u673a\u6a21\u62df\u4eba\u7c7b\u51b3\u7b56\u7684\u4e00\u79cd\u7b97\u6cd5\uff0c\u8868\u73b0\u4e3a\u8ffd\u6c42\u5f53\u524d\u6700\u4f18\u89e3\uff0c\u800c\u4e0d\u987e\u53ca\u5168\u5c40\u6700\u4f18\u89e3\uff0c\u5177\u6709\u300c\u77ed\u89c6\u300d\u7279\u70b9\uff0c\u5373\u4f18\u5148\u9009\u62e9\u5f53\u524d\u6700\u6709\u5229\u7684\u65b9\u6848\u3002","title":"\u4ecb\u7ecd"},{"location":"algo/greedy/#_2","text":"\u8d2a\u5fc3\u7b97\u6cd5\u9002\u7528\u4e8e\u5177\u6709\u6700\u6709\u5b50\u7ed3\u6784\u7684\u95ee\u9898\uff0c\u53ca\u5b50\u95ee\u9898\u7684\u89e3\u53ef\u4ee5\u9012\u63a8\u5230\u539f\u95ee\u9898\u7684\u89e3\u3002","title":"\u4f7f\u7528\u573a\u666f"},{"location":"algo/greedy/#_3","text":"\\star \\star \u53cd\u8bc1\u6cd5\uff1a\u5047\u8bbe\u5f53\u524d\u89e3\u4e0d\u662f\u6700\u4f18\u89e3\uff0c\u5982\u679c\u4e0d\u80fd\u627e\u5230\u4e00\u7ec4\u65b0\u7684\u89e3\u8868\u73b0\u7684\u6bd4\u5f53\u524d\u89e3\u8981\u597d\uff0c\u90a3\u4e48\u5f53\u524d\u89e3\u5373\u4e3a\u6700\u4f18\u89e3 \\star \\star \u5f52\u7eb3\u6cd5\uff1a\u8ba1\u7b97n=1\u65f6\u7684\u6700\u4f18\u89e3 F_{1} F_{1} \uff0c\u8bc1\u660e\u4e4b\u540e\u7684\u6bcf\u4e00\u4e2a\u89e3 F_{n} F_{n} \u53ef\u4ee5\u7531\u524d\u4e00\u4e2a\u5bfc\u51fa","title":"\u8bc1\u660e"},{"location":"algo/greedy/#_4","text":"\u8d2a\u5fc3\u7b97\u6cd5\u4e0e\u52a8\u6001\u89c4\u5212\u7684\u533a\u522b\u4e3a\uff0c\u8d2a\u5fc3\u95ee\u9898\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0\u3002","title":"\u533a\u522b"},{"location":"algo/greedy/#_5","text":"","title":"\u9898\u76ee"},{"location":"algo/greedy/#_6","text":"\u516c\u53f8\u6709 2n \u4e2a\u5e94\u8058\u8005\u53c2\u52a0\u9762\u8bd5\uff0c\u53ef\u4ee5\u9009\u62e9A\u3001B\u5176\u4e2d\u4e00\u5904\uff0c\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 costs =[[259, 770], [448, 54], [926, 667], [184, 139], [840, 118], [577, 469]] \u8868\u793a\u5e94\u8058\u8005\u53bbA\u3001B\u4e24\u5904\u7684\u8d39\u7528\uff0c\u73b0\u5728\u9700\u8981\u5e73\u5747\u5206\u522b 2n \u4e2a\u4eba\u5230 A\u3001B \u4e24\u5904\uff0c\u8bd5\u95ee\uff0c\u6700\u5c0f\u7684\u6210\u672c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u8003\u8651 2n \u4e2a\u4eba\u90fd\u53bb B \u65f6\uff0c\u603b\u7684\u8d39\u7528\u662f \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \u3002\u6b64\u65f6\uff0c\u6211\u4eec\u9700\u8981\u9009\u62e9 n \u4e2a\u4eba\u653e\u5230 A \u5904\uff0c\u90a3\u4e48\u5982\u4f55\u9009\u62e9\u5462\uff1f\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u5982\u679c\u5c06\u4e00\u4e2a\u4eba\u4ece B \u653e\u5230 A\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u603b\u6210\u672c\u53d8\u5316\u91cf\u662f \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \uff0c\u521a\u597d\u5bf9\u5e94\u7740\u6210\u672cA - B\uff0c\u90a3\u4e48\u5bf9\u4e8e n \u4e2a\u4eba\uff0c\u6211\u4eec\u5e0c\u671b\u9009\u62e9\u524d n \u4e2a\u6700\u5c0f\u5dee\u503c\u3002\u5047\u8bbe\u8bf4\uff0c\u6211\u4eec\u6709\u4e00\u4e2a\u89e3\uff0c\u4e0d\u662f\u5dee\u503c\u7684\u524d n \u4e2a\uff0c\u90a3\u4e48\u6211\u4eec\u603b\u53ef\u4ee5\u627e\u5230\u4e00\u4e2a\u66f4\u5c0f\u7684\u5dee\u503c\uff0c\u4f7f\u5f97\u603b\u7684\u8d39\u7528\u53d8\u5c0f\uff0c\u8fd9\u5c31\u662f\u8d2a\u5fc3\u7684\u601d\u60f3\u3002 \u8fd9\u91cc\uff0c\u6211\u4eec\u7528\u4e86\u6392\u5e8f\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u4e2d\u95f4\u7684\u67d0\u4e00\u4e2a\u503c\uff0c\u4f7f\u5f97\u524d n \u4e2a\u5dee\u503c\u5747\u5c0f\u96e8\u540e n \u4e2a\u5dee\u503c\u3002\u6539\u8fdb\u7684\u5feb\u6392\u80fd\u591f\u5b9e\u73b0\u6b64\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int twoCitySchedCost ( vector < vector < int >>& costs ) { int ans = 0 , n = ( int ) costs . size (); int l = 0 , r = n - 1 ; while ( true ) { while ( l < r ) { while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { r -- ; } swap ( costs [ l ], costs [ r ]); while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { l ++ ; } swap ( costs [ l ], costs [ r ]); } if ( 2 * l == n - 2 ) { break ; } if ( 2 * l > n - 2 ) { r = l - 1 ; l = 0 ; } else { l ++ ; r = n - 1 ; } } for ( int i = 0 ; i < n / 2 ; i ++ ) { ans += costs [ i ][ 0 ] + costs [ n - 1 - i ][ 1 ]; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u5e94\u8058\u8005\u7684\u603b\u4eba\u6570\u3002","title":"\u5206\u914d\u4eba\u5458"},{"location":"algo/greedy/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4 costs = [1, 3, 2, 4, 1] \u8868\u793a\u96ea\u7cd5\u7684\u4ef7\u683c\uff0c\u4ee5\u53ca\u4e00\u4e2a\u6574\u6570 coins = 7 \u8868\u793a\u6301\u6709\u7684\u91d1\u989d\uff0c\u8bd5\u95ee\uff0c\u6211\u4eec\u53ef\u4ee5\u4e70\u591a\u5c11\u652f\u96ea\u7cd5\uff1f \u300c\u5206\u6790\u300d \u5c06\u96ea\u7cd5\u7684\u4ef7\u683c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u6c42\u7d2f\u8ba1\u82b1\u8d39\u4e0d\u8d85\u8fc7\u7ed9\u5b9a\u91d1\u989d\u7684\u96ea\u7cd5\u6570\u76ee\u3002\u4e3a\u4ec0\u4e48\u8fd9\u6837\u662f\u6b63\u786e\u7684\uff1f\u6392\u5e8f\u540e\u7684\u96ea\u7cd5\u4ef7\u683c\uff1a c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} \u7ecf\u8fc7\u8ba1\u7b97\uff0c\u53d1\u73b0\u524d k \u652f\u96ea\u7cd5\u662f\u80fd\u591f\u4e70\u4e0b\u7684\uff0c\u7b2c k + 1 \u652f\u96ea\u7cd5\u662f\u4e0d\u80fd\u4e70\u4e0b\u3002\u6b64\u65f6\u662f\u6700\u4f18\u89e3\u3002\u5f53\u7136\uff0c\u4f1a\u5b58\u5728\u53e6\u4e00\u79cd\u60c5\u51b5\uff0c\u67d0\u652f\u96ea\u7cd5\u4e0d\u662f\u4ef7\u683c\u524d k \u5c0f\u7684\uff0c\u4f46\u662f\u5df2\u7136\u80fd\u591f\u4e70\u4e0b\uff0c\u6b64\u65f6\u5bf9\u5e94\u7684\u7ed9\u5b9a\u7684\u94b1\u6ca1\u6709\u90fd\u82b1\u5b8c\u3002\u5373\u4fbf\u5982\u6b64\uff0c\u96ea\u7cd5\u7684\u603b\u6570\u5df2\u7136\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 int maxIceCream ( vector < int >& costs , int coins ) { int ans = 0 ; sort ( costs . begin (), costs . end ()); for ( int cost : costs ) { if ( cost > coins ) { return ans ; } coins -= cost ; ans ++ ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u96ea\u7cd5\u7684\u6570\u76ee\u3002","title":"\u4e70\u96ea\u7cd5"},{"location":"algo/greedy/#x-y","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6b63\u6570 X \u548c Y\uff0c\u53ea\u80fd\u5c06 X \u52a0\u500d\u6216\u8005\u5c06 X \u51cf\u53bb\u4e00\uff0c\u8bd5\u95ee\u7ecf\u8fc7\u591a\u5c11\u6b21\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u53ef\u4ee5\u628a X \u53d8\u6210 Y\uff1f \u300c\u5206\u6790\u300d \u5982\u679c X >= Y\uff0c\u90a3\u4e48\u53ea\u80fd\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\uff1b\u53cd\u4e4b\uff0c\u6267\u884c\u52a0\u500d\u64cd\u4f5c\u5feb\u901f\u903c\u8fd1 Y \uff0c\u5728\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\u3002\u4f46\u662f\u5728\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\uff0c\u8003\u8651\u5230\u6570\u636e\u8303\u56f4\u95ee\u9898\uff0c\u6211\u4eec\u503e\u5411\u4f7f\u7528\u9006\u5411\u601d\u7ef4\uff0c\u5373\u5c06 Y \u51cf\u534a\u6216\u8005\u52a0\u4e00\u53d8\u6210 X\u3002\u6ce8\u610f\u5230\uff0c\u5f53 Y \u4e3a\u5947\u6570\u65f6\uff0c\u53ea\u80fd\u6267\u884c\u52a0\u4e00\u64cd\u4f5c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int brokenCalc ( int x , int y ) { if ( x >= y ) { return x - y ; } int ans = 0 ; while ( x < y ) { if ( y % 2 != 0 ) { y ++ ; } else { y >>= 1 ; } ans ++ ; } return ans + x - y ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log y) O(\\log y) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u7531 X \u5230 Y \u7684\u6700\u5c11\u64cd\u4f5c\u6570"},{"location":"algo/greedy/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 2, 4] \u548c\u4e00\u4e2a\u6574\u6570 k = 5\uff0c\u6bcf\u6b21\u5141\u8bb8\u9009\u6570\u7ec4\u4e2d\u7684\u4e00\u4e2a\u6570\u52a0\u4e00\uff0c\u6700\u591a\u6267\u884c k \u6b21\u3002\u8bd5\u95ee\uff0c\u8fd9\u6837\u7684\u64cd\u4f5c\u540e\uff0c\u6570\u7ec4\u4e2d\u7684\u6700\u9ad8\u9891\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570\u662f\u591a\u5c11\uff1f\u4e0a\u8ff0\u4f8b\u5b50\u7684\u7ed3\u679c\u662f 3\u3002 \u300c\u5206\u6790\u300d \u3010\u52a0\u4e00\u3011\u64cd\u4f5c\u662f\u5355\u5411\u884c\u4e3a\uff0c\u5373\u53ea\u6709\u5c06\u8f83\u5c0f\u7684\u6570\u3010\u52a0\u4e00\u3011\u624d\u6709\u610f\u4e49\uff0c\u5e76\u4e14\uff0c\u8d8a\u9760\u8fd1\u76ee\u6807\u7684\u6570\u3010\u52a0\u4e00\u3011\u7684\u6b21\u6570\u8d8a\u5c11\uff0c\u8fd9\u7b26\u5408\u4e86\u3010\u8d2a\u5fc3\u3011\u7684\u601d\u60f3\u3002\u56e0\u6b64\uff0c\u89e3\u9898\u529e\u6cd5\u662f\u3010\u6392\u5e8f\u3011+\u3010\u4e8c\u5206\u67e5\u627e\u3011+\u3010\u524d\u7f00\u548c\u3011\uff0c\u6211\u4eec\u5c06\u6570\u7ec4\u6392\u5e8f\u540e\uff0c\u76f8\u540c\u7684\u503c\u9760\u5728\u4e00\u8d77\u3002\u4efb\u610f\u4e00\u4e2a\u53ef\u884c\u89e3\u5fc5\u7136\u6ee1\u8db3\u8fd9\u6837\u4e00\u4e2a\u7279\u5f81\uff1a\u5b83\u662f\u4e00\u4e2a\u533a\u95f4 [l, r] \u8fd9\u4e2a\u533a\u95f4\u7684\u6240\u6709\u503c\u90fd\u4f1a\u53d8\u6210 nums[ r ]\uff0c\u6211\u4eec\u60f3\u627e\u6700\u9ad8\u9891\u7684\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u4e5f\u5c31\u662f [l, r] \u8fd9\u4e2a\u533a\u95f4\u7684\u957f\u5ea6\uff0c\u81ea\u7136\u5730\u5e0c\u671b\u8fd9\u4e2a\u533a\u95f4\u8d8a\u957f\u8d8a\u597d\u3002\u4f46\u662f\uff0c\u8fd9\u4e2a\u533a\u95f4\u9700\u8981\u6ee1\u8db3\u4e00\u4e2a\u8981\u6c42\uff0c\u3010\u52a0\u4e00\u3011\u7684\u64cd\u4f5c\u6b21\u6570\u4e0d\u8d85\u8fc7 k\uff0c\u90a3\u4e48\u5982\u4f55\u8ba1\u7b97\u3010\u52a0\u4e00\u3011\u64cd\u4f5c\u6570\u5462\uff1f\u7b54\u6848\u662f\u3010\u524d\u7f00\u548c\u3011\uff0c\u5373\u3010\u52a0\u4e00\u3011\u64cd\u4f5c\u6570\u7b49\u4e8e\u3010\u64cd\u4f5c\u540e\u7684\u533a\u95f4\u548c\u3011\u51cf\u53bb\u3010\u64cd\u4f5c\u524d\u7684\u533a\u95f4\u548c\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int maxFrequency ( vector < int >& nums , int k ) { int n = ( int ) nums . size (), ans = 0 ; if ( n == 0 ) { return 0 ; } sort ( nums . begin (), nums . end ()); vector < long > sum ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { sum [ i + 1 ] = sum [ i ] + nums [ i ]; int l = 0 , r = i ; while ( l < r ) { int m = ( l + r ) >> 1 ; if (( long )( i + 1 - m ) * nums [ i ] - ( sum [ i + 1 ] - sum [ m ]) > k ) { l = m + 1 ; } else { r = m ; } } ans = max ( ans , i - l + 1 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u589e\u52a0 k \u540e\u9ad8\u9891\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570"},{"location":"algo/greedy/#_8","text":"\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4f4d\u5076\u6570\u7684\u6570\u7ec4 nums = [3, 5, 4, 2, 4, 6]\uff0c\u5c06\u6570\u7ec4\u5185\u7684\u5143\u7d20\u4e24\u4e24\u914d\u5bf9\uff0c\u5e76\u8ba1\u7b97\u4e24\u8005\u548c\uff0c\u8bd5\u95ee\u6240\u6709\u7684\u914d\u5bf9\u548c\u7684\u6700\u5c0f\u503c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u6211\u4eec\u5e0c\u671b\u5f97\u5230\u6700\u5c0f\u548c\uff0c\u90a3\u4e48\u4f18\u5148\u9009\u62e9\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u914d\u5bf9\uff0c\u8fd9\u7b26\u5408\u3010\u8d2a\u5fc3\u3011\u7684\u60f3\u6cd5\u3002\u5e76\u4e14\u6211\u4eec\u53ef\u4ee5\u8bc1\u660e\uff0c\u6709\u5e8f\u7684\u56db\u4e2a\u6570\uff1aa\u3001b\u3001c\u3001d\uff0c\u53ea\u6709 \uff08a + d\uff09\u3001(b + c) \u8fd9\u6837\u7684\u7ec4\u5408\u5177\u6709\u6700\u5c0f\u548c\u3002\u90a3\u4e48\uff0c\u5bf9\u4e8e 2n \u4e2a\u5143\u7d20\uff0c\u6700\u4f18\u914d\u5bf9\u5982\u4e0b s = \\min \\{x_{1}+x_{2n}, x_{2}+x_{xn-1}, \\cdots, x_{n}+x_{n+1}\\} s = \\min \\{x_{1}+x_{2n}, x_{2}+x_{xn-1}, \\cdots, x_{n}+x_{n+1}\\} \u5047\u8bbe\u6211\u4eec\u8c03\u6574\u4e24\u4e2a\u503c x_{i} x_{i} , x_{j} x_{j} \u7684\u4f4d\u7f6e\uff0c\u5f97\u5230\u4e00\u4e2a\u65b0\u7684\u89e3 s\u2018\uff0c\u5229\u7528\u4e0a\u9762\u7684 a\u3001b\u3001c\u3001d \u7684\u8bc1\u660e\u59d0\u7ed3\u679c\uff0c\u53ef\u77e5\u65b0\u89e3 s' \u4e00\u5b9a\u662f\u4e0d\u4f18\u4e8e s \u7684\u3002 1 2 3 4 5 6 7 8 int minPairSum ( vector < int >& nums ) { int ans = INT_MIN , n = ( int ) nums . size (); sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n / 2 ; i ++ ) { ans = max ( ans , nums [ i ] + nums [ n - 1 - i ]); } return ans ; }","title":"\u4e24\u6570\u548c\u7684\u6700\u5c0f\u503c"},{"location":"algo/greedy/#_9","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4eba\u5458\u4f53\u91cd\u7684\u5217\u8868 people = [3, 5, 3, 4] \u548c\u4e00\u4e2a\u6574\u6570 limit = 5\uff0c\u4e00\u8258\u8239\u4e00\u6b21\u6700\u591a\u8f7d\u4e24\u4e2a\u4eba\uff0c\u5e76\u4e14\u91cd\u91cf\u548c\u4e0d\u8d85\u8fc7 limit\uff0c\u8bd5\u95ee\u6700\u5c0f\u9700\u8981\u591a\u5c11\u8258\u8239\uff1f \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u5c3d\u53ef\u80fd\u7684\u8ba9\u4e00\u8258\u8239\u8f7d\u4e24\u4e2a\u4eba\uff0c\u4ece\u4f53\u91cd\u5927\u7684\u4eba\u5f00\u59cb\u904d\u5386\uff0c\u5982\u679c\u80fd\u9047\u5230\u4e00\u4e2a\u8f7b\u7684\u4eba\uff0c\u5c31\u628a\u4ed6\u52a0\u5165\u5230\u8239\u4e0a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int numRescueBoats ( vector < int >& people , int limit ) { int ans = 0 , l = 0 , r = ( int ) people . size () - 1 ; sort ( people . begin (), people . end ()); while ( l < r ) { if ( people [ l ] + people [ r ] <= limit ) { l ++ ; } ans ++ ; r -- ; } return ans + ( l == r ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6700\u5c0f\u7684\u8239\u6570"},{"location":"algo/greedy/#_10","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 nums = [1, 0, 5]\uff0c\u6bcf\u6b21\u53ef\u4ee5\u9009\u82e5\u5e72\u4e2a\u4f4d\u7f6e\uff0c\u5c06\u6570\u5b57\u51cf\u4e00\uff0c\u7136\u540e\u5bf9\u76f8\u90bb\u7684\u4e00\u4e2a\u4f4d\u7f6e\u52a0\u4e00\uff0c\u5982\u4e0b \\begin{matrix} \\text{1st: } & 1 & & 0 & \\leftarrow & 5 & & \\Rightarrow & & 1 & & 1 & & 4 \\\\ \\text{2nd: } & 1 & \\leftarrow & 1 & \\leftarrow & 4 & & \\Rightarrow & & 2 & & 1 & & 3 \\\\ \\text{3rd: } & 2 & \\leftarrow & 1 & \\leftarrow & 3 & & \\Rightarrow & & 2 & & 2 & & 2 \\\\ \\end{matrix} \\begin{matrix} \\text{1st: } & 1 & & 0 & \\leftarrow & 5 & & \\Rightarrow & & 1 & & 1 & & 4 \\\\ \\text{2nd: } & 1 & \\leftarrow & 1 & \\leftarrow & 4 & & \\Rightarrow & & 2 & & 1 & & 3 \\\\ \\text{3rd: } & 2 & \\leftarrow & 1 & \\leftarrow & 3 & & \\Rightarrow & & 2 & & 2 & & 2 \\\\ \\end{matrix} \u300c\u5206\u6790\u300d \u3010\u8d2a\u5fc3\u3011\u5148\u5224\u65ad\u6570\u503c\u4e4b\u548c\u80fd\u5426\u88ab\u6570\u7ec4\u957f\u5ea6\u6574\u9664\u3002\u5982\u679c\u53ef\u4ee5\u7684\u8bdd\uff0c\u6bcf\u4e00\u4e2a\u6570\u51cf\u53bb\u5e73\u5747\u503c\uff0c\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5982\u679c\u662f\u6b63\u6570 k\uff0c\u90a3\u4e48\u610f\u5473\u7740\uff0c\u6700\u5c11 k \u6b21\u3010\u51cf\u4e00\u3011\uff0c\u5982\u679c\u662f\u8d1f\u6570\uff0c\u6700\u5c11 k \u6b21\u3010\u52a0\u4e00\u3011\uff0c\u5e76\u4e14\u5982\u679c\u51fa\u73b0\u8fde\u7eed\u51e0\u4e2a\u6b63\u6570\u6216\u8005\u8d1f\u6570\uff0c\u8fd9\u610f\u5473\u7740\uff0c\u3010\u51cf\u4e00\u3011\u6216\u8005\u3010\u52a0\u4e00\u3011\u9700\u8981\u4f20\u9012\u5230\u540e\u9762\u7684\u4f4d\u7f6e\uff0c\u4f8b\u5982 [1, 1, -1, -1] \u548c [1, -1, -1, 1] \u662f\u4e0d\u540c\u7684\uff0c\u524d\u8005\u9700\u8981 2 \u6b21\uff0c\u800c\u540e\u8005\u9700\u8981 1 \u6b21\uff0c\u8fd9\u662f\u56e0\u4e3a [1, 1] \u6bd7\u90bb\u51fa\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int findMinMoves ( vector < int >& machines ) { int sum = 0 , cnt = 0 ; for ( int m : machines ) { sum += m ; cnt ++ ; } if ( sum % cnt != 0 ) { return - 1 ; } int ans = 0 , avg = sum / cnt ; for ( int & m : machines ) { m -= avg ; } int presum = 0 ; for ( int m : machines ) { presum += m ; ans = max ( ans , max ( abs ( presum ), m )); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u5747\u5206\u6570\u5b57"},{"location":"algo/greedy/#ipo","text":"\u7ed9\u4f60 n \u4e2a\u9879\u76ee\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u9879\u76ee i \uff0c\u5b83\u90fd\u6709\u4e00\u4e2a\u7eaf\u5229\u6da6 profits[i] \uff0c\u548c\u542f\u52a8\u8be5\u9879\u76ee\u9700\u8981\u7684\u6700\u5c0f\u8d44\u672c capital[i] \u3002\u6700\u521d\uff0c\u4f60\u7684\u8d44\u672c\u4e3a w \u3002\u5f53\u4f60\u5b8c\u6210\u4e00\u4e2a\u9879\u76ee\u65f6\uff0c\u4f60\u5c06\u83b7\u5f97\u7eaf\u5229\u6da6\uff0c\u4e14\u5229\u6da6\u5c06\u88ab\u6dfb\u52a0\u5230\u4f60\u7684\u603b\u8d44\u672c\u4e2d\u3002\u603b\u800c\u8a00\u4e4b\uff0c\u4ece\u7ed9\u5b9a\u9879\u76ee\u4e2d\u9009\u62e9 \u6700\u591a k \u4e2a\u4e0d\u540c\u9879\u76ee\u7684\u5217\u8868\uff0c\u4ee5 \u6700\u5927\u5316\u6700\u7ec8\u8d44\u672c \uff0c\u5e76\u8f93\u51fa\u6700\u7ec8\u53ef\u83b7\u5f97\u7684\u6700\u591a\u8d44\u672c\u3002 \u5982k = 2, w = 0, profits = [1,2,3], capital = [0,1,1] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u7531\u4e8e\u4f60\u7684\u521d\u59cb\u8d44\u672c\u4e3a 0\uff0c\u4f60\u4ec5\u53ef\u4ee5\u4ece 0 \u53f7\u9879\u76ee\u5f00\u59cb\u3002\u5728\u5b8c\u6210\u540e\uff0c\u4f60\u5c06\u83b7\u5f97 1 \u7684\u5229\u6da6\uff0c\u4f60\u7684\u603b\u8d44\u672c\u5c06\u53d8\u4e3a 1\u3002\u6b64\u65f6\u4f60\u53ef\u4ee5\u9009\u62e9\u5f00\u59cb 1 \u53f7\u6216 2 \u53f7\u9879\u76ee\u3002\u7531\u4e8e\u4f60\u6700\u591a\u53ef\u4ee5\u9009\u62e9\u4e24\u4e2a\u9879\u76ee\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u5b8c\u6210 2 \u53f7\u9879\u76ee\u4ee5\u83b7\u5f97\u6700\u5927\u7684\u8d44\u672c\u3002\u56e0\u6b64\uff0c\u8f93\u51fa\u6700\u540e\u6700\u5927\u5316\u7684\u8d44\u672c\uff0c\u4e3a 0 + 1 + 3 = 4\u3002 \u300c\u5206\u6790\u300d \u3010\u8d2a\u5fc3 + \u5927\u9876\u5806\u3011\u56e0\u4e3a w \u4e00\u76f4\u5728\u53d8\u6362\uff0c\u6211\u95e8\u6392\u9664\u4e86\u52a8\u6001\u89c4\u5212\u7684\u53ef\u80fd\u6027\u3002\u9898\u76ee\u7684\u610f\u601d\u662f\uff0c\u6bcf\u6b21\u4ece\u6240\u6709\u4e0d\u8d85\u8fc7 w \u7684\u9879\u76ee\u4e2d\u9009\u62e9\u6700\u5927\u7684\u6536\u76ca\u7684\u90a3\u4e2a\uff0c\u7136\u540e\u66f4\u65b0 w\uff0c\u8fd9\u5c31\u662f\u3010\u8d2a\u5fc3\u3011\u7684\u601d\u60f3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int findMaximizedCapital ( int k , int w , vector < int >& profits , vector < int >& capital ) { priority_queue < int , vector < int > , less < int >> pq ; vector < vector < int >> cp ; int n = ( int ) profits . size (); for ( int i = 0 ; i < n ; i ++ ) { cp . emplace_back ( vector < int > { capital [ i ], profits [ i ]}); } sort ( cp . begin (), cp . end ()); for ( int i = 0 , j = 0 ; i < k ; i ++ ) { for (; j < n && cp [ j ][ 0 ] <= w ; j ++ ) { pq . push ( cp [ j ][ 1 ]); } if ( pq . empty ()) { break ; } w += pq . top (); pq . pop (); } return w ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"IPO"},{"location":"algo/greedy/#_11","text":"\u7ed9\u51fa\u4e00\u4e2a\u4efb\u52a1\u5217\u8868 tasks = [[1, 2],[2, 4],[4, 8]]\uff0c\u8868\u793a\u4e00\u4e2a\u4efb\u52a1\u7684\u6240\u9700\u8981\u7684\u80fd\u91cf\u548c\u5f00\u542f\u8fd9\u9879\u4efb\u52a1\u7684\u80fd\u91cf\uff0c\u5982\u4efb\u52a11\u9700\u8981\u80fd\u91cf\u503c 2 \u624d\u80fd\u542f\u52a8\uff0c\u5b8c\u6210\u540e\uff0c\u6263\u9664\u80fd\u91cf\u503c 1.\u8bd5\u95ee\uff0c\u6700\u5c11\u8981\u51c6\u5907\u591a\u5c11\u80fd\u91cf\u503c\uff0c\u624d\u80fd\u5b8c\u6210\u6240\u6709\u4efb\u52a1\uff08\u53ef\u4ee5\u65e0\u5e8f\uff09\uff1f \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u4efb\u610f\u4e24\u4e2a\u4efb\u52a1\uff0ct1 \u548c t2\uff0ct1[ 1 ] - t1[ 0 ] > t2[ 1 ] - t2[ 0 ]\uff0c\u5982\u679c\u5148\u5b8c\u6210 t1 \u540e\u5b8c\u6210 t2\uff0c\u90a3\u4e48 t1 \u7684\u5dee\u503c\u6709\u4e00\u90e8\u53ef\u4ee5\u7ed9 t2[ 1 ]\uff0c\u53cd\u8fc7\u6765\uff0c\u5148\u5b8c\u6210 t2\uff0c\u5bf9 t1 \u989d\u5916\u8865\u5145\u66f4\u591a\u7684\u80fd\u91cf\u3002\u56e0\u6b64\u6211\u4eec\u9009\u62e9\u5bf9 tasks \u6309\u7167\u3010\u6240\u9700\u80fd\u91cf\u503c - \u6d88\u8017\u80fd\u91cf\u503c\u3011\u6392\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int minimumEffort ( vector < vector < int >>& tasks ) { int ans = 0 ; sort ( tasks . begin (), tasks . end (), []( const vector < int > a , const vector < int > b ){ return a [ 1 ] - a [ 0 ] < b [ 1 ] - b [ 0 ]; }); for ( auto task : tasks ) { if ( ans + task [ 0 ] < task [ 1 ]) { ans = task [ 1 ]; } else { ans += task [ 0 ]; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u5b8c\u6210\u4efb\u52a1\u7684\u6700\u5c0f\u521d\u59cb\u80fd\u91cf"},{"location":"algo/greedy/#_12","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 3, 6] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0c\u5bf9\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u3010\u52a0k\u3011\u6216\u8005\u3010\u51cfk\u3011\uff0c\u8bd5\u95ee\uff0c\u6700\u7ec8\u7684\u65b0\u6570\u7ec4\u7684\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c\u4e4b\u5dee\u7684\u6700\u5c0f\u662f\u591a\u5c11\uff1f\u4f8b\u5b50\u5bf9\u5e94\u7684\u7ed3\u679c\u662f 3 \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u5bf9\u6570\u7ec4\u8fdb\u884c\u6392\u5e8f\u540e\uff0c\u6709\u4e00\u4e2a\u4f4d\u7f6e i \u6ee1\u8db3\uff0ci \u53ca\u5176\u5de6\u4fa7\u7684\u6570\u503c\u3010\u52a0k\u3011\uff0ci \u53f3\u4fa7\u7684\u6570\u3010\u51cfk\u3011\u3002\u5e76\u4e14\uff0cmin(nums[ 0 ] + k, nums[i + 1] - k) \u5f62\u6210\u4e0b\u754c\uff0cmax(nums[ i ] + k, nums[n - 1] - k) \u5f62\u6210\u4e0b\u754c 1 2 3 4 5 6 7 8 9 10 11 int smallestRangeII ( vector < int >& nums , int k ) { int n = ( int ) nums . size (); sort ( nums . begin (), nums . end ()); int ans = nums [ n - 1 ] - nums [ 0 ]; for ( int i = 0 ; i < n - 1 ; i ++ ) { int hi = max ( nums [ i ] + k , nums [ n - 1 ] - k ); int lo = min ( nums [ 0 ] + k , nums [ i + 1 ] - k ); ans = min ( ans , hi - lo ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6700\u5c0f\u5dee\u503c"},{"location":"algo/greedy/#_13","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 interval = [[1, 2], [2, 3], [3, 4], [1, 3]]\uff0c\u5220\u9664\u67d0\u4e9b\u533a\u95f4\u540e\uff0c\u5269\u4f59\u7684\u533a\u95f4\u4e92\u4e0d\u91cd\u53e0\uff0c\u6c42\u6700\u5c11\u5220\u9664\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u3010\u6392\u5e8f + \u8d2a\u5fc3\u3011\u6309\u7167\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u6392\u5e8f\uff0c\u7136\u540e\u4ece\u7b2c\u4e00\u4e2a\u533a\u95f4\u5f00\u59cb\u8d2a\u5fc3\u5730\u627e\u5230\u6240\u6709\u65e0\u91cd\u53e0\u7684\u533a\u95f4\u3002\u6211\u4eec\u7684\u76ee\u7684\u662f\u627e\u5230\u6700\u591a\u7684\u533a\u95f4\uff0c\u90a3\u4e48\u5355\u4e2a\u533a\u95f4\u8de8\u5ea6\u5e94\u5f53\u5c3d\u53ef\u80fd\u5c0f\u3002\u8003\u8651\u6392\u5e8f\u540e\u7684\u4e24\u4e2a\u76f8\u90bb\u533a\u95f4 v1\u3001v2\uff0c\u4ed6\u4eec\u7684\u91cd\u53e0\u5173\u7cfb\u6709\u4e09\u79cd\uff1a\uff081\uff09v1 \u5b8c\u5168\u5305\u542b\u4e8e v2\uff0c\uff082\uff09v1 \u4e0e v2 \u90e8\u5206\u91cd\u53e0\uff0c\uff083\uff09v1 \u4e0e v2 \u4e0d\u91cd\u53e0\u3002\u60c5\u51b5\uff081\uff09\u548c\uff082\uff09\u90fd\u662f\u4e0d\u7b26\u5408\u7684\uff0c\u9700\u8981\u53bb\u6389\u5176\u4e2d\u4e00\u4e2a\uff0c\u663e\u7136\u53bb\u6389 v2 \u66f4\u80fd\u4fdd\u8bc1\u540e\u7eed\u7684\u533a\u95f4\u51fa\u73b0\u66f4\u591a\u7684\u672a\u91cd\u53e0\u533a\u95f4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int eraseOverlapIntervals ( vector < vector < int >>& intervals ) { int n = ( int ) intervals . size (), cnt = 1 ; sort ( intervals . begin (), intervals . end (), []( const auto & v1 , const auto & v2 ){ return v1 [ 1 ] < v2 [ 1 ]; }); int right = intervals [ 0 ][ 1 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( right <= intervals [ i ][ 0 ]) { right = intervals [ i ][ 1 ]; cnt ++ ; } } return n - cnt ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u65e0\u91cd\u590d\u533a\u95f4"},{"location":"algo/greedy/#_14","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \uff0c\u4f60\u6700\u521d\u4f4d\u4e8e\u6570\u7ec4\u7684 \u7b2c\u4e00\u4e2a\u4e0b\u6807 \u3002\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u4f60\u5728\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u7684\u6700\u5927\u957f\u5ea6\u3002\u5224\u65ad\u4f60\u662f\u5426\u80fd\u591f\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4e0b\u6807\u3002\u4f8b\u5982\uff0cnums = [2,3,1,1,4]\uff0c\u8fd4\u56de true\uff0c\u56e0\u4e3a\u53ef\u4ee5\u5148\u8df3 1 \u6b65\uff0c\u4ece\u4e0b\u6807 0 \u5230\u8fbe\u4e0b\u6807 1, \u7136\u540e\u518d\u4ece\u4e0b\u6807 1 \u8df3 3 \u6b65\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4e0b\u6807\u3002 1 2 3 4 5 6 7 8 9 10 bool canJump ( vector < int >& nums ) { int n = ( int ) nums . size (), farestPositon = 0 , end = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { farestPositon = max ( farestPositon , nums [ i ] + i ); if ( i == end ) { end = farestPositon ; } } return end >= n - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u8df3\u8dc3\u6e38\u620f"},{"location":"algo/greedy/#ii","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0c\u4f60\u6700\u521d\u4f4d\u4e8e\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u3002\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u4f60\u5728\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u7684\u6700\u5927\u957f\u5ea6\u3002\u4f60\u7684\u76ee\u6807\u662f\u4f7f\u7528\u6700\u5c11\u7684\u8df3\u8dc3\u6b21\u6570\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002 \u5047\u8bbe\u4f60\u603b\u662f\u53ef\u4ee5\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002\u4f8b\u5982\uff0cnums = [2,3,1,1,4]\uff0c\u8fd4\u56de 2\u3002\u56e0\u4e3a\u4ece\u4e0b\u6807\u4e3a 0 \u8df3\u5230\u4e0b\u6807\u4e3a 1 \u7684\u4f4d\u7f6e\uff0c\u8df3 1 \u6b65\uff0c\u7136\u540e\u8df3 3 \u6b65\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 int jump ( vector < int >& nums ) { int n = ( int ) nums . size (), farestPositon = 0 , end = 0 , ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { farestPositon = max ( farestPositon , nums [ i ] + i ); if ( i == end ) { end = farestPositon ; ans ++ ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u8df3\u8dc3\u6e38\u620f II"},{"location":"algo/leetcode/","text":"0004. Median of Two Sorted Arrays* \u00b6 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example: nums1 = [1, 3] nums2 = [2] The median is 2.0 nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Solution: This problem requires a time complexity in O(log(m+n)), which determines that we cannot merge sort the twos arrays then get a median value because of o(m+n). A faisible solution is to find k-th value in two sorted arrays based on binary search. \\bigstar \\bigstar Cut two sorted arrays In fact, median is a statistique term, which means a value in middle position. If we want acquire a median value in one sorted array, it is easy to take the value in middlle position. \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad For example, the cutting line split an array into two parts with same size, l1 and r1 are left value and right value of cut postion. Left example is odd array, l1 = r1 = 3, while right example is even array, l1 = 3, r1 = 4. Similarly, we can generalize this to two arrays. If we can find such a cut for two arrays that the number of left cut and the number of right cut are equal, we can determine a median value for the 2 arrays. For example, we determine cut position k1, k2 for A, B respectively. \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\bigstar \\bigstar Unify odd and even number According to traditional way, we have to treat case-by-case: it is different to calculate median value for odd array and even array. In order to conquer this problem, we introuce a virtual placeholder. For example, an original array A is 1 2 3 4 5 and we insert a virtual placeholder # into A, which becomes A' = #1#2#3#4#5#. We see, lenghth of the original array is 5, while length of the new array is 5*2+1. If we cut A' at position 4(5 th character from left). With this method, it's easy to get value in the original. Cut position c = 4 \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} If cut position for A' is in first # or last #, it will cause a overflow problem. \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} As the example shows, if cut position at first #, left = min(A[0], B[0]), while cut position at last #, right = max(A[-1], B[-1]). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = int ( nums1 . size ()), n2 = int ( nums2 . size ()); if ( n1 == 0 ) { return ( nums2 [( n2 - 1 ) / 2 ] + nums2 [ n2 / 2 ]) / 2.0 ; } if ( n2 == 0 ) { return ( nums1 [( n1 - 1 ) / 2 ] + nums1 [ n1 / 2 ]) / 2.0 ; } int MAX = nums1 [ n1 - 1 ] > nums2 [ n2 - 1 ] ? nums1 [ n1 - 1 ] : nums2 [ n2 - 1 ]; int MIN = nums1 [ 0 ] < nums2 [ 0 ] ? nums1 [ 0 ] : nums2 [ 0 ]; if ( n1 < n2 ) { return findK ( nums1 , nums2 , 0 , 2 * n1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums2 , nums1 , 0 , 2 * n2 , n2 , n1 , MAX , MIN ); } } double findK ( vector < int > nums1 , vector < int > nums2 , int b , int e , int n1 , int n2 , int MAX , int MIN ) { int l1 = 0 , l2 = 0 , r1 = 0 , r2 = 0 ; int k1 = ( b + e ) / 2 , k2 = ( n1 + n2 - k1 ); if ( k1 == 0 ) { l1 = MIN ; r1 = nums1 [ 0 ]; } else if ( k1 >= 2 * n1 ) { l1 = nums1 [ n1 - 1 ]; r1 = MAX ; } else { l1 = nums1 [( k1 - 1 ) / 2 ]; r1 = nums1 [ k1 / 2 ]; } if ( k2 == 0 ) { l2 = MIN ; r2 = nums2 [ 0 ]; } else if ( k2 >= 2 * n2 ) { l2 = nums2 [ n2 - 1 ]; r2 = MAX ; } else { l2 = nums2 [( k2 - 1 ) / 2 ]; r2 = nums2 [ k2 / 2 ]; } if ( l1 <= r2 && l2 <= r1 ) { return (( l1 > l2 ? l1 : l2 ) + ( r1 < r2 ? r1 : r2 )) / 2.0 ; } else if ( l1 > r2 ) { return findK ( nums1 , nums2 , b , k1 - 1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums1 , nums2 , k1 + 1 , e , n1 , n2 , MAX , MIN ); } } }; 0005. Longest Palindromic Substring* \u00b6 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\" Output: \"bb\" Solution: Dynamic programming: We construct a table, such that table[i][j] represent a substring fron s[i] to s[j] is palindromic or not. Note that, each single character is palindromic, namely table[i][i] is true. We also assignment table[i][i+1] = true if two adjacent characters are same. Then we visit other substirngs to find the longest one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : string longestPalindrome ( string s ) { int n = int ( s . length ()), pos = 0 , len = 1 ; if ( n < 2 ) { return s ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; pos = i ; len = 2 ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { pos = i ; len = k + 1 ; dp [ i ][ j ] = true ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return s . substr ( pos , len ); } }; 0006. ZigZag Conversion \u00b6 The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : string convert ( string s , int numRows ) { int n = int ( s . length ()); if ( n == 0 || numRows < 2 ) { return s ; } string res = \"\" ; int nRow = numRows , num = 2 * numRows - 2 ; int nCol = ( n / num ) * ( num - nRow + 1 ); if ( n % num < nRow ) { nCol ++ ; } else { nCol += ( n % num ) - nRow + 1 ; } char * mat = new char [ nRow * nCol ]{}; for ( int k = 0 ; k < n ; k ++ ) { int quo = k / num , mod = k % num ; int i = - 1 , j = quo * ( num - nRow + 1 ); if ( mod < nRow ) { i = mod ; } else { i = nRow - 2 - ( mod - nRow ); j += mod - nRow + 1 ; } mat [ i * nCol + j ] = s [ k ]; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( mat [ i * nCol + j ]) { res . push_back ( mat [ i * nCol + j ]); } } } delete [] mat ; return res ; } }; 0007. \u6574\u6570\u53cd\u8f6c \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u7ed9\u4f60\u4e00\u4e2a 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570 x \uff0c\u8fd4\u56de\u5c06 x \u4e2d\u7684\u6570\u5b57\u90e8\u5206\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\u3002 \u5982\u679c\u53cd\u8f6c\u540e\u6574\u6570\u8d85\u8fc7 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570\u7684\u8303\u56f4 [\u2212231, 231 \u2212 1] \uff0c\u5c31\u8fd4\u56de 0\u3002 \u5047\u8bbe\u73af\u5883\u4e0d\u5141\u8bb8\u5b58\u50a8 64 \u4f4d\u6574\u6570\uff08\u6709\u7b26\u53f7\u6216\u65e0\u7b26\u53f7\uff09\u3002 \u8f93\u5165\uff1ax = 123 \u8f93\u51fa\uff1a321 \u8f93\u5165\uff1ax = -123 \u8f93\u51fa\uff1a-321 \u8f93\u5165\uff1ax = 120 \u8f93\u51fa\uff1a21 \u8f93\u5165\uff1ax = 0 \u8f93\u51fa\uff1a0 */ class Solution { public : int reverse ( int x ) { int ans = 0 ; if ( x == INT_MIN ) { return 0 ; } while ( x ) { if ( ans > INT_MAX / 10 || ans < INT_MIN / 10 ) { return 0 ; } ans = ans * 10 + ( x % 10 ); x /= 10 ; } return ans ; } }; 0010. Regular Expression Matching* \u00b6 Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"a \" Output: true Explanation: ' ' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\" p = \". \" Output: true Explanation: \". \" means \"zero or more (*) of any character (.)\". Example: 4 Input: s = \"aab\" p = \"c a b\" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\". Example 5: Input: s = \"mississippi\" p = \"mis is p*.\" Output: false Solution: Consider two string s, p. i, j denote some position in s and p. We use dynamic programming with a matrix dp (ns+1) \\times (np+1) (ns+1) \\times (np+1) . ns and np are length of s and p. dp[i][j] denote if s[i:] and p[j:] match. The last entry dp[ns][np] is true. because '' and '' match. Firstly, we check if s[i] and p[j] match ij_match is false or true. Secondly, if p[j+1] is , dp[i][j] has two independent sources: dp[i][j+2] and dp[i+1][j]. In detail, dp[i][j+2] represents we jump over * to check dp[i][j+2]. Similarly, dp[i+1][j] influences dp[i][j] but we have to consider ij_match. Both ij_match and dp[i+1][j] are true, dp[i][j] is true. Otherwise, p[j+1] is not , dp[i][j] is dependent of ij_match and dp[i+1][j+1]. Finally, return dp[0][0] Remark: why we don't consider ij_match for dp[i][j+2]? Because we jump over *. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '.' ); if ( j < np - 1 && p [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } int res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } }; 0011. Container With Most Water* \u00b6 Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 Solution: Brutal force cause Time Limit Exceeded. We use two points method. 1) Firstly, we set two extremities as initial values. 2) Then we move the shorter side towards the longer side one step, e.g. moving 1 towards 7. 3) We repeat 2) until two side are adjacent. During this process, we calculate the max area. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. */ class Solution { public : int maxArea ( vector < int >& height ) { int n = int ( height . size ()); if ( n < 2 ) { return 0 ; } int i = 0 , j = n - 1 , res = 0 ; while ( i < j ) { int a = height [ i ], b = height [ j ]; int B = a < b ? a : b , H = j - i ; if ( B * H > res ) { res = B * H ; } if ( a < b ) { i ++ ; } else { j -- ; } } return res ; } }; 0014. Longest Common Prefix \u00b6 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { int n = int ( strs . size ()); if ( n == 0 ) { return \"\" ; } string str = \"\" ; for ( int j = 0 ; j < int ( strs [ 0 ]. length ()); j ++ ) { char flag = strs [ 0 ][ j ]; for ( int i = 1 ; i < n ; i ++ ) { if ( strs [ i ][ j ] != flag ) { return str ; } } str . push_back ( flag ); } return str ; } }; 0018. 4Sum \u00b6 Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] */ class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < vector < int >> res ; if ( n < 4 ) { return res ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { int b = j + 1 , e = n - 1 ; while ( b < e ) { int sum = nums [ i ] + nums [ j ] + nums [ b ] + nums [ e ]; if ( sum < target ) { b ++ ; } else if ( sum > target ) { e -- ; } else { while ( i < n - 3 && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < n - 2 && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( b < e && nums [ b ] == nums [ b + 1 ]) { b ++ ; } while ( b < e && nums [ e ] == nums [ e - 1 ]) { e -- ; } vector < int > arr ; arr . push_back ( nums [ i ]); arr . push_back ( nums [ j ]); arr . push_back ( nums [ b ]); arr . push_back ( nums [ e ]); res . push_back ( arr ); b ++ ; e -- ; } } } } return res ; } }; 0019. Remove Nth Node From End of List* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. */ // Two pointers class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { if ( n < 1 || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 , head ); ListNode * p1 = pre , * p2 = head , * p3 = head ; while ( n -- ) { if ( p3 == nullptr ) { return head ; } p3 = p3 -> next ; } while ( p3 != nullptr ) { p3 = p3 -> next ; p2 = p2 -> next ; p1 = p1 -> next ; } p1 -> next = p2 -> next ; delete p2 ; head = pre -> next ; delete pre ; return head ; } }; 0022. Generate Parentheses \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] */ class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > res ; if ( n == 0 ) { return res ; } string str = \"\" ; append ( res , str , n , 0 , 0 , 0 ); return res ; } void append ( vector < string > & res , string str , int n , int idx , int nLeft , int nRight ) { if ( idx == 2 * n ) { if ( nRight == nLeft ) { res . push_back ( str ); } return ; } if ( nLeft >= nRight && nLeft < n ) { append ( res , str + '(' , n , idx + 1 , nLeft + 1 , nRight ); } append ( res , str + ')' , n , idx + 1 , nLeft , nRight + 1 ); } }; 0024. Swap Nodes in Pairs \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Given 1->2->3->4, you should return the list as 2->1->4->3. */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); ListNode * par = head , * son = head -> next , * gra = pre ; pre -> next = head ; while ( son != nullptr ) { par -> next = son -> next ; son -> next = par ; gra -> next = son ; gra = par ; par = par -> next ; if ( par == nullptr ) { break ; } son = par -> next ; } head = pre -> next ; delete pre ; return head ; } }; 0025. Reverse Nodes in k-Group \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k < 2 ) { return head ; } ListNode * front = head ; for ( int i = 0 ; i < k ; i ++ ) { if ( front == nullptr ) { return head ; } front = front -> next ; } bool isEnd = false ; ListNode * pre = new ListNode ( 0 , head ); ListNode * gra = pre , * par = head , * son = head -> next ; while ( true ) { ListNode * temp = front , * p1 = gra , * p2 = par , * p3 = son ; while ( p2 != temp ) { if ( front == nullptr ) { isEnd = true ; } else { front = front -> next ; } p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { break ; } p3 = p3 -> next ; } par -> next = p2 ; gra -> next = p1 ; gra = par ; par = p2 ; son = p3 ; if ( isEnd || p3 == nullptr ) { break ; } } head = pre -> next ; delete pre ; return head ; } }; 0028. Implement strStr()* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: haystack = \"hello\", needle = \"ll\" Output: 2 */ class Solution { public : int strStr ( string haystack , string needle ) { string T = haystack , P = needle ; int nT = int ( T . length ()), nP = int ( P . length ()); if ( nP == 0 ) { return 0 ; } if ( nT == 0 ) { return - 1 ; } int * next = new int [ nP ]{}; int i = 0 , j = 0 , t = next [ 0 ] = - 1 , k = 0 ; while ( k < nP - 1 ) { if ( t < 0 || P [ t ] == P [ k ]) { next [ ++ k ] = ++ t ; } else { t = next [ t ]; } } while ( i < nT && j < nP ) { if ( j < 0 || T [ i ] == P [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } delete [] next ; if ( i - j <= nT - nP ) { return i - j ; } else { return - 1 ; } } }; 0029. Divide Two Integers* \u00b6 Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = truncate(3.33333..) = 3. Example 2: Input: dividend = 7, divisor = -3 Output: -2 Explanation: 7/-3 = truncate(-2.33333..) = -2. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int divide ( int dividend , int divisor ) { int MAX = ( 1ll << 31 ) - 1 ; long m = abs ( long ( dividend )), n = abs ( long ( divisor )), quo = 0 ; while ( m >= n ) { long s = n , incre = 1 ; while (( s << 1 ) <= m ) { s <<= 1 ; incre <<= 1 ; } quo += incre ; m -= s ; } if (( dividend < 0 ) ^ ( divisor < 0 )) { quo *= - 1 ; } return quo > MAX ? MAX : int ( quo ); } }; 0030. Substring with Concatenation of All Words* \u00b6 You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order. Example: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"] Output: [6,9,12] Constraints: 1 <= s.length <= 10^{4} 10^{4} s consists of lower-case English letters. 1 <= words.length <= 5000 1 <= words[i].length <= 30 words[i] consists of lower-case English letters. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { vector < int > res ; int n = int ( words . size ()), sLen = int ( s . length ()); if ( n == 0 || n * words [ 0 ]. length () > sLen ) { return res ; } sort ( words . begin (), words . end ()); int i = 0 , wordLen = int ( words [ 0 ]. length ()), wordsLen = n * wordLen ; while ( i + wordsLen <= sLen ) { string subStr = s . substr ( i , wordsLen ); vector < string > tmp ; for ( int j = 0 ; j < wordsLen ; j += wordLen ) { tmp . push_back ( subStr . substr ( j , wordLen )); } sort ( tmp . begin (), tmp . end ()); bool isOk = true ; for ( int k = 0 ; k < n ; k ++ ) { if ( tmp [ k ] != words [ k ]) { isOk = false ; break ; } } if ( isOk ) { res . push_back ( i ); } i ++ ; } return res ; } }; 0031. Next Permutation* \u00b6 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. Example: 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1 Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = int ( nums . size ()), idx = - 1 ; if ( n < 2 ) { return ; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( nums [ i - 1 ] < nums [ i ]) { idx = i - 1 ; break ; } } if ( idx == - 1 ) { sort ( nums . begin (), nums . end ()); return ; } for ( int i = n - 1 ; i > idx ; i -- ) { if ( nums [ i ] > nums [ idx ]) { swap ( nums [ i ], nums [ idx ]); sort ( nums . begin () + idx + 1 , nums . end ()); return ; } } } }; 0032. Longest Valid Parentheses* \u00b6 Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int longestValidParentheses ( string s ) { int maxLen = 0 , n = int ( s . length ()), leftCount = 0 ; if ( n < 2 ) { return maxLen ; } int * dp = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { if ( leftCount == 0 && s [ i ] == ')' ) { continue ; } if ( s [ i ] == '(' ) { leftCount ++ ; } else { leftCount -- ; dp [ i ] = dp [ i - 1 ] + 1 ; if ( i - dp [ i ] * 2 >= 0 ) { dp [ i ] += dp [ i - dp [ i ] * 2 ]; } } maxLen = maxLen > dp [ i ] ? maxLen : dp [ i ]; } delete [] dp ; return maxLen * 2 ; } }; 0034. Find First and Last Position of Element in Sorted Array \u00b6 Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. Follow up: Could you write an algorithm with O(log n) runtime complexity? Example: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Input: nums = [], target = 0 Output: [-1,-1] Constraints: 0 <= nums.length <= 10^{5} 10^{5} - 10^{9} 10^{9} <= nums[i] <= 10^{9} 10^{9} nums is a non-decreasing array. - 10^{9} 10^{9} <= target <= 10^{9} 10^{9} Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < int > res ; res . push_back ( - 1 ); res . push_back ( - 1 ); if ( n < 1 ) { return res ; } res [ 0 ] = binSearFir ( nums , target , 0 , n - 1 ); res [ 1 ] = binSearSec ( nums , target , 0 , n ); return res ; } int binSearFir ( vector < int > & nums , int target , int b , int e ) { if ( b == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] < target ) { return binSearFir ( nums , target , m + 1 , e ); } else { return binSearFir ( nums , target , b , m ); } } int binSearSec ( vector < int > & nums , int target , int b , int e ) { if ( b + 1 == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] <= target ) { return binSearSec ( nums , target , m , e ); } else { return binSearSec ( nums , target , b , m ); } } }; 0035. \u641c\u7d22\u63d2\u5165\u4f4d\u7f6e \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* \u7ed9\u5b9a\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\u548c\u4e00\u4e2a\u76ee\u6807\u503c\uff0c\u5728\u6570\u7ec4\u4e2d\u627e\u5230\u76ee\u6807\u503c\uff0c\u5e76\u8fd4\u56de\u5176\u7d22\u5f15\u3002 \u5982\u679c\u76ee\u6807\u503c\u4e0d\u5b58\u5728\u4e8e\u6570\u7ec4\u4e2d\uff0c\u8fd4\u56de\u5b83\u5c06\u4f1a\u88ab\u6309\u987a\u5e8f\u63d2\u5165\u7684\u4f4d\u7f6e\u3002 \u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u4e2d\u65e0\u91cd\u590d\u5143\u7d20\u3002 \u793a\u4f8b 1: \u8f93\u5165: [1,3,5,6], 5 \u8f93\u51fa: 2 \u793a\u4f8b 2: \u8f93\u5165: [1,3,5,6], 2 \u8f93\u51fa: 1 \u793a\u4f8b 3: \u8f93\u5165: [1,3,5,6], 7 \u8f93\u51fa: 4 */ class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m ; } } return l ; } }; 0036. Valid Sudoku* \u00b6 Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { continue ; } if ( ! isValidForij ( board , i , j )) { return false ; } } } return true ; } bool isValidForij ( vector < vector < char >> board , int i , int j ) { int dupRow = 0 , dupCol = 0 ; for ( int k = 0 ; k < 9 ; k ++ ) { if ( board [ k ][ j ] == board [ i ][ j ]) { dupRow ++ ; } if ( board [ i ][ k ] == board [ i ][ j ]) { dupCol ++ ; } } if ( dupRow > 1 || dupCol > 1 ) { return false ; } int m = i / 3 , n = j / 3 , dupSubBox = 0 ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 3 ; y ++ ) { if ( board [ m * 3 + x ][ n * 3 + y ] == board [ i ][ j ]) { dupSubBox ++ ; } } } if ( dupSubBox > 1 ) { return false ; } return true ; } }; 0037. Sudoku Solver* \u00b6 Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells. $$ \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\ 6 & . & . & 1 & 9 & 5 & . & . & . \\ . & 9 & 8 & . & . & . & . & 6 & . \\ 8 & . & . & . & 6 & . & . & . & 3 \\ 4 & . & . & 8 & . & 3 & . & . & 1 \\ 7 & . & . & . & 2 & . & . & . & 6 \\ . & 6 & . & . & . & . & 2 & 8 & . \\ . & . & . & 4 & 1 & 9 & . & . & 5 \\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { isSolver ( board ); } bool isSolver ( vector < vector < char >> & board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { for ( char c = '1' ; c <= '9' ; c ++ ) { if ( isFeasible ( board , i , j , c )) { board [ i ][ j ] = c ; if ( isSolver ( board )) { return true ; } else { board [ i ][ j ] = '.' ; } } } // No feasible number return false ; } } } return true ; } bool isFeasible ( vector < vector < char >> board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ row ][ i ] == c ) { return false ; } if ( board [ i ][ col ] == c ) { return false ; } if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) { return false ; } } return true ; } }; 0041. First Missing Positive* \u00b6 Given an unsorted integer array, find the smallest missing positive integer. Example: Input: [1,2,0] Output: 3 Input: [3,4,-1,1] Output: 2 Input: [7,8,9,11,12] Output: 1 Follow up: Your algorithm should run in O(n) time and uses constant extra space. Solution: \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { int n = int ( nums . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] <= 0 ) { nums [ i ] = n + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { int num = abs ( nums [ i ]); if ( num <= n ) { nums [ num - 1 ] = - abs ( nums [ num - 1 ]); } } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] > 0 ) { return i + 1 ; } } return n + 1 ; } }; 0043. Multiply Strings \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /* Input: num1 = \"123\", num2 = \"456\" Output: \"56088\" */ class Solution { public : string multiply ( string num1 , string num2 ) { string ans = \"\" ; if ( num1 == \"0\" || num2 == \"0\" ) { return \"0\" ; } int n2 = int ( num2 . length ()); for ( int j = n2 - 1 ; j >= 0 ; j -- ) { string str = strMultiChar ( num1 , num2 [ j ]); str . insert ( str . length (), n2 - 1 - j , '0' ); ans = strAdd ( ans , str ); } return ans ; } string strAdd ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); if ( n1 < n2 ) { swap ( s1 , s2 ); swap ( n1 , n2 ); } string ans = \"\" ; int i = n1 - 1 , j = n2 - 1 , add1 = 0 ; while ( i >= 0 && j >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + ( s2 [ j -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } while ( i >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans . insert ( 0 , 1 , '1' ); } return ans ; } string strMultiChar ( string str , char c ) { string ans = \"\" ; int n = int ( str . length ()), add1 = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int res = ( str [ i ] - '0' ) * ( c - '0' ) + add1 ; add1 = 0 ; if ( res > 9 ) { add1 = res / 10 ; res = res % 10 ; } char insertChar = '0' + res ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans = to_string ( add1 ) + ans ; } return ans ; } }; 0044. Wildcard Matching \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Input: s = \"adceb\", p = \"*a*b\" Output: true */ class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); int ** dp = new int * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new int [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMat = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '?' || p [ j ] == '*' ); if ( p [ j ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 1 ] || ( ijMat && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMat && dp [ i + 1 ][ j + 1 ]; } } } bool ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0048. Rotate Image \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 1 2 3 7 4 1 4 5 6 -> 8 5 2 7 8 9 9 6 3 */ class Solution { public : void rotate ( vector < vector < int >>& matrix ) { int n = int ( matrix . size ()); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - 1 - i ; j ++ ) { int b = i , e = n - 1 - i ; int first = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ b + e - j ][ b ]; matrix [ b + e - j ][ b ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ b + j - i ][ e ]; matrix [ b + j - i ][ e ] = first ; } } } }; 0049. Group Anagrams \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] */ class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; int n = int ( strs . size ()); if ( n == 0 ) { return ans ; } unordered_map < string , vector < string >> dict ; for ( string & str : strs ) { string tmp = str ; sort ( tmp . begin (), tmp . end ()); dict [ tmp ]. emplace_back ( str ); } unordered_map < string , vector < string >>:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { ans . emplace_back ( iter -> second ); } return ans ; } }; 0050. Pow(x, n) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 */ class Solution { public : double myPow ( double x , int n ) { double ans = 1.0 , tmp = x ; bool isNeg = false ; long pow = n ; if ( n < 0 ) { pow = - pow ; isNeg = true ; } long k = 1 ; while ( pow > 0 ) { if ( pow == 1 ) { ans *= x ; break ; } tmp *= tmp ; k *= 2 ; if ( k * 2 > pow ) { ans *= tmp ; tmp = x ; pow = pow - k ; k = 1 ; } } if ( isNeg ) { return 1 / ans ; } return ans ; } }; 0051. N-Queens \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: n = 4 Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"], [\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] */ class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; string str = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { str += \".\" ; } vector < string > res ( n , str ); unordered_set < int > col , diag1 , diag2 ; DFS ( col , diag1 , diag2 , n , 0 , ans , res ); return ans ; } void DFS ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int n , int i , vector < vector < string >> & ans , vector < string > & res ) { if ( i == n ) { ans . emplace_back ( res ); return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkPos ( col , diag1 , diag2 , i , j )) { res [ i ][ j ] = 'Q' ; col . insert ( j ); diag1 . insert ( i - j ); diag2 . insert ( i + j ); DFS ( col , diag1 , diag2 , n , i + 1 , ans , res ); res [ i ][ j ] = '.' ; col . erase ( j ); diag1 . erase ( i - j ); diag2 . erase ( i + j ); } } } bool isOkPos ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int i , int j ) { if ( col . find ( j ) != col . end () || diag1 . find ( i - j ) != diag1 . end () || diag2 . find ( i + j ) != diag2 . end ()) { return false ; } return true ; } }; 0052. N-Queens II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* Input: n = 4 Output: 2 */ class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; unordered_set < int > col , dg1 , dg2 ; DFS ( col , dg1 , dg2 , 0 , n , ans ); return ans ; } void DFS ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int n , int & ans ) { if ( i == n ) { ans ++ ; return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkQueenPos ( col , dg1 , dg2 , i , j )) { col . insert ( j ); dg1 . insert ( i - j ); dg2 . insert ( i + j ); DFS ( col , dg1 , dg2 , i + 1 , n , ans ); col . erase ( j ); dg1 . erase ( i - j ); dg2 . erase ( i + j ); } } } bool isOkQueenPos ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int j ) { if ( col . find ( j ) != col . end () || dg1 . find ( i - j ) != dg1 . end () || dg2 . find ( i + j ) != dg2 . end ()) { return false ; } return true ; } }; 0054. Spiral Matrix \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* 1 -> 2 -> 3 | v 4 -> 5 6 ^ | | v 7 <- 8 <- 9 */ class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { vector < int > ans ; int m = int ( matrix . size ()); if ( m == 0 ) { return ans ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return ans ; } bool * vis = new bool [ m * n ]{}; int i = 0 , j = 0 ; while ( true ) { bool updated = false ; while ( true ) { if ( j >= n || vis [ i * n + j ]) { j -- ; i ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j ++ ; } while ( true ) { if ( i >= m || vis [ i * n + j ]) { i -- ; j -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i ++ ; } while ( true ) { if ( j < 0 || vis [ i * n + j ]) { j ++ ; i -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j -- ; } while ( true ) { if ( i < 0 || vis [ i * n + j ]) { i ++ ; j ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i -- ; } if ( ! updated ) { break ; } } delete [] vis ; return ans ; } }; 0056. Merge Intervals \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. */ class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); sort ( intervals . begin (), intervals . end ()); int b = 0 , rightMax = intervals [ b ][ 1 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( rightMax < intervals [ i - 1 ][ 1 ]) { rightMax = intervals [ i - 1 ][ 1 ]; } if ( rightMax < intervals [ i ][ 0 ]) { ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], rightMax }); b = i ; rightMax = intervals [ i ][ 1 ]; } } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ n - 1 ][ 1 ], rightMax ) }); return ans ; } }; 0057. Insert Interval \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. */ class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); if ( n == 0 || ( intervals [ 0 ][ 0 ] >= newInterval [ 0 ] && intervals [ n - 1 ][ 1 ] <= newInterval [ 1 ])) { ans . emplace_back ( newInterval ); return ans ; } int b = 0 , e = - 1 ; while ( b < n ) { if ( intervals [ b ][ 0 ] > newInterval [ 1 ]) { ans . emplace_back ( newInterval ); for ( int i = b ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 1 ]) { return intervals ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 0 ]) { break ; } if ( intervals [ b ][ 0 ] > newInterval [ 0 ]) { intervals [ b ][ 0 ] = newInterval [ 0 ]; break ; } ans . emplace_back ( intervals [ b ++ ]); } if ( b == n ) { ans . emplace_back ( newInterval ); return ans ; } e = b + 1 ; while ( e < n && ( ( intervals [ e ][ 0 ] <= newInterval [ 1 ] && intervals [ e ][ 1 ] >= newInterval [ 1 ]) || ( intervals [ e ][ 0 ] >= newInterval [ 0 ] && intervals [ e ][ 1 ] <= newInterval [ 1 ]) ) ) { e ++ ; } if ( e == n ) { ans . emplace_back ( vector < int > { min ( newInterval [ 0 ], intervals [ b ][ 0 ]), max ( newInterval [ 1 ], intervals [ n - 1 ][ 1 ]) }); return ans ; } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ e - 1 ][ 1 ], newInterval [ 1 ]) }); for ( int i = e ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } }; 0058. Length of Last Word \u00b6 Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0. A word is a maximal substring consisting of non-space characters only. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: s = \"Hello World\" Output: 5 */ class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 , n = int ( s . length ()); if ( n == 0 ) { return ans ; } bool isCount = false ; int i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' && isCount ) { break ; } if ( s [ i ] == ' ' ) { i -- ; continue ; } ans ++ ; i -- ; isCount = true ; } return ans ; } }; 0059. Spiral Matrix II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] 1 -> 2 -> 3 | v 8 -> 9 4 ^ | | v 7 <- 6 <- 5 */ class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n , 0 )); int i = 0 , j = 0 , num = 1 ; while ( num <= n * n ) { while ( true ) { if ( j >= n || ans [ i ][ j ]) { j -- ; i ++ ; break ; } ans [ i ][ j ++ ] = num ++ ; } while ( true ) { if ( i >= n || ans [ i ][ j ]) { i -- ; j -- ; break ; } ans [ i ++ ][ j ] = num ++ ; } while ( true ) { if ( j < 0 || ans [ i ][ j ]) { j ++ ; i -- ; break ; } ans [ i ][ j -- ] = num ++ ; } while ( true ) { if ( i <= 0 || ans [ i ][ j ]) { i ++ ; j ++ ; break ; } ans [ i -- ][ j ] = num ++ ; } } return ans ; } }; 0061. Rotate List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k <= 0 ) { return head ; } int cnt = 0 ; ListNode * curNode = head , * tail = head ; while ( curNode != nullptr ) { cnt ++ ; if ( curNode -> next == nullptr ) { tail = curNode ; } curNode = curNode -> next ; } k %= cnt ; k = cnt - k ; ListNode * p1 = head ; for ( int i = 1 ; i < k ; i ++ ) { p1 = p1 -> next ; } tail -> next = head ; head = p1 -> next ; p1 -> next = nullptr ; return head ; } }; 0069 Sqrt(x)* \u00b6 Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Input: x = 4 Output: 2 Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. */ class Solution { public : int mySqrt ( int x ) { // Binary search long lo = 1 , hi = x ; while ( lo <= hi ) { long mi = ( lo + hi ) / 2 ; if ( mi * mi < x ) { lo = mi + 1 ; } else if ( mi * mi > x ) { hi = mi - 1 ; } else { return int ( mi ); } } return int ( hi ); } }; 0075. Sort Colors* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] */ class Solution { public : void sortColors ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return ; } int p0 = 0 , p1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] == 0 ) { swap ( nums [ i ], nums [ p0 ]); if ( p0 < p1 ) { swap ( nums [ i ], nums [ p1 ]); } p0 ++ ; p1 ++ ; } else if ( nums [ i ] == 1 ) { swap ( nums [ i ], nums [ p1 ++ ]); } } } }; 0076. Minimum Window Substring* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" */ class Solution { public : string minWindow ( string s , string t ) { unordered_map < char , int > tDict , sDict ; for ( const auto & c : t ) { tDict [ c ] ++ ; } int ns = int ( s . length ()); int l = 0 , r = - 1 , ansL = - 1 , minLen = INT_MAX ; while ( r < ns ) { if ( tDict . find ( s [ ++ r ]) != tDict . end ()) { sDict [ s [ r ]] ++ ; } while ( isCover ( tDict , sDict ) && l <= r ) { if ( r - l + 1 < minLen ) { minLen = r - l + 1 ; ansL = l ; } if ( tDict . find ( s [ l ]) != tDict . end ()) { sDict [ s [ l ]] -- ; } l ++ ; } } return - 1 == ansL ? string () : s . substr ( ansL , minLen ); } bool isCover ( unordered_map < char , int > & tDict , unordered_map < char , int > & sDict ) { for ( const auto & item : tDict ) { if ( sDict [ item . first ] < item . second ) { return false ; } } return true ; } }; 0077. Combinations \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: n = 4, k = 2 Output: 1, 4 3, 4 2, 3 1, 2 1, 3 1, 4 */ class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; if ( n < 0 || k < 0 || n < k ) { return ans ; } vector < int > arr ; combination ( ans , arr , n , k , 1 ); return ans ; } void combination ( vector < vector < int >> & ans , vector < int > & arr , int n , int k , int idx ) { if ( k == 0 ) { ans . emplace_back ( arr ); return ; } for ( int i = idx ; i <= n ; i ++ ) { arr . emplace_back ( i ); combination ( ans , arr , n , k - 1 , i + 1 ); arr . pop_back (); } } }; 0078. Subsets \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); vector < int > arr ; dfs ( ans , arr , nums , n , 0 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int n , int idx ) { if ( idx == n ) { ans . emplace_back ( arr ); } else { arr . emplace_back ( nums [ idx ]); dfs ( ans , arr , nums , n , idx + 1 ); arr . pop_back (); dfs ( ans , arr , nums , n , idx + 1 ); } } }; 0079. Word Search \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* board = A B C E S F C S A D E E word = \"ABCCED\", return true */ class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { int nRow = int ( board . size ()); if ( nRow == 0 ) { return false ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return false ; } int len = int ( word . length ()); bool ans = false ; bool * vis = new bool [ nRow * nCol ]{}; for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] != word [ 0 ]) { continue ; } ans = isExistWord ( board , word , nRow , nCol , i , j , vis , len , 0 ); if ( ans ) { break ; } } if ( ans ) { break ; } } delete [] vis ; return ans ; } bool isExistWord ( vector < vector < char >> & board , string word , int nRow , int nCol , int i , int j , bool * vis , int len , int k ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || vis [ i * nCol + j ] || board [ i ][ j ] != word [ k ]) { return false ; } if ( k == len - 1 ) { return true ; } vis [ i * nCol + j ] = true ; bool u = isExistWord ( board , word , nRow , nCol , i - 1 , j , vis , len , k + 1 ); if ( u ) { return true ; } bool d = isExistWord ( board , word , nRow , nCol , i + 1 , j , vis , len , k + 1 ); if ( d ) { return true ; } bool l = isExistWord ( board , word , nRow , nCol , i , j - 1 , vis , len , k + 1 ); if ( l ) { return true ; } bool r = isExistWord ( board , word , nRow , nCol , i , j + 1 , vis , len , k + 1 ); if ( r ) { return true ; } vis [ i * nCol + j ] = false ; return false ; } }; 0080. Remove Duplicates from Sorted Array II* \u00b6 Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3] Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3] */ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 3 ) { return n ; } int len = 1 , count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { count ++ ; } else { count = 1 ; } if ( count <= 2 ) { nums [ len ++ ] = nums [ i ]; } } return len ; } }; 0082. Remove Duplicates from Sorted List II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5 1 -> 2 -> 5 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = pre , * p2 = head ; while ( p2 != nullptr ) { bool isDup = false ; while ( p2 -> next != nullptr && p2 -> next -> val == p2 -> val ) { p2 = p2 -> next ; isDup = true ; } p2 = p2 -> next ; if ( isDup ) { p1 -> next = p2 ; } else { p1 = p1 -> next ; } } head = pre -> next ; delete pre ; return head ; } }; 0083. Remove Duplicates from Sorted List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: 1 -> 1 -> 2 Output: 1 -> 2 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next ; while ( true ) { while ( p2 != nullptr && p1 -> val == p2 -> val ) { p2 = p2 -> next ; } p1 -> next = p2 ; p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } return head ; } }; 0084. Largest Rectangle in Histogram* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. */ class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 , n = int ( heights . size ()); if ( n == 0 ) { return ans ; } heights . emplace_back ( 0 ); stack < int > stk ; for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } int area = H * W ; if ( ans < area ) { ans = area ; } } stk . push ( i ); } heights . pop_back (); return ans ; } }; 0085. Maximal Rectangle* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 max area = 6 */ class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { int ans = 0 ; int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( matrix [ 0 ]. size ()); vector < int > heights ( nCol , 0 ); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { heights [ j ] = ( heights [ j ] + 1 ) * ( matrix [ i ][ j ] - '0' ); } ans = max ( ans , getRecArea ( heights )); } return ans ; } int getRecArea ( vector < int > heights ) { int ans = 0 , n = int ( heights . size ()); stack < int > stk ; heights . emplace_back ( 0 ); for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } ans = max ( ans , W * H ); } stk . push ( i ); } return ans ; } }; 0086. Partition List \u00b6 Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* from 1 -> 4 -> 3 -> 2 -> 5 -> 2 to 1 -> 2 -> 2 -> 4 -> 3 -> 5 */ Input : head = [ 1 , 4 , 3 , 2 , 5 , 2 ], x = 3 Output : [ 1 , 2 , 2 , 4 , 3 , 5 ] class Solution { public : ListNode * partition ( ListNode * head , int x ) { if ( head == nullptr ) { return head ; } ListNode * h1 = new ListNode ( 0 ), * h2 = new ListNode ( 0 ); ListNode * p1 = head , * p2 = head -> next , * cur1 = h1 , * cur2 = h2 ; while ( p1 != nullptr ) { if ( p1 -> val < x ) { cur1 -> next = p1 ; cur1 = p1 ; } else { cur2 -> next = p1 ; cur2 = p1 ; } p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } cur2 -> next = nullptr ; cur1 -> next = h2 -> next ; head = h1 -> next ; delete h1 ; delete h2 ; return head ; } }; 0087. Scramble String* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y. Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x. Apply step 1 recursively on each of the two substrings x and y. Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. Input: s1 = \"great\", s2 = \"rgeat\" Output: true */ class Solution { public : bool isScramble ( string s1 , string s2 ) { int n = int ( s1 . length ()); if ( n != int ( s2 . length ())) { return false ; } if ( n == 0 ) { return true ; } bool *** dp = new bool ** [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool * [ n ]; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ] = new bool [ n + 1 ]{}; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ][ 1 ] = s1 [ i ] == s2 [ j ]; } } for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { for ( int j = 0 ; j < n - len + 1 ; j ++ ) { for ( int k = 1 ; k < len ; k ++ ) { dp [ i ][ j ][ len ] = ( ( dp [ i ][ j ][ k ] && dp [ i + k ][ j + k ][ len - k ]) || ( dp [ i + k ][ j ][ len - k ] && dp [ i ][ j + len - k ][ k ]) ); if ( dp [ i ][ j ][ len ]) { break ; } } } } } bool ans = dp [ 0 ][ 0 ][ n ]; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { delete [] dp [ i ][ j ]; } delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0088. Merge Sorted Array \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] */ class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int pos = int ( nums1 . size ()) - 1 ; if ( pos < 0 ) { return ; } int i = m - 1 , j = n - 1 ; while ( i >= 0 && j >= 0 ) { if ( nums1 [ i ] > nums2 [ j ]) { nums1 [ pos -- ] = nums1 [ i -- ]; } else { nums1 [ pos -- ] = nums2 [ j -- ]; } } while ( i >= 0 ) { nums1 [ pos -- ] = nums1 [ i -- ]; } while ( j >= 0 ) { nums1 [ pos -- ] = nums2 [ j -- ]; } } }; 0090. Subsets II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] */ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); sort ( nums . begin (), nums . end ()); vector < int > arr ; dfs ( ans , arr , nums , 0 , n ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int idx , int n ) { for ( int i = idx ; i < n ; i ++ ) { if ( i > idx && nums [ i ] == nums [ i - 1 ]) { continue ; } arr . emplace_back ( nums [ i ]); dfs ( ans , arr , nums , i + 1 , n ); arr . pop_back (); } ans . emplace_back ( arr ); } }; 0091. Decode Ways \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 'A' -> \"1\" 'B' -> \"2\" ... 'Z' -> \"26\" Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). */ class Solution { public : int numDecodings ( string s ) { int n = ( int ) s . length (); if ( n == 0 || s [ 0 ] == '0' ) { return 0 ; } if ( n == 1 ) { return 1 ; } int a = ( s [ n - 1 ] != '0' ); int b = 0 ; if ( s [ n - 2 ] != '0' ) { b = a + (( s [ n - 2 ] - '0' ) * 10 + s [ n - 1 ] - '0' <= 26 ); } if ( n == 2 ) { return b ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { int c = 0 ; if ( s [ i ] == '0' ) { a = b ; b = c ; continue ; } c += b ; if ( i < n - 1 && ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) <= 26 ) { c += a ; } a = b ; b = c ; } return b ; } }; 0092. Reverse Linked List II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] 1 -> 2 -> 3 -> 4 -> 5 | v 1 -> 4 -> 3 -> 2 -> 5 */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int left , int right ) { if ( left >= right || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = head , * p0 = pre ; int i = 1 ; while ( i < left ) { p1 = p1 -> next ; p0 = p0 -> next ; i ++ ; if ( p1 == nullptr ) { delete pre ; return head ; } } ListNode * tail = p1 , * p2 = p1 -> next ; if ( p2 == nullptr ) { delete pre ; return head ; } ListNode * p3 = p2 -> next ; while ( i < right ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } p3 = p3 -> next ; i ++ ; } p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } }; 0093. Restore IP Addresses \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] */ class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; int n = int ( s . length ()); if ( n < 4 || n > 12 ) { return ans ; } unordered_map < string , bool > dict ; vector < string > sol ; find ( ans , s , 0 , n , dict , sol ); return ans ; } void find ( vector < string > & ans , string & s , int i , int n , unordered_map < string , bool > & dict , vector < string > & sol ) { if ( sol . size () > 4 ) { return ; } if ( i >= n ) { if ( sol . size () != 4 ) { return ; } string res = \"\" ; for ( int i = 0 ; i < 3 ; i ++ ) { res += sol [ i ]; res . push_back ( '.' ); } res += sol [ 3 ]; ans . emplace_back ( res ); return ; } for ( int k = 1 ; k <= 3 ; k ++ ) { if ( i + k > n ) { continue ; } string str = s . substr ( i , k ); if ( dict . find ( str ) == dict . end ()) { dict [ str ] = isLegalIp ( str ); } if ( ! dict [ str ]) { continue ; } sol . emplace_back ( str ); find ( ans , s , i + k , n , dict , sol ); sol . pop_back (); } } bool isLegalIp ( string str ) { int len = int ( str . length ()); if ( len > 1 && str [ 0 ] == '0' ) { return false ; } int val = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] > '9' || str [ i ] < '0' ) { return false ; } val = val * 10 + ( str [ i ] - '0' ); } return val < 256 ; } }; 0094. Binary Tree Inorder Traversal* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; stack < TreeNode *> st ; TreeNode * curNode = root ; while ( curNode != nullptr ) { while ( curNode != nullptr ) { if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } st . push ( curNode ); curNode = curNode -> left ; } curNode = st . top (); st . pop (); while ( ! st . empty () && curNode -> right == nullptr ) { res . push_back ( curNode -> val ); curNode = st . top (); st . pop (); } res . push_back ( curNode -> val ); if ( ! st . empty ()) { curNode = st . top (); st . pop (); } else { curNode = nullptr ; } } return res ; } }; 0096. Unique Binary Search Trees \u00b6 Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: n = 3 Output: 5 Input: n = 1 Output: 1 */ class Solution { public : int numTrees ( int n ) { long C = 1 ; for ( int i = 0 ; i < n ; i ++ ) { C = C * 2 * ( 2 * i + 1 ) / ( i + 2 ) ; } return int ( C ); } }; 0098. Validate Binary Search Tree \u00b6 Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 2 / \\ 1 3 is a BST 5 / \\ 1 4 / \\ 3 6 is not a BST */ class Solution { public : bool isValidBST ( TreeNode * root ) { TreeNode * prec = nullptr ; return isBST ( root , prec ); } bool isBST ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { bool left = isBST ( root -> left , prec ); if ( left == false ) { return false ; } if ( prec == nullptr ) { prec = root ; } else if ( prec -> val >= root -> val ) { return false ; } prec = root ; bool right = isBST ( root -> right , prec ); if ( right == false ) { return false ; } } return true ; } }; 0100. Same Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: p = [1,2,3], q = [1,2,3] Output: true */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( p == nullptr && q == nullptr ) { return true ; } if (( p == nullptr && q != nullptr ) || ( p != nullptr && q == nullptr ) || ( p -> val != q -> val )) { return false ; } bool left = isSameTree ( p -> left , q -> left ); if ( ! left ) { return false ; } bool right = isSameTree ( p -> right , q -> right ); if ( ! right ) { return false ; } return true ; } }; 0101. Symmetric Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1 / \\ 2 2 / \\ / \\ 3 4 4 3 */ class Solution { public : bool isSymmetric ( TreeNode * root ) { if ( root == nullptr ) { return true ; } return isSymmetricTree ( root -> left , root -> right ); } bool isSymmetricTree ( TreeNode * leftTree , TreeNode * rightTree ) { if ( leftTree == nullptr && rightTree == nullptr ) { return true ; } if (( leftTree != nullptr && rightTree == nullptr ) || ( leftTree == nullptr && rightTree != nullptr ) || leftTree -> val != rightTree -> val ) { return false ; } bool left = isSymmetricTree ( leftTree -> left , rightTree -> right ); if ( ! left ) { return false ; } bool right = isSymmetricTree ( leftTree -> right , rightTree -> left ); if ( ! right ) { return false ; } return true ; } }; 0102. Binary Tree Level Order Traversal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { ans . emplace_back ( arr ); arr . clear (); last = nextLast ; } } return ans ; } }; 0103. Binary Tree Zigzag Level Order Traversal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* 3 / \\ 9 20 / \\ 15 7 [ [3], [20,9], [15,7] ] */ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; int level = 1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { if ( level % 2 == 0 ) { int n = int ( arr . size ()); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr [ i ], arr [ n - 1 - i ]); } } ans . emplace_back ( arr ); arr . clear (); last = nextLast ; level ++ ; } } return ans ; } }; 0104. Maximum Depth of Binary Tree \u00b6 Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 3 / \\ 9 20 / \\ 15 7 max depth = 3 */ class Solution { public : int maxDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = maxDepth ( root -> left ); int rightDep = maxDepth ( root -> right ); return 1 + max ( leftDep , rightDep ); } }; 0110. Balanced Binary Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( root == nullptr ) { return true ; } bool ans = true ; getDepth ( root , ans ); return ans ; } int getDepth ( TreeNode * root , bool & isBal ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDepth ( root -> left , isBal ); int rightDep = getDepth ( root -> right , isBal ); if ( abs ( leftDep - rightDep ) > 1 ) { isBal = false ; } return 1 + max ( leftDep , rightDep ); } }; 0111. Minimum Depth of Binary Tree \u00b6 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 3 / \\ 9 20 / \\ 15 7 min depth = 2 */ class Solution { public : int minDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = minDepth ( root -> left ); int rightDep = minDepth ( root -> right ); if ( leftDep != 0 && rightDep != 0 ) { return 1 + min ( leftDep , rightDep ); } else { return 1 + max ( leftDep , rightDep ); } } }; 0112. Path Sum \u00b6 Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true 1 / \\ 2 3 Input: root = [1,2,3], targetSum = 5 Output: false */ class Solution { public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( root == nullptr ) { return false ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( root -> val == targetSum ) { return true ; } return false ; } bool isInLeft = hasPathSum ( root -> left , targetSum - root -> val ); if ( isInLeft ) { return true ; } bool isInRight = hasPathSum ( root -> right , targetSum - root -> val ); if ( isInRight ) { return true ; } return false ; } }; 0113. Path Sum II \u00b6 Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path's sum equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int targetSum ) { vector < vector < int >> ans ; if ( root == nullptr ) { return ans ; } vector < int > arr ; findPaths ( root , targetSum , ans , arr ); return ans ; } void findPaths ( TreeNode * root , int resVal , vector < vector < int >> & ans , vector < int > & arr ) { if ( root == nullptr ) { return ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( resVal == root -> val ) { arr . emplace_back ( root -> val ); ans . emplace_back ( arr ); arr . pop_back (); } return ; } arr . emplace_back ( root -> val ); findPaths ( root -> left , resVal - root -> val , ans , arr ); findPaths ( root -> right , resVal - root -> val , ans , arr ); arr . pop_back (); } }; 0114. Flatten Binary Tree to Linked List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 1 1 / \\ \\ 2 5 -> 2 / \\ \\ \\ 3 4 6 3 \\ 4 \\ 5 \\ 6 */ class Solution { public : void flatten ( TreeNode * root ) { TreeNode * prec = nullptr ; preOrder ( root , prec ); } void preOrder ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { TreeNode * left = root -> left , * right = root -> right ; if ( prec != nullptr ) { prec -> left = nullptr ; prec -> right = root ; } prec = root ; preOrder ( left , prec ); preOrder ( right , prec ); } } }; 0115. Distinct Subsequences* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag */ class Solution { public : int numDistinct ( string s , string t ) { int ns = int ( s . length ()), nt = int ( t . length ()); if ( ns < nt ) { return 0 ; } long ** dp = new long * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new long [ nt + 1 ]{}; } for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = nt ; j >= 0 ; j -- ) { if ( j == nt ) { dp [ i ][ j ] = 1 ; } else if ( i == ns ) { dp [ i ][ j ] = 0 ; } else { if ( s [ i ] == t [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + dp [ i + 1 ][ j ]; } else { dp [ i ][ j ] = dp [ i + 1 ][ j ]; } } } } int ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0126. Word Ladder II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] Output: [ [\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"] ] Explanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\" */ class Solution { public : unordered_map < string , int > wordId ; vector < string > idWord ; vector < vector < int >> edges ; unordered_set < string > dict ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; idWord . emplace_back ( word ); edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } void dfs ( vector < vector < string >> & ans , int & maxDep , int dep , vector < string > & arr , int id , int & t , vector < int > & level ) { if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . emplace_back ( idWord [ id ]); } if ( id == t ) { ans . emplace_back ( arr ); } for ( int & nextId : edges [ id ]) { if ( level [ nextId ] > level [ id ]) { dfs ( ans , maxDep , dep + 1 , arr , nextId , t , level ); } } if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . pop_back (); } } vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; for ( string & word : wordList ) { addEdge ( word ); dict . insert ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return ans ; } if ( dict . find ( beginWord ) == dict . end ()) { addEdge ( beginWord ); dict . insert ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { break ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } if ( level [ t ] == INT_MAX ) { return ans ; } vector < string > arr ; dfs ( ans , level [ t ], 0 , arr , s , t , level ); return ans ; } }; 0127. Word Ladder* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = \"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\" Output: 5 Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long. */ class Solution { public : unordered_map < string , int > wordId ; vector < vector < int >> edges ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { for ( string & word : wordList ) { addEdge ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return 0 ; } if ( wordId . find ( beginWord ) == wordId . end ()) { addEdge ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { return level [ t ] / 2 + 1 ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } return 0 ; } }; 0128. Longest Consecutive Sequence* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. */ class Solution { public : int longestConsecutive ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int ans = 1 ; unordered_set < int > hash ; for ( const auto & ele : nums ) { hash . insert ( ele ); } for ( const int & ele : nums ) { if ( hash . find ( ele - 1 ) != hash . end ()) { int curNum = ele ; int len = 1 ; while ( hash . find ( curNum ) != hash . end ()) { curNum ++ ; len ++ ; } ans = max ( ans , len ); } } return ans ; } }; 0129. Sum Root to Leaf Numbers \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 4 / \\ 9 0 / \\ 5 1 sum = 495 + 491 + 40 = 1026 */ class Solution { public : int sumNumbers ( TreeNode * root ) { int num = 0 ; return dfs ( root , num ); } int dfs ( TreeNode * root , int num ) { if ( root == nullptr ) { return 0 ; } if ( root -> left == nullptr && root -> right == nullptr ) { return num * 10 + root -> val ;; } int left = dfs ( root -> left , num * 10 + root -> val ); int right = dfs ( root -> right , num * 10 + root -> val ); return left + right ; } }; 0130. Surrounded Regions* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* X X X X X X X X X O O X -> X X X X X X O X X X X X X O X X X O X X */ class Solution { public : void solve ( vector < vector < char >>& board ) { int nRow = ( int ) board . size (); if ( nRow <= 2 ) { return ; } int nCol = ( int ) board [ 0 ]. size (); if ( nCol <= 2 ) { return ; } for ( int i = 0 ; i < nRow ; i ++ ) { if ( board [ i ][ 0 ] == 'O' ) { dfs ( board , nRow , nCol , i , 0 ); } if ( board [ i ][ nCol - 1 ] == 'O' ) { dfs ( board , nRow , nCol , i , nCol - 1 ); } } for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ 0 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , 0 , j ); } if ( board [ nRow - 1 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , nRow - 1 , j ); } } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] == 'O' ) { board [ i ][ j ] = 'X' ; } if ( board [ i ][ j ] == 'A' ) { board [ i ][ j ] = 'O' ; } } } } void dfs ( vector < vector < char >> & board , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || board [ i ][ j ] == 'A' || board [ i ][ j ] == 'X' ) { return ; } board [ i ][ j ] = 'A' ; dfs ( board , nRow , nCol , i + 1 , j ); dfs ( board , nRow , nCol , i - 1 , j ); dfs ( board , nRow , nCol , i , j + 1 ); dfs ( board , nRow , nCol , i , j - 1 ); } }; 0131. Palindrome Partitioning \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: s = \"aab\" Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]] */ class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; int n = ( int ) s . length (); if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } vector < string > arr ; move ( ans , arr , dp , n , 0 , s ); for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } void move ( vector < vector < string >> & ans , vector < string > & arr , bool ** dp , int n , int pos , string & s ) { if ( pos >= n ) { if ( ! arr . empty ()) { ans . emplace_back ( arr ); } return ; } for ( int len = 0 ; len < n - pos ; len ++ ) { if ( dp [ pos ][ pos + len ]) { arr . emplace_back ( s . substr ( pos , len + 1 )); move ( ans , arr , dp , n , pos + len + 1 , s ); arr . pop_back (); } } } }; 0132. Palindrome Partitioning II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /* Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. */ class Solution { public : int minCut ( string s ) { int n = int ( s . length ()); if ( n < 2 ) { return 0 ; } bool ** dp = new bool * [ n ]; int * cut = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ 0 ][ j ]) { cut [ j ] = 0 ; continue ; } int cutNum = INT_MAX ; for ( int i = j ; i > 0 ; i -- ) { if ( dp [ i ][ j ] && cutNum > cut [ i - 1 ] + 1 ) { cutNum = cut [ i - 1 ] + 1 ; } } cut [ j ] = cutNum ; } int ans = cut [ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; delete [] cut ; return ans ; } }; 0136. Single Number \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* Input: nums = [4,1,2,1,2] Output: 4 */ class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int & ele : nums ) { ans ^= ele ; } return ans ; } }; 0137. \u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u9664\u67d0\u4e2a\u5143\u7d20\u4ec5\u51fa\u73b0 \u4e00\u6b21 \u5916\uff0c\u5176\u4f59\u6bcf\u4e2a\u5143\u7d20\u90fd \u6070\u51fa\u73b0 \u4e09\u6b21 \u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u90a3\u4e2a\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\u7684\u5143\u7d20\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [2,2,3,2] \u8f93\u51fa\uff1a3 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [0,1,0,1,0,1,99] \u8f93\u51fa\uff1a99 */ class Solution { public : int singleNumber ( vector < int >& nums ) { unordered_map < int , int > dict ; for ( int ele : nums ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter = dict . begin (); for (; iter != dict . end (); iter ++ ) { if ( iter -> second == 1 ) { return iter -> first ; } } return - 1 ; } }; 0142. Linked List Cycle II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) { return head ; } ListNode * p1 = head , * p2 = head ; while ( true ) { if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; p1 = p1 -> next ; if ( p1 == p2 ) { break ; } } p1 = head ; while ( p1 != p2 ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } }; 0144. Binary Tree Preorder Traversal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { curNode = st . top (); st . pop (); ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { st . push ( curNode -> left ); } } return ans ; } }; class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; while ( true ) { while ( curNode != nullptr ) { ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } curNode = curNode -> left ; } if ( st . empty ()) { break ; } curNode = st . top (); st . pop (); } return ans ; } }; 0151. Reverse Words in a String \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: s = \" hello world \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces. */ class Solution { public : string reverseWords ( string s ) { int pos = 0 ; for ( int i = 0 ; i < ( int ) s . length (); i ++ , pos ++ ) { if ( s [ i ] != ' ' ) { break ; } } string str = \"\" ; for ( int i = pos ; i < ( int ) s . length (); i ++ ) { if ( i > 0 && s [ i ] == ' ' && s [ i - 1 ] == ' ' ) { continue ; } str . push_back ( s [ i ]); } int n = int ( str . length ()); if ( str [ n - 1 ] == ' ' ) { n -- ; } str . resize ( n ); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( str [ i ], str [ n - 1 - i ]); } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int b = j , e = i - 1 ; while ( b < e ) { swap ( str [ b ++ ], str [ e -- ]); } j = i + 1 ; } } str . resize ( n ); return str ; } }; 0154. Find Minimum in Rotated Sorted Array II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [2,2,2,0,1] Output: 0 */ class Solution { public : int findMin ( vector < int >& nums ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ l ] == nums [ r ]) { while ( l < r && nums [ l ] == nums [ l + 1 ]) { l ++ ; } while ( l < r && nums [ r ] == nums [ r - 1 ]) { r -- ; } if (( l + 1 <= r && nums [ l ] < nums [ l + 1 ] && nums [ r ] < nums [ r - 1 ]) || l == r ) { return nums [ l ]; } l ++ ; } else { if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } } return nums [ r ]; } }; 0155. Min Stack \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 */ class MinStack { vector < int > arr1 , arr2 ; public : /** initialize your data structure here. */ MinStack () { } void push ( int val ) { arr1 . emplace_back ( val ); if ( arr2 . empty () || arr2 . back () > val ) { arr2 . emplace_back ( val ); } else { arr2 . emplace_back ( arr2 . back ()); } } void pop () { arr1 . pop_back (); arr2 . pop_back (); } int top () { return arr1 . back (); } int getMin () { return arr2 . back (); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(val); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */ 0173. Binary Search Tree Iterator \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /* Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { vector < int > arr ; vector < int > :: iterator iter ; public : BSTIterator ( TreeNode * root ) { inOrder ( root ); iter = arr . begin (); } void inOrder ( TreeNode * root ) { if ( root != nullptr ) { inOrder ( root -> left ); arr . emplace_back ( root -> val ); inOrder ( root -> right ); } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return 0 ; } } bool hasNext () { return iter != arr . end (); } }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */ 0174. Dungeon Game* \u00b6 The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* -2(K) -3 3 -5 -10 1 10 30 -5(P) For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN. */ class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { int m = int ( dungeon . size ()); if ( m == 0 ) { return 1 ; } int n = int ( dungeon [ 0 ]. size ()); if ( n == 0 ) { return 1 ; } vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { int minVal = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); dp [ i ][ j ] = max ( minVal - dungeon [ i ][ j ], 1 ); } } int ans = dp [ 0 ][ 0 ]; return ans ; } }; 0179. Largest Number* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [3,30,34,5,9] Output: \"9534330\" */ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans = \"\" ; if ( nums . empty ()) { return ans ; } sort ( nums . begin (), nums . end (), []( const int & x , const int & y ) { long i = 10 , j = 10 ; while ( i <= x ) { i *= 10 ; } while ( j <= y ) { j *= 10 ; } return j * x + y > i * y + x ; }); if ( nums [ 0 ] == 0 ) { return \"0\" ; } for ( const int & ele : nums ) { ans += to_string ( ele ); } return ans ; } }; 0190. Reverse Bits* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. */ class Solution { public : uint32_t reverseBits ( uint32_t n ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { ans |= ( n & 1 ) << ( 31 - i ); n = n >> 1 ; } return ans ; } }; class Solution { public : uint32_t reverseBits ( uint32_t n ) { const uint32_t M1 = 0x55555555 ; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333 ; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f ; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff ; // 00000000111111110000000011111111 n = ( n >> 1 & M1 ) | ( n & M1 ) << 1 ; n = ( n >> 2 & M2 ) | ( n & M2 ) << 2 ; n = ( n >> 4 & M4 ) | ( n & M4 ) << 4 ; n = ( n >> 8 & M8 ) | ( n & M8 ) << 8 ; return n >> 16 | n << 16 ; } }; 0191. Number of 1 Bits \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. */ class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; while ( n ) { n &= n - 1 ; ans ++ ; } return ans ; //return __builtin_popcount(n); } }; 0199. Binary Tree Right Side View \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } int maxLevel = - 1 ; rightOrder ( root , ans , 0 , maxLevel ); return ans ; } void rightOrder ( TreeNode * root , vector < int > & ans , int level , int & maxLevel ) { if ( root != nullptr ) { if ( level > maxLevel ) { ans . emplace_back ( root -> val ); maxLevel = level ; } rightOrder ( root -> right , ans , level + 1 , maxLevel ); rightOrder ( root -> left , ans , level + 1 , maxLevel ); } } }; 0200. Number of Islands \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* grid = { {'1', '1', '0', '0', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '1', '0', '0'}, {'0', '0', '0', '1', '1'} } number of islands is 3 */ class Solution { public : int numIslands ( vector < vector < char >>& grid ) { int ans = 0 ; int nRow = int ( grid . size ()); if ( nRow == 0 ) { return 0 ; } int nCol = int ( grid [ 0 ]. size ()); if ( nCol == 0 ) { return 0 ; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( grid [ i ][ j ] == '0' ) { continue ; } if ( isIsland ( grid , nRow , nCol , i , j )) { ans ++ ; } } } return ans ; } bool isIsland ( vector < vector < char >> & grid , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || grid [ i ][ j ] == '0' ) { return false ; } bool res = true ; grid [ i ][ j ] = '0' ; bool u = isIsland ( grid , nRow , nCol , i - 1 , j ); bool d = isIsland ( grid , nRow , nCol , i + 1 , j ); bool l = isIsland ( grid , nRow , nCol , i , j - 1 ); bool r = isIsland ( grid , nRow , nCol , i , j + 1 ); return res || u || d || l || r ; } }; 0209. Minimum Size Subarray Sum \u00b6 Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 */ class Solution { public : int minSubArrayLen ( int target , vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int minLen = INT_MAX , l = 0 , r = 0 , sum = nums [ 0 ]; while ( r < n && l <= r ) { if ( sum < target ) { if ( r + 1 < n ) { sum += nums [ r + 1 ]; } r ++ ; } else { if ( minLen > r - l + 1 ) { minLen = r - l + 1 ; } sum -= nums [ l ++ ]; } } return minLen == INT_MAX ? 0 : minLen ; } }; 0212. Word Search II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* board = o a a n e t a e i h k r i f l v words = \"oath\",\"pea\",\"eat\",\"rain\" Output: \"eat\",\"oath\" */ class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { vector < string > ans ; int nRow = int ( board . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return ans ; } unordered_set < string > hash ; unordered_set < string > res ; int maxLen = 0 ; for ( string & word : words ) { hash . insert ( word ); maxLen = max ( maxLen , int ( word . length ())); } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { bool * vis = new bool [ nRow * nCol ]{}; string str = \"\" ; collect ( board , str , nRow , nCol , i , j , 0 , maxLen , hash , res , vis ); delete [] vis ; } } unordered_set < string >:: iterator iter ; for ( iter = res . begin (); iter != res . end (); iter ++ ) { ans . emplace_back ( * iter ); } return ans ; } void collect ( vector < vector < char >> & board , string & str , int nRow , int nCol , int i , int j , int len , int maxLen , unordered_set < string > & hash , unordered_set < string > & res , bool * vis ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || len > maxLen || vis [ i * nCol + j ]) { return ; } str . push_back ( board [ i ][ j ]); vis [ i * nCol + j ] = true ; if ( hash . find ( str ) != hash . end () && res . find ( str ) == res . end ()) { res . insert ( str ); } collect ( board , str , nRow , nCol , i - 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i + 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j - 1 , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j + 1 , len + 1 , maxLen , hash , res , vis ); str . pop_back (); vis [ i * nCol + j ] = false ; } }; 0215. Kth Largest Element in an Array \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 */ class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { int n = int ( nums . size ()); k = n - k ; int b = 0 , e = n - 1 ; while ( true ) { int i = b , j = e ; while ( i < j ) { while ( i < j && nums [ i ] <= nums [ j ]) { j -- ; } swap ( nums [ i ], nums [ j ]); while ( i < j && nums [ i ] <= nums [ j ]) { i ++ ; } swap ( nums [ i ], nums [ j ]); } if ( i == k ) { return nums [ i ]; } else if ( i > k ) { e = i - 1 ; } else { b = i + 1 ; } } return 0 ; } }; 0216. Combination Sum III \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. */ class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; if ( k == 0 || n > 45 ) { return ans ; } vector < int > arr ; dfs ( ans , arr , k , n , 1 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , int k , int n , int idx ) { if ( k <= 0 || n <= 0 || idx > 9 ) { if ( k == 0 && n == 0 ) { ans . emplace_back ( arr ); } return ; } for ( int i = idx ; i < 10 ; i ++ ) { arr . emplace_back ( i ); dfs ( ans , arr , k - 1 , n - i , i + 1 ); arr . pop_back (); } } }; 0219. Contains Duplicate II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: nums = [1,2,3,1,2,3], k = 2 Output: false */ class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( nums [ i ]) != hash . end ()) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } }; 0220. Contains Duplicate III* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false */ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; set < int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { iter = hash . lower_bound ( max ( nums [ i ], INT_MIN + t ) - t ); if ( iter != hash . end () && * iter <= min ( nums [ i ], INT_MAX - t ) + t ) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } }; 0222. \u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u4e2a\u6570* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* 1 / \\ 2 3 / \\ / 4 5 6 */ class Solution { public : int countNodes ( TreeNode * root ) { int ans = 0 ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; while ( curNode != nullptr ) { TreeNode * ll = curNode -> left , * lr = curNode -> left ; TreeNode * rl = curNode -> right , * rr = curNode -> right ; int lCnt = 1 , rCnt = 1 ; while ( ll != nullptr && lr != nullptr && rl != nullptr && rr != nullptr ) { ll = ll -> left ; lr = lr -> right ; rl = rl -> left ; rr = rr -> right ; lCnt <<= 1 ; rCnt <<= 1 ; } if ( ll == nullptr && rl == nullptr ) { ans += lCnt - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr != nullptr && rl == nullptr ) { ans += ( lCnt * 2 ) - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr == nullptr ) { ans += rCnt - 1 + 1 ; curNode = curNode -> left ; } else { ans += lCnt * 2 - 1 + 1 ; curNode = curNode -> right ; } } return ans ; } }; 0224. Basic Calculator \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23 */ class Solution { public : int calculate ( string s ) { stack < int > sn ; stack < char > so ; int num = 0 , n = int ( s . length ()), i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' ) { i -- ; continue ; } if ( s [ i ] == ')' ) { so . push ( ')' ); } else if ( s [ i ] == '(' ) { while ( so . top () != ')' ) { int n1 = sn . top (); sn . pop (); int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"wrong operator: %c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } so . pop (); } else if ( s [ i ] == '+' || s [ i ] == '-' ) { so . push ( s [ i ]); } else { long times = 1 ; while ( i >= 0 && s [ i ] >= '0' && s [ i ] <= '9' ) { num += ( s [ i -- ] - '0' ) * times ; times *= 10 ; } sn . push ( num ); //printf(\"num=%d\\n\", num); num = 0 ; continue ; } i -- ; } if ( s [ 0 ] == '-' ) { sn . push ( 0 ); } while ( ! so . empty ()) { int n1 = sn . top (); sn . pop (); if ( sn . empty ()) { sn . push ( n1 ); break ; } int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"%c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } if ( ! so . empty () && so . top () == '-' ) { return - sn . top (); } return sn . top (); } }; 0232. Implement Queue using Stacks \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false */ // s1 is input stack, s2 is output stack class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () { } /** Push element x to the back of queue. */ void push ( int x ) { s1 . push ( x ); } /** Removes the element from in front of queue and returns that element. */ int pop () { int ans = peek (); s2 . pop (); return ans ; } /** Get the front element. */ int peek () { if ( s2 . empty ()) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } } return s2 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty () && s2 . empty (); } }; 0236. Lowest Common Ancestor of a Binary Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* 3 / \\ 5 1 / \\ / \\ 6 2 0 8 / \\ 7 4 p = 5, q = 1 nearest common ancester is 3 */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { vector < TreeNode *> t1 , t2 , tmp ; dfs ( root , p , tmp , t1 ); tmp . clear (); dfs ( root , q , tmp , t2 ); int n1 = ( int ) t1 . size (), n2 = ( int ) t2 . size (); int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( t1 [ i ] != t2 [ j ]) { break ; } i ++ ; j ++ ; } if ( i == n1 ) { return t1 [ i - 1 ]; } if ( j == n2 ) { return t2 [ j - 1 ]; } return t1 [ i - 1 ]; } void dfs ( TreeNode * root , TreeNode *& node , vector < TreeNode *> & t , vector < TreeNode *> & res ) { if ( root == nullptr ) { return ; } t . emplace_back ( root ); if ( root == node ) { res = t ; return ; } dfs ( root -> left , node , t , res ); dfs ( root -> right , node , t , res ); t . pop_back (); } }; 0239. Sliding Window Maximum \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 */ class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; multiset < int > hash ; int n = ( int ) nums . size (); for ( int i = 0 ; i < k ; i ++ ) { hash . insert ( nums [ i ]); } for ( int i = k ; i < n ; i ++ ) { ans . emplace_back ( *-- hash . end ()); hash . erase ( hash . find ( nums [ i - k ])); hash . insert ( nums [ i ]); } ans . emplace_back ( *-- hash . end ()); return ans ; } }; class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; int n = ( int ) nums . size (); priority_queue < pair < int , int >> pq ; for ( int i = 0 ; i < k ; i ++ ) { pq . emplace ( nums [ i ], i ); } for ( int i = k ; i <= n ; i ++ ) { while ( pq . top (). second + k < i ) { pq . pop (); } ans . emplace_back ( pq . top (). first ); if ( i < n ) { pq . emplace ( nums [ i ], i ); } } return ans ; } }; 0263. Ugly Number \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: n = 6 Output: true Explanation: 6 = 2 \u00d7 3 */ class Solution { public : bool isUgly ( int n ) { if ( n <= 0 ) { return false ; } while ( n % 2 == 0 ) { n /= 2 ; } while ( n % 3 == 0 ) { n /= 3 ; } while ( n % 5 == 0 ) { n /= 5 ; } return n == 1 ; } }; 0264. Ugly Number II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. */ class Solution { public : int nthUglyNumber ( int n ) { int ans = 0 ; if ( n <= 6 ) { return n ; } int * dp = new int [ n ]{}; dp [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ f2 ] * 2 , min ( dp [ f3 ] * 3 , dp [ f5 ] * 5 )); while ( dp [ f2 ] * 2 <= dp [ i ]) { f2 ++ ; } while ( dp [ f3 ] * 3 <= dp [ i ]) { f3 ++ ; } while ( dp [ f5 ] * 5 <= dp [ i ]) { f5 ++ ; } } ans = dp [ n - 1 ]; delete [] dp ; return ans ; } }; 0312. Burst Balloons* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 */ class Solution { public : int maxCoins ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ n + 2 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { dp [ i ] = new int [ n + 2 ]{}; } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i + 2 ; j <= n + 1 ; j ++ ) { int MAX = 0 ; for ( int k = i + 1 ; k < j ; k ++ ) { int left = ( i == 0 ? 1 : nums [ i - 1 ]); int mid = nums [ k - 1 ]; int right = ( j == n + 1 ? 1 : nums [ j - 1 ]); int prod = left * mid * right ; MAX = max ( MAX , dp [ i ][ k ] + prod + dp [ k ][ j ]); } dp [ i ][ j ] = MAX ; } } int ans = dp [ 0 ][ n + 1 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0331. Verify Preorder Serialization of a Binary Tree* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # */ class Solution { public : bool isValidSerialization ( string preorder ) { int n = int ( preorder . length ()), i = 0 , numNull = 1 ; if ( n == 0 ) { return true ; } while ( i < n ) { if ( numNull <= 0 ) { return false ; } if ( preorder [ i ] == '#' ) { numNull -- ; i ++ ; } else if ( preorder [ i ] == ',' ) { i ++ ; } else { while ( i < n && preorder [ i ] >= '0' && preorder [ i ] <= '9' ) { i ++ ; } numNull ++ ; } } return numNull == 0 ; } }; 0338. Counting Bits \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: 5 Output: [0,1,1,2,1,2] */ class Solution { public : vector < int > countBits ( int num ) { vector < int > ans ( num + 1 , 0 ); for ( int i = 1 ; i <= num ; i ++ ) { ans [ i ] = ans [ i / 2 ] + i % 2 ; } return ans ; } }; 0341. Flatten Nested List Iterator* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. */ /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector<NestedInteger> &getList() const; * }; */ class NestedIterator { vector < int > vals ; vector < int >:: iterator iter ; public : NestedIterator ( vector < NestedInteger > & nestedList ) { dfs ( nestedList ); iter = vals . begin (); } void dfs ( const vector < NestedInteger > & nestedList ) { for ( auto & ni : nestedList ) { if ( ni . isInteger ()) { vals . emplace_back ( ni . getInteger ()); } else { dfs ( ni . getList ()); } } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return - 1 ; } } bool hasNext () { return iter != vals . end (); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout << i.next(); */ 0343. Integer Break \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36. */ class Solution { public : int integerBreak ( int n ) { if ( n < 2 ) { return n ; } if ( n == 2 || n == 3 ) { return n - 1 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { int prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( prod < dp [ j ] * dp [ i - j ]) { prod = dp [ j ] * dp [ i - j ]; } } dp [ i ] = prod ; } int ans = dp [ n ]; delete [] dp ; return ans ; } }; 0354. Russian Doll Envelopes* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). */ class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { int n = int ( envelopes . size ()), len = 1 ; if ( n <= 1 ) { return n ; } sort ( envelopes . begin (), envelopes . end (), []( const auto & e1 , const auto & e2 ) { return e1 [ 0 ] < e2 [ 0 ] || ( e1 [ 0 ] == e2 [ 0 ] && e1 [ 1 ] > e2 [ 1 ]); }); vector < vector < int >> dp ( n + 1 , vector < int > { 0 , 0 }); dp [ len ] = envelopes [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( envelopes [ i ][ 0 ] > dp [ len ][ 0 ] && envelopes [ i ][ 1 ] > dp [ len ][ 1 ]) { dp [ ++ len ] = envelopes [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ][ 0 ] < envelopes [ i ][ 0 ] && dp [ m ][ 1 ] < envelopes [ i ][ 1 ]) { l = m + 1 ; } else { r = m - 1 ; } } dp [ l ] = envelopes [ i ]; } } return len ; } }; 0365. Water and Jug Problem \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs. If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty. Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 Output: true Explanation: The famous Die Hard example */ class Solution { public : bool canMeasureWater ( int jug1Capacity , int jug2Capacity , int targetCapacity ) { int x = jug1Capacity ; int y = jug2Capacity ; int z = targetCapacity ; if ( z > x + y ) { return false ; } if ( z == x || z == y ) { return true ; } if ( x > y ) { swap ( x , y ); } int diff = y % x ; if ( diff == 0 ) { return z % x == 0 ; } for ( int i = 0 ; i < x ; i ++ ) { if ( diff == z || x + diff == z || y + diff == z || y - x + diff == z ) { return true ; } diff = ( y - ( x - diff )) % x ; } return false ; } }; 0367. Valid Perfect Square \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: num = 16 Output: true Input: num = 14 Output: false */ class Solution { public : bool isPerfectSquare ( int num ) { long l = 1 , r = num ; while ( l <= r ) { long m = ( l + r ) >> 1 ; long res = m * m ; if ( res == num ) { return true ; } else if ( res < num ) { l = m + 1 ; } else { r = m - 1 ; } } return false ; } }; 0368. Largest Divisible Subset \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies: answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them. Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. */ class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { vector < int > ans ; int n = ( int ) nums . size (); if ( n < 2 ) { return nums ; } sort ( nums . begin (), nums . end ()); vector < int > dp ( n , 1 ); vector < int > par ( n , - 1 ); int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( nums [ i ] % nums [ j ] == 0 && dp [ j ] + 1 > dp [ i ]) { dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); par [ i ] = j ; } } len = max ( len , dp [ i ]); } ans . resize ( len ); for ( int i = n - 1 ; i >= 0 ;) { if ( dp [ i ] == len ) { ans [ -- len ] = nums [ i ]; i = par [ i ]; } else { i -- ; } } return ans ; } }; 0395. Longest Substring with At Least K Repeating Characters* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* Input: s = \"ababbc\", k = 2 Output: 5 Explanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times. */ class Solution { public : int longestSubstring ( string s , int k ) { int n = int ( s . length ()), ans = 0 ; for ( int t = 1 ; t <= 26 ; t ++ ) { int l = 0 , r = 0 , tot = 0 , numLessK = 0 ; int * count = new int [ 26 ]{}; while ( r < n ) { count [ s [ r ] - 'a' ] ++ ; if ( count [ s [ r ] - 'a' ] == 1 ) { tot ++ ; numLessK ++ ; } if ( count [ s [ r ] - 'a' ] == k ) { numLessK -- ; } while ( tot > t ) { count [ s [ l ] - 'a' ] -- ; if ( count [ s [ l ] - 'a' ] == k - 1 ) { numLessK ++ ; } if ( count [ s [ l ] - 'a' ] == 0 ) { numLessK -- ; tot -- ; } l ++ ; } if ( numLessK == 0 ) { ans = max ( ans , r - l + 1 ); } r ++ ; } delete [] count ; } return ans ; } }; 0403. \u9752\u86d9\u8fc7\u6cb3* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* \u4e00\u53ea\u9752\u86d9\u60f3\u8981\u8fc7\u6cb3\u3002 \u5047\u5b9a\u6cb3\u6d41\u88ab\u7b49\u5206\u4e3a\u82e5\u5e72\u4e2a\u5355\u5143\u683c\uff0c\u5e76\u4e14\u5728\u6bcf\u4e00\u4e2a\u5355\u5143\u683c\u5185 \u90fd\u6709\u53ef\u80fd\u653e\u6709\u4e00\u5757\u77f3\u5b50\uff08\u4e5f\u6709\u53ef\u80fd\u6ca1\u6709\uff09\u3002 \u9752\u86d9\u53ef\u4ee5\u8df3\u4e0a\u77f3\u5b50\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8df3 \u5165\u6c34\u4e2d\u3002 \u7ed9\u4f60\u77f3\u5b50\u7684\u4f4d\u7f6e\u5217\u8868 stones\uff08\u7528\u5355\u5143\u683c\u5e8f\u53f7 \u5347\u5e8f \u8868\u793a\uff09\uff0c \u8bf7\u5224\u5b9a\u9752\u86d9\u80fd \u5426\u6210\u529f\u8fc7\u6cb3\uff08\u5373\u80fd\u5426\u5728\u6700\u540e\u4e00\u6b65\u8df3\u81f3\u6700\u540e\u4e00\u5757\u77f3\u5b50\u4e0a\uff09\u3002 \u5f00\u59cb\u65f6\uff0c \u9752\u86d9\u9ed8\u8ba4\u5df2\u7ad9\u5728\u7b2c\u4e00\u5757\u77f3\u5b50\u4e0a\uff0c\u5e76\u53ef\u4ee5\u5047\u5b9a\u5b83\u7b2c\u4e00\u6b65\u53ea\u80fd\u8df3\u8dc3\u4e00\u4e2a\u5355 \u4f4d\uff08\u5373\u53ea\u80fd\u4ece\u5355\u5143\u683c 1 \u8df3\u81f3\u5355\u5143\u683c 2 \uff09\u3002 \u5982\u679c\u9752\u86d9\u4e0a\u4e00\u6b65\u8df3\u8dc3\u4e86 k \u4e2a\u5355\u4f4d\uff0c\u90a3\u4e48\u5b83\u63a5\u4e0b\u6765\u7684\u8df3\u8dc3\u8ddd\u79bb\u53ea\u80fd\u9009\u62e9\u4e3a k - 1\u3001 k \u6216 k + 1 \u4e2a\u5355\u4f4d\u3002 \u53e6\u8bf7\u6ce8\u610f\uff0c\u9752\u86d9\u53ea\u80fd\u5411\u524d\u65b9\uff08\u7ec8\u70b9\u7684\u65b9\u5411\uff09\u8df3\u8dc3\u3002 \u8f93\u5165\uff1astones = [0,1,3,5,6,8,12,17] \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a\u9752\u86d9\u53ef\u4ee5\u6210\u529f\u8fc7\u6cb3\uff0c\u6309\u7167\u5982\u4e0b\u65b9\u6848\u8df3\u8dc3\uff1a\u8df3 1 \u4e2a\u5355\u4f4d\u5230\u7b2c 2 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 3 \u5757\u77f3\u5b50, \u63a5\u7740 \u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 4 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 3 \u4e2a\u5355\u4f4d\u5230\u7b2c 6 \u5757\u77f3\u5b50, \u8df3 4 \u4e2a\u5355\u4f4d\u5230\u7b2c 7 \u5757\u77f3\u5b50, \u6700\u540e\uff0c\u8df3 5 \u4e2a\u5355\u4f4d\u5230\u7b2c 8 \u4e2a\u77f3\u5b50\uff08\u5373\u6700\u540e\u4e00\u5757\u77f3\u5b50\uff09\u3002 \u8f93\u5165\uff1astones = [0,1,2,3,4,8,9,11] \u8f93\u51fa\uff1afalse \u89e3\u91ca\uff1a\u8fd9\u662f\u56e0\u4e3a\u7b2c 5 \u548c\u7b2c 6 \u4e2a\u77f3\u5b50\u4e4b\u95f4\u7684\u95f4\u8ddd\u592a\u5927\uff0c\u6ca1\u6709\u53ef\u9009\u7684\u65b9\u6848\u4f9b\u9752\u86d9\u8df3 \u8dc3\u8fc7\u53bb\u3002 */ class Solution { public : bool canCross ( vector < int >& stones ) { unordered_map < int , int > dict ; int n = ( int ) stones . size (); if ( n <= 1 ) { return true ; } vector < vector < int >> dp ( n , vector < int > ( n , 0 )); dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( stones [ i ] - stones [ i - 1 ] > i ) { return false ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { int k = stones [ i ] - stones [ j ]; if ( k > j + 1 ) { break ; } dp [ i ][ k ] = dp [ j ][ k - 1 ] || dp [ j ][ k ] || dp [ j ][ k + 1 ]; if ( i == n - 1 && dp [ i ][ k ]) { return true ; } } } return false ; } }; 0407. \u63a5\u96e8\u6c34 II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /* \u7ed9\u4f60\u4e00\u4e2a m x n \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u7684\u503c\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u4e8c\u7ef4\u9ad8\u5ea6\u56fe\u6bcf\u4e2a\u5355 \u5143\u7684\u9ad8\u5ea6\uff0c\u8bf7\u8ba1\u7b97\u56fe\u4e2d\u5f62\u72b6\u6700\u591a\u80fd\u63a5\u591a\u5c11\u4f53\u79ef\u7684\u96e8\u6c34\u3002 \u793a\u4f8b\uff1a \u7ed9\u51fa\u5982\u4e0b 3x6 \u7684\u9ad8\u5ea6\u56fe: [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] \u8fd4\u56de 4 \u3002 */ class Solution { public : int trapRainWater ( vector < vector < int >>& heightMap ) { int nRow = ( int ) heightMap . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) heightMap [ 0 ]. size (); if ( nCol < 3 ) { return 0 ; } typedef pair < int , pair < int , int >> PIII ; priority_queue < PIII , vector < PIII > , greater < PIII >> heap ; bool ** vis = new bool * [ nRow ]; for ( int i = 0 ; i < nRow ; i ++ ) { vis [ i ] = new bool [ nCol ]{}; heap . push ({ heightMap [ i ][ 0 ], { i , 0 }}); heap . push ({ heightMap [ i ][ nCol - 1 ], { i , nCol - 1 }}); vis [ i ][ 0 ] = vis [ i ][ nCol - 1 ] = true ; } for ( int j = 0 ; j < nCol ; j ++ ) { heap . push ({ heightMap [ 0 ][ j ], { 0 , j }}); heap . push ({ heightMap [ nRow - 1 ][ j ], { nRow - 1 , j }}); vis [ 0 ][ j ] = vis [ nRow - 1 ][ j ] = true ; } int dx [ 4 ] = { - 1 , 0 , 1 , 0 }, dy [ 4 ] = { 0 , - 1 , 0 , 1 }; int ans = 0 ; while ( ! heap . empty ()) { auto cur = heap . top (); heap . pop (); int x = cur . second . first , y = cur . second . second ; int h = cur . first ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx >= 0 && xx < nRow && yy >= 0 && yy < nCol && ! vis [ xx ][ yy ]) { vis [ xx ][ yy ] = true ; ans += max ( h - heightMap [ xx ][ yy ], 0 ); heap . push ({ max ( h , heightMap [ xx ][ yy ]), { xx , yy }}); } } } for ( int i = 0 ; i < nRow ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } }; 0470. Implement Rand10() Using Rand7()* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: n = 3 Output: [3,8,10] */ // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 class Solution { public : int rand10 () { int ans = 0 , i = 0 , j = 0 ; do { i = rand7 (); j = rand7 (); ans = ( i - 1 ) * 7 + j ; } while ( ans > 40 ); return ans % 10 + 1 ; } }; 0503. Next Greater Element II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. */ class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return vector < int > {}; } vector < int > ans ( n , - 1 ); stack < int > st ; for ( int i = 0 ; i < 2 * n - 1 ; i ++ ) { while ( ! st . empty () && nums [ st . top ()] < nums [ i % n ]) { ans [ st . top ()] = nums [ i % n ]; st . pop (); } st . push ( i % n ); } return ans ; } }; 0516. Longest Palindromic Subsequence* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000. Input: \"bbbab\" Output: 4 */ class Solution { public : int longestPalindromeSubseq ( string s ) { int n = int ( s . length ()); if ( n <= 1 ) { return n ; } int ** dp = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new int [ n ]{}; dp [ i ][ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] + 2 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } } } int ans = dp [ 0 ][ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0530. Minimum Absolute Difference in BST \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 1 \\ 3 / 2 output: 1 */ class Solution { public : int getMinimumDifference ( TreeNode * root ) { TreeNode * last = nullptr ; int ans = INT_MAX ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & diff ) { if ( root != nullptr ) { inOrder ( root -> left , last , diff ); if ( last == nullptr ) { last = root ; } else { diff = min ( diff , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , diff ); } } }; 0543. Diameter of Binary Tree \u00b6 Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. */ class Solution { public : int diameterOfBinaryTree ( TreeNode * root ) { int max = 0 ; getDep ( root , max ); return max ; } int getDep ( TreeNode * root , int & maxLen ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDep ( root -> left , maxLen ); int rightDep = getDep ( root -> right , maxLen ); int curLen = leftDep + rightDep ; maxLen = maxLen > curLen ? maxLen : curLen ; return ( leftDep > rightDep ? leftDep : rightDep ) + 1 ; } }; 0554. \u7816\u5899* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u4f60\u7684\u9762\u524d\u6709\u4e00\u5835\u77e9\u5f62\u7684\u3001\u7531 n \u884c\u7816\u5757\u7ec4\u6210\u7684\u7816\u5899\u3002\u8fd9\u4e9b\u7816\u5757\u9ad8\u5ea6\u76f8\u540c\uff08\u4e5f\u5c31\u662f\u4e00\u4e2a\u5355\u4f4d\u9ad8\uff09 \u4f46\u662f\u5bbd\u5ea6\u4e0d\u540c\u3002\u6bcf\u4e00\u884c\u7816\u5757\u7684\u5bbd\u5ea6\u4e4b\u548c\u5e94\u8be5\u76f8\u7b49\u3002 \u4f60\u73b0\u5728\u8981\u753b\u4e00\u6761 \u81ea\u9876\u5411\u4e0b \u7684\u3001\u7a7f\u8fc7 \u6700\u5c11 \u7816\u5757\u7684\u5782\u7ebf\u3002\u5982\u679c\u4f60\u753b\u7684\u7ebf\u53ea\u662f\u4ece\u7816\u5757\u7684\u8fb9\u7f18\u7ecf\u8fc7\uff0c \u5c31\u4e0d\u7b97\u7a7f\u8fc7\u8fd9\u5757\u7816\u3002\u4f60\u4e0d\u80fd\u6cbf\u7740\u5899\u7684\u4e24\u4e2a\u5782\u76f4\u8fb9\u7f18\u4e4b\u4e00\u753b\u7ebf\uff0c\u8fd9\u6837\u663e\u7136\u662f\u6ca1\u6709\u7a7f\u8fc7\u4e00\u5757\u7816\u7684\u3002 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 wall \uff0c\u8be5\u6570\u7ec4\u5305\u542b\u8fd9\u5835\u5899\u7684\u76f8\u5173\u4fe1\u606f\u3002\u5176\u4e2d\uff0cwall[i] \u662f\u4e00\u4e2a\u4ee3\u8868\u4ece\u5de6 \u81f3\u53f3\u6bcf\u5757\u7816\u7684\u5bbd\u5ea6\u7684\u6570\u7ec4\u3002\u4f60\u9700\u8981\u627e\u51fa\u600e\u6837\u753b\u624d\u80fd\u4f7f\u8fd9\u6761\u7ebf \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf\u6700\u5c11 \uff0c\u5e76\u4e14\u8fd4\u56de \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf \u3002 \u8f93\u5165\uff1awall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] \u8f93\u51fa\uff1a2 \u8f93\u5165\uff1awall = [[1],[1],[1]] \u8f93\u51fa\uff1a3 */ class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int n = ( int ) wall . size (); if ( n == 0 ) { return 0 ; } int ans = 0 ; unordered_map < int , int > cnt ; for ( auto arr : wall ) { int len = ( int ) arr . size (); int sum = 0 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { sum += arr [ i ]; cnt [ sum ] ++ ; } } unordered_map < int , int >:: iterator iter ; for ( iter = cnt . begin (); iter != cnt . end (); iter ++ ) { ans = max ( ans , iter -> second ); } return n - ans ; } }; 0633. \u5e73\u65b9\u6570\u4e4b\u548c* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 c \uff0c\u4f60\u8981\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6574\u6570 a \u548c b\uff0c\u4f7f\u5f97 a^2 + b^2 = c \u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ac = 5 \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a1 * 1 + 2 * 2 = 5 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ac = 3 \u8f93\u51fa\uff1afalse \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ac = 4 \u8f93\u51fa\uff1atrue \u793a\u4f8b 4\uff1a \u8f93\u5165\uff1ac = 2 \u8f93\u51fa\uff1atrue \u793a\u4f8b 5\uff1a \u8f93\u5165\uff1ac = 1 \u8f93\u51fa\uff1atrue */ class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 , r = ( long ) sqrt ( c ); while ( l <= r ) { long sqaureSum = l * l + r * r ; if ( sqaureSum == c ) { return true ; } else if ( sqaureSum < c ) { l ++ ; } else { r -- ; } } return false ; } }; 0647. Palindromic Substrings \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". */ class Solution { public : int countSubstrings ( string s ) { int n = int ( s . length ()), ans = n ; if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i - 1 ] == s [ i ]) { dp [ i - 1 ][ i ] = true ; ans ++ ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; ans ++ ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0690. \u5458\u5de5\u7684\u91cd\u8981\u6027 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* \u7ed9\u5b9a\u4e00\u4e2a\u4fdd\u5b58\u5458\u5de5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u5305\u542b\u4e86\u5458\u5de5 \u552f\u4e00\u7684 id \uff0c\u91cd\u8981\u5ea6\u548c\u76f4\u7cfb\u4e0b\u5c5e\u7684 id \u3002 \u6bd4\u5982\uff0c\u5458\u5de5 1 \u662f\u5458\u5de5 2 \u7684\u9886\u5bfc\uff0c\u5458\u5de5 2 \u662f\u5458\u5de5 3 \u7684\u9886\u5bfc\u3002\u4ed6\u4eec\u76f8\u5e94\u7684\u91cd\u8981\u5ea6\u4e3a 15 , 10 , 5 \u3002 \u90a3\u4e48\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u662f [1, 15, [2]] \uff0c\u5458\u5de5 2\u7684 \u6570\u636e\u7ed3\u6784\u662f [2, 10, [3]] \uff0c\u5458\u5de53 \u7684\u6570\u636e\u7ed3\u6784\u662f [3, 5, []] \u3002\u6ce8\u610f\u867d\u7136\u5458\u5de5 3 \u4e5f\u662f\u5458\u5de5 1 \u7684\u4e00\u4e2a\u4e0b\u5c5e\uff0c\u4f46\u662f\u7531\u4e8e \u5e76\u4e0d\u662f\u76f4\u7cfb \u4e0b\u5c5e\uff0c\u56e0\u6b64\u6ca1\u6709\u4f53\u73b0\u5728\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 \u73b0\u5728\u8f93\u5165\u4e00\u4e2a\u516c\u53f8\u7684\u6240\u6709\u5458\u5de5\u4fe1\u606f\uff0c\u4ee5\u53ca\u5355\u4e2a\u5458\u5de5 id \uff0c\u8fd4\u56de\u8fd9\u4e2a\u5458\u5de5\u548c\u4ed6\u6240\u6709\u4e0b\u5c5e\u7684\u91cd\u8981\u5ea6\u4e4b\u548c\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 \u8f93\u51fa\uff1a11 \u89e3\u91ca\uff1a \u5458\u5de5 1 \u81ea\u8eab\u7684\u91cd\u8981\u5ea6\u662f 5 \uff0c\u4ed6\u6709\u4e24\u4e2a\u76f4\u7cfb\u4e0b\u5c5e 2 \u548c 3 \uff0c\u800c\u4e14 2 \u548c 3 \u7684\u91cd\u8981\u5ea6\u5747\u4e3a 3 \u3002 \u56e0\u6b64\u5458\u5de5 1 \u7684\u603b\u91cd\u8981\u5ea6\u662f 5 + 3 + 3 = 11 \u3002 */ /* // Definition for Employee. class Employee { public: int id; int importance; vector< int> subordinates; }; */ class Solution { public : int dfs ( unordered_set < int > & vis , unordered_map < int , int > & dict , unordered_map < int , vector < int >> & next , int id ) { int ans = 0 ; for ( int sub : next [ id ]) { if ( vis . find ( sub ) == vis . end ()) { vis . insert ( sub ); ans += dfs ( vis , dict , next , sub ); } } return ans + dict [ id ]; } int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , int > dict ; unordered_map < int , vector < int >> next ; unordered_set < int > vis ; for ( auto employee : employees ) { dict [ employee -> id ] = employee -> importance ; next [ employee -> id ] = employee -> subordinates ; } return dfs ( vis , dict , next , id ); } }; 0704. Binary Search \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 */ class Solution { public : int search ( vector < int >& nums , int target ) { int n = ( int ) nums . size (); if ( n == 0 ) { return - 1 ; } int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return m ; } else if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m - 1 ; } } return - 1 ; } }; 0738. Monotone Increasing Digits* \u00b6 Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits. (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: N = 10 Output: 9 Input: N = 1234 Output: 1234 Input: N = 332 Output: 299 */ class Solution { public : int monotoneIncreasingDigits ( int N ) { int ans = 0 ; string str = to_string ( N ); int len = int ( str . length ()), idx = - 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] < str [ i - 1 ]) { idx = i ; break ; } } if ( idx == - 1 ) { return N ; } int pos = idx - 1 ; while ( pos >= 1 && str [ pos ] == str [ pos - 1 ]) { pos -- ; } str [ pos ] -- ; // current position decrease by 1 for ( int i = pos + 1 ; i < len ; i ++ ) { str [ i ] = '9' ; } for ( int i = len - 1 , pow = 1 ; i >= 0 ; i -- , pow *= 10 ) { ans += ( str [ i ] - '0' ) * pow ; } return ans ; } }; 0741. Cherry Pickup* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect by following the rules below: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells. When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0. If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected. Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]] Output: 5 Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible. Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 */ class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { int n = int ( grid . size ()); if ( n == 0 ) { return 0 ; } vector < vector < vector < int >>> dp ( n , vector < vector < int >> ( n , vector < int > ( n , - 1 ))); int ans = move ( dp , grid , 0 , 0 , 0 , n ); return max ( 0 , ans ); } int move ( vector < vector < vector < int >>> & dp , vector < vector < int >> & grid , int r1 , int c1 , int c2 , int n ) { int r2 = r1 + c1 - c2 ; if ( r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid [ r1 ][ c1 ] == - 1 || grid [ r2 ][ c2 ] == - 1 ) { return - 2 ; } if ( r1 == n - 1 && c1 == n - 1 ) { return grid [ r1 ][ c1 ]; } if ( dp [ r1 ][ c1 ][ c2 ] != - 1 ) { return dp [ r1 ][ c1 ][ c2 ]; } int ans = move ( dp , grid , r1 , c1 + 1 , c2 + 1 , n ); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 + 1 , n )); ans = max ( ans , move ( dp , grid , r1 , c1 + 1 , c2 , n )); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 , n )); if ( ans >= 0 ) { ans += grid [ r1 ][ c1 ] + ( c1 != c2 || r1 != r2 ) * grid [ r2 ][ c2 ]; } dp [ r1 ][ c1 ][ c2 ] = ans ; return ans ; } }; 0752. Open the Lock* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\" Output: 6 Explanation: A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\". Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \"0102\". */ class Solution { public : int openLock ( vector < string >& deadends , string target ) { string init = \"0000\" ; int n = int ( init . length ()), ans = 0 ; unordered_set < string > vis ; for ( string & str : deadends ) { vis . insert ( str ); } if ( vis . find ( init ) != vis . end ()) { return - 1 ; } queue < string > qLock ; qLock . push ( init ); while ( ! qLock . empty ()) { int num = int ( qLock . size ()); while ( num -- ) { string str = qLock . front (); qLock . pop (); if ( str == target ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { string tmp = str ; for ( int d = - 1 ; d <= 1 ; d += 2 ) { tmp [ i ] = ( str [ i ] - '0' + 10 + d ) % 10 + '0' ; if ( vis . find ( tmp ) == vis . end ()) { vis . insert ( tmp ); qLock . push ( tmp ); } } } } ans ++ ; } return - 1 ; } }; 0766. Toeplitz Matrix \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 1 2 3 4 5 1 2 3 9 5 1 2 */ class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { int m = int ( matrix . size ()); if ( m == 0 ) { return false ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return false ; } for ( int j = 0 ; j < n ; j ++ ) { int first = matrix [ 0 ][ j ]; for ( int i = 0 ; i < min ( m , n - j ); i ++ ) { if ( first != matrix [ i ][ i + j ]) { return false ; } } } for ( int i = 1 ; i < m ; i ++ ) { int first = matrix [ i ][ 0 ]; for ( int j = 0 ; j < min ( n , m - i ); j ++ ) { if ( first != matrix [ i + j ][ j ]) { return false ; } } } return true ; } }; 0769. Max Chunks To Make Sorted* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. */ class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 1 , n = ( int ) arr . size (); if ( n <= 1 ) { return ans ; } vector < int > rightMin ( n , 0 ); rightMin [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; i -- ) { rightMin [ i ] = min ( rightMin [ i + 1 ], arr [ i ]); } int leftMax = arr [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( leftMax <= rightMin [ i ]) { ans ++ ; } leftMax = max ( leftMax , arr [ i ]); } return ans ; } }; 0781. Rabbits in Forest \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered \"1\" could both be the same color, say red. The rabbit than answered \"2\" can't be red or the answers would be inconsistent. Say the rabbit that answered \"2\" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't. Input: answers = [10, 10, 10] Output: 11 Input: answers = [] Output: 0 */ class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; unordered_map < int , int > dict ; for ( int & ele : answers ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { if ( iter -> first == 0 ) { ans += iter -> second ; } else { if ( iter -> first + 1 >= iter -> second ) { ans += iter -> first + 1 ; } else { if ( iter -> second % ( iter -> first + 1 ) == 0 ) { ans += iter -> second ; } else { ans += ( iter -> second / ( iter -> first + 1 ) + 1 ) * ( iter -> first + 1 ); } } } } return ans ; } }; 0783. Minimum Distance Between BST Nodes \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 4 / \\ 2 6 / \\ 1 5 output: 1 */ class Solution { public : int minDiffInBST ( TreeNode * root ) { int ans = INT_MAX ; TreeNode * last = nullptr ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & ans ) { if ( root != nullptr ) { inOrder ( root -> left , last , ans ); if ( last == nullptr ) { last = root ; } else { ans = min ( ans , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , ans ); } } }; 0832. Flipping an Image \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] */ class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { int m = int ( A . size ()), n = int ( A [ 0 ]. size ()); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { swap ( A [ i ][ j ], A [ i ][ n - 1 - j ]); } for ( int j = 0 ; j < n ; j ++ ) { A [ i ][ j ] = 1 - A [ i ][ j ]; } } return A ; } }; 0845. Longest Mountain in Array* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5. */ class Solution { public : int longestMountain ( vector < int >& arr ) { int ans = 0 , n = int ( arr . size ()); if ( n < 3 ) { return 0 ; } vector < int > left ( n , 0 ), right ( n , 0 ); for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ]) { left [ i ] = left [ i - 1 ] + 1 ; } if ( arr [ n - 1 - i ] > arr [ n - i ]) { right [ n - 1 - i ] = right [ n - i ] + 1 ; } } if ( arr [ n - 1 ] > arr [ n - 2 ]) { left [ n - 1 ] = left [ n - 2 ] + 1 ; } if ( arr [ 0 ] > arr [ 1 ]) { right [ 0 ] = right [ 1 ] + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( left [ i ] && right [ i ]) { ans = max ( left [ i ] + right [ i ] + 1 , ans ); } } return ans ; } }; 0897. Increasing Order Search Tree* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 5 1 / \\ \\ 1 7 5 \\ 7 */ class Solution { public : TreeNode * increasingBST ( TreeNode * root ) { TreeNode * last = nullptr ; TreeNode * head = nullptr ; inOrder ( root , last , head ); return head ; } void inOrder ( TreeNode * root , TreeNode *& last , TreeNode *& head ) { if ( root != nullptr ) { inOrder ( root -> left , last , head ); if ( last != nullptr ) { last -> right = root ; last -> left = nullptr ; root -> left = nullptr ; } else { head = root ; } last = root ; inOrder ( root -> right , last , head ); } } }; 0921. Minimum Add to Make Parentheses Valid* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: \"()))((\" Output: 4 */ class Solution { public : int minAddToMakeValid ( string S ) { int left = 0 , ans = 0 ; for ( const char & c : S ) { if ( c == '(' ) { left ++ ; } else { if ( left > 0 ) { left -- ; } else { ans ++ ; } } } return ans + left ; } }; 0938. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u8303\u56f4\u548c \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 10 / \\ 5 15 / \\ \\ 3 7 18 \u8f93\u5165\uff1aroot = [10,5,15,3,7,null,18], low = 7, high = 15 \u8f93\u51fa\uff1a32 */ class Solution { public : int rangeSumBST ( TreeNode * root , int low , int high ) { if ( root == nullptr ) { return 0 ; } int left = rangeSumBST ( root -> left , low , high ); int val = 0 ; if ( root -> val >= low && root -> val <= high ) { val = root -> val ; } int right = rangeSumBST ( root -> right , low , high ); return left + val + right ; } }; 1006. Clumsy Factorial* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 */ class Solution { public : int clumsy ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 ) { return 2 ; } else if ( N == 3 ) { return 6 ; } else if ( N == 4 ) { return 7 ; } else { if ( N % 4 == 0 ) { return N + 1 ; } else if ( N % 4 == 1 ) { return N + 2 ; } else if ( N % 4 == 2 ) { return N + 2 ; } else { return N - 1 ; } } } }; 1047. Remove All Adjacent Duplicates In String \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". */ class Solution { public : string removeDuplicates ( string S ) { int n = int ( S . length ()); if ( n <= 1 ) { return S ; } string ans = \"\" ; for ( const char & c : S ) { if ( ! ans . empty () && ans . back () == c ) { ans . pop_back (); } else { ans . push_back ( c ); } } return ans ; } }; 1052. Grumpy Bookstore Owner \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16. */ class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int ans = 0 , n = int ( customers . size ()); if ( n == 0 ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { if ( grumpy [ i ] == 0 ) { ans += customers [ i ]; } } int add = 0 , maxAdd = 0 ; for ( int i = 0 ; i < X ; i ++ ) { ans += customers [ i ] * grumpy [ i ]; } for ( int i = 1 ; i < n - X + 1 ; i ++ ) { add += - customers [ i - 1 ] * grumpy [ i - 1 ] + customers [ i + X - 1 ] * grumpy [ i + X - 1 ]; if ( maxAdd < add ) { maxAdd = add ; } } return ans + maxAdd ; } }; 1178. Number of Valid Words for Each Puzzle* \u00b6 With respect to a given puzzle string, a word is valid if both the following conditions are satisfied: word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\"; while invalid words are \"beefed\" (doesn't include \"a\") and \"based\" (includes \"s\" which isn't in the puzzle). Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"] Output: [1,1,3,2,4,0] Explanation: 1 valid word for \"aboveyz\" : \"aaaa\" 1 valid word for \"abrodyz\" : \"aaaa\" 3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\" 2 valid words for \"absoryz\" : \"aaaa\", \"asas\" 4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\" There're no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'. */ class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { int n = int ( puzzles . size ()); unordered_map < int , int > dict ; for ( const string & word : words ) { int mask = 0 ; for ( const char & c : word ) { mask |= ( 1 << ( c - 'a' )); } if ( __builtin_popcount ( mask ) <= 7 ) { dict [ mask ] ++ ; } } vector < int > ans ; for ( const string & puzzle : puzzles ) { int tot = 0 ; for ( int choose = 0 ; choose < ( 1 << 6 ); choose ++ ) { int mask = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( choose & ( 1 << i )) { mask |= ( 1 << ( puzzle [ i + 1 ] - 'a' )); } } mask |= ( 1 << ( puzzle [ 0 ] - 'a' )); tot += dict [ mask ]; } ans . emplace_back ( tot ); } return ans ; } }; 1411. Number of Ways to Paint N \u00d7 3 Grid \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. */ class Solution { public : int numOfWays ( int n ) { int aba = 6 , abc = 6 ; /* aba = aba * 3 + abc * 2 abc = aba * 2 + abc * 2; */ const int MOD = 1000000007 ; for ( int i = 1 ; i < n ; i ++ ) { int new_aba = ( aba * 3ll + abc * 2ll ) % MOD ; int new_abc = ( aba * 2ll + abc * 2ll ) % MOD ; aba = new_aba ; abc = new_abc ; } return ( aba + abc ) % MOD ; } }; 1553. \u5403\u6389 N \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* \u53a8\u623f\u91cc\u603b\u5171\u6709 n \u4e2a\u6a58\u5b50\uff0c\u4f60\u51b3\u5b9a\u6bcf\u4e00\u5929\u9009\u62e9\u5982\u4e0b\u65b9\u5f0f\u4e4b\u4e00\u5403\u8fd9\u4e9b\u6a58\u5b50\uff1a \u5403\u6389\u4e00\u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 2 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 n/2 \u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 3 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 2*(n/3) \u4e2a\u6a58\u5b50\u3002 \u6bcf\u5929\u4f60\u53ea\u80fd\u4ece\u4ee5\u4e0a 3 \u79cd\u65b9\u6848\u4e2d\u9009\u62e9\u4e00\u79cd\u65b9\u6848\u3002 \u8bf7\u4f60\u8fd4\u56de\u5403\u6389\u6240\u6709 n \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1an = 10 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u4f60\u603b\u5171\u6709 10 \u4e2a\u6a58\u5b50\u3002 \u7b2c 1 \u5929\uff1a\u5403 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 10 - 1 = 9\u3002 \u7b2c 2 \u5929\uff1a\u5403 6 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 9 - 2*(9/3) = 9 - 6 = 3\u3002\uff089 \u53ef\u4ee5\u88ab 3 \u6574\u9664\uff09 \u7b2c 3 \u5929\uff1a\u5403 2 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 3 - 2*(3/3) = 3 - 2 = 1\u3002 \u7b2c 4 \u5929\uff1a\u5403\u6389\u6700\u540e 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 1 - 1 = 0\u3002 \u4f60\u9700\u8981\u81f3\u5c11 4 \u5929\u5403\u6389 10 \u4e2a\u6a58\u5b50\u3002 */ class Solution { public : unordered_map < int , int > dict ; int minDays ( int n ) { if ( n <= 1 ) { return 1 ; } if ( dict . find ( n ) != dict . end ()) { return dict [ n ]; } else { return dict [ n ] = min ( n % 2 + 1 + minDays ( n / 2 ), n % 3 + 1 + minDays ( n / 3 )); } } }; 1585. Check If String Is Transformable With Substring Sort Operations* \u00b6 Given two strings s and t, you want to transform string s into string t using the following operation any number of times: Choose a non-empty substring in s and sort it in-place so the characters are in ascending order. For example, applying the operation on the underlined substring in \"14234\" results in \"12344\". Return true if it is possible to transform string s into string t. Otherwise, return false. A substring is a contiguous sequence of characters within a string. Example: Input: s = \"84532\", t = \"34852\" Output: true Explanation: You can transform s into t using the following sort operations: \"84532\" (from index 2 to 3) -> \"84352\" \"84352\" (from index 0 to 2) -> \"34852\" Input: s = \"34521\", t = \"23415\" Output: true Explanation: You can transform s into t using the following sort operations: \"34521\" -> \"23451\" \"23451\" -> \"23415\" Input: s = \"12345\", t = \"12435\" Output: false Input: s = \"1\", t = \"2\" Output: false Constraints: s.length == t.length 1 <= s.length <= 105 s and t only contain digits from '0' to '9'. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isTransformable ( string s , string t ) { vector < vector < int >> idx ( 10 ); vector < int > count ( 10 ); for ( int i = 0 ; i < int ( s . length ()); i ++ ) { idx [ s [ i ] - '0' ]. push_back ( i ); } for ( int i = 0 ; i < int ( t . length ()); i ++ ) { int digit = t [ i ] - '0' ; if ( count [ digit ] == idx [ digit ]. size ()) { return false ; } for ( int j = 0 ; j < digit ; j ++ ) { if ( count [ j ] != idx [ j ]. size () && idx [ j ][ count [ j ]] < idx [ digit ][ count [ digit ]]) { return false ; } } count [ digit ] ++ ; } return true ; } };","title":"Leetcode"},{"location":"algo/leetcode/#0004-median-of-two-sorted-arrays","text":"There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example: nums1 = [1, 3] nums2 = [2] The median is 2.0 nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Solution: This problem requires a time complexity in O(log(m+n)), which determines that we cannot merge sort the twos arrays then get a median value because of o(m+n). A faisible solution is to find k-th value in two sorted arrays based on binary search. \\bigstar \\bigstar Cut two sorted arrays In fact, median is a statistique term, which means a value in middle position. If we want acquire a median value in one sorted array, it is easy to take the value in middlle position. \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad For example, the cutting line split an array into two parts with same size, l1 and r1 are left value and right value of cut postion. Left example is odd array, l1 = r1 = 3, while right example is even array, l1 = 3, r1 = 4. Similarly, we can generalize this to two arrays. If we can find such a cut for two arrays that the number of left cut and the number of right cut are equal, we can determine a median value for the 2 arrays. For example, we determine cut position k1, k2 for A, B respectively. \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\bigstar \\bigstar Unify odd and even number According to traditional way, we have to treat case-by-case: it is different to calculate median value for odd array and even array. In order to conquer this problem, we introuce a virtual placeholder. For example, an original array A is 1 2 3 4 5 and we insert a virtual placeholder # into A, which becomes A' = #1#2#3#4#5#. We see, lenghth of the original array is 5, while length of the new array is 5*2+1. If we cut A' at position 4(5 th character from left). With this method, it's easy to get value in the original. Cut position c = 4 \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} If cut position for A' is in first # or last #, it will cause a overflow problem. \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} As the example shows, if cut position at first #, left = min(A[0], B[0]), while cut position at last #, right = max(A[-1], B[-1]). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = int ( nums1 . size ()), n2 = int ( nums2 . size ()); if ( n1 == 0 ) { return ( nums2 [( n2 - 1 ) / 2 ] + nums2 [ n2 / 2 ]) / 2.0 ; } if ( n2 == 0 ) { return ( nums1 [( n1 - 1 ) / 2 ] + nums1 [ n1 / 2 ]) / 2.0 ; } int MAX = nums1 [ n1 - 1 ] > nums2 [ n2 - 1 ] ? nums1 [ n1 - 1 ] : nums2 [ n2 - 1 ]; int MIN = nums1 [ 0 ] < nums2 [ 0 ] ? nums1 [ 0 ] : nums2 [ 0 ]; if ( n1 < n2 ) { return findK ( nums1 , nums2 , 0 , 2 * n1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums2 , nums1 , 0 , 2 * n2 , n2 , n1 , MAX , MIN ); } } double findK ( vector < int > nums1 , vector < int > nums2 , int b , int e , int n1 , int n2 , int MAX , int MIN ) { int l1 = 0 , l2 = 0 , r1 = 0 , r2 = 0 ; int k1 = ( b + e ) / 2 , k2 = ( n1 + n2 - k1 ); if ( k1 == 0 ) { l1 = MIN ; r1 = nums1 [ 0 ]; } else if ( k1 >= 2 * n1 ) { l1 = nums1 [ n1 - 1 ]; r1 = MAX ; } else { l1 = nums1 [( k1 - 1 ) / 2 ]; r1 = nums1 [ k1 / 2 ]; } if ( k2 == 0 ) { l2 = MIN ; r2 = nums2 [ 0 ]; } else if ( k2 >= 2 * n2 ) { l2 = nums2 [ n2 - 1 ]; r2 = MAX ; } else { l2 = nums2 [( k2 - 1 ) / 2 ]; r2 = nums2 [ k2 / 2 ]; } if ( l1 <= r2 && l2 <= r1 ) { return (( l1 > l2 ? l1 : l2 ) + ( r1 < r2 ? r1 : r2 )) / 2.0 ; } else if ( l1 > r2 ) { return findK ( nums1 , nums2 , b , k1 - 1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums1 , nums2 , k1 + 1 , e , n1 , n2 , MAX , MIN ); } } };","title":"0004. Median of Two Sorted Arrays*"},{"location":"algo/leetcode/#0005-longest-palindromic-substring","text":"Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\" Output: \"bb\" Solution: Dynamic programming: We construct a table, such that table[i][j] represent a substring fron s[i] to s[j] is palindromic or not. Note that, each single character is palindromic, namely table[i][i] is true. We also assignment table[i][i+1] = true if two adjacent characters are same. Then we visit other substirngs to find the longest one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : string longestPalindrome ( string s ) { int n = int ( s . length ()), pos = 0 , len = 1 ; if ( n < 2 ) { return s ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; pos = i ; len = 2 ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { pos = i ; len = k + 1 ; dp [ i ][ j ] = true ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return s . substr ( pos , len ); } };","title":"0005. Longest Palindromic Substring*"},{"location":"algo/leetcode/#0006-zigzag-conversion","text":"The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : string convert ( string s , int numRows ) { int n = int ( s . length ()); if ( n == 0 || numRows < 2 ) { return s ; } string res = \"\" ; int nRow = numRows , num = 2 * numRows - 2 ; int nCol = ( n / num ) * ( num - nRow + 1 ); if ( n % num < nRow ) { nCol ++ ; } else { nCol += ( n % num ) - nRow + 1 ; } char * mat = new char [ nRow * nCol ]{}; for ( int k = 0 ; k < n ; k ++ ) { int quo = k / num , mod = k % num ; int i = - 1 , j = quo * ( num - nRow + 1 ); if ( mod < nRow ) { i = mod ; } else { i = nRow - 2 - ( mod - nRow ); j += mod - nRow + 1 ; } mat [ i * nCol + j ] = s [ k ]; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( mat [ i * nCol + j ]) { res . push_back ( mat [ i * nCol + j ]); } } } delete [] mat ; return res ; } };","title":"0006. ZigZag Conversion"},{"location":"algo/leetcode/#0007","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u7ed9\u4f60\u4e00\u4e2a 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570 x \uff0c\u8fd4\u56de\u5c06 x \u4e2d\u7684\u6570\u5b57\u90e8\u5206\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\u3002 \u5982\u679c\u53cd\u8f6c\u540e\u6574\u6570\u8d85\u8fc7 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570\u7684\u8303\u56f4 [\u2212231, 231 \u2212 1] \uff0c\u5c31\u8fd4\u56de 0\u3002 \u5047\u8bbe\u73af\u5883\u4e0d\u5141\u8bb8\u5b58\u50a8 64 \u4f4d\u6574\u6570\uff08\u6709\u7b26\u53f7\u6216\u65e0\u7b26\u53f7\uff09\u3002 \u8f93\u5165\uff1ax = 123 \u8f93\u51fa\uff1a321 \u8f93\u5165\uff1ax = -123 \u8f93\u51fa\uff1a-321 \u8f93\u5165\uff1ax = 120 \u8f93\u51fa\uff1a21 \u8f93\u5165\uff1ax = 0 \u8f93\u51fa\uff1a0 */ class Solution { public : int reverse ( int x ) { int ans = 0 ; if ( x == INT_MIN ) { return 0 ; } while ( x ) { if ( ans > INT_MAX / 10 || ans < INT_MIN / 10 ) { return 0 ; } ans = ans * 10 + ( x % 10 ); x /= 10 ; } return ans ; } };","title":"0007. \u6574\u6570\u53cd\u8f6c"},{"location":"algo/leetcode/#0010-regular-expression-matching","text":"Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"a \" Output: true Explanation: ' ' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\" p = \". \" Output: true Explanation: \". \" means \"zero or more (*) of any character (.)\". Example: 4 Input: s = \"aab\" p = \"c a b\" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\". Example 5: Input: s = \"mississippi\" p = \"mis is p*.\" Output: false Solution: Consider two string s, p. i, j denote some position in s and p. We use dynamic programming with a matrix dp (ns+1) \\times (np+1) (ns+1) \\times (np+1) . ns and np are length of s and p. dp[i][j] denote if s[i:] and p[j:] match. The last entry dp[ns][np] is true. because '' and '' match. Firstly, we check if s[i] and p[j] match ij_match is false or true. Secondly, if p[j+1] is , dp[i][j] has two independent sources: dp[i][j+2] and dp[i+1][j]. In detail, dp[i][j+2] represents we jump over * to check dp[i][j+2]. Similarly, dp[i+1][j] influences dp[i][j] but we have to consider ij_match. Both ij_match and dp[i+1][j] are true, dp[i][j] is true. Otherwise, p[j+1] is not , dp[i][j] is dependent of ij_match and dp[i+1][j+1]. Finally, return dp[0][0] Remark: why we don't consider ij_match for dp[i][j+2]? Because we jump over *. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '.' ); if ( j < np - 1 && p [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } int res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } };","title":"0010. Regular Expression Matching*"},{"location":"algo/leetcode/#0011-container-with-most-water","text":"Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 Solution: Brutal force cause Time Limit Exceeded. We use two points method. 1) Firstly, we set two extremities as initial values. 2) Then we move the shorter side towards the longer side one step, e.g. moving 1 towards 7. 3) We repeat 2) until two side are adjacent. During this process, we calculate the max area. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. */ class Solution { public : int maxArea ( vector < int >& height ) { int n = int ( height . size ()); if ( n < 2 ) { return 0 ; } int i = 0 , j = n - 1 , res = 0 ; while ( i < j ) { int a = height [ i ], b = height [ j ]; int B = a < b ? a : b , H = j - i ; if ( B * H > res ) { res = B * H ; } if ( a < b ) { i ++ ; } else { j -- ; } } return res ; } };","title":"0011. Container With Most Water*"},{"location":"algo/leetcode/#0014-longest-common-prefix","text":"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { int n = int ( strs . size ()); if ( n == 0 ) { return \"\" ; } string str = \"\" ; for ( int j = 0 ; j < int ( strs [ 0 ]. length ()); j ++ ) { char flag = strs [ 0 ][ j ]; for ( int i = 1 ; i < n ; i ++ ) { if ( strs [ i ][ j ] != flag ) { return str ; } } str . push_back ( flag ); } return str ; } };","title":"0014. Longest Common Prefix"},{"location":"algo/leetcode/#0018-4sum","text":"Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] */ class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < vector < int >> res ; if ( n < 4 ) { return res ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { int b = j + 1 , e = n - 1 ; while ( b < e ) { int sum = nums [ i ] + nums [ j ] + nums [ b ] + nums [ e ]; if ( sum < target ) { b ++ ; } else if ( sum > target ) { e -- ; } else { while ( i < n - 3 && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < n - 2 && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( b < e && nums [ b ] == nums [ b + 1 ]) { b ++ ; } while ( b < e && nums [ e ] == nums [ e - 1 ]) { e -- ; } vector < int > arr ; arr . push_back ( nums [ i ]); arr . push_back ( nums [ j ]); arr . push_back ( nums [ b ]); arr . push_back ( nums [ e ]); res . push_back ( arr ); b ++ ; e -- ; } } } } return res ; } };","title":"0018. 4Sum"},{"location":"algo/leetcode/#0019-remove-nth-node-from-end-of-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. */ // Two pointers class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { if ( n < 1 || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 , head ); ListNode * p1 = pre , * p2 = head , * p3 = head ; while ( n -- ) { if ( p3 == nullptr ) { return head ; } p3 = p3 -> next ; } while ( p3 != nullptr ) { p3 = p3 -> next ; p2 = p2 -> next ; p1 = p1 -> next ; } p1 -> next = p2 -> next ; delete p2 ; head = pre -> next ; delete pre ; return head ; } };","title":"0019. Remove Nth Node From End of List*"},{"location":"algo/leetcode/#0022-generate-parentheses","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] */ class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > res ; if ( n == 0 ) { return res ; } string str = \"\" ; append ( res , str , n , 0 , 0 , 0 ); return res ; } void append ( vector < string > & res , string str , int n , int idx , int nLeft , int nRight ) { if ( idx == 2 * n ) { if ( nRight == nLeft ) { res . push_back ( str ); } return ; } if ( nLeft >= nRight && nLeft < n ) { append ( res , str + '(' , n , idx + 1 , nLeft + 1 , nRight ); } append ( res , str + ')' , n , idx + 1 , nLeft , nRight + 1 ); } };","title":"0022. Generate Parentheses"},{"location":"algo/leetcode/#0024-swap-nodes-in-pairs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Given 1->2->3->4, you should return the list as 2->1->4->3. */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); ListNode * par = head , * son = head -> next , * gra = pre ; pre -> next = head ; while ( son != nullptr ) { par -> next = son -> next ; son -> next = par ; gra -> next = son ; gra = par ; par = par -> next ; if ( par == nullptr ) { break ; } son = par -> next ; } head = pre -> next ; delete pre ; return head ; } };","title":"0024. Swap Nodes in Pairs"},{"location":"algo/leetcode/#0025-reverse-nodes-in-k-group","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k < 2 ) { return head ; } ListNode * front = head ; for ( int i = 0 ; i < k ; i ++ ) { if ( front == nullptr ) { return head ; } front = front -> next ; } bool isEnd = false ; ListNode * pre = new ListNode ( 0 , head ); ListNode * gra = pre , * par = head , * son = head -> next ; while ( true ) { ListNode * temp = front , * p1 = gra , * p2 = par , * p3 = son ; while ( p2 != temp ) { if ( front == nullptr ) { isEnd = true ; } else { front = front -> next ; } p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { break ; } p3 = p3 -> next ; } par -> next = p2 ; gra -> next = p1 ; gra = par ; par = p2 ; son = p3 ; if ( isEnd || p3 == nullptr ) { break ; } } head = pre -> next ; delete pre ; return head ; } };","title":"0025. Reverse Nodes in k-Group"},{"location":"algo/leetcode/#0028-implement-strstr","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: haystack = \"hello\", needle = \"ll\" Output: 2 */ class Solution { public : int strStr ( string haystack , string needle ) { string T = haystack , P = needle ; int nT = int ( T . length ()), nP = int ( P . length ()); if ( nP == 0 ) { return 0 ; } if ( nT == 0 ) { return - 1 ; } int * next = new int [ nP ]{}; int i = 0 , j = 0 , t = next [ 0 ] = - 1 , k = 0 ; while ( k < nP - 1 ) { if ( t < 0 || P [ t ] == P [ k ]) { next [ ++ k ] = ++ t ; } else { t = next [ t ]; } } while ( i < nT && j < nP ) { if ( j < 0 || T [ i ] == P [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } delete [] next ; if ( i - j <= nT - nP ) { return i - j ; } else { return - 1 ; } } };","title":"0028. Implement strStr()*"},{"location":"algo/leetcode/#0029-divide-two-integers","text":"Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = truncate(3.33333..) = 3. Example 2: Input: dividend = 7, divisor = -3 Output: -2 Explanation: 7/-3 = truncate(-2.33333..) = -2. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int divide ( int dividend , int divisor ) { int MAX = ( 1ll << 31 ) - 1 ; long m = abs ( long ( dividend )), n = abs ( long ( divisor )), quo = 0 ; while ( m >= n ) { long s = n , incre = 1 ; while (( s << 1 ) <= m ) { s <<= 1 ; incre <<= 1 ; } quo += incre ; m -= s ; } if (( dividend < 0 ) ^ ( divisor < 0 )) { quo *= - 1 ; } return quo > MAX ? MAX : int ( quo ); } };","title":"0029. Divide Two Integers*"},{"location":"algo/leetcode/#0030-substring-with-concatenation-of-all-words","text":"You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order. Example: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"] Output: [6,9,12] Constraints: 1 <= s.length <= 10^{4} 10^{4} s consists of lower-case English letters. 1 <= words.length <= 5000 1 <= words[i].length <= 30 words[i] consists of lower-case English letters. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { vector < int > res ; int n = int ( words . size ()), sLen = int ( s . length ()); if ( n == 0 || n * words [ 0 ]. length () > sLen ) { return res ; } sort ( words . begin (), words . end ()); int i = 0 , wordLen = int ( words [ 0 ]. length ()), wordsLen = n * wordLen ; while ( i + wordsLen <= sLen ) { string subStr = s . substr ( i , wordsLen ); vector < string > tmp ; for ( int j = 0 ; j < wordsLen ; j += wordLen ) { tmp . push_back ( subStr . substr ( j , wordLen )); } sort ( tmp . begin (), tmp . end ()); bool isOk = true ; for ( int k = 0 ; k < n ; k ++ ) { if ( tmp [ k ] != words [ k ]) { isOk = false ; break ; } } if ( isOk ) { res . push_back ( i ); } i ++ ; } return res ; } };","title":"0030. Substring with Concatenation of All Words*"},{"location":"algo/leetcode/#0031-next-permutation","text":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. Example: 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1 Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = int ( nums . size ()), idx = - 1 ; if ( n < 2 ) { return ; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( nums [ i - 1 ] < nums [ i ]) { idx = i - 1 ; break ; } } if ( idx == - 1 ) { sort ( nums . begin (), nums . end ()); return ; } for ( int i = n - 1 ; i > idx ; i -- ) { if ( nums [ i ] > nums [ idx ]) { swap ( nums [ i ], nums [ idx ]); sort ( nums . begin () + idx + 1 , nums . end ()); return ; } } } };","title":"0031. Next Permutation*"},{"location":"algo/leetcode/#0032-longest-valid-parentheses","text":"Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int longestValidParentheses ( string s ) { int maxLen = 0 , n = int ( s . length ()), leftCount = 0 ; if ( n < 2 ) { return maxLen ; } int * dp = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { if ( leftCount == 0 && s [ i ] == ')' ) { continue ; } if ( s [ i ] == '(' ) { leftCount ++ ; } else { leftCount -- ; dp [ i ] = dp [ i - 1 ] + 1 ; if ( i - dp [ i ] * 2 >= 0 ) { dp [ i ] += dp [ i - dp [ i ] * 2 ]; } } maxLen = maxLen > dp [ i ] ? maxLen : dp [ i ]; } delete [] dp ; return maxLen * 2 ; } };","title":"0032. Longest Valid Parentheses*"},{"location":"algo/leetcode/#0034-find-first-and-last-position-of-element-in-sorted-array","text":"Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. Follow up: Could you write an algorithm with O(log n) runtime complexity? Example: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Input: nums = [], target = 0 Output: [-1,-1] Constraints: 0 <= nums.length <= 10^{5} 10^{5} - 10^{9} 10^{9} <= nums[i] <= 10^{9} 10^{9} nums is a non-decreasing array. - 10^{9} 10^{9} <= target <= 10^{9} 10^{9} Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < int > res ; res . push_back ( - 1 ); res . push_back ( - 1 ); if ( n < 1 ) { return res ; } res [ 0 ] = binSearFir ( nums , target , 0 , n - 1 ); res [ 1 ] = binSearSec ( nums , target , 0 , n ); return res ; } int binSearFir ( vector < int > & nums , int target , int b , int e ) { if ( b == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] < target ) { return binSearFir ( nums , target , m + 1 , e ); } else { return binSearFir ( nums , target , b , m ); } } int binSearSec ( vector < int > & nums , int target , int b , int e ) { if ( b + 1 == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] <= target ) { return binSearSec ( nums , target , m , e ); } else { return binSearSec ( nums , target , b , m ); } } };","title":"0034. Find First and Last Position of Element in Sorted Array"},{"location":"algo/leetcode/#0035","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* \u7ed9\u5b9a\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\u548c\u4e00\u4e2a\u76ee\u6807\u503c\uff0c\u5728\u6570\u7ec4\u4e2d\u627e\u5230\u76ee\u6807\u503c\uff0c\u5e76\u8fd4\u56de\u5176\u7d22\u5f15\u3002 \u5982\u679c\u76ee\u6807\u503c\u4e0d\u5b58\u5728\u4e8e\u6570\u7ec4\u4e2d\uff0c\u8fd4\u56de\u5b83\u5c06\u4f1a\u88ab\u6309\u987a\u5e8f\u63d2\u5165\u7684\u4f4d\u7f6e\u3002 \u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u4e2d\u65e0\u91cd\u590d\u5143\u7d20\u3002 \u793a\u4f8b 1: \u8f93\u5165: [1,3,5,6], 5 \u8f93\u51fa: 2 \u793a\u4f8b 2: \u8f93\u5165: [1,3,5,6], 2 \u8f93\u51fa: 1 \u793a\u4f8b 3: \u8f93\u5165: [1,3,5,6], 7 \u8f93\u51fa: 4 */ class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m ; } } return l ; } };","title":"0035. \u641c\u7d22\u63d2\u5165\u4f4d\u7f6e"},{"location":"algo/leetcode/#0036-valid-sudoku","text":"Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { continue ; } if ( ! isValidForij ( board , i , j )) { return false ; } } } return true ; } bool isValidForij ( vector < vector < char >> board , int i , int j ) { int dupRow = 0 , dupCol = 0 ; for ( int k = 0 ; k < 9 ; k ++ ) { if ( board [ k ][ j ] == board [ i ][ j ]) { dupRow ++ ; } if ( board [ i ][ k ] == board [ i ][ j ]) { dupCol ++ ; } } if ( dupRow > 1 || dupCol > 1 ) { return false ; } int m = i / 3 , n = j / 3 , dupSubBox = 0 ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 3 ; y ++ ) { if ( board [ m * 3 + x ][ n * 3 + y ] == board [ i ][ j ]) { dupSubBox ++ ; } } } if ( dupSubBox > 1 ) { return false ; } return true ; } };","title":"0036. Valid Sudoku*"},{"location":"algo/leetcode/#0037-sudoku-solver","text":"Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells. $$ \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\ 6 & . & . & 1 & 9 & 5 & . & . & . \\ . & 9 & 8 & . & . & . & . & 6 & . \\ 8 & . & . & . & 6 & . & . & . & 3 \\ 4 & . & . & 8 & . & 3 & . & . & 1 \\ 7 & . & . & . & 2 & . & . & . & 6 \\ . & 6 & . & . & . & . & 2 & 8 & . \\ . & . & . & 4 & 1 & 9 & . & . & 5 \\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { isSolver ( board ); } bool isSolver ( vector < vector < char >> & board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { for ( char c = '1' ; c <= '9' ; c ++ ) { if ( isFeasible ( board , i , j , c )) { board [ i ][ j ] = c ; if ( isSolver ( board )) { return true ; } else { board [ i ][ j ] = '.' ; } } } // No feasible number return false ; } } } return true ; } bool isFeasible ( vector < vector < char >> board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ row ][ i ] == c ) { return false ; } if ( board [ i ][ col ] == c ) { return false ; } if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) { return false ; } } return true ; } };","title":"0037. Sudoku Solver*"},{"location":"algo/leetcode/#0041-first-missing-positive","text":"Given an unsorted integer array, find the smallest missing positive integer. Example: Input: [1,2,0] Output: 3 Input: [3,4,-1,1] Output: 2 Input: [7,8,9,11,12] Output: 1 Follow up: Your algorithm should run in O(n) time and uses constant extra space. Solution: \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { int n = int ( nums . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] <= 0 ) { nums [ i ] = n + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { int num = abs ( nums [ i ]); if ( num <= n ) { nums [ num - 1 ] = - abs ( nums [ num - 1 ]); } } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] > 0 ) { return i + 1 ; } } return n + 1 ; } };","title":"0041. First Missing Positive*"},{"location":"algo/leetcode/#0043-multiply-strings","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /* Input: num1 = \"123\", num2 = \"456\" Output: \"56088\" */ class Solution { public : string multiply ( string num1 , string num2 ) { string ans = \"\" ; if ( num1 == \"0\" || num2 == \"0\" ) { return \"0\" ; } int n2 = int ( num2 . length ()); for ( int j = n2 - 1 ; j >= 0 ; j -- ) { string str = strMultiChar ( num1 , num2 [ j ]); str . insert ( str . length (), n2 - 1 - j , '0' ); ans = strAdd ( ans , str ); } return ans ; } string strAdd ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); if ( n1 < n2 ) { swap ( s1 , s2 ); swap ( n1 , n2 ); } string ans = \"\" ; int i = n1 - 1 , j = n2 - 1 , add1 = 0 ; while ( i >= 0 && j >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + ( s2 [ j -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } while ( i >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans . insert ( 0 , 1 , '1' ); } return ans ; } string strMultiChar ( string str , char c ) { string ans = \"\" ; int n = int ( str . length ()), add1 = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int res = ( str [ i ] - '0' ) * ( c - '0' ) + add1 ; add1 = 0 ; if ( res > 9 ) { add1 = res / 10 ; res = res % 10 ; } char insertChar = '0' + res ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans = to_string ( add1 ) + ans ; } return ans ; } };","title":"0043. Multiply Strings"},{"location":"algo/leetcode/#0044-wildcard-matching","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Input: s = \"adceb\", p = \"*a*b\" Output: true */ class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); int ** dp = new int * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new int [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMat = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '?' || p [ j ] == '*' ); if ( p [ j ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 1 ] || ( ijMat && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMat && dp [ i + 1 ][ j + 1 ]; } } } bool ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0044. Wildcard Matching"},{"location":"algo/leetcode/#0048-rotate-image","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 1 2 3 7 4 1 4 5 6 -> 8 5 2 7 8 9 9 6 3 */ class Solution { public : void rotate ( vector < vector < int >>& matrix ) { int n = int ( matrix . size ()); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - 1 - i ; j ++ ) { int b = i , e = n - 1 - i ; int first = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ b + e - j ][ b ]; matrix [ b + e - j ][ b ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ b + j - i ][ e ]; matrix [ b + j - i ][ e ] = first ; } } } };","title":"0048. Rotate Image"},{"location":"algo/leetcode/#0049-group-anagrams","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] */ class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; int n = int ( strs . size ()); if ( n == 0 ) { return ans ; } unordered_map < string , vector < string >> dict ; for ( string & str : strs ) { string tmp = str ; sort ( tmp . begin (), tmp . end ()); dict [ tmp ]. emplace_back ( str ); } unordered_map < string , vector < string >>:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { ans . emplace_back ( iter -> second ); } return ans ; } };","title":"0049. Group Anagrams"},{"location":"algo/leetcode/#0050-powx-n","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 */ class Solution { public : double myPow ( double x , int n ) { double ans = 1.0 , tmp = x ; bool isNeg = false ; long pow = n ; if ( n < 0 ) { pow = - pow ; isNeg = true ; } long k = 1 ; while ( pow > 0 ) { if ( pow == 1 ) { ans *= x ; break ; } tmp *= tmp ; k *= 2 ; if ( k * 2 > pow ) { ans *= tmp ; tmp = x ; pow = pow - k ; k = 1 ; } } if ( isNeg ) { return 1 / ans ; } return ans ; } };","title":"0050. Pow(x, n)"},{"location":"algo/leetcode/#0051-n-queens","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: n = 4 Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"], [\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] */ class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; string str = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { str += \".\" ; } vector < string > res ( n , str ); unordered_set < int > col , diag1 , diag2 ; DFS ( col , diag1 , diag2 , n , 0 , ans , res ); return ans ; } void DFS ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int n , int i , vector < vector < string >> & ans , vector < string > & res ) { if ( i == n ) { ans . emplace_back ( res ); return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkPos ( col , diag1 , diag2 , i , j )) { res [ i ][ j ] = 'Q' ; col . insert ( j ); diag1 . insert ( i - j ); diag2 . insert ( i + j ); DFS ( col , diag1 , diag2 , n , i + 1 , ans , res ); res [ i ][ j ] = '.' ; col . erase ( j ); diag1 . erase ( i - j ); diag2 . erase ( i + j ); } } } bool isOkPos ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int i , int j ) { if ( col . find ( j ) != col . end () || diag1 . find ( i - j ) != diag1 . end () || diag2 . find ( i + j ) != diag2 . end ()) { return false ; } return true ; } };","title":"0051. N-Queens"},{"location":"algo/leetcode/#0052-n-queens-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* Input: n = 4 Output: 2 */ class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; unordered_set < int > col , dg1 , dg2 ; DFS ( col , dg1 , dg2 , 0 , n , ans ); return ans ; } void DFS ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int n , int & ans ) { if ( i == n ) { ans ++ ; return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkQueenPos ( col , dg1 , dg2 , i , j )) { col . insert ( j ); dg1 . insert ( i - j ); dg2 . insert ( i + j ); DFS ( col , dg1 , dg2 , i + 1 , n , ans ); col . erase ( j ); dg1 . erase ( i - j ); dg2 . erase ( i + j ); } } } bool isOkQueenPos ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int j ) { if ( col . find ( j ) != col . end () || dg1 . find ( i - j ) != dg1 . end () || dg2 . find ( i + j ) != dg2 . end ()) { return false ; } return true ; } };","title":"0052. N-Queens II"},{"location":"algo/leetcode/#0054-spiral-matrix","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* 1 -> 2 -> 3 | v 4 -> 5 6 ^ | | v 7 <- 8 <- 9 */ class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { vector < int > ans ; int m = int ( matrix . size ()); if ( m == 0 ) { return ans ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return ans ; } bool * vis = new bool [ m * n ]{}; int i = 0 , j = 0 ; while ( true ) { bool updated = false ; while ( true ) { if ( j >= n || vis [ i * n + j ]) { j -- ; i ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j ++ ; } while ( true ) { if ( i >= m || vis [ i * n + j ]) { i -- ; j -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i ++ ; } while ( true ) { if ( j < 0 || vis [ i * n + j ]) { j ++ ; i -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j -- ; } while ( true ) { if ( i < 0 || vis [ i * n + j ]) { i ++ ; j ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i -- ; } if ( ! updated ) { break ; } } delete [] vis ; return ans ; } };","title":"0054. Spiral Matrix"},{"location":"algo/leetcode/#0056-merge-intervals","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. */ class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); sort ( intervals . begin (), intervals . end ()); int b = 0 , rightMax = intervals [ b ][ 1 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( rightMax < intervals [ i - 1 ][ 1 ]) { rightMax = intervals [ i - 1 ][ 1 ]; } if ( rightMax < intervals [ i ][ 0 ]) { ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], rightMax }); b = i ; rightMax = intervals [ i ][ 1 ]; } } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ n - 1 ][ 1 ], rightMax ) }); return ans ; } };","title":"0056. Merge Intervals"},{"location":"algo/leetcode/#0057-insert-interval","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. */ class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); if ( n == 0 || ( intervals [ 0 ][ 0 ] >= newInterval [ 0 ] && intervals [ n - 1 ][ 1 ] <= newInterval [ 1 ])) { ans . emplace_back ( newInterval ); return ans ; } int b = 0 , e = - 1 ; while ( b < n ) { if ( intervals [ b ][ 0 ] > newInterval [ 1 ]) { ans . emplace_back ( newInterval ); for ( int i = b ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 1 ]) { return intervals ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 0 ]) { break ; } if ( intervals [ b ][ 0 ] > newInterval [ 0 ]) { intervals [ b ][ 0 ] = newInterval [ 0 ]; break ; } ans . emplace_back ( intervals [ b ++ ]); } if ( b == n ) { ans . emplace_back ( newInterval ); return ans ; } e = b + 1 ; while ( e < n && ( ( intervals [ e ][ 0 ] <= newInterval [ 1 ] && intervals [ e ][ 1 ] >= newInterval [ 1 ]) || ( intervals [ e ][ 0 ] >= newInterval [ 0 ] && intervals [ e ][ 1 ] <= newInterval [ 1 ]) ) ) { e ++ ; } if ( e == n ) { ans . emplace_back ( vector < int > { min ( newInterval [ 0 ], intervals [ b ][ 0 ]), max ( newInterval [ 1 ], intervals [ n - 1 ][ 1 ]) }); return ans ; } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ e - 1 ][ 1 ], newInterval [ 1 ]) }); for ( int i = e ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } };","title":"0057. Insert Interval"},{"location":"algo/leetcode/#0058-length-of-last-word","text":"Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0. A word is a maximal substring consisting of non-space characters only. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: s = \"Hello World\" Output: 5 */ class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 , n = int ( s . length ()); if ( n == 0 ) { return ans ; } bool isCount = false ; int i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' && isCount ) { break ; } if ( s [ i ] == ' ' ) { i -- ; continue ; } ans ++ ; i -- ; isCount = true ; } return ans ; } };","title":"0058. Length of Last Word"},{"location":"algo/leetcode/#0059-spiral-matrix-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] 1 -> 2 -> 3 | v 8 -> 9 4 ^ | | v 7 <- 6 <- 5 */ class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n , 0 )); int i = 0 , j = 0 , num = 1 ; while ( num <= n * n ) { while ( true ) { if ( j >= n || ans [ i ][ j ]) { j -- ; i ++ ; break ; } ans [ i ][ j ++ ] = num ++ ; } while ( true ) { if ( i >= n || ans [ i ][ j ]) { i -- ; j -- ; break ; } ans [ i ++ ][ j ] = num ++ ; } while ( true ) { if ( j < 0 || ans [ i ][ j ]) { j ++ ; i -- ; break ; } ans [ i ][ j -- ] = num ++ ; } while ( true ) { if ( i <= 0 || ans [ i ][ j ]) { i ++ ; j ++ ; break ; } ans [ i -- ][ j ] = num ++ ; } } return ans ; } };","title":"0059. Spiral Matrix II"},{"location":"algo/leetcode/#0061-rotate-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k <= 0 ) { return head ; } int cnt = 0 ; ListNode * curNode = head , * tail = head ; while ( curNode != nullptr ) { cnt ++ ; if ( curNode -> next == nullptr ) { tail = curNode ; } curNode = curNode -> next ; } k %= cnt ; k = cnt - k ; ListNode * p1 = head ; for ( int i = 1 ; i < k ; i ++ ) { p1 = p1 -> next ; } tail -> next = head ; head = p1 -> next ; p1 -> next = nullptr ; return head ; } };","title":"0061. Rotate List"},{"location":"algo/leetcode/#0069-sqrtx","text":"Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Input: x = 4 Output: 2 Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. */ class Solution { public : int mySqrt ( int x ) { // Binary search long lo = 1 , hi = x ; while ( lo <= hi ) { long mi = ( lo + hi ) / 2 ; if ( mi * mi < x ) { lo = mi + 1 ; } else if ( mi * mi > x ) { hi = mi - 1 ; } else { return int ( mi ); } } return int ( hi ); } };","title":"0069 Sqrt(x)*"},{"location":"algo/leetcode/#0075-sort-colors","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] */ class Solution { public : void sortColors ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return ; } int p0 = 0 , p1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] == 0 ) { swap ( nums [ i ], nums [ p0 ]); if ( p0 < p1 ) { swap ( nums [ i ], nums [ p1 ]); } p0 ++ ; p1 ++ ; } else if ( nums [ i ] == 1 ) { swap ( nums [ i ], nums [ p1 ++ ]); } } } };","title":"0075. Sort Colors*"},{"location":"algo/leetcode/#0076-minimum-window-substring","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" */ class Solution { public : string minWindow ( string s , string t ) { unordered_map < char , int > tDict , sDict ; for ( const auto & c : t ) { tDict [ c ] ++ ; } int ns = int ( s . length ()); int l = 0 , r = - 1 , ansL = - 1 , minLen = INT_MAX ; while ( r < ns ) { if ( tDict . find ( s [ ++ r ]) != tDict . end ()) { sDict [ s [ r ]] ++ ; } while ( isCover ( tDict , sDict ) && l <= r ) { if ( r - l + 1 < minLen ) { minLen = r - l + 1 ; ansL = l ; } if ( tDict . find ( s [ l ]) != tDict . end ()) { sDict [ s [ l ]] -- ; } l ++ ; } } return - 1 == ansL ? string () : s . substr ( ansL , minLen ); } bool isCover ( unordered_map < char , int > & tDict , unordered_map < char , int > & sDict ) { for ( const auto & item : tDict ) { if ( sDict [ item . first ] < item . second ) { return false ; } } return true ; } };","title":"0076. Minimum Window Substring*"},{"location":"algo/leetcode/#0077-combinations","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: n = 4, k = 2 Output: 1, 4 3, 4 2, 3 1, 2 1, 3 1, 4 */ class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; if ( n < 0 || k < 0 || n < k ) { return ans ; } vector < int > arr ; combination ( ans , arr , n , k , 1 ); return ans ; } void combination ( vector < vector < int >> & ans , vector < int > & arr , int n , int k , int idx ) { if ( k == 0 ) { ans . emplace_back ( arr ); return ; } for ( int i = idx ; i <= n ; i ++ ) { arr . emplace_back ( i ); combination ( ans , arr , n , k - 1 , i + 1 ); arr . pop_back (); } } };","title":"0077. Combinations"},{"location":"algo/leetcode/#0078-subsets","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); vector < int > arr ; dfs ( ans , arr , nums , n , 0 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int n , int idx ) { if ( idx == n ) { ans . emplace_back ( arr ); } else { arr . emplace_back ( nums [ idx ]); dfs ( ans , arr , nums , n , idx + 1 ); arr . pop_back (); dfs ( ans , arr , nums , n , idx + 1 ); } } };","title":"0078. Subsets"},{"location":"algo/leetcode/#0079-word-search","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* board = A B C E S F C S A D E E word = \"ABCCED\", return true */ class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { int nRow = int ( board . size ()); if ( nRow == 0 ) { return false ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return false ; } int len = int ( word . length ()); bool ans = false ; bool * vis = new bool [ nRow * nCol ]{}; for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] != word [ 0 ]) { continue ; } ans = isExistWord ( board , word , nRow , nCol , i , j , vis , len , 0 ); if ( ans ) { break ; } } if ( ans ) { break ; } } delete [] vis ; return ans ; } bool isExistWord ( vector < vector < char >> & board , string word , int nRow , int nCol , int i , int j , bool * vis , int len , int k ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || vis [ i * nCol + j ] || board [ i ][ j ] != word [ k ]) { return false ; } if ( k == len - 1 ) { return true ; } vis [ i * nCol + j ] = true ; bool u = isExistWord ( board , word , nRow , nCol , i - 1 , j , vis , len , k + 1 ); if ( u ) { return true ; } bool d = isExistWord ( board , word , nRow , nCol , i + 1 , j , vis , len , k + 1 ); if ( d ) { return true ; } bool l = isExistWord ( board , word , nRow , nCol , i , j - 1 , vis , len , k + 1 ); if ( l ) { return true ; } bool r = isExistWord ( board , word , nRow , nCol , i , j + 1 , vis , len , k + 1 ); if ( r ) { return true ; } vis [ i * nCol + j ] = false ; return false ; } };","title":"0079. Word Search"},{"location":"algo/leetcode/#0080-remove-duplicates-from-sorted-array-ii","text":"Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3] Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3] */ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 3 ) { return n ; } int len = 1 , count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { count ++ ; } else { count = 1 ; } if ( count <= 2 ) { nums [ len ++ ] = nums [ i ]; } } return len ; } };","title":"0080. Remove Duplicates from Sorted Array II*"},{"location":"algo/leetcode/#0082-remove-duplicates-from-sorted-list-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5 1 -> 2 -> 5 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = pre , * p2 = head ; while ( p2 != nullptr ) { bool isDup = false ; while ( p2 -> next != nullptr && p2 -> next -> val == p2 -> val ) { p2 = p2 -> next ; isDup = true ; } p2 = p2 -> next ; if ( isDup ) { p1 -> next = p2 ; } else { p1 = p1 -> next ; } } head = pre -> next ; delete pre ; return head ; } };","title":"0082. Remove Duplicates from Sorted List II*"},{"location":"algo/leetcode/#0083-remove-duplicates-from-sorted-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: 1 -> 1 -> 2 Output: 1 -> 2 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next ; while ( true ) { while ( p2 != nullptr && p1 -> val == p2 -> val ) { p2 = p2 -> next ; } p1 -> next = p2 ; p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } return head ; } };","title":"0083. Remove Duplicates from Sorted List"},{"location":"algo/leetcode/#0084-largest-rectangle-in-histogram","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. */ class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 , n = int ( heights . size ()); if ( n == 0 ) { return ans ; } heights . emplace_back ( 0 ); stack < int > stk ; for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } int area = H * W ; if ( ans < area ) { ans = area ; } } stk . push ( i ); } heights . pop_back (); return ans ; } };","title":"0084. Largest Rectangle in Histogram*"},{"location":"algo/leetcode/#0085-maximal-rectangle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 max area = 6 */ class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { int ans = 0 ; int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( matrix [ 0 ]. size ()); vector < int > heights ( nCol , 0 ); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { heights [ j ] = ( heights [ j ] + 1 ) * ( matrix [ i ][ j ] - '0' ); } ans = max ( ans , getRecArea ( heights )); } return ans ; } int getRecArea ( vector < int > heights ) { int ans = 0 , n = int ( heights . size ()); stack < int > stk ; heights . emplace_back ( 0 ); for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } ans = max ( ans , W * H ); } stk . push ( i ); } return ans ; } };","title":"0085. Maximal Rectangle*"},{"location":"algo/leetcode/#0086-partition-list","text":"Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* from 1 -> 4 -> 3 -> 2 -> 5 -> 2 to 1 -> 2 -> 2 -> 4 -> 3 -> 5 */ Input : head = [ 1 , 4 , 3 , 2 , 5 , 2 ], x = 3 Output : [ 1 , 2 , 2 , 4 , 3 , 5 ] class Solution { public : ListNode * partition ( ListNode * head , int x ) { if ( head == nullptr ) { return head ; } ListNode * h1 = new ListNode ( 0 ), * h2 = new ListNode ( 0 ); ListNode * p1 = head , * p2 = head -> next , * cur1 = h1 , * cur2 = h2 ; while ( p1 != nullptr ) { if ( p1 -> val < x ) { cur1 -> next = p1 ; cur1 = p1 ; } else { cur2 -> next = p1 ; cur2 = p1 ; } p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } cur2 -> next = nullptr ; cur1 -> next = h2 -> next ; head = h1 -> next ; delete h1 ; delete h2 ; return head ; } };","title":"0086. Partition List"},{"location":"algo/leetcode/#0087-scramble-string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y. Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x. Apply step 1 recursively on each of the two substrings x and y. Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. Input: s1 = \"great\", s2 = \"rgeat\" Output: true */ class Solution { public : bool isScramble ( string s1 , string s2 ) { int n = int ( s1 . length ()); if ( n != int ( s2 . length ())) { return false ; } if ( n == 0 ) { return true ; } bool *** dp = new bool ** [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool * [ n ]; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ] = new bool [ n + 1 ]{}; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ][ 1 ] = s1 [ i ] == s2 [ j ]; } } for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { for ( int j = 0 ; j < n - len + 1 ; j ++ ) { for ( int k = 1 ; k < len ; k ++ ) { dp [ i ][ j ][ len ] = ( ( dp [ i ][ j ][ k ] && dp [ i + k ][ j + k ][ len - k ]) || ( dp [ i + k ][ j ][ len - k ] && dp [ i ][ j + len - k ][ k ]) ); if ( dp [ i ][ j ][ len ]) { break ; } } } } } bool ans = dp [ 0 ][ 0 ][ n ]; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { delete [] dp [ i ][ j ]; } delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0087. Scramble String*"},{"location":"algo/leetcode/#0088-merge-sorted-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] */ class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int pos = int ( nums1 . size ()) - 1 ; if ( pos < 0 ) { return ; } int i = m - 1 , j = n - 1 ; while ( i >= 0 && j >= 0 ) { if ( nums1 [ i ] > nums2 [ j ]) { nums1 [ pos -- ] = nums1 [ i -- ]; } else { nums1 [ pos -- ] = nums2 [ j -- ]; } } while ( i >= 0 ) { nums1 [ pos -- ] = nums1 [ i -- ]; } while ( j >= 0 ) { nums1 [ pos -- ] = nums2 [ j -- ]; } } };","title":"0088. Merge Sorted Array"},{"location":"algo/leetcode/#0090-subsets-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] */ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); sort ( nums . begin (), nums . end ()); vector < int > arr ; dfs ( ans , arr , nums , 0 , n ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int idx , int n ) { for ( int i = idx ; i < n ; i ++ ) { if ( i > idx && nums [ i ] == nums [ i - 1 ]) { continue ; } arr . emplace_back ( nums [ i ]); dfs ( ans , arr , nums , i + 1 , n ); arr . pop_back (); } ans . emplace_back ( arr ); } };","title":"0090. Subsets II*"},{"location":"algo/leetcode/#0091-decode-ways","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 'A' -> \"1\" 'B' -> \"2\" ... 'Z' -> \"26\" Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). */ class Solution { public : int numDecodings ( string s ) { int n = ( int ) s . length (); if ( n == 0 || s [ 0 ] == '0' ) { return 0 ; } if ( n == 1 ) { return 1 ; } int a = ( s [ n - 1 ] != '0' ); int b = 0 ; if ( s [ n - 2 ] != '0' ) { b = a + (( s [ n - 2 ] - '0' ) * 10 + s [ n - 1 ] - '0' <= 26 ); } if ( n == 2 ) { return b ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { int c = 0 ; if ( s [ i ] == '0' ) { a = b ; b = c ; continue ; } c += b ; if ( i < n - 1 && ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) <= 26 ) { c += a ; } a = b ; b = c ; } return b ; } };","title":"0091. Decode Ways"},{"location":"algo/leetcode/#0092-reverse-linked-list-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] 1 -> 2 -> 3 -> 4 -> 5 | v 1 -> 4 -> 3 -> 2 -> 5 */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int left , int right ) { if ( left >= right || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = head , * p0 = pre ; int i = 1 ; while ( i < left ) { p1 = p1 -> next ; p0 = p0 -> next ; i ++ ; if ( p1 == nullptr ) { delete pre ; return head ; } } ListNode * tail = p1 , * p2 = p1 -> next ; if ( p2 == nullptr ) { delete pre ; return head ; } ListNode * p3 = p2 -> next ; while ( i < right ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } p3 = p3 -> next ; i ++ ; } p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } };","title":"0092. Reverse Linked List II"},{"location":"algo/leetcode/#0093-restore-ip-addresses","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] */ class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; int n = int ( s . length ()); if ( n < 4 || n > 12 ) { return ans ; } unordered_map < string , bool > dict ; vector < string > sol ; find ( ans , s , 0 , n , dict , sol ); return ans ; } void find ( vector < string > & ans , string & s , int i , int n , unordered_map < string , bool > & dict , vector < string > & sol ) { if ( sol . size () > 4 ) { return ; } if ( i >= n ) { if ( sol . size () != 4 ) { return ; } string res = \"\" ; for ( int i = 0 ; i < 3 ; i ++ ) { res += sol [ i ]; res . push_back ( '.' ); } res += sol [ 3 ]; ans . emplace_back ( res ); return ; } for ( int k = 1 ; k <= 3 ; k ++ ) { if ( i + k > n ) { continue ; } string str = s . substr ( i , k ); if ( dict . find ( str ) == dict . end ()) { dict [ str ] = isLegalIp ( str ); } if ( ! dict [ str ]) { continue ; } sol . emplace_back ( str ); find ( ans , s , i + k , n , dict , sol ); sol . pop_back (); } } bool isLegalIp ( string str ) { int len = int ( str . length ()); if ( len > 1 && str [ 0 ] == '0' ) { return false ; } int val = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] > '9' || str [ i ] < '0' ) { return false ; } val = val * 10 + ( str [ i ] - '0' ); } return val < 256 ; } };","title":"0093. Restore IP Addresses"},{"location":"algo/leetcode/#0094-binary-tree-inorder-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; stack < TreeNode *> st ; TreeNode * curNode = root ; while ( curNode != nullptr ) { while ( curNode != nullptr ) { if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } st . push ( curNode ); curNode = curNode -> left ; } curNode = st . top (); st . pop (); while ( ! st . empty () && curNode -> right == nullptr ) { res . push_back ( curNode -> val ); curNode = st . top (); st . pop (); } res . push_back ( curNode -> val ); if ( ! st . empty ()) { curNode = st . top (); st . pop (); } else { curNode = nullptr ; } } return res ; } };","title":"0094. Binary Tree Inorder Traversal*"},{"location":"algo/leetcode/#0096-unique-binary-search-trees","text":"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: n = 3 Output: 5 Input: n = 1 Output: 1 */ class Solution { public : int numTrees ( int n ) { long C = 1 ; for ( int i = 0 ; i < n ; i ++ ) { C = C * 2 * ( 2 * i + 1 ) / ( i + 2 ) ; } return int ( C ); } };","title":"0096. Unique Binary Search Trees"},{"location":"algo/leetcode/#0098-validate-binary-search-tree","text":"Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 2 / \\ 1 3 is a BST 5 / \\ 1 4 / \\ 3 6 is not a BST */ class Solution { public : bool isValidBST ( TreeNode * root ) { TreeNode * prec = nullptr ; return isBST ( root , prec ); } bool isBST ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { bool left = isBST ( root -> left , prec ); if ( left == false ) { return false ; } if ( prec == nullptr ) { prec = root ; } else if ( prec -> val >= root -> val ) { return false ; } prec = root ; bool right = isBST ( root -> right , prec ); if ( right == false ) { return false ; } } return true ; } };","title":"0098. Validate Binary Search Tree"},{"location":"algo/leetcode/#0100-same-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: p = [1,2,3], q = [1,2,3] Output: true */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( p == nullptr && q == nullptr ) { return true ; } if (( p == nullptr && q != nullptr ) || ( p != nullptr && q == nullptr ) || ( p -> val != q -> val )) { return false ; } bool left = isSameTree ( p -> left , q -> left ); if ( ! left ) { return false ; } bool right = isSameTree ( p -> right , q -> right ); if ( ! right ) { return false ; } return true ; } };","title":"0100. Same Tree"},{"location":"algo/leetcode/#0101-symmetric-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1 / \\ 2 2 / \\ / \\ 3 4 4 3 */ class Solution { public : bool isSymmetric ( TreeNode * root ) { if ( root == nullptr ) { return true ; } return isSymmetricTree ( root -> left , root -> right ); } bool isSymmetricTree ( TreeNode * leftTree , TreeNode * rightTree ) { if ( leftTree == nullptr && rightTree == nullptr ) { return true ; } if (( leftTree != nullptr && rightTree == nullptr ) || ( leftTree == nullptr && rightTree != nullptr ) || leftTree -> val != rightTree -> val ) { return false ; } bool left = isSymmetricTree ( leftTree -> left , rightTree -> right ); if ( ! left ) { return false ; } bool right = isSymmetricTree ( leftTree -> right , rightTree -> left ); if ( ! right ) { return false ; } return true ; } };","title":"0101. Symmetric Tree"},{"location":"algo/leetcode/#0102-binary-tree-level-order-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { ans . emplace_back ( arr ); arr . clear (); last = nextLast ; } } return ans ; } };","title":"0102. Binary Tree Level Order Traversal"},{"location":"algo/leetcode/#0103-binary-tree-zigzag-level-order-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* 3 / \\ 9 20 / \\ 15 7 [ [3], [20,9], [15,7] ] */ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; int level = 1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { if ( level % 2 == 0 ) { int n = int ( arr . size ()); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr [ i ], arr [ n - 1 - i ]); } } ans . emplace_back ( arr ); arr . clear (); last = nextLast ; level ++ ; } } return ans ; } };","title":"0103. Binary Tree Zigzag Level Order Traversal"},{"location":"algo/leetcode/#0104-maximum-depth-of-binary-tree","text":"Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 3 / \\ 9 20 / \\ 15 7 max depth = 3 */ class Solution { public : int maxDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = maxDepth ( root -> left ); int rightDep = maxDepth ( root -> right ); return 1 + max ( leftDep , rightDep ); } };","title":"0104. Maximum Depth of Binary Tree"},{"location":"algo/leetcode/#0110-balanced-binary-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( root == nullptr ) { return true ; } bool ans = true ; getDepth ( root , ans ); return ans ; } int getDepth ( TreeNode * root , bool & isBal ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDepth ( root -> left , isBal ); int rightDep = getDepth ( root -> right , isBal ); if ( abs ( leftDep - rightDep ) > 1 ) { isBal = false ; } return 1 + max ( leftDep , rightDep ); } };","title":"0110. Balanced Binary Tree"},{"location":"algo/leetcode/#0111-minimum-depth-of-binary-tree","text":"Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 3 / \\ 9 20 / \\ 15 7 min depth = 2 */ class Solution { public : int minDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = minDepth ( root -> left ); int rightDep = minDepth ( root -> right ); if ( leftDep != 0 && rightDep != 0 ) { return 1 + min ( leftDep , rightDep ); } else { return 1 + max ( leftDep , rightDep ); } } };","title":"0111. Minimum Depth of Binary Tree"},{"location":"algo/leetcode/#0112-path-sum","text":"Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true 1 / \\ 2 3 Input: root = [1,2,3], targetSum = 5 Output: false */ class Solution { public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( root == nullptr ) { return false ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( root -> val == targetSum ) { return true ; } return false ; } bool isInLeft = hasPathSum ( root -> left , targetSum - root -> val ); if ( isInLeft ) { return true ; } bool isInRight = hasPathSum ( root -> right , targetSum - root -> val ); if ( isInRight ) { return true ; } return false ; } };","title":"0112. Path Sum"},{"location":"algo/leetcode/#0113-path-sum-ii","text":"Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path's sum equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int targetSum ) { vector < vector < int >> ans ; if ( root == nullptr ) { return ans ; } vector < int > arr ; findPaths ( root , targetSum , ans , arr ); return ans ; } void findPaths ( TreeNode * root , int resVal , vector < vector < int >> & ans , vector < int > & arr ) { if ( root == nullptr ) { return ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( resVal == root -> val ) { arr . emplace_back ( root -> val ); ans . emplace_back ( arr ); arr . pop_back (); } return ; } arr . emplace_back ( root -> val ); findPaths ( root -> left , resVal - root -> val , ans , arr ); findPaths ( root -> right , resVal - root -> val , ans , arr ); arr . pop_back (); } };","title":"0113. Path Sum II"},{"location":"algo/leetcode/#0114-flatten-binary-tree-to-linked-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 1 1 / \\ \\ 2 5 -> 2 / \\ \\ \\ 3 4 6 3 \\ 4 \\ 5 \\ 6 */ class Solution { public : void flatten ( TreeNode * root ) { TreeNode * prec = nullptr ; preOrder ( root , prec ); } void preOrder ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { TreeNode * left = root -> left , * right = root -> right ; if ( prec != nullptr ) { prec -> left = nullptr ; prec -> right = root ; } prec = root ; preOrder ( left , prec ); preOrder ( right , prec ); } } };","title":"0114. Flatten Binary Tree to Linked List"},{"location":"algo/leetcode/#0115-distinct-subsequences","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag */ class Solution { public : int numDistinct ( string s , string t ) { int ns = int ( s . length ()), nt = int ( t . length ()); if ( ns < nt ) { return 0 ; } long ** dp = new long * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new long [ nt + 1 ]{}; } for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = nt ; j >= 0 ; j -- ) { if ( j == nt ) { dp [ i ][ j ] = 1 ; } else if ( i == ns ) { dp [ i ][ j ] = 0 ; } else { if ( s [ i ] == t [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + dp [ i + 1 ][ j ]; } else { dp [ i ][ j ] = dp [ i + 1 ][ j ]; } } } } int ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0115. Distinct Subsequences*"},{"location":"algo/leetcode/#0126-word-ladder-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] Output: [ [\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"] ] Explanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\" */ class Solution { public : unordered_map < string , int > wordId ; vector < string > idWord ; vector < vector < int >> edges ; unordered_set < string > dict ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; idWord . emplace_back ( word ); edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } void dfs ( vector < vector < string >> & ans , int & maxDep , int dep , vector < string > & arr , int id , int & t , vector < int > & level ) { if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . emplace_back ( idWord [ id ]); } if ( id == t ) { ans . emplace_back ( arr ); } for ( int & nextId : edges [ id ]) { if ( level [ nextId ] > level [ id ]) { dfs ( ans , maxDep , dep + 1 , arr , nextId , t , level ); } } if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . pop_back (); } } vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; for ( string & word : wordList ) { addEdge ( word ); dict . insert ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return ans ; } if ( dict . find ( beginWord ) == dict . end ()) { addEdge ( beginWord ); dict . insert ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { break ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } if ( level [ t ] == INT_MAX ) { return ans ; } vector < string > arr ; dfs ( ans , level [ t ], 0 , arr , s , t , level ); return ans ; } };","title":"0126. Word Ladder II*"},{"location":"algo/leetcode/#0127-word-ladder","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = \"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\" Output: 5 Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long. */ class Solution { public : unordered_map < string , int > wordId ; vector < vector < int >> edges ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { for ( string & word : wordList ) { addEdge ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return 0 ; } if ( wordId . find ( beginWord ) == wordId . end ()) { addEdge ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { return level [ t ] / 2 + 1 ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } return 0 ; } };","title":"0127. Word Ladder*"},{"location":"algo/leetcode/#0128-longest-consecutive-sequence","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. */ class Solution { public : int longestConsecutive ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int ans = 1 ; unordered_set < int > hash ; for ( const auto & ele : nums ) { hash . insert ( ele ); } for ( const int & ele : nums ) { if ( hash . find ( ele - 1 ) != hash . end ()) { int curNum = ele ; int len = 1 ; while ( hash . find ( curNum ) != hash . end ()) { curNum ++ ; len ++ ; } ans = max ( ans , len ); } } return ans ; } };","title":"0128. Longest Consecutive Sequence*"},{"location":"algo/leetcode/#0129-sum-root-to-leaf-numbers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 4 / \\ 9 0 / \\ 5 1 sum = 495 + 491 + 40 = 1026 */ class Solution { public : int sumNumbers ( TreeNode * root ) { int num = 0 ; return dfs ( root , num ); } int dfs ( TreeNode * root , int num ) { if ( root == nullptr ) { return 0 ; } if ( root -> left == nullptr && root -> right == nullptr ) { return num * 10 + root -> val ;; } int left = dfs ( root -> left , num * 10 + root -> val ); int right = dfs ( root -> right , num * 10 + root -> val ); return left + right ; } };","title":"0129. Sum Root to Leaf Numbers"},{"location":"algo/leetcode/#0130-surrounded-regions","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* X X X X X X X X X O O X -> X X X X X X O X X X X X X O X X X O X X */ class Solution { public : void solve ( vector < vector < char >>& board ) { int nRow = ( int ) board . size (); if ( nRow <= 2 ) { return ; } int nCol = ( int ) board [ 0 ]. size (); if ( nCol <= 2 ) { return ; } for ( int i = 0 ; i < nRow ; i ++ ) { if ( board [ i ][ 0 ] == 'O' ) { dfs ( board , nRow , nCol , i , 0 ); } if ( board [ i ][ nCol - 1 ] == 'O' ) { dfs ( board , nRow , nCol , i , nCol - 1 ); } } for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ 0 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , 0 , j ); } if ( board [ nRow - 1 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , nRow - 1 , j ); } } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] == 'O' ) { board [ i ][ j ] = 'X' ; } if ( board [ i ][ j ] == 'A' ) { board [ i ][ j ] = 'O' ; } } } } void dfs ( vector < vector < char >> & board , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || board [ i ][ j ] == 'A' || board [ i ][ j ] == 'X' ) { return ; } board [ i ][ j ] = 'A' ; dfs ( board , nRow , nCol , i + 1 , j ); dfs ( board , nRow , nCol , i - 1 , j ); dfs ( board , nRow , nCol , i , j + 1 ); dfs ( board , nRow , nCol , i , j - 1 ); } };","title":"0130. Surrounded Regions*"},{"location":"algo/leetcode/#0131-palindrome-partitioning","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: s = \"aab\" Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]] */ class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; int n = ( int ) s . length (); if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } vector < string > arr ; move ( ans , arr , dp , n , 0 , s ); for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } void move ( vector < vector < string >> & ans , vector < string > & arr , bool ** dp , int n , int pos , string & s ) { if ( pos >= n ) { if ( ! arr . empty ()) { ans . emplace_back ( arr ); } return ; } for ( int len = 0 ; len < n - pos ; len ++ ) { if ( dp [ pos ][ pos + len ]) { arr . emplace_back ( s . substr ( pos , len + 1 )); move ( ans , arr , dp , n , pos + len + 1 , s ); arr . pop_back (); } } } };","title":"0131. Palindrome Partitioning"},{"location":"algo/leetcode/#0132-palindrome-partitioning-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /* Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. */ class Solution { public : int minCut ( string s ) { int n = int ( s . length ()); if ( n < 2 ) { return 0 ; } bool ** dp = new bool * [ n ]; int * cut = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ 0 ][ j ]) { cut [ j ] = 0 ; continue ; } int cutNum = INT_MAX ; for ( int i = j ; i > 0 ; i -- ) { if ( dp [ i ][ j ] && cutNum > cut [ i - 1 ] + 1 ) { cutNum = cut [ i - 1 ] + 1 ; } } cut [ j ] = cutNum ; } int ans = cut [ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; delete [] cut ; return ans ; } };","title":"0132. Palindrome Partitioning II*"},{"location":"algo/leetcode/#0136-single-number","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* Input: nums = [4,1,2,1,2] Output: 4 */ class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int & ele : nums ) { ans ^= ele ; } return ans ; } };","title":"0136. Single Number"},{"location":"algo/leetcode/#0137-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u9664\u67d0\u4e2a\u5143\u7d20\u4ec5\u51fa\u73b0 \u4e00\u6b21 \u5916\uff0c\u5176\u4f59\u6bcf\u4e2a\u5143\u7d20\u90fd \u6070\u51fa\u73b0 \u4e09\u6b21 \u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u90a3\u4e2a\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\u7684\u5143\u7d20\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [2,2,3,2] \u8f93\u51fa\uff1a3 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [0,1,0,1,0,1,99] \u8f93\u51fa\uff1a99 */ class Solution { public : int singleNumber ( vector < int >& nums ) { unordered_map < int , int > dict ; for ( int ele : nums ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter = dict . begin (); for (; iter != dict . end (); iter ++ ) { if ( iter -> second == 1 ) { return iter -> first ; } } return - 1 ; } };","title":"0137. \u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 II"},{"location":"algo/leetcode/#0142-linked-list-cycle-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) { return head ; } ListNode * p1 = head , * p2 = head ; while ( true ) { if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; p1 = p1 -> next ; if ( p1 == p2 ) { break ; } } p1 = head ; while ( p1 != p2 ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } };","title":"0142. Linked List Cycle II"},{"location":"algo/leetcode/#0144-binary-tree-preorder-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { curNode = st . top (); st . pop (); ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { st . push ( curNode -> left ); } } return ans ; } }; class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; while ( true ) { while ( curNode != nullptr ) { ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } curNode = curNode -> left ; } if ( st . empty ()) { break ; } curNode = st . top (); st . pop (); } return ans ; } };","title":"0144. Binary Tree Preorder Traversal"},{"location":"algo/leetcode/#0151-reverse-words-in-a-string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: s = \" hello world \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces. */ class Solution { public : string reverseWords ( string s ) { int pos = 0 ; for ( int i = 0 ; i < ( int ) s . length (); i ++ , pos ++ ) { if ( s [ i ] != ' ' ) { break ; } } string str = \"\" ; for ( int i = pos ; i < ( int ) s . length (); i ++ ) { if ( i > 0 && s [ i ] == ' ' && s [ i - 1 ] == ' ' ) { continue ; } str . push_back ( s [ i ]); } int n = int ( str . length ()); if ( str [ n - 1 ] == ' ' ) { n -- ; } str . resize ( n ); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( str [ i ], str [ n - 1 - i ]); } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int b = j , e = i - 1 ; while ( b < e ) { swap ( str [ b ++ ], str [ e -- ]); } j = i + 1 ; } } str . resize ( n ); return str ; } };","title":"0151. Reverse Words in a String"},{"location":"algo/leetcode/#0154-find-minimum-in-rotated-sorted-array-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [2,2,2,0,1] Output: 0 */ class Solution { public : int findMin ( vector < int >& nums ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ l ] == nums [ r ]) { while ( l < r && nums [ l ] == nums [ l + 1 ]) { l ++ ; } while ( l < r && nums [ r ] == nums [ r - 1 ]) { r -- ; } if (( l + 1 <= r && nums [ l ] < nums [ l + 1 ] && nums [ r ] < nums [ r - 1 ]) || l == r ) { return nums [ l ]; } l ++ ; } else { if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } } return nums [ r ]; } };","title":"0154. Find Minimum in Rotated Sorted Array II"},{"location":"algo/leetcode/#0155-min-stack","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 */ class MinStack { vector < int > arr1 , arr2 ; public : /** initialize your data structure here. */ MinStack () { } void push ( int val ) { arr1 . emplace_back ( val ); if ( arr2 . empty () || arr2 . back () > val ) { arr2 . emplace_back ( val ); } else { arr2 . emplace_back ( arr2 . back ()); } } void pop () { arr1 . pop_back (); arr2 . pop_back (); } int top () { return arr1 . back (); } int getMin () { return arr2 . back (); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(val); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */","title":"0155. Min Stack"},{"location":"algo/leetcode/#0173-binary-search-tree-iterator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /* Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { vector < int > arr ; vector < int > :: iterator iter ; public : BSTIterator ( TreeNode * root ) { inOrder ( root ); iter = arr . begin (); } void inOrder ( TreeNode * root ) { if ( root != nullptr ) { inOrder ( root -> left ); arr . emplace_back ( root -> val ); inOrder ( root -> right ); } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return 0 ; } } bool hasNext () { return iter != arr . end (); } }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */","title":"0173. Binary Search Tree Iterator"},{"location":"algo/leetcode/#0174-dungeon-game","text":"The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* -2(K) -3 3 -5 -10 1 10 30 -5(P) For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN. */ class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { int m = int ( dungeon . size ()); if ( m == 0 ) { return 1 ; } int n = int ( dungeon [ 0 ]. size ()); if ( n == 0 ) { return 1 ; } vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { int minVal = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); dp [ i ][ j ] = max ( minVal - dungeon [ i ][ j ], 1 ); } } int ans = dp [ 0 ][ 0 ]; return ans ; } };","title":"0174. Dungeon Game*"},{"location":"algo/leetcode/#0179-largest-number","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [3,30,34,5,9] Output: \"9534330\" */ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans = \"\" ; if ( nums . empty ()) { return ans ; } sort ( nums . begin (), nums . end (), []( const int & x , const int & y ) { long i = 10 , j = 10 ; while ( i <= x ) { i *= 10 ; } while ( j <= y ) { j *= 10 ; } return j * x + y > i * y + x ; }); if ( nums [ 0 ] == 0 ) { return \"0\" ; } for ( const int & ele : nums ) { ans += to_string ( ele ); } return ans ; } };","title":"0179. Largest Number*"},{"location":"algo/leetcode/#0190-reverse-bits","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. */ class Solution { public : uint32_t reverseBits ( uint32_t n ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { ans |= ( n & 1 ) << ( 31 - i ); n = n >> 1 ; } return ans ; } }; class Solution { public : uint32_t reverseBits ( uint32_t n ) { const uint32_t M1 = 0x55555555 ; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333 ; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f ; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff ; // 00000000111111110000000011111111 n = ( n >> 1 & M1 ) | ( n & M1 ) << 1 ; n = ( n >> 2 & M2 ) | ( n & M2 ) << 2 ; n = ( n >> 4 & M4 ) | ( n & M4 ) << 4 ; n = ( n >> 8 & M8 ) | ( n & M8 ) << 8 ; return n >> 16 | n << 16 ; } };","title":"0190. Reverse Bits*"},{"location":"algo/leetcode/#0191-number-of-1-bits","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. */ class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; while ( n ) { n &= n - 1 ; ans ++ ; } return ans ; //return __builtin_popcount(n); } };","title":"0191. Number of 1 Bits"},{"location":"algo/leetcode/#0199-binary-tree-right-side-view","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } int maxLevel = - 1 ; rightOrder ( root , ans , 0 , maxLevel ); return ans ; } void rightOrder ( TreeNode * root , vector < int > & ans , int level , int & maxLevel ) { if ( root != nullptr ) { if ( level > maxLevel ) { ans . emplace_back ( root -> val ); maxLevel = level ; } rightOrder ( root -> right , ans , level + 1 , maxLevel ); rightOrder ( root -> left , ans , level + 1 , maxLevel ); } } };","title":"0199. Binary Tree Right Side View"},{"location":"algo/leetcode/#0200-number-of-islands","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* grid = { {'1', '1', '0', '0', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '1', '0', '0'}, {'0', '0', '0', '1', '1'} } number of islands is 3 */ class Solution { public : int numIslands ( vector < vector < char >>& grid ) { int ans = 0 ; int nRow = int ( grid . size ()); if ( nRow == 0 ) { return 0 ; } int nCol = int ( grid [ 0 ]. size ()); if ( nCol == 0 ) { return 0 ; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( grid [ i ][ j ] == '0' ) { continue ; } if ( isIsland ( grid , nRow , nCol , i , j )) { ans ++ ; } } } return ans ; } bool isIsland ( vector < vector < char >> & grid , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || grid [ i ][ j ] == '0' ) { return false ; } bool res = true ; grid [ i ][ j ] = '0' ; bool u = isIsland ( grid , nRow , nCol , i - 1 , j ); bool d = isIsland ( grid , nRow , nCol , i + 1 , j ); bool l = isIsland ( grid , nRow , nCol , i , j - 1 ); bool r = isIsland ( grid , nRow , nCol , i , j + 1 ); return res || u || d || l || r ; } };","title":"0200. Number of Islands"},{"location":"algo/leetcode/#0209-minimum-size-subarray-sum","text":"Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 */ class Solution { public : int minSubArrayLen ( int target , vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int minLen = INT_MAX , l = 0 , r = 0 , sum = nums [ 0 ]; while ( r < n && l <= r ) { if ( sum < target ) { if ( r + 1 < n ) { sum += nums [ r + 1 ]; } r ++ ; } else { if ( minLen > r - l + 1 ) { minLen = r - l + 1 ; } sum -= nums [ l ++ ]; } } return minLen == INT_MAX ? 0 : minLen ; } };","title":"0209. Minimum Size Subarray Sum"},{"location":"algo/leetcode/#0212-word-search-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* board = o a a n e t a e i h k r i f l v words = \"oath\",\"pea\",\"eat\",\"rain\" Output: \"eat\",\"oath\" */ class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { vector < string > ans ; int nRow = int ( board . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return ans ; } unordered_set < string > hash ; unordered_set < string > res ; int maxLen = 0 ; for ( string & word : words ) { hash . insert ( word ); maxLen = max ( maxLen , int ( word . length ())); } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { bool * vis = new bool [ nRow * nCol ]{}; string str = \"\" ; collect ( board , str , nRow , nCol , i , j , 0 , maxLen , hash , res , vis ); delete [] vis ; } } unordered_set < string >:: iterator iter ; for ( iter = res . begin (); iter != res . end (); iter ++ ) { ans . emplace_back ( * iter ); } return ans ; } void collect ( vector < vector < char >> & board , string & str , int nRow , int nCol , int i , int j , int len , int maxLen , unordered_set < string > & hash , unordered_set < string > & res , bool * vis ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || len > maxLen || vis [ i * nCol + j ]) { return ; } str . push_back ( board [ i ][ j ]); vis [ i * nCol + j ] = true ; if ( hash . find ( str ) != hash . end () && res . find ( str ) == res . end ()) { res . insert ( str ); } collect ( board , str , nRow , nCol , i - 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i + 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j - 1 , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j + 1 , len + 1 , maxLen , hash , res , vis ); str . pop_back (); vis [ i * nCol + j ] = false ; } };","title":"0212. Word Search II"},{"location":"algo/leetcode/#0215-kth-largest-element-in-an-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 */ class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { int n = int ( nums . size ()); k = n - k ; int b = 0 , e = n - 1 ; while ( true ) { int i = b , j = e ; while ( i < j ) { while ( i < j && nums [ i ] <= nums [ j ]) { j -- ; } swap ( nums [ i ], nums [ j ]); while ( i < j && nums [ i ] <= nums [ j ]) { i ++ ; } swap ( nums [ i ], nums [ j ]); } if ( i == k ) { return nums [ i ]; } else if ( i > k ) { e = i - 1 ; } else { b = i + 1 ; } } return 0 ; } };","title":"0215. Kth Largest Element in an Array"},{"location":"algo/leetcode/#0216-combination-sum-iii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. */ class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; if ( k == 0 || n > 45 ) { return ans ; } vector < int > arr ; dfs ( ans , arr , k , n , 1 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , int k , int n , int idx ) { if ( k <= 0 || n <= 0 || idx > 9 ) { if ( k == 0 && n == 0 ) { ans . emplace_back ( arr ); } return ; } for ( int i = idx ; i < 10 ; i ++ ) { arr . emplace_back ( i ); dfs ( ans , arr , k - 1 , n - i , i + 1 ); arr . pop_back (); } } };","title":"0216. Combination Sum III"},{"location":"algo/leetcode/#0219-contains-duplicate-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: nums = [1,2,3,1,2,3], k = 2 Output: false */ class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( nums [ i ]) != hash . end ()) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } };","title":"0219. Contains Duplicate II"},{"location":"algo/leetcode/#0220-contains-duplicate-iii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false */ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; set < int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { iter = hash . lower_bound ( max ( nums [ i ], INT_MIN + t ) - t ); if ( iter != hash . end () && * iter <= min ( nums [ i ], INT_MAX - t ) + t ) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } };","title":"0220. Contains Duplicate III*"},{"location":"algo/leetcode/#0222","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* 1 / \\ 2 3 / \\ / 4 5 6 */ class Solution { public : int countNodes ( TreeNode * root ) { int ans = 0 ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; while ( curNode != nullptr ) { TreeNode * ll = curNode -> left , * lr = curNode -> left ; TreeNode * rl = curNode -> right , * rr = curNode -> right ; int lCnt = 1 , rCnt = 1 ; while ( ll != nullptr && lr != nullptr && rl != nullptr && rr != nullptr ) { ll = ll -> left ; lr = lr -> right ; rl = rl -> left ; rr = rr -> right ; lCnt <<= 1 ; rCnt <<= 1 ; } if ( ll == nullptr && rl == nullptr ) { ans += lCnt - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr != nullptr && rl == nullptr ) { ans += ( lCnt * 2 ) - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr == nullptr ) { ans += rCnt - 1 + 1 ; curNode = curNode -> left ; } else { ans += lCnt * 2 - 1 + 1 ; curNode = curNode -> right ; } } return ans ; } };","title":"0222. \u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u4e2a\u6570*"},{"location":"algo/leetcode/#0224-basic-calculator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23 */ class Solution { public : int calculate ( string s ) { stack < int > sn ; stack < char > so ; int num = 0 , n = int ( s . length ()), i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' ) { i -- ; continue ; } if ( s [ i ] == ')' ) { so . push ( ')' ); } else if ( s [ i ] == '(' ) { while ( so . top () != ')' ) { int n1 = sn . top (); sn . pop (); int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"wrong operator: %c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } so . pop (); } else if ( s [ i ] == '+' || s [ i ] == '-' ) { so . push ( s [ i ]); } else { long times = 1 ; while ( i >= 0 && s [ i ] >= '0' && s [ i ] <= '9' ) { num += ( s [ i -- ] - '0' ) * times ; times *= 10 ; } sn . push ( num ); //printf(\"num=%d\\n\", num); num = 0 ; continue ; } i -- ; } if ( s [ 0 ] == '-' ) { sn . push ( 0 ); } while ( ! so . empty ()) { int n1 = sn . top (); sn . pop (); if ( sn . empty ()) { sn . push ( n1 ); break ; } int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"%c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } if ( ! so . empty () && so . top () == '-' ) { return - sn . top (); } return sn . top (); } };","title":"0224. Basic Calculator"},{"location":"algo/leetcode/#0232-implement-queue-using-stacks","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false */ // s1 is input stack, s2 is output stack class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () { } /** Push element x to the back of queue. */ void push ( int x ) { s1 . push ( x ); } /** Removes the element from in front of queue and returns that element. */ int pop () { int ans = peek (); s2 . pop (); return ans ; } /** Get the front element. */ int peek () { if ( s2 . empty ()) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } } return s2 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty () && s2 . empty (); } };","title":"0232. Implement Queue using Stacks"},{"location":"algo/leetcode/#0236-lowest-common-ancestor-of-a-binary-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* 3 / \\ 5 1 / \\ / \\ 6 2 0 8 / \\ 7 4 p = 5, q = 1 nearest common ancester is 3 */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { vector < TreeNode *> t1 , t2 , tmp ; dfs ( root , p , tmp , t1 ); tmp . clear (); dfs ( root , q , tmp , t2 ); int n1 = ( int ) t1 . size (), n2 = ( int ) t2 . size (); int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( t1 [ i ] != t2 [ j ]) { break ; } i ++ ; j ++ ; } if ( i == n1 ) { return t1 [ i - 1 ]; } if ( j == n2 ) { return t2 [ j - 1 ]; } return t1 [ i - 1 ]; } void dfs ( TreeNode * root , TreeNode *& node , vector < TreeNode *> & t , vector < TreeNode *> & res ) { if ( root == nullptr ) { return ; } t . emplace_back ( root ); if ( root == node ) { res = t ; return ; } dfs ( root -> left , node , t , res ); dfs ( root -> right , node , t , res ); t . pop_back (); } };","title":"0236. Lowest Common Ancestor of a Binary Tree"},{"location":"algo/leetcode/#0239-sliding-window-maximum","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 */ class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; multiset < int > hash ; int n = ( int ) nums . size (); for ( int i = 0 ; i < k ; i ++ ) { hash . insert ( nums [ i ]); } for ( int i = k ; i < n ; i ++ ) { ans . emplace_back ( *-- hash . end ()); hash . erase ( hash . find ( nums [ i - k ])); hash . insert ( nums [ i ]); } ans . emplace_back ( *-- hash . end ()); return ans ; } }; class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; int n = ( int ) nums . size (); priority_queue < pair < int , int >> pq ; for ( int i = 0 ; i < k ; i ++ ) { pq . emplace ( nums [ i ], i ); } for ( int i = k ; i <= n ; i ++ ) { while ( pq . top (). second + k < i ) { pq . pop (); } ans . emplace_back ( pq . top (). first ); if ( i < n ) { pq . emplace ( nums [ i ], i ); } } return ans ; } };","title":"0239. Sliding Window Maximum"},{"location":"algo/leetcode/#0263-ugly-number","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: n = 6 Output: true Explanation: 6 = 2 \u00d7 3 */ class Solution { public : bool isUgly ( int n ) { if ( n <= 0 ) { return false ; } while ( n % 2 == 0 ) { n /= 2 ; } while ( n % 3 == 0 ) { n /= 3 ; } while ( n % 5 == 0 ) { n /= 5 ; } return n == 1 ; } };","title":"0263. Ugly Number"},{"location":"algo/leetcode/#0264-ugly-number-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. */ class Solution { public : int nthUglyNumber ( int n ) { int ans = 0 ; if ( n <= 6 ) { return n ; } int * dp = new int [ n ]{}; dp [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ f2 ] * 2 , min ( dp [ f3 ] * 3 , dp [ f5 ] * 5 )); while ( dp [ f2 ] * 2 <= dp [ i ]) { f2 ++ ; } while ( dp [ f3 ] * 3 <= dp [ i ]) { f3 ++ ; } while ( dp [ f5 ] * 5 <= dp [ i ]) { f5 ++ ; } } ans = dp [ n - 1 ]; delete [] dp ; return ans ; } };","title":"0264. Ugly Number II"},{"location":"algo/leetcode/#0312-burst-balloons","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 */ class Solution { public : int maxCoins ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ n + 2 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { dp [ i ] = new int [ n + 2 ]{}; } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i + 2 ; j <= n + 1 ; j ++ ) { int MAX = 0 ; for ( int k = i + 1 ; k < j ; k ++ ) { int left = ( i == 0 ? 1 : nums [ i - 1 ]); int mid = nums [ k - 1 ]; int right = ( j == n + 1 ? 1 : nums [ j - 1 ]); int prod = left * mid * right ; MAX = max ( MAX , dp [ i ][ k ] + prod + dp [ k ][ j ]); } dp [ i ][ j ] = MAX ; } } int ans = dp [ 0 ][ n + 1 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0312. Burst Balloons*"},{"location":"algo/leetcode/#0331-verify-preorder-serialization-of-a-binary-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # */ class Solution { public : bool isValidSerialization ( string preorder ) { int n = int ( preorder . length ()), i = 0 , numNull = 1 ; if ( n == 0 ) { return true ; } while ( i < n ) { if ( numNull <= 0 ) { return false ; } if ( preorder [ i ] == '#' ) { numNull -- ; i ++ ; } else if ( preorder [ i ] == ',' ) { i ++ ; } else { while ( i < n && preorder [ i ] >= '0' && preorder [ i ] <= '9' ) { i ++ ; } numNull ++ ; } } return numNull == 0 ; } };","title":"0331. Verify Preorder Serialization of a Binary Tree*"},{"location":"algo/leetcode/#0338-counting-bits","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: 5 Output: [0,1,1,2,1,2] */ class Solution { public : vector < int > countBits ( int num ) { vector < int > ans ( num + 1 , 0 ); for ( int i = 1 ; i <= num ; i ++ ) { ans [ i ] = ans [ i / 2 ] + i % 2 ; } return ans ; } };","title":"0338. Counting Bits"},{"location":"algo/leetcode/#0341-flatten-nested-list-iterator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. */ /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector<NestedInteger> &getList() const; * }; */ class NestedIterator { vector < int > vals ; vector < int >:: iterator iter ; public : NestedIterator ( vector < NestedInteger > & nestedList ) { dfs ( nestedList ); iter = vals . begin (); } void dfs ( const vector < NestedInteger > & nestedList ) { for ( auto & ni : nestedList ) { if ( ni . isInteger ()) { vals . emplace_back ( ni . getInteger ()); } else { dfs ( ni . getList ()); } } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return - 1 ; } } bool hasNext () { return iter != vals . end (); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout << i.next(); */","title":"0341. Flatten Nested List Iterator*"},{"location":"algo/leetcode/#0343-integer-break","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36. */ class Solution { public : int integerBreak ( int n ) { if ( n < 2 ) { return n ; } if ( n == 2 || n == 3 ) { return n - 1 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { int prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( prod < dp [ j ] * dp [ i - j ]) { prod = dp [ j ] * dp [ i - j ]; } } dp [ i ] = prod ; } int ans = dp [ n ]; delete [] dp ; return ans ; } };","title":"0343. Integer Break"},{"location":"algo/leetcode/#0354-russian-doll-envelopes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). */ class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { int n = int ( envelopes . size ()), len = 1 ; if ( n <= 1 ) { return n ; } sort ( envelopes . begin (), envelopes . end (), []( const auto & e1 , const auto & e2 ) { return e1 [ 0 ] < e2 [ 0 ] || ( e1 [ 0 ] == e2 [ 0 ] && e1 [ 1 ] > e2 [ 1 ]); }); vector < vector < int >> dp ( n + 1 , vector < int > { 0 , 0 }); dp [ len ] = envelopes [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( envelopes [ i ][ 0 ] > dp [ len ][ 0 ] && envelopes [ i ][ 1 ] > dp [ len ][ 1 ]) { dp [ ++ len ] = envelopes [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ][ 0 ] < envelopes [ i ][ 0 ] && dp [ m ][ 1 ] < envelopes [ i ][ 1 ]) { l = m + 1 ; } else { r = m - 1 ; } } dp [ l ] = envelopes [ i ]; } } return len ; } };","title":"0354. Russian Doll Envelopes*"},{"location":"algo/leetcode/#0365-water-and-jug-problem","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs. If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty. Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 Output: true Explanation: The famous Die Hard example */ class Solution { public : bool canMeasureWater ( int jug1Capacity , int jug2Capacity , int targetCapacity ) { int x = jug1Capacity ; int y = jug2Capacity ; int z = targetCapacity ; if ( z > x + y ) { return false ; } if ( z == x || z == y ) { return true ; } if ( x > y ) { swap ( x , y ); } int diff = y % x ; if ( diff == 0 ) { return z % x == 0 ; } for ( int i = 0 ; i < x ; i ++ ) { if ( diff == z || x + diff == z || y + diff == z || y - x + diff == z ) { return true ; } diff = ( y - ( x - diff )) % x ; } return false ; } };","title":"0365. Water and Jug Problem"},{"location":"algo/leetcode/#0367-valid-perfect-square","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: num = 16 Output: true Input: num = 14 Output: false */ class Solution { public : bool isPerfectSquare ( int num ) { long l = 1 , r = num ; while ( l <= r ) { long m = ( l + r ) >> 1 ; long res = m * m ; if ( res == num ) { return true ; } else if ( res < num ) { l = m + 1 ; } else { r = m - 1 ; } } return false ; } };","title":"0367. Valid Perfect Square"},{"location":"algo/leetcode/#0368-largest-divisible-subset","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies: answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them. Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. */ class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { vector < int > ans ; int n = ( int ) nums . size (); if ( n < 2 ) { return nums ; } sort ( nums . begin (), nums . end ()); vector < int > dp ( n , 1 ); vector < int > par ( n , - 1 ); int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( nums [ i ] % nums [ j ] == 0 && dp [ j ] + 1 > dp [ i ]) { dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); par [ i ] = j ; } } len = max ( len , dp [ i ]); } ans . resize ( len ); for ( int i = n - 1 ; i >= 0 ;) { if ( dp [ i ] == len ) { ans [ -- len ] = nums [ i ]; i = par [ i ]; } else { i -- ; } } return ans ; } };","title":"0368. Largest Divisible Subset"},{"location":"algo/leetcode/#0395-longest-substring-with-at-least-k-repeating-characters","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* Input: s = \"ababbc\", k = 2 Output: 5 Explanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times. */ class Solution { public : int longestSubstring ( string s , int k ) { int n = int ( s . length ()), ans = 0 ; for ( int t = 1 ; t <= 26 ; t ++ ) { int l = 0 , r = 0 , tot = 0 , numLessK = 0 ; int * count = new int [ 26 ]{}; while ( r < n ) { count [ s [ r ] - 'a' ] ++ ; if ( count [ s [ r ] - 'a' ] == 1 ) { tot ++ ; numLessK ++ ; } if ( count [ s [ r ] - 'a' ] == k ) { numLessK -- ; } while ( tot > t ) { count [ s [ l ] - 'a' ] -- ; if ( count [ s [ l ] - 'a' ] == k - 1 ) { numLessK ++ ; } if ( count [ s [ l ] - 'a' ] == 0 ) { numLessK -- ; tot -- ; } l ++ ; } if ( numLessK == 0 ) { ans = max ( ans , r - l + 1 ); } r ++ ; } delete [] count ; } return ans ; } };","title":"0395. Longest Substring with At Least K Repeating Characters*"},{"location":"algo/leetcode/#0403","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* \u4e00\u53ea\u9752\u86d9\u60f3\u8981\u8fc7\u6cb3\u3002 \u5047\u5b9a\u6cb3\u6d41\u88ab\u7b49\u5206\u4e3a\u82e5\u5e72\u4e2a\u5355\u5143\u683c\uff0c\u5e76\u4e14\u5728\u6bcf\u4e00\u4e2a\u5355\u5143\u683c\u5185 \u90fd\u6709\u53ef\u80fd\u653e\u6709\u4e00\u5757\u77f3\u5b50\uff08\u4e5f\u6709\u53ef\u80fd\u6ca1\u6709\uff09\u3002 \u9752\u86d9\u53ef\u4ee5\u8df3\u4e0a\u77f3\u5b50\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8df3 \u5165\u6c34\u4e2d\u3002 \u7ed9\u4f60\u77f3\u5b50\u7684\u4f4d\u7f6e\u5217\u8868 stones\uff08\u7528\u5355\u5143\u683c\u5e8f\u53f7 \u5347\u5e8f \u8868\u793a\uff09\uff0c \u8bf7\u5224\u5b9a\u9752\u86d9\u80fd \u5426\u6210\u529f\u8fc7\u6cb3\uff08\u5373\u80fd\u5426\u5728\u6700\u540e\u4e00\u6b65\u8df3\u81f3\u6700\u540e\u4e00\u5757\u77f3\u5b50\u4e0a\uff09\u3002 \u5f00\u59cb\u65f6\uff0c \u9752\u86d9\u9ed8\u8ba4\u5df2\u7ad9\u5728\u7b2c\u4e00\u5757\u77f3\u5b50\u4e0a\uff0c\u5e76\u53ef\u4ee5\u5047\u5b9a\u5b83\u7b2c\u4e00\u6b65\u53ea\u80fd\u8df3\u8dc3\u4e00\u4e2a\u5355 \u4f4d\uff08\u5373\u53ea\u80fd\u4ece\u5355\u5143\u683c 1 \u8df3\u81f3\u5355\u5143\u683c 2 \uff09\u3002 \u5982\u679c\u9752\u86d9\u4e0a\u4e00\u6b65\u8df3\u8dc3\u4e86 k \u4e2a\u5355\u4f4d\uff0c\u90a3\u4e48\u5b83\u63a5\u4e0b\u6765\u7684\u8df3\u8dc3\u8ddd\u79bb\u53ea\u80fd\u9009\u62e9\u4e3a k - 1\u3001 k \u6216 k + 1 \u4e2a\u5355\u4f4d\u3002 \u53e6\u8bf7\u6ce8\u610f\uff0c\u9752\u86d9\u53ea\u80fd\u5411\u524d\u65b9\uff08\u7ec8\u70b9\u7684\u65b9\u5411\uff09\u8df3\u8dc3\u3002 \u8f93\u5165\uff1astones = [0,1,3,5,6,8,12,17] \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a\u9752\u86d9\u53ef\u4ee5\u6210\u529f\u8fc7\u6cb3\uff0c\u6309\u7167\u5982\u4e0b\u65b9\u6848\u8df3\u8dc3\uff1a\u8df3 1 \u4e2a\u5355\u4f4d\u5230\u7b2c 2 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 3 \u5757\u77f3\u5b50, \u63a5\u7740 \u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 4 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 3 \u4e2a\u5355\u4f4d\u5230\u7b2c 6 \u5757\u77f3\u5b50, \u8df3 4 \u4e2a\u5355\u4f4d\u5230\u7b2c 7 \u5757\u77f3\u5b50, \u6700\u540e\uff0c\u8df3 5 \u4e2a\u5355\u4f4d\u5230\u7b2c 8 \u4e2a\u77f3\u5b50\uff08\u5373\u6700\u540e\u4e00\u5757\u77f3\u5b50\uff09\u3002 \u8f93\u5165\uff1astones = [0,1,2,3,4,8,9,11] \u8f93\u51fa\uff1afalse \u89e3\u91ca\uff1a\u8fd9\u662f\u56e0\u4e3a\u7b2c 5 \u548c\u7b2c 6 \u4e2a\u77f3\u5b50\u4e4b\u95f4\u7684\u95f4\u8ddd\u592a\u5927\uff0c\u6ca1\u6709\u53ef\u9009\u7684\u65b9\u6848\u4f9b\u9752\u86d9\u8df3 \u8dc3\u8fc7\u53bb\u3002 */ class Solution { public : bool canCross ( vector < int >& stones ) { unordered_map < int , int > dict ; int n = ( int ) stones . size (); if ( n <= 1 ) { return true ; } vector < vector < int >> dp ( n , vector < int > ( n , 0 )); dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( stones [ i ] - stones [ i - 1 ] > i ) { return false ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { int k = stones [ i ] - stones [ j ]; if ( k > j + 1 ) { break ; } dp [ i ][ k ] = dp [ j ][ k - 1 ] || dp [ j ][ k ] || dp [ j ][ k + 1 ]; if ( i == n - 1 && dp [ i ][ k ]) { return true ; } } } return false ; } };","title":"0403. \u9752\u86d9\u8fc7\u6cb3*"},{"location":"algo/leetcode/#0407-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /* \u7ed9\u4f60\u4e00\u4e2a m x n \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u7684\u503c\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u4e8c\u7ef4\u9ad8\u5ea6\u56fe\u6bcf\u4e2a\u5355 \u5143\u7684\u9ad8\u5ea6\uff0c\u8bf7\u8ba1\u7b97\u56fe\u4e2d\u5f62\u72b6\u6700\u591a\u80fd\u63a5\u591a\u5c11\u4f53\u79ef\u7684\u96e8\u6c34\u3002 \u793a\u4f8b\uff1a \u7ed9\u51fa\u5982\u4e0b 3x6 \u7684\u9ad8\u5ea6\u56fe: [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] \u8fd4\u56de 4 \u3002 */ class Solution { public : int trapRainWater ( vector < vector < int >>& heightMap ) { int nRow = ( int ) heightMap . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) heightMap [ 0 ]. size (); if ( nCol < 3 ) { return 0 ; } typedef pair < int , pair < int , int >> PIII ; priority_queue < PIII , vector < PIII > , greater < PIII >> heap ; bool ** vis = new bool * [ nRow ]; for ( int i = 0 ; i < nRow ; i ++ ) { vis [ i ] = new bool [ nCol ]{}; heap . push ({ heightMap [ i ][ 0 ], { i , 0 }}); heap . push ({ heightMap [ i ][ nCol - 1 ], { i , nCol - 1 }}); vis [ i ][ 0 ] = vis [ i ][ nCol - 1 ] = true ; } for ( int j = 0 ; j < nCol ; j ++ ) { heap . push ({ heightMap [ 0 ][ j ], { 0 , j }}); heap . push ({ heightMap [ nRow - 1 ][ j ], { nRow - 1 , j }}); vis [ 0 ][ j ] = vis [ nRow - 1 ][ j ] = true ; } int dx [ 4 ] = { - 1 , 0 , 1 , 0 }, dy [ 4 ] = { 0 , - 1 , 0 , 1 }; int ans = 0 ; while ( ! heap . empty ()) { auto cur = heap . top (); heap . pop (); int x = cur . second . first , y = cur . second . second ; int h = cur . first ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx >= 0 && xx < nRow && yy >= 0 && yy < nCol && ! vis [ xx ][ yy ]) { vis [ xx ][ yy ] = true ; ans += max ( h - heightMap [ xx ][ yy ], 0 ); heap . push ({ max ( h , heightMap [ xx ][ yy ]), { xx , yy }}); } } } for ( int i = 0 ; i < nRow ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } };","title":"0407. \u63a5\u96e8\u6c34 II*"},{"location":"algo/leetcode/#0470-implement-rand10-using-rand7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: n = 3 Output: [3,8,10] */ // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 class Solution { public : int rand10 () { int ans = 0 , i = 0 , j = 0 ; do { i = rand7 (); j = rand7 (); ans = ( i - 1 ) * 7 + j ; } while ( ans > 40 ); return ans % 10 + 1 ; } };","title":"0470. Implement Rand10() Using Rand7()*"},{"location":"algo/leetcode/#0503-next-greater-element-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. */ class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return vector < int > {}; } vector < int > ans ( n , - 1 ); stack < int > st ; for ( int i = 0 ; i < 2 * n - 1 ; i ++ ) { while ( ! st . empty () && nums [ st . top ()] < nums [ i % n ]) { ans [ st . top ()] = nums [ i % n ]; st . pop (); } st . push ( i % n ); } return ans ; } };","title":"0503. Next Greater Element II*"},{"location":"algo/leetcode/#0516-longest-palindromic-subsequence","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000. Input: \"bbbab\" Output: 4 */ class Solution { public : int longestPalindromeSubseq ( string s ) { int n = int ( s . length ()); if ( n <= 1 ) { return n ; } int ** dp = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new int [ n ]{}; dp [ i ][ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] + 2 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } } } int ans = dp [ 0 ][ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0516. Longest Palindromic Subsequence*"},{"location":"algo/leetcode/#0530-minimum-absolute-difference-in-bst","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 1 \\ 3 / 2 output: 1 */ class Solution { public : int getMinimumDifference ( TreeNode * root ) { TreeNode * last = nullptr ; int ans = INT_MAX ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & diff ) { if ( root != nullptr ) { inOrder ( root -> left , last , diff ); if ( last == nullptr ) { last = root ; } else { diff = min ( diff , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , diff ); } } };","title":"0530. Minimum Absolute Difference in BST"},{"location":"algo/leetcode/#0543-diameter-of-binary-tree","text":"Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. */ class Solution { public : int diameterOfBinaryTree ( TreeNode * root ) { int max = 0 ; getDep ( root , max ); return max ; } int getDep ( TreeNode * root , int & maxLen ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDep ( root -> left , maxLen ); int rightDep = getDep ( root -> right , maxLen ); int curLen = leftDep + rightDep ; maxLen = maxLen > curLen ? maxLen : curLen ; return ( leftDep > rightDep ? leftDep : rightDep ) + 1 ; } };","title":"0543. Diameter of Binary Tree"},{"location":"algo/leetcode/#0554","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u4f60\u7684\u9762\u524d\u6709\u4e00\u5835\u77e9\u5f62\u7684\u3001\u7531 n \u884c\u7816\u5757\u7ec4\u6210\u7684\u7816\u5899\u3002\u8fd9\u4e9b\u7816\u5757\u9ad8\u5ea6\u76f8\u540c\uff08\u4e5f\u5c31\u662f\u4e00\u4e2a\u5355\u4f4d\u9ad8\uff09 \u4f46\u662f\u5bbd\u5ea6\u4e0d\u540c\u3002\u6bcf\u4e00\u884c\u7816\u5757\u7684\u5bbd\u5ea6\u4e4b\u548c\u5e94\u8be5\u76f8\u7b49\u3002 \u4f60\u73b0\u5728\u8981\u753b\u4e00\u6761 \u81ea\u9876\u5411\u4e0b \u7684\u3001\u7a7f\u8fc7 \u6700\u5c11 \u7816\u5757\u7684\u5782\u7ebf\u3002\u5982\u679c\u4f60\u753b\u7684\u7ebf\u53ea\u662f\u4ece\u7816\u5757\u7684\u8fb9\u7f18\u7ecf\u8fc7\uff0c \u5c31\u4e0d\u7b97\u7a7f\u8fc7\u8fd9\u5757\u7816\u3002\u4f60\u4e0d\u80fd\u6cbf\u7740\u5899\u7684\u4e24\u4e2a\u5782\u76f4\u8fb9\u7f18\u4e4b\u4e00\u753b\u7ebf\uff0c\u8fd9\u6837\u663e\u7136\u662f\u6ca1\u6709\u7a7f\u8fc7\u4e00\u5757\u7816\u7684\u3002 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 wall \uff0c\u8be5\u6570\u7ec4\u5305\u542b\u8fd9\u5835\u5899\u7684\u76f8\u5173\u4fe1\u606f\u3002\u5176\u4e2d\uff0cwall[i] \u662f\u4e00\u4e2a\u4ee3\u8868\u4ece\u5de6 \u81f3\u53f3\u6bcf\u5757\u7816\u7684\u5bbd\u5ea6\u7684\u6570\u7ec4\u3002\u4f60\u9700\u8981\u627e\u51fa\u600e\u6837\u753b\u624d\u80fd\u4f7f\u8fd9\u6761\u7ebf \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf\u6700\u5c11 \uff0c\u5e76\u4e14\u8fd4\u56de \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf \u3002 \u8f93\u5165\uff1awall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] \u8f93\u51fa\uff1a2 \u8f93\u5165\uff1awall = [[1],[1],[1]] \u8f93\u51fa\uff1a3 */ class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int n = ( int ) wall . size (); if ( n == 0 ) { return 0 ; } int ans = 0 ; unordered_map < int , int > cnt ; for ( auto arr : wall ) { int len = ( int ) arr . size (); int sum = 0 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { sum += arr [ i ]; cnt [ sum ] ++ ; } } unordered_map < int , int >:: iterator iter ; for ( iter = cnt . begin (); iter != cnt . end (); iter ++ ) { ans = max ( ans , iter -> second ); } return n - ans ; } };","title":"0554. \u7816\u5899*"},{"location":"algo/leetcode/#0633","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 c \uff0c\u4f60\u8981\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6574\u6570 a \u548c b\uff0c\u4f7f\u5f97 a^2 + b^2 = c \u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ac = 5 \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a1 * 1 + 2 * 2 = 5 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ac = 3 \u8f93\u51fa\uff1afalse \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ac = 4 \u8f93\u51fa\uff1atrue \u793a\u4f8b 4\uff1a \u8f93\u5165\uff1ac = 2 \u8f93\u51fa\uff1atrue \u793a\u4f8b 5\uff1a \u8f93\u5165\uff1ac = 1 \u8f93\u51fa\uff1atrue */ class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 , r = ( long ) sqrt ( c ); while ( l <= r ) { long sqaureSum = l * l + r * r ; if ( sqaureSum == c ) { return true ; } else if ( sqaureSum < c ) { l ++ ; } else { r -- ; } } return false ; } };","title":"0633. \u5e73\u65b9\u6570\u4e4b\u548c*"},{"location":"algo/leetcode/#0647-palindromic-substrings","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". */ class Solution { public : int countSubstrings ( string s ) { int n = int ( s . length ()), ans = n ; if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i - 1 ] == s [ i ]) { dp [ i - 1 ][ i ] = true ; ans ++ ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; ans ++ ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0647. Palindromic Substrings"},{"location":"algo/leetcode/#0690","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* \u7ed9\u5b9a\u4e00\u4e2a\u4fdd\u5b58\u5458\u5de5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u5305\u542b\u4e86\u5458\u5de5 \u552f\u4e00\u7684 id \uff0c\u91cd\u8981\u5ea6\u548c\u76f4\u7cfb\u4e0b\u5c5e\u7684 id \u3002 \u6bd4\u5982\uff0c\u5458\u5de5 1 \u662f\u5458\u5de5 2 \u7684\u9886\u5bfc\uff0c\u5458\u5de5 2 \u662f\u5458\u5de5 3 \u7684\u9886\u5bfc\u3002\u4ed6\u4eec\u76f8\u5e94\u7684\u91cd\u8981\u5ea6\u4e3a 15 , 10 , 5 \u3002 \u90a3\u4e48\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u662f [1, 15, [2]] \uff0c\u5458\u5de5 2\u7684 \u6570\u636e\u7ed3\u6784\u662f [2, 10, [3]] \uff0c\u5458\u5de53 \u7684\u6570\u636e\u7ed3\u6784\u662f [3, 5, []] \u3002\u6ce8\u610f\u867d\u7136\u5458\u5de5 3 \u4e5f\u662f\u5458\u5de5 1 \u7684\u4e00\u4e2a\u4e0b\u5c5e\uff0c\u4f46\u662f\u7531\u4e8e \u5e76\u4e0d\u662f\u76f4\u7cfb \u4e0b\u5c5e\uff0c\u56e0\u6b64\u6ca1\u6709\u4f53\u73b0\u5728\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 \u73b0\u5728\u8f93\u5165\u4e00\u4e2a\u516c\u53f8\u7684\u6240\u6709\u5458\u5de5\u4fe1\u606f\uff0c\u4ee5\u53ca\u5355\u4e2a\u5458\u5de5 id \uff0c\u8fd4\u56de\u8fd9\u4e2a\u5458\u5de5\u548c\u4ed6\u6240\u6709\u4e0b\u5c5e\u7684\u91cd\u8981\u5ea6\u4e4b\u548c\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 \u8f93\u51fa\uff1a11 \u89e3\u91ca\uff1a \u5458\u5de5 1 \u81ea\u8eab\u7684\u91cd\u8981\u5ea6\u662f 5 \uff0c\u4ed6\u6709\u4e24\u4e2a\u76f4\u7cfb\u4e0b\u5c5e 2 \u548c 3 \uff0c\u800c\u4e14 2 \u548c 3 \u7684\u91cd\u8981\u5ea6\u5747\u4e3a 3 \u3002 \u56e0\u6b64\u5458\u5de5 1 \u7684\u603b\u91cd\u8981\u5ea6\u662f 5 + 3 + 3 = 11 \u3002 */ /* // Definition for Employee. class Employee { public: int id; int importance; vector< int> subordinates; }; */ class Solution { public : int dfs ( unordered_set < int > & vis , unordered_map < int , int > & dict , unordered_map < int , vector < int >> & next , int id ) { int ans = 0 ; for ( int sub : next [ id ]) { if ( vis . find ( sub ) == vis . end ()) { vis . insert ( sub ); ans += dfs ( vis , dict , next , sub ); } } return ans + dict [ id ]; } int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , int > dict ; unordered_map < int , vector < int >> next ; unordered_set < int > vis ; for ( auto employee : employees ) { dict [ employee -> id ] = employee -> importance ; next [ employee -> id ] = employee -> subordinates ; } return dfs ( vis , dict , next , id ); } };","title":"0690. \u5458\u5de5\u7684\u91cd\u8981\u6027"},{"location":"algo/leetcode/#0704-binary-search","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 */ class Solution { public : int search ( vector < int >& nums , int target ) { int n = ( int ) nums . size (); if ( n == 0 ) { return - 1 ; } int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return m ; } else if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m - 1 ; } } return - 1 ; } };","title":"0704. Binary Search"},{"location":"algo/leetcode/#0738-monotone-increasing-digits","text":"Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits. (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: N = 10 Output: 9 Input: N = 1234 Output: 1234 Input: N = 332 Output: 299 */ class Solution { public : int monotoneIncreasingDigits ( int N ) { int ans = 0 ; string str = to_string ( N ); int len = int ( str . length ()), idx = - 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] < str [ i - 1 ]) { idx = i ; break ; } } if ( idx == - 1 ) { return N ; } int pos = idx - 1 ; while ( pos >= 1 && str [ pos ] == str [ pos - 1 ]) { pos -- ; } str [ pos ] -- ; // current position decrease by 1 for ( int i = pos + 1 ; i < len ; i ++ ) { str [ i ] = '9' ; } for ( int i = len - 1 , pow = 1 ; i >= 0 ; i -- , pow *= 10 ) { ans += ( str [ i ] - '0' ) * pow ; } return ans ; } };","title":"0738. Monotone Increasing Digits*"},{"location":"algo/leetcode/#0741-cherry-pickup","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect by following the rules below: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells. When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0. If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected. Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]] Output: 5 Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible. Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 */ class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { int n = int ( grid . size ()); if ( n == 0 ) { return 0 ; } vector < vector < vector < int >>> dp ( n , vector < vector < int >> ( n , vector < int > ( n , - 1 ))); int ans = move ( dp , grid , 0 , 0 , 0 , n ); return max ( 0 , ans ); } int move ( vector < vector < vector < int >>> & dp , vector < vector < int >> & grid , int r1 , int c1 , int c2 , int n ) { int r2 = r1 + c1 - c2 ; if ( r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid [ r1 ][ c1 ] == - 1 || grid [ r2 ][ c2 ] == - 1 ) { return - 2 ; } if ( r1 == n - 1 && c1 == n - 1 ) { return grid [ r1 ][ c1 ]; } if ( dp [ r1 ][ c1 ][ c2 ] != - 1 ) { return dp [ r1 ][ c1 ][ c2 ]; } int ans = move ( dp , grid , r1 , c1 + 1 , c2 + 1 , n ); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 + 1 , n )); ans = max ( ans , move ( dp , grid , r1 , c1 + 1 , c2 , n )); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 , n )); if ( ans >= 0 ) { ans += grid [ r1 ][ c1 ] + ( c1 != c2 || r1 != r2 ) * grid [ r2 ][ c2 ]; } dp [ r1 ][ c1 ][ c2 ] = ans ; return ans ; } };","title":"0741. Cherry Pickup*"},{"location":"algo/leetcode/#0752-open-the-lock","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\" Output: 6 Explanation: A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\". Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \"0102\". */ class Solution { public : int openLock ( vector < string >& deadends , string target ) { string init = \"0000\" ; int n = int ( init . length ()), ans = 0 ; unordered_set < string > vis ; for ( string & str : deadends ) { vis . insert ( str ); } if ( vis . find ( init ) != vis . end ()) { return - 1 ; } queue < string > qLock ; qLock . push ( init ); while ( ! qLock . empty ()) { int num = int ( qLock . size ()); while ( num -- ) { string str = qLock . front (); qLock . pop (); if ( str == target ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { string tmp = str ; for ( int d = - 1 ; d <= 1 ; d += 2 ) { tmp [ i ] = ( str [ i ] - '0' + 10 + d ) % 10 + '0' ; if ( vis . find ( tmp ) == vis . end ()) { vis . insert ( tmp ); qLock . push ( tmp ); } } } } ans ++ ; } return - 1 ; } };","title":"0752. Open the Lock*"},{"location":"algo/leetcode/#0766-toeplitz-matrix","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 1 2 3 4 5 1 2 3 9 5 1 2 */ class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { int m = int ( matrix . size ()); if ( m == 0 ) { return false ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return false ; } for ( int j = 0 ; j < n ; j ++ ) { int first = matrix [ 0 ][ j ]; for ( int i = 0 ; i < min ( m , n - j ); i ++ ) { if ( first != matrix [ i ][ i + j ]) { return false ; } } } for ( int i = 1 ; i < m ; i ++ ) { int first = matrix [ i ][ 0 ]; for ( int j = 0 ; j < min ( n , m - i ); j ++ ) { if ( first != matrix [ i + j ][ j ]) { return false ; } } } return true ; } };","title":"0766. Toeplitz Matrix"},{"location":"algo/leetcode/#0769-max-chunks-to-make-sorted","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. */ class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 1 , n = ( int ) arr . size (); if ( n <= 1 ) { return ans ; } vector < int > rightMin ( n , 0 ); rightMin [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; i -- ) { rightMin [ i ] = min ( rightMin [ i + 1 ], arr [ i ]); } int leftMax = arr [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( leftMax <= rightMin [ i ]) { ans ++ ; } leftMax = max ( leftMax , arr [ i ]); } return ans ; } };","title":"0769. Max Chunks To Make Sorted*"},{"location":"algo/leetcode/#0781-rabbits-in-forest","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered \"1\" could both be the same color, say red. The rabbit than answered \"2\" can't be red or the answers would be inconsistent. Say the rabbit that answered \"2\" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't. Input: answers = [10, 10, 10] Output: 11 Input: answers = [] Output: 0 */ class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; unordered_map < int , int > dict ; for ( int & ele : answers ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { if ( iter -> first == 0 ) { ans += iter -> second ; } else { if ( iter -> first + 1 >= iter -> second ) { ans += iter -> first + 1 ; } else { if ( iter -> second % ( iter -> first + 1 ) == 0 ) { ans += iter -> second ; } else { ans += ( iter -> second / ( iter -> first + 1 ) + 1 ) * ( iter -> first + 1 ); } } } } return ans ; } };","title":"0781. Rabbits in Forest"},{"location":"algo/leetcode/#0783-minimum-distance-between-bst-nodes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 4 / \\ 2 6 / \\ 1 5 output: 1 */ class Solution { public : int minDiffInBST ( TreeNode * root ) { int ans = INT_MAX ; TreeNode * last = nullptr ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & ans ) { if ( root != nullptr ) { inOrder ( root -> left , last , ans ); if ( last == nullptr ) { last = root ; } else { ans = min ( ans , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , ans ); } } };","title":"0783. Minimum Distance Between BST Nodes"},{"location":"algo/leetcode/#0832-flipping-an-image","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] */ class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { int m = int ( A . size ()), n = int ( A [ 0 ]. size ()); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { swap ( A [ i ][ j ], A [ i ][ n - 1 - j ]); } for ( int j = 0 ; j < n ; j ++ ) { A [ i ][ j ] = 1 - A [ i ][ j ]; } } return A ; } };","title":"0832. Flipping an Image"},{"location":"algo/leetcode/#0845-longest-mountain-in-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5. */ class Solution { public : int longestMountain ( vector < int >& arr ) { int ans = 0 , n = int ( arr . size ()); if ( n < 3 ) { return 0 ; } vector < int > left ( n , 0 ), right ( n , 0 ); for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ]) { left [ i ] = left [ i - 1 ] + 1 ; } if ( arr [ n - 1 - i ] > arr [ n - i ]) { right [ n - 1 - i ] = right [ n - i ] + 1 ; } } if ( arr [ n - 1 ] > arr [ n - 2 ]) { left [ n - 1 ] = left [ n - 2 ] + 1 ; } if ( arr [ 0 ] > arr [ 1 ]) { right [ 0 ] = right [ 1 ] + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( left [ i ] && right [ i ]) { ans = max ( left [ i ] + right [ i ] + 1 , ans ); } } return ans ; } };","title":"0845. Longest Mountain in Array*"},{"location":"algo/leetcode/#0897-increasing-order-search-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 5 1 / \\ \\ 1 7 5 \\ 7 */ class Solution { public : TreeNode * increasingBST ( TreeNode * root ) { TreeNode * last = nullptr ; TreeNode * head = nullptr ; inOrder ( root , last , head ); return head ; } void inOrder ( TreeNode * root , TreeNode *& last , TreeNode *& head ) { if ( root != nullptr ) { inOrder ( root -> left , last , head ); if ( last != nullptr ) { last -> right = root ; last -> left = nullptr ; root -> left = nullptr ; } else { head = root ; } last = root ; inOrder ( root -> right , last , head ); } } };","title":"0897. Increasing Order Search Tree*"},{"location":"algo/leetcode/#0921-minimum-add-to-make-parentheses-valid","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: \"()))((\" Output: 4 */ class Solution { public : int minAddToMakeValid ( string S ) { int left = 0 , ans = 0 ; for ( const char & c : S ) { if ( c == '(' ) { left ++ ; } else { if ( left > 0 ) { left -- ; } else { ans ++ ; } } } return ans + left ; } };","title":"0921. Minimum Add to Make Parentheses Valid*"},{"location":"algo/leetcode/#0938","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 10 / \\ 5 15 / \\ \\ 3 7 18 \u8f93\u5165\uff1aroot = [10,5,15,3,7,null,18], low = 7, high = 15 \u8f93\u51fa\uff1a32 */ class Solution { public : int rangeSumBST ( TreeNode * root , int low , int high ) { if ( root == nullptr ) { return 0 ; } int left = rangeSumBST ( root -> left , low , high ); int val = 0 ; if ( root -> val >= low && root -> val <= high ) { val = root -> val ; } int right = rangeSumBST ( root -> right , low , high ); return left + val + right ; } };","title":"0938. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u8303\u56f4\u548c"},{"location":"algo/leetcode/#1006-clumsy-factorial","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 */ class Solution { public : int clumsy ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 ) { return 2 ; } else if ( N == 3 ) { return 6 ; } else if ( N == 4 ) { return 7 ; } else { if ( N % 4 == 0 ) { return N + 1 ; } else if ( N % 4 == 1 ) { return N + 2 ; } else if ( N % 4 == 2 ) { return N + 2 ; } else { return N - 1 ; } } } };","title":"1006. Clumsy Factorial*"},{"location":"algo/leetcode/#1047-remove-all-adjacent-duplicates-in-string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". */ class Solution { public : string removeDuplicates ( string S ) { int n = int ( S . length ()); if ( n <= 1 ) { return S ; } string ans = \"\" ; for ( const char & c : S ) { if ( ! ans . empty () && ans . back () == c ) { ans . pop_back (); } else { ans . push_back ( c ); } } return ans ; } };","title":"1047. Remove All Adjacent Duplicates In String"},{"location":"algo/leetcode/#1052-grumpy-bookstore-owner","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16. */ class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int ans = 0 , n = int ( customers . size ()); if ( n == 0 ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { if ( grumpy [ i ] == 0 ) { ans += customers [ i ]; } } int add = 0 , maxAdd = 0 ; for ( int i = 0 ; i < X ; i ++ ) { ans += customers [ i ] * grumpy [ i ]; } for ( int i = 1 ; i < n - X + 1 ; i ++ ) { add += - customers [ i - 1 ] * grumpy [ i - 1 ] + customers [ i + X - 1 ] * grumpy [ i + X - 1 ]; if ( maxAdd < add ) { maxAdd = add ; } } return ans + maxAdd ; } };","title":"1052. Grumpy Bookstore Owner"},{"location":"algo/leetcode/#1178-number-of-valid-words-for-each-puzzle","text":"With respect to a given puzzle string, a word is valid if both the following conditions are satisfied: word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\"; while invalid words are \"beefed\" (doesn't include \"a\") and \"based\" (includes \"s\" which isn't in the puzzle). Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"] Output: [1,1,3,2,4,0] Explanation: 1 valid word for \"aboveyz\" : \"aaaa\" 1 valid word for \"abrodyz\" : \"aaaa\" 3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\" 2 valid words for \"absoryz\" : \"aaaa\", \"asas\" 4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\" There're no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'. */ class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { int n = int ( puzzles . size ()); unordered_map < int , int > dict ; for ( const string & word : words ) { int mask = 0 ; for ( const char & c : word ) { mask |= ( 1 << ( c - 'a' )); } if ( __builtin_popcount ( mask ) <= 7 ) { dict [ mask ] ++ ; } } vector < int > ans ; for ( const string & puzzle : puzzles ) { int tot = 0 ; for ( int choose = 0 ; choose < ( 1 << 6 ); choose ++ ) { int mask = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( choose & ( 1 << i )) { mask |= ( 1 << ( puzzle [ i + 1 ] - 'a' )); } } mask |= ( 1 << ( puzzle [ 0 ] - 'a' )); tot += dict [ mask ]; } ans . emplace_back ( tot ); } return ans ; } };","title":"1178. Number of Valid Words for Each Puzzle*"},{"location":"algo/leetcode/#1411-number-of-ways-to-paint-n-3-grid","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. */ class Solution { public : int numOfWays ( int n ) { int aba = 6 , abc = 6 ; /* aba = aba * 3 + abc * 2 abc = aba * 2 + abc * 2; */ const int MOD = 1000000007 ; for ( int i = 1 ; i < n ; i ++ ) { int new_aba = ( aba * 3ll + abc * 2ll ) % MOD ; int new_abc = ( aba * 2ll + abc * 2ll ) % MOD ; aba = new_aba ; abc = new_abc ; } return ( aba + abc ) % MOD ; } };","title":"1411. Number of Ways to Paint N \u00d7 3 Grid"},{"location":"algo/leetcode/#1553-n","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* \u53a8\u623f\u91cc\u603b\u5171\u6709 n \u4e2a\u6a58\u5b50\uff0c\u4f60\u51b3\u5b9a\u6bcf\u4e00\u5929\u9009\u62e9\u5982\u4e0b\u65b9\u5f0f\u4e4b\u4e00\u5403\u8fd9\u4e9b\u6a58\u5b50\uff1a \u5403\u6389\u4e00\u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 2 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 n/2 \u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 3 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 2*(n/3) \u4e2a\u6a58\u5b50\u3002 \u6bcf\u5929\u4f60\u53ea\u80fd\u4ece\u4ee5\u4e0a 3 \u79cd\u65b9\u6848\u4e2d\u9009\u62e9\u4e00\u79cd\u65b9\u6848\u3002 \u8bf7\u4f60\u8fd4\u56de\u5403\u6389\u6240\u6709 n \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1an = 10 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u4f60\u603b\u5171\u6709 10 \u4e2a\u6a58\u5b50\u3002 \u7b2c 1 \u5929\uff1a\u5403 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 10 - 1 = 9\u3002 \u7b2c 2 \u5929\uff1a\u5403 6 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 9 - 2*(9/3) = 9 - 6 = 3\u3002\uff089 \u53ef\u4ee5\u88ab 3 \u6574\u9664\uff09 \u7b2c 3 \u5929\uff1a\u5403 2 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 3 - 2*(3/3) = 3 - 2 = 1\u3002 \u7b2c 4 \u5929\uff1a\u5403\u6389\u6700\u540e 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 1 - 1 = 0\u3002 \u4f60\u9700\u8981\u81f3\u5c11 4 \u5929\u5403\u6389 10 \u4e2a\u6a58\u5b50\u3002 */ class Solution { public : unordered_map < int , int > dict ; int minDays ( int n ) { if ( n <= 1 ) { return 1 ; } if ( dict . find ( n ) != dict . end ()) { return dict [ n ]; } else { return dict [ n ] = min ( n % 2 + 1 + minDays ( n / 2 ), n % 3 + 1 + minDays ( n / 3 )); } } };","title":"1553. \u5403\u6389 N \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570*"},{"location":"algo/leetcode/#1585-check-if-string-is-transformable-with-substring-sort-operations","text":"Given two strings s and t, you want to transform string s into string t using the following operation any number of times: Choose a non-empty substring in s and sort it in-place so the characters are in ascending order. For example, applying the operation on the underlined substring in \"14234\" results in \"12344\". Return true if it is possible to transform string s into string t. Otherwise, return false. A substring is a contiguous sequence of characters within a string. Example: Input: s = \"84532\", t = \"34852\" Output: true Explanation: You can transform s into t using the following sort operations: \"84532\" (from index 2 to 3) -> \"84352\" \"84352\" (from index 0 to 2) -> \"34852\" Input: s = \"34521\", t = \"23415\" Output: true Explanation: You can transform s into t using the following sort operations: \"34521\" -> \"23451\" \"23451\" -> \"23415\" Input: s = \"12345\", t = \"12435\" Output: false Input: s = \"1\", t = \"2\" Output: false Constraints: s.length == t.length 1 <= s.length <= 105 s and t only contain digits from '0' to '9'. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isTransformable ( string s , string t ) { vector < vector < int >> idx ( 10 ); vector < int > count ( 10 ); for ( int i = 0 ; i < int ( s . length ()); i ++ ) { idx [ s [ i ] - '0' ]. push_back ( i ); } for ( int i = 0 ; i < int ( t . length ()); i ++ ) { int digit = t [ i ] - '0' ; if ( count [ digit ] == idx [ digit ]. size ()) { return false ; } for ( int j = 0 ; j < digit ; j ++ ) { if ( count [ j ] != idx [ j ]. size () && idx [ j ][ count [ j ]] < idx [ digit ][ count [ digit ]]) { return false ; } } count [ digit ] ++ ; } return true ; } };","title":"1585. Check If String Is Transformable With Substring Sort Operations*"},{"location":"algo/math/","text":"\u6700\u5927\u516c\u7ea6\u6570 & \u6700\u5c0f\u516c\u500d\u6570 \u00b6 \u4e24\u6570\u6700\u5927\u516c\u7ea6\u6570 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Brutal force: enumerate all numbers from 1 to min(a, b), save the greatest. */ int GCD_enumerate ( int a , int b ) { int c = ( a < b ? a : b ); int gcd = 1 ; for ( int i = 1 ; i <= c ; i ++ ) { if ( a % i == 0 && b % i == 0 ) { gcd = i ; } } return gcd ; } int GCD_Euclidean_Algorithm_divide ( int a , int b ) { while ( a * b ) { if ( a < b ) { b %= a ; } else { a %= b ; } } return ( a > b ? a : b ); } int GCD_Euclidean_Algorithm_subtract ( int a , int b ) { while ( a * b ) { if ( a < b ) { b -= a ; } else { a -= b ; } } return ( a > b ? a : b ); } \u6570\u7ec4\u7684\u6700\u5927\u516c\u7ea6\u6570 \u00b6 1 2 3 4 5 6 7 8 9 int GCD_Array ( vector < int > arr ) { int n = int ( arr . size ()); if ( n == 1 ) { return arr [ 0 ]; } int gcd = GCD_Euclidean_Algorithm_divide ( arr [ 0 ], arr [ 1 ]); for ( int i = 2 ; i < n ; i ++ ) { gcd = GCD_Euclidean_Algorithm_divide ( gcd , arr [ i ]); } return gcd ; } \u6700\u5c0f\u516c\u500d\u6570 \u00b6 \\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} \\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} 1 2 3 4 int LCM ( int a , int b ) { int gcd = GCD_Euclidean_Algorithm_divide ( a , b ); return ( a * b ) / gcd ; } \u88f4\u8700\u5b9a\u7406 \u00b6 \u4e24\u4e2a\u6574\u6570a\u3001b\uff0c\u8bbe d \u662f\u5b83\u4eec\u7684\u6700\u5927\u516c\u7ea6\u6570\uff0c\u90a3\u4e48 ax + by = m \u6709\u6574\u6570\u89e3\uff08x\uff0cy\uff09\u7684\u5145\u8981\u6761\u4ef6\u662f m \u662f d \u7684\u6574\u6570\u500d\u3002\u5f53 m = 1\u65f6\uff0ca \u4e0e b \u4e92\u8d28\u3002 \u63a8\u5e7f\u5230\u4e00\u7ec4\u6574\u6570 \\{a_{1}, a_{2}, \\cdots, a_{n}\\} \\{a_{1}, a_{2}, \\cdots, a_{n}\\} \uff0cd \u662f\u5b83\u4eec\u7684\u6700\u5927\u516c\u7ea6\u6570\uff0c\u65b9\u7a0b \\sum_{i = 1}^{n} a_{i} x_{i} = m \\sum_{i = 1}^{n} a_{i} x_{i} = m \u6709\u6574\u6570\u89e3 (x_{1}, x_{2}, \\cdots, x_{n}) (x_{1}, x_{2}, \\cdots, x_{n}) \u7684\u5145\u8981\u6761\u4ef6\u662f m \u662f d \u7684\u6574\u6570\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int get_gcd ( int x , int y ) { while ( x != 0 && y != 0 ) { if ( abs ( x ) > abs ( y )) { x = x % y ; } else { y = y % x ; } } return x + y ; } bool isGoodArray ( vector < int >& nums ) { if ( nums . empty ()) { return false ; } int gcd = nums [ 0 ]; for ( int num : nums ) { gcd = get_gcd ( gcd , num ); } return gcd == 1 ; } \u6c34\u58f6\u95ee\u9898 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6c34\u58f6\uff0c\u5bb9\u91cf\u662f a \u548c b\uff0c\u73b0\u6709\u4e0d\u9650\u4f9b\u5e94\u7684\u6c34\uff0c\u8bf7\u95ee\u80fd\u5426\u7528\u8fd9\u4e24\u4e2a\u6c34\u58f6\u91cf\u51fa\u6070\u597d\u5bb9\u91cf\u4e3a c \u7684\u6c34\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool canMeasureWater ( int jug1Capacity , int jug2Capacity , int targetCapacity ) { if ( jug1Capacity + jug2Capacity < targetCapacity ) { return false ; } while ( jug1Capacity != 0 && jug2Capacity != 0 ) { if ( jug1Capacity > jug2Capacity ) { jug1Capacity %= jug2Capacity ; } else { jug2Capacity %= jug1Capacity ; } } return targetCapacity % ( jug1Capacity + jug2Capacity ) == 0 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log \\max(jug1Capacity, jug2Capacity)) O(\\log \\max(jug1Capacity, jug2Capacity)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4f4d\u8fd0\u7b97 \u00b6 \u539f\u7801 \u53cd\u7801 \u8865\u7801 \u00b6 \u300c\u539f\u7801\u300d \u7b2c\u4e00\u4f4d\u662f\u7b26\u53f7\u4f4d\uff0c\u5176\u4f59\u8868\u793a\u503c \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} 8 \u4f4d\u4e8c\u8fdb\u5236\u539f\u7801\u7684\u53ef\u4ee5\u8868\u793a\u7684\u8303\u56f4\u662f [1111 111, 0111 111] \u5373 [-127, 127] \u300c\u53cd\u7801\u300d \u6b63\u6570\u7684\u53cd\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u53cd\u7801\u662f\u7b26\u53f7\u4f4d\u4e0d\u53d8\uff0c\u5176\u4f59\u4f4d\u7f6e\u9010\u4e2a\u53d6\u53cd\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \u300c\u8865\u7801\u300d \u6b63\u6570\u7684\u8865\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u8865\u7801\u5728\u5176\u53cd\u7801\u7684\u6700\u540e\u4e00\u4f4d\u52a0 1\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \u300c\u5f15\u5165\u53cd\u7801\u7684\u539f\u56e0\u300d \u8ba1\u7b97\u673a\u4e8c\u8fdb\u5236\u8fd0\u7b97\u505a\u52a0\u51cf\u4e58\u9664\u8ba1\u7b97\u65f6\uff0c\u5e0c\u671b\u5176\u8bbe\u8ba1\u6a21\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u4f46\u662f\u5bf9\u4e8e\u8d1f\u6570\u800c\u8a00\uff0c\u539f\u7801\u5b58\u5728\u7b26\u53f7\u4f4d\uff0c\u5982\u679c\u53c2\u4e0e\u4e8c\u8fdb\u5236\u8ba1\u7b97\u7684\u8bdd\uff0c\u5bb9\u6613\u51fa\u73b0\u9519\u8bef\u7b54\u6848\u3002 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \u6240\u4ee5\u9700\u8981\u5f15\u5165\u53cd\u7801 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \u4e3a\u4e86\u89e3\u51b3 -0 \u95ee\u9898\uff0c\u8865\u7801\u5e94\u8fd0\u800c\u751f \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \u6b64\u5916[1000 0000]\u8868\u793a -128 \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \u56e0\u6b64 8 \u4f4d\u4e8c\u8fdb\u5236\u53ef\u4ee5\u8868\u793a\u7684\u6570\u5b57\u8303\u56f4\u662f [-128, 127]\u3002 XOR \u00b6 \u6309\u4f4d\u5f02\u6216 (XOR) \u5bf9\u4e8e\u4e8c\u8fdb\u5236\u7684\u4e24\u4e2a\u6570a\uff0c b\u5728\u76f8\u540c\u4f4d\u7f6e\u4e0a\u7684\u505a\u4f4d\u8fd0\u7b97\uff1a\u540c\u4e3a 1 \u6216\u8005\u540c\u4e3a 0 \u5219\u4e3a 0\uff1b \u53cd\u4e4b\u4e3a 1\u3002 \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \u4e24\u4e2a\u6027\u8d28 \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \u300c\u9898\u76ee\u300d \u300cLeetcode 1734. \u89e3\u7801\u5f02\u6216\u540e\u7684\u6392\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 perm \uff0c\u5b83\u662f\u524d n \u4e2a\u6b63\u6574\u6570\u7684\u6392\u5217\uff0c\u4e14 n \u662f\u4e2a \u5947\u6570 \u3002 \u5b83\u88ab\u52a0\u5bc6\u6210\u53e6\u4e00\u4e2a\u957f\u5ea6\u4e3a n - 1 \u7684\u6574\u6570\u6570\u7ec4 encoded \uff0c\u6ee1\u8db3 encoded[i] = perm[i] XOR perm[i + 1] \u3002\u6bd4\u65b9\u8bf4\uff0c\u5982\u679c perm = [1,3,2] \uff0c \u90a3\u4e48 encoded = [2,1] \u3002 \u7ed9\u4f60 encoded \u6570\u7ec4\uff0c\u8bf7\u4f60\u8fd4\u56de\u539f\u59cb\u6570\u7ec4 perm \u3002\u9898\u76ee\u4fdd\u8bc1\u7b54\u6848\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aencoded = [3,1] \u8f93\u51fa\uff1a[1,2,3] \u89e3\u91ca\uff1a\u5982\u679c perm = [1,2,3] \uff0c\u90a3\u4e48 encoded = [1 XOR 2,2 XOR 3] = [3,1] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aencoded = [6,5,4,6] \u8f93\u51fa\uff1a[2,4,1,5,3] */ /* perm\u5305\u542b\u4e861-n+1\u7684\u6240\u6709\u6570\u5b57\uff0cn\u4e3aencoded\u7684\u957f\u5ea6 total = perm[0] ^ ... ^ perm[n-1] perm[0] ^ perm[1] = encoded[0] perm[1] ^ perm[2] = encoded[1] perm[2] ^ perm[3] = encoded[2] perm[3] ^ perm[4] = encoded[3] \u6240\u4ee5\uff0cencoded\u6570\u7ec4\u4e2d\u5947\u6570\u4f4d\u7f6e\u7684\u5143\u7d20XOR\uff0c\u5bf9\u5e94\u4e86perm1-n\u7684XOR\uff0c \u7531\u6b64\uff0c\u53ef\u4ee5\u6c42\u5f97perm[0]\u7684\u5927\u5c0f */ vector < int > decode ( vector < int >& encoded ) { int n = ( int ) encoded . size (); vector < int > perm ; int total = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { total ^= i ; } int odd = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { odd ^= encoded [ i ]; } perm . emplace_back ( total ^ odd ); for ( int i = 0 ; i < n ; i ++ ) { perm . emplace_back ( perm . back () ^ encoded [ i ]); } return perm ; } \u300cLeetcode 810. \u9ed1\u677f\u5f02\u6216\u6e38\u620f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* \u9ed1\u677f\u4e0a\u5199\u7740\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums[i] \u3002Alice \u548c Bob \u8f6e\u6d41\u4ece\u9ed1\u677f\u4e0a\u64e6\u6389\u4e00\u4e2a\u6570\u5b57\uff0cAlice \u5148\u624b\u3002 \u5982\u679c\u64e6\u9664\u4e00\u4e2a\u6570\u5b57\u540e\uff0c\u5269\u4f59\u7684\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u51fa\u7684\u7ed3\u679c\u7b49\u4e8e 0 \u7684\u8bdd\uff0c\u5f53\u524d\u73a9\u5bb6\u6e38\u620f\u5931\u8d25\u3002 (\u53e6\u5916\uff0c\u5982\u679c\u53ea\u5269\u4e00\u4e2a\u6570\u5b57\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u5230\u5b83\u672c\u8eab\uff1b\u5982\u679c\u65e0\u6570\u5b57\u5269\u4f59\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u4e3a 0\u3002\uff09 \u6362\u79cd\u8bf4\u6cd5\u5c31\u662f\uff0c\u8f6e\u5230\u67d0\u4e2a\u73a9\u5bb6\u65f6\uff0c\u5982\u679c\u5f53\u524d\u9ed1\u677f\u4e0a\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u7b49\u4e8e 0\uff0c\u8fd9\u4e2a\u73a9\u5bb6\u83b7\u80dc\u3002 \u5047\u8bbe\u4e24\u4e2a\u73a9\u5bb6\u6bcf\u6b65\u90fd\u4f7f\u7528\u6700\u4f18\u89e3\uff0c\u5f53\u4e14\u4ec5\u5f53 Alice \u83b7\u80dc\u65f6\u8fd4\u56de true\u3002 \u793a\u4f8b\uff1a \u8f93\u5165: nums = [1, 1, 2] \u8f93\u51fa: false \u89e3\u91ca: Alice \u6709\u4e24\u4e2a\u9009\u62e9: \u64e6\u6389\u6570\u5b57 1 \u6216 2\u3002 \u5982\u679c\u64e6\u6389 1, \u6570\u7ec4\u53d8\u6210 [1, 2]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 2 = 3\u3002\u90a3\u4e48 Bob \u53ef\u4ee5\u64e6\u6389\u4efb\u610f\u6570\u5b57\uff0c \u56e0\u4e3a Alice \u4f1a\u6210\u4e3a\u64e6\u6389\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u7684\u4eba\uff0c\u5979\u603b\u662f\u4f1a\u8f93\u3002 \u5982\u679c Alice \u64e6\u6389 2\uff0c\u90a3\u4e48\u6570\u7ec4\u53d8\u6210[1, 1]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 1 = 0\u3002Alice \u4ecd\u7136\u4f1a\u8f93 \u6389\u6e38\u620f\u3002 */ /* \u5206\u6790\uff1a \u5728\u67d0\u4e00\u56de\u5408\u4e2d\uff0c\u5f53\u524d\u5269\u4f59\u7684\u4e2a\u6570 n \u662f\u5076\u6570\u7684\u65f6\u5019\uff0c\u4e0d\u8bba Alice \u9009\u53d6\u54ea\u4e00\u4e2a\u503c\uff0c\u5f97\u5230\u7684\u5269\u4f59\u548c\u90fd\u4e0d\u53ef\u80fd\u4e3a 0\uff0c \u5e76\u4e14\u6b64\u65f6\uff0c\u5269\u4f59\u5947\u6570\u4e2a\u6570\u5b57 n-1\uff0c\u90a3\u4e48 Bob \u9762\u5bf9\u7684\u5c40\u9762\u5c31\u662f\uff1a\uff081\uff09\u5f53\u524d\u5f02\u6216\u548c\u4e3a 0 \uff0c\u6216\u8005\uff082\uff09\u8fdb\u5165\u4e0b\u4e00\u56de \u5408\u3002\u5f53\u8fdb\u5165\u4e0b\u4e00\u56de\u5408\u65f6\uff0c Alice \u53c8\u4f1a\u9762\u4e34\u76f8\u540c\u7684\u5c40\u9762\uff0c\u6240\u4ee5\uff0cn \u4e3a\u5076\u6570\u65f6\uff0cAlice \u4e0d\u4f1a\u8f93\u3002 \u5f53 n \u4e3a\u5947\u6570\u65f6\uff0c\u89d2\u8272\u53cd\u8f6c\uff0cBob \u80af\u5b9a\u4f1a\u8d62\u3002 */ bool xorGame ( vector < int >& nums ) { int n = ( int ) nums . size (); if ( n % 2 == 0 ) { return true ; } int sum = 0 ; for ( int num : nums ) { sum ^= num ; } return sum == 0 ; } Brian Kernighan \u7b97\u6cd5 \u00b6 \u8ba1\u7b97\u4e00\u4e2a\u6574\u6570\u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b 1 \u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 int cnt = 0 ; while ( num ) { num &= ( num - 1 ); cnt ++ ; } return cnt ; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(\\log C) O(\\log C) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u5176\u4e2d C \u4e3a\u88ab\u8ba1\u7b97\u7684\u6574\u6570\u503c\u3002 \u6bd4\u7279\u4f4d\u8ba1\u6570 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 n \uff0c\u5bf9\u4e8e 0 <= i <= n \u4e2d\u7684\u6bcf\u4e2a i \uff0c\u8ba1\u7b97\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d 1 \u7684\u4e2a\u6570 \uff0c\u8fd4\u56de\u4e00\u4e2a\u957f\u5ea6\u4e3a n + 1 \u7684\u6570\u7ec4 ans \u4f5c\u4e3a\u7b54\u6848\u3002\u4f8b\u5982\uff0cn = 5\uff0c\u8fd4\u56de [0,1,1,2,1,2]\uff0c\u8868\u793a 0 - 5 \u8fd9\u516d\u4e2a\u6570\u5b57\u5728\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u5206\u522b\u542b\u6709 1 \u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u5bf9\u6bcf\u4e00\u4e2a\u6570\u5b57\uff0c\u53ef\u4ee5\u7528\u6c49\u660e\u65b9\u6cd5\uff08C++ \u4e2d\u7684 __builtin_popcount\uff09\u5728 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0b\u6c42\u7684\u3002\u4f46\u8003\u8651\u9012\u63a8\u5173\u7cfb\u65f6\uff0c\u53ef\u4ee5\u964d\u4f4e\u5230\u7ebf\u5f62\u3002\u4e00\u4e2a\u6570\u5b57 x\u3002\u53f3\u79fb\u4e00\u4f4d\u7684\u5230 y\uff0c\u90a3\u4e48 x \u548c y \u6240\u542b\u6709\u7684 1 \u7684\u4e2a\u6570\u5dee\u53d6\u51b3\u4e8e x \u7684\u6700\u4f4e\u4f4d\u662f\u5426\u4e3a 1\u3002 1 2 3 4 5 6 7 vector < int > countBits ( int num ) { vector < int > ans ( num + 1 , 0 ); for ( int i = 1 ; i <= num ; i ++ ) { ans [ i ] = ans [ i / 2 ] + i % 2 ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u6c49\u660e\u8ddd\u79bb \u00b6 \u4e24\u4e2a\u6574\u6570\u4e4b\u95f4\u7684\u6c49\u660e\u8ddd\u79bb\uff08Hamming Distance\uff09\u6307\u7684\u662f\u8fd9\u4e24\u4e2a\u6570\u5b57\u5bf9\u5e94\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u540c\u7684\u4f4d\u7f6e\u7684\u6570\u76ee\u3002 \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \u300c\u5206\u6790\u300d \u6309\u7167\u5b9a\u4e49\uff0c\u6c49\u660e\u8ddd\u79bb\u662f\u4e8c\u8fdb\u5236\u4e0d\u540c\u7684\u4f4d\u7f6e\u6570\u76ee\u548c\uff0c\u8fd9\u4e0e\u5f02\u6216\u8fd0\u7b97\u6070\u597d\u543b\u5408\u3002\u6211\u4eec\u53ef\u4ee5\u7387\u5148\u8ba1\u7b97\u5f02\u6216\u7684\u7ed3\u679c\uff0c\u7136\u540e\u4f7f\u7528 Brian Kernighan \u7b97\u6cd5\u6c42\u8fd9\u6570\u503c\u7684\u4e8c\u8fdb\u5236\u4e2a\u6570\u3002C++ \u4e2d\u6709\u5185\u7f6e\u51fd\u6570 __builtin_popcount() \uff0c\u53ef\u4ee5\u8c03\u7528\u3002 1 2 3 int hammingDistance ( int x , int y ) { return __builtin_popcount ( x ^ y ); } \u300c\u62d3\u5c55\u300d \u5982\u679c\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e 10000\uff0c\u6c42\u6570\u7ec4\u5185\u4efb\u610f\u4e24\u4e2a\u6570\u7684\u6c49\u540d\u8ddd\u79bb\u548c\u3002\u4f8b\u5982 arr = [4, 14, 2], \u5176\u6c49\u660e\u8ddd\u79bb\u548c\u662f\uff084\uff0c14\uff09+\uff084\uff0c2\uff09+\uff0814\uff0c2\uff09= 2 + 2 + 2 = 6 1 2 3 4 5 6 7 8 9 10 11 12 int totalHammingDistance ( vector < int >& nums ) { int n = ( int ) nums . size (); int ans = 0 ; for ( int i = 0 ; i < 30 ; i ++ ) { int cnt = 0 ; for ( int num : nums ) { cnt += ( num >> i ) & 1 ; } ans += cnt * ( n - cnt ); } return ans ; } \u533a\u95f4\u6309\u4f4d\u4e0e \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u533a\u95f4 [left, right] \u6c42\u8fd9\u4e2a\u533a\u95f4\u6240\u6709\u503c\u7684\u6309\u4f4d\u4e0e\uff0c\u5305\u62ec\u7aef\u70b9\u503c\u3002 \u300c\u5206\u6790\u300d \u3010Brian Kernighan \u7b97\u6cd5\u3011\u5bf9\u4e8e [left, right] \u533a\u95f4\u5185\u7684\u6240\u6709\u503c\uff0c\u6309\u7167\u9898\u610f\u7ed3\u679c\u5e94\u4e3a \\text{res = left & left+1 &} \\cdots \\text{& right-1 & right} \\text{res = left & left+1 &} \\cdots \\text{& right-1 & right} \u4e24\u4e2a\u6570\u6309\u4f4d\u4e0e\u7684\u7ed3\u679c\u52bf\u5fc5\u4e0d\u8d85\u8fc7\u4e24\u6570\u4e2d\u8f83\u5c0f\u7684\u90a3\u4e2a\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u53f3\u7aef\u70b9\u5f00\u59cb\u4e0d\u65ad\u6c42\u4e24\u76f8\u90bb\u6570\u7684\u6309\u4f4d\u4e0e 1 2 3 4 5 6 int rangeBitwiseAnd ( int left , int right ) { while ( left < right ) { right &= right - 1 ; } return right ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log (right - left)) O(\\log (right - left)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4e0d\u4f7f\u7528\u52a0\u51cf\u8fd0\u7b97\u7b26\u6c42\u4e24\u6570\u4e4b\u548c \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570a\u3001b\uff0c\u5728\u4e0d\u4f7f\u7528 +\u3001- \u7684\u60c5\u51b5\u4e0b\uff0c\u6c42 a + b \u300c\u5206\u6790\u300d \u5c06 a\u3001b\u8f6c\u5316\u4e3a\u4e8c\u8fdb\u5236\u6570\u503c\u8fdb\u884c\u8fd0\u7b97 1 2 3 4 5 6 7 8 9 int getSum ( int a , int b ) { while ( true ) { unsigned pos = unsigned ( a & b ); if ( pos == 0 ) { break ; } a ^= b ; b = pos << 1 ; } return a ^ b ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log \\min(\\left \\| a \\right \\|, \\left \\| b \\right \\|)) O(\\log \\min(\\left \\| a \\right \\|, \\left \\| b \\right \\|)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u6309\u4f4d\u4e0e\u540e\u7684\u5f02\u6216\u548c \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 A = [1, 2, 3] \u548c B = [5, 6]\uff0cA \u548c B \u7684\u5143\u7d20\u4e24\u4e24\u6309\u4f4d\u4e0e\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u5f62\u6210\u4e00\u4e2a len(A) * len(B) \u7684\u6570\u7ec4\uff0c\u6c42\u8fd9\u4e2a\u6570\u7ec4\u5143\u7d20\u7684\u5f02\u6216\u548c\u3002 \u300c\u5206\u6790\u300d \u3010\u4f4d\u8fd0\u7b97\u3011\u5047\u8bbe\u6700\u540e\u7684\u7ed3\u679c\u6709 m \u4f4d\uff0c\u5728\u6240\u6709\u7684\u6309\u4f4d\u4e0e\u7ed3\u679c\u4e2d\uff0c\u7b2c k \u4f4d\u4e0a\uff0c\u5fc5\u987b\u6709\u5947\u6570\u4e2a 1\uff0c\u6700\u7ec8\u7b54\u6848\u7684\u7b2c k \u4f4d\u624d\u4f1a\u662f 1\u3002\u56e0\u4e3a len(A) * len(B) \u662f\u5947\u6570\uff0c\u90a3\u4e48 len(A) \u548c len(B) \u90fd\u662f\u5947\u6570\uff0c\u6240\u6709 A \u548c B \u7684\u5f02\u6216\u548c\u7684\u7b2c k \u4f4d\u5fc5\u987b\u662f 1\u3002 1 2 3 4 5 6 7 8 9 10 int getXORSum ( vector < int >& arr1 , vector < int >& arr2 ) { int sum1 = 0 , sum2 = 0 ; for ( int num : arr1 ) { sum1 ^= num ; } for ( int num : arr2 ) { sum2 ^= num ; } return sum1 & sum2 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u975e\u7a7a\u6574\u6570\u6570\u7ec4 nums \uff0c\u9664\u4e86\u67d0\u4e2a\u5143\u7d20\u53ea\u51fa\u73b0\u4e00\u6b21\u4ee5\u5916\uff0c\u5176\u4f59\u6bcf\u4e2a\u5143\u7d20\u5747\u51fa\u73b0\u4e24\u6b21\u3002\u627e\u51fa\u90a3\u4e2a\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\u7684\u5143\u7d20\u3002\u8981\u6c42\u7ebf\u5f62\u65f6\u95f4\u590d\u6742\u5ea6\u548c\u5e38\u6570\u7a7a\u95f4\u590d\u6742\u5ea6\u3002\u4f8b\u5982\uff0cnums = [4,1,2,1,2]\uff0c\u6700\u540e\u8fd4\u56de 4\u3002 \u300c\u5206\u6790\u300d \u4e24\u4e2a\u76f8\u7b49\u7684\u6570\u8fdb\u884c\u300c\u5f02\u6216\u300d\u64cd\u4f5c\u4f1a\u53d8\u62100\u3002 1 2 3 4 5 6 7 int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int & ele : nums ) { ans ^= ele ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u6570\u7ec4\u4e2d\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 I \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 2, 2, 3] \u53ea\u6709\u4e24\u4e2a\u6570\u7ec4\u51fa\u73b0 1 \u6b21\uff0c\u5176\u4f59\u90fd\u51fa\u73b0\u4e24\u6b21\uff0c\u6c42\u8fd9\u4e2a\u4e24\u4e2a\u6570\u5b57 \u300c\u5206\u6790\u300d \u3010\u5f02\u6216\u8fd0\u7b97\u3011\u4e24\u4e2a\u76f8\u540c\u7684\u6570\u5f02\u6216\u7ed3\u679c\u662f 0\u3002\u6839\u636e\u6574\u4e2a\u6570\u7ec4\u7684\u5f02\u6216\u548c res \u7684\u6700\u9ad8\u4f4d\u6765\u533a\u5206\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u5355\u6b21\u51fa\u73b0\u7684\u6570\u5b57\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < int > singleNumbers ( vector < int >& nums ) { vector < int > ans ; int XOR = 0 ; for ( int num : nums ) { XOR ^= num ; } int pos = 0 ; while ( XOR >> 1 ) { pos ++ ; XOR >>= 1 ; } int a = 0 , b = 0 ; for ( int num : nums ) { ( num >> pos ) & 1 ? a ^= num : b ^= num ; } return vector < int > { a , b }; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u6570\u7ec4\u4e2d\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 II \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [4, 3, 3, 3]\uff0c\u53ea\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u4e00\u6b21\uff0c\u5176\u4f59\u90fd\u51fa\u73b0\u4e09\u6b21\uff0c\u7528\u7ebf\u6027\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u548c\u5e38\u6570\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u627e\u5230\u8fd9\u4e2a\u6570\u5b57\u3002 \u300c\u5206\u6790\u300d \u3010\u4f4d\u8fd0\u7b97\u3011\u6bcf\u4e00\u4f4d\u4e0a\u7684 1 \u7684\u6570\u76ee\u4e00\u5b9a\u662f 3 \u7684\u500d\u6570\u52a0\u4e00\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int singleNumber ( vector < int >& nums ) { int ans = 0 ; vector < int > bits ( 32 , 0 ); for ( int num : nums ) { for ( int i = 0 ; ( 1l << i ) <= num && i < 32 ; i ++ ) { bits [ i ] += ( num >> i ) & 1 ; } } for ( int i = 0 ; i < 32 ; i ++ ) { ans |= ( 1 << i ) * ( bits [ i ] % 3 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u53d6\u6a21 \u00b6 \u4e00\u4e2a\u516c\u5f0f\uff1a(A * B) % k = ((A % k) * (B % k)) % k \u5e42\u6307\u6570\u53d6\u6a21 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 a = 2 \u548c \u4e00\u4e2a\u6570\u7ec4 b = [1, 0] \u8868\u793a\u5e42\u4e3a 10\uff0c\u6c42 a^{b} a^{b} \u5bf9 1337 \u53d6\u6a21\u3002 \u300c\u5206\u6790\u300d \u4ee5\u7ed9\u51fa\u7684 a \u548c b \u4e3a\u4f8b a^{b} = 2^{[1, 0]} = (2^{[1]})^{10} \\cdot 2^{0} a^{b} = 2^{[1, 0]} = (2^{[1]})^{10} \\cdot 2^{0} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int mod = 1337 ; int pow ( int a , int p ) { int ans = 1 ; while ( p > 0 ) { if ( p & 1 ) { ans = (( ans % mod ) * ( a % mod )) % mod ; } p >>= 1 ; a = (( a % mod ) * ( a % mod )) % mod ; } return ans ; } int superPow ( int a , vector < int >& b ) { if ( b . empty ()) { return 1 ; } int res1 = pow ( a , b . back ()); b . pop_back (); int res2 = pow ( superPow ( a , b ), 10 ); return (( res1 % mod ) * ( res2 % mod )) % mod ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cn \u662f b \u7684\u957f\u5ea6 \u9636\u4e58 \u00b6 \u9636\u4e58\u5c3e\u65700\u7684\u4e2a\u6570 \u00b6 \u8ba1\u7b97 n \u7684\u9636\u4e58\u6709\u591a\u5c11\u4e2a\u5c3e0\u3002 \u300c\u5206\u6790\u300d \u4e00\u4e2a\u6570\u7684\u5c3e0\u4e2a\u6570\u4ee3\u8868\u80fd\u591f\u5bf9 10 \u53d6\u4f59\u6570\u7684\u6b21\u6570\u300210 = 2 * 5\uff0c\u56e0\u6b64\u662f\u6c42 2 \u548c 5 \u6574\u9664\u7684\u4e2a\u6570\uff0c\u5e76\u4e14\u88ab 5 \u6574\u9664\u7684\u4e2a\u6570\u662f\u5c11\u4e8e\u88ab 2 \u6574\u9664\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 int trailingZeroes ( int n ) { int ans = 0 ; while ( n >= 5 ) { n /= 5 ; ans += n ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u6570\u5b57 \u00b6 \u7edf\u8ba1\u67d0\u4e2a\u6570\u5b57\u7684\u51fa\u73b0\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6570 n \u548c\u4e00\u4e2a 1 - 9 \u7684\u6570\u5b57 digit\uff0c\u7edf\u8ba1 1 - n \u6240\u6709\u6570\u5b57\u4e2d digit \u51fa\u73b0\u7684\u6b21\u6570\u3002\u4f8b\u5982 n = 13\uff0cdigit = 1\uff0c\u5305\u542b 1 \u7684\u6570\u5b57\u6709\uff1a1\u300110\u300111\u300112\u300113\uff0c1 \u51fa\u73b0\u4e86 6 \u6b21\u3002 \u300c\u5206\u6790\u300d \u8fd9\u662f\u4e00\u4e2a\u6570\u5b66\u9898\u76ee\uff0c\u4ee5 n = 2593\uff0cdigit = 5 \u4e3a\u4f8b \u4f4d \u5546 \u4f59\u6570 digit = '5' \u4e2a\u6570 \u4e2a\u4f4d i = 1 Quotient = 2593 / (10 * i) = 259 Mod = 2593 % (10 * i) = 3 259 * i + (3 > 5) * i = 259 \u4e2a\u4f4d i = 10 Quotient = 2593 / (10 * i) = 25 Mod = 2593 % (10 * i) = 93 25 * i + (9 > 5) * i = 260 \u4e2a\u4f4d i = 100 Quotient = 2593 / (10 * i) = 2 Mod = 2593 % (10 * i) = 593 2 * i + (5 == 5) * (93 + 1) = 294 \u4e2a\u4f4d i = 1000 Quotient = 2593 / (10 * i) = 0 Mod = 2593 % (10 * i) = 2593 0 * i + (2 > 5) * i = 0 \u603b\u8ba1 '5' \u7684\u4e2a\u6570\uff1a 259 + 260 + 294 = 813. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int countDigitOne ( int n , int digit = 1 ) { int ans = 0 ; for ( unsigned int i = 1 ; i <= n ; i *= 10 ) { int quo = n / ( 10ll * i ), mod = n % ( 10ll * i ); ans += quo * i ; if ( mod / i > digit ) { ans += i ; } else if ( mod / i == digit ) { ans += mod % i + 1 ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u7edd\u5bf9\u503c \u00b6 \u7edd\u5bf9\u503c\u5dee\u7684\u6700\u5927\u548c \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 arr1 = [1, -2, -5, 0, 10], arr2 = [0, -2, -1, -7, -4]\uff0c\u6c42\u4e0b\u5f0f\u7684\u6700\u5927\u503c \\max_{i, j \\in [0, n)} \\left | i - j \\right | + \\left | \\text{A[ i ]} - \\text{A[ j ]} \\right | + \\left | \\text{B[ i ]} - \\text{B[ j ]} \\right | \\max_{i, j \\in [0, n)} \\left | i - j \\right | + \\left | \\text{A[ i ]} - \\text{A[ j ]} \\right | + \\left | \\text{B[ i ]} - \\text{B[ j ]} \\right | \u300c\u5206\u6790\u300d \u5982\u679c\u6c42 |A[ i ] - A[ j ]| \u7684\u6700\u5927\u503c\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u7684\u77e5\u9053\u7b49\u4ef7\u4e8e max(A) - min(A) \u3002\u540c\u6837\u5730\u5bf9\u4e8e\u4e09\u4e2a\u7edd\u5bf9\u503c \\begin{aligned} & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(A[ i ] + B[ i ] + i) - (A[ j ] + B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(A[ i ] + B[ i ] - i) - (A[ j ] + B[ j ] - j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(A[ i ] - B[ i ] + i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(A[ i ] - B[ i ] - i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(- A[ i ] + B[ i ] + i) - (- A[ j ] + B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(- A[ i ] + B[ i ] - i) - (- A[ j ] + B[ j ] - j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(- A[ i ] - B[ i ] + i) - (- A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(- A[ i ] - B[ i ] - i) - (- A[ j ] - B[ j ] + j)} \\end{aligned} \\begin{aligned} & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(A[ i ] + B[ i ] + i) - (A[ j ] + B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(A[ i ] + B[ i ] - i) - (A[ j ] + B[ j ] - j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(A[ i ] - B[ i ] + i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(A[ i ] - B[ i ] - i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(- A[ i ] + B[ i ] + i) - (- A[ j ] + B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(- A[ i ] + B[ i ] - i) - (- A[ j ] + B[ j ] - j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(- A[ i ] - B[ i ] + i) - (- A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(- A[ i ] - B[ i ] - i) - (- A[ j ] - B[ j ] + j)} \\end{aligned} \u56e0\u6b64\u53ef\u4ee5\u5c06\u4e0a\u5f0f\u5b50\u5f52\u7eb3\u6210 \\begin{aligned} & p = \\text{A[ i ] + B[ i ] + i} \\\\ & Q = \\text{A[ i ] + B[ i ] - i} \\\\ & M = \\text{A[ i ] - B[ i ] + i} \\\\ & N = \\text{A[ i ] - B[ i ] - i} \\end{aligned} \\begin{aligned} & p = \\text{A[ i ] + B[ i ] + i} \\\\ & Q = \\text{A[ i ] + B[ i ] - i} \\\\ & M = \\text{A[ i ] - B[ i ] + i} \\\\ & N = \\text{A[ i ] - B[ i ] - i} \\end{aligned} \u6700\u7ec8\u7684\u7ed3\u679c\u4e3a \\max \\begin{cases} \\max(P) - \\min(P) \\\\ \\max(Q) - \\min(Q) \\\\ \\max(M) - \\min(M) \\\\ \\max(N) - \\min(N) \\end{cases} \\max \\begin{cases} \\max(P) - \\min(P) \\\\ \\max(Q) - \\min(Q) \\\\ \\max(M) - \\min(M) \\\\ \\max(N) - \\min(N) \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int maxAbsValExpr ( vector < int >& arr1 , vector < int >& arr2 ) { int n = ( int ) arr1 . size (), ans = 0 ; vector < vector < int >> max_min ( 4 , vector < int > { INT_MIN , INT_MAX }); for ( int i = 0 ; i < n ; i ++ ) { max_min [ 0 ][ 0 ] = max ( max_min [ 0 ][ 0 ], arr1 [ i ] + arr2 [ i ] + i ); max_min [ 0 ][ 1 ] = min ( max_min [ 0 ][ 1 ], arr1 [ i ] + arr2 [ i ] + i ); max_min [ 1 ][ 0 ] = max ( max_min [ 1 ][ 0 ], arr1 [ i ] + arr2 [ i ] - i ); max_min [ 1 ][ 1 ] = min ( max_min [ 1 ][ 1 ], arr1 [ i ] + arr2 [ i ] - i ); max_min [ 2 ][ 0 ] = max ( max_min [ 2 ][ 0 ], arr1 [ i ] - arr2 [ i ] + i ); max_min [ 2 ][ 1 ] = min ( max_min [ 2 ][ 1 ], arr1 [ i ] - arr2 [ i ] + i ); max_min [ 3 ][ 0 ] = max ( max_min [ 3 ][ 0 ], arr1 [ i ] - arr2 [ i ] - i ); max_min [ 3 ][ 1 ] = min ( max_min [ 3 ][ 1 ], arr1 [ i ] - arr2 [ i ] - i ); } for ( int i = 0 ; i < 4 ; i ++ ) { ans = max ( ans , max_min [ i ][ 0 ] - max_min [ i ][ 1 ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4e11\u6570 \u00b6 \u5982\u679c\u4e00\u4e2a\u6574\u6570\uff0c\u5b83\u7684\u8d28\u56e0\u5b50\u53ea\u5728 2\u30013\u30015 \u4e4b\u4e2d\uff0c\u90a3\u4e48\u5c31\u662f\u4e11\u6570\u3002\u5982 15 = 3 * 5 \u4e11\u6570 I \u00b6 \u5224\u65ad\u662f\u5426\u662f\u4e11\u6570 1 2 3 4 5 6 7 bool isUgly ( int n ) { if ( n <= 0 ) { return false ; } while ( n % 2 == 0 ) { n /= 2 ; } while ( n % 3 == 0 ) { n /= 3 ; } while ( n % 5 == 0 ) { n /= 5 ; } return n == 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4e11\u6570 II \u00b6 \u6c42\u7b2c n \u4e2a\u4e11\u6570 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 \u662f\u524d 10 \u4e2a\u4e11\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 int nthUglyNumber ( int n ) { if ( n == 0 ) { return 1 ; } vector < int > dp ( n , 0 ); int f2 = 0 , f3 = 0 , f5 = 0 ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ f2 ] * 2 , min ( dp [ f3 ] * 3 , dp [ f5 ] * 5 )); if ( dp [ i ] == dp [ f2 ] * 2 ) { f2 ++ ; } if ( dp [ i ] == dp [ f3 ] * 3 ) { f3 ++ ; } if ( dp [ i ] == dp [ f5 ] * 5 ) { f5 ++ ; } } return dp [ n - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u4e11\u6570 III \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u8d28\u6570\u6570\u7ec4 primes = [2, 7, 13, 19]\uff0c\u6c42\u7b2c n \u4e2a\u8d85\u7ea7\u4e11\u6570\uff0c\u6ee1\u8db3\u6240\u6709\u7684\u8d28\u56e0\u5b50\u90fd\u5728\u8fd9\u4e2a primes \u6570\u7ec4\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int nthSuperUglyNumber ( int n , vector < int >& primes ) { int m = ( int ) primes . size (); vector < int > dp ( n , 0 ), f ( m , 0 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int minVal = INT_MAX ; for ( int j = 0 ; j < m ; j ++ ) { minVal = min ( minVal , dp [ f [ j ]] * primes [ j ]); } dp [ i ] = minVal ; for ( int j = 0 ; j < m ; j ++ ) { if ( dp [ f [ j ]] * primes [ j ] == dp [ i ]) { f [ j ] ++ ; } } } return dp [ n - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) \uff0cm \u662f primes \u7684\u957f\u5ea6 \u4e11\u6570 IV \u00b6 \u7ed9\u5b9a\u56db\u4e2a\u6574\u6570\uff0cn = 1000000000, a = 2, b = 217983653, c = 336916467\uff0c\u6c42\u7b2c n \u4e2a\u6570\uff0c\u8fd9\u4e2a\u6570\u53ef\u4ee5\u6574\u9664 a\u3001b\u3001c\u5176\u4e2d\u7684\u4e00\u4e2a\u6216\u591a\u4e2a\u3002 \u300c\u5206\u6790\u300d [1, X] \u4e4b\u95f4\uff0c\u6709\u591a\u5c11\u4e2a\u6570\u53ef\u4ee5\u88ab a e.g. \u6574\u9664\uff1f\u7b54\u6848\u662f\uff1a \\left \\lfloor \\frac{X}{a} \\right \\rfloor \\left \\lfloor \\frac{X}{a} \\right \\rfloor \uff0c\u90a3\u4e48\u5bf9\u4e8e a\u3001b\u3001c \u4e09\u4e2a\u9664\u6570\u800c\u8a00\uff0c[1, X] \u533a\u95f4\u4e2d\u7b26\u5408\u6761\u4ef6\u7684\u4e2a\u6570\u662f \\begin{aligned} \\text{ans} =& \\left \\lfloor \\frac{X}{a} \\right \\rfloor + \\left \\lfloor \\frac{X}{b} \\right \\rfloor + \\left \\lfloor \\frac{X}{c} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(a, b)} \\right \\rfloor - \\left \\lfloor \\frac{X}{\\text{LCM}(a, c)} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(b, c)} \\right \\rfloor + \\left \\lfloor \\frac{X}{\\text{LCM}(a, b, c)} \\right \\rfloor \\end{aligned} \\begin{aligned} \\text{ans} =& \\left \\lfloor \\frac{X}{a} \\right \\rfloor + \\left \\lfloor \\frac{X}{b} \\right \\rfloor + \\left \\lfloor \\frac{X}{c} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(a, b)} \\right \\rfloor - \\left \\lfloor \\frac{X}{\\text{LCM}(a, c)} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(b, c)} \\right \\rfloor + \\left \\lfloor \\frac{X}{\\text{LCM}(a, b, c)} \\right \\rfloor \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 long lcm ( int a , int b ) { long mul = ( long ) a * b ; while ( a != 0 && b != 0 ) { if ( a > b ) { a %= b ; } else { b %= a ; } } return mul / ( a + b ); } int nthUglyNumber ( int n , int a , int b , int c ) { long ab = lcm ( a , b ), bc = lcm ( b , c ), ac = lcm ( a , c ); long abc = lcm ( ab , c ), l = 0 , r = INT_MAX ; while ( l < r ) { long m = ( l + r ) >> 1 ; long res = m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc ; if ( res < n ) { l = m + 1 ; } else { r = m ; } } return ( int ) l ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log INT_MAX) O(\\log INT_MAX) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u6469\u5c14\u6295\u7968\u6cd5 \u00b6 \u6469\u5c14\u6295\u7968\u6cd5\u662f\u4e00\u79cd\u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u7684\u7b97\u6cd5\uff0c\u7528\u6765\u627e\u5230\u4e00\u4e2a\u6570\u7ec4\u7684\u591a\u6570\u5143\u7d20\u3002\u8fd9\u91cc\u7684\u591a\u6570\uff0c\u53ef\u4ee5\u662f\u8d85\u8fc7\u6574\u4e2a\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u4e5f\u53ef\u4ee5\u662f\u8d85\u8fc7\u6574\u4e2a\u6570\u7ec4\u7684\u2153\u3002 \u7b97\u6cd5\u7684\u601d\u60f3\u662f\u7528\u4e00\u4e2a\u5143\u7d20\u4e0e\u53e6\u4e00\u4e2a\u5143\u7d20\u62b5\u6d88\u3002 \u627e\u5230\u8d85\u8fc7\u4e00\u534a\u7684\u5143\u7d20 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int majorityElement ( vector < int >& nums ) { int n = int ( nums . size ()); int count = 0 , maj = - 1 ; for ( int num : nums ) { if ( count == 0 ) { maj = num ; count = 1 ; continue ; } if ( num == maj ) { count ++ ; } else { count -- ; } } return maj ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u627e\u5230\u8d85\u8fc7\u4e09\u5206\u4e4b\u4e00\u7684\u5143\u7d20\uff08\u4eec\uff09 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; if ( nums . empty ()) { return ans ; } int cddt1 = nums [ 0 ], cddt2 = nums [ 0 ], cnt1 = 0 , cnt2 = 0 ; for ( int num : nums ) { if ( cddt1 == num ) { cnt1 ++ ; continue ; } if ( cddt2 == num ) { cnt2 ++ ; continue ; } if ( cnt1 == 0 ) { cnt1 ++ ; cddt1 = num ; continue ; } if ( cnt2 == 0 ) { cnt2 ++ ; cddt2 = num ; continue ; } cnt1 -- ; cnt2 -- ; } cnt1 = 0 ; cnt2 = 0 ; for ( int num : nums ) { if ( cddt1 == num ) { cnt1 ++ ; } else if ( cddt2 == num ) { cnt2 ++ ; } } if ( cnt1 > nums . size () / 3 ) { ans . emplace_back ( cddt1 ); } if ( cnt2 > nums . size () / 3 ) { ans . emplace_back ( cddt2 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u7f16\u7801 \u00b6 \u683c\u96f7\u7f16\u7801 \u00b6 \u683c\u96f7\u7f16\u7801\u662f\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\u5b57\u7cfb\u7edf\uff0c\u5728\u8be5\u7cfb\u7edf\u4e2d\uff0c\u4e24\u4e2a\u8fde\u7eed\u7684\u6570\u503c\u4ec5\u6709\u4e00\u4e2a\u4f4d\u6570\u7684\u5dee\u5f02\u3002\u7ed9\u5b9a\u4e00\u4e2a\u4ee3\u8868\u7f16\u7801\u603b\u4f4d\u6570\u7684\u975e\u8d1f\u6574\u6570 n\uff0c\u6253\u5370\u5176\u683c\u96f7\u7f16\u7801\u5e8f\u5217\u3002\u5373\u4f7f\u6709\u591a\u4e2a\u4e0d\u540c\u7b54\u6848\uff0c\u4f60\u4e5f\u53ea\u9700\u8981\u8fd4\u56de\u5176\u4e2d\u4e00\u79cd\u3002\u683c\u96f7\u7f16\u7801\u5e8f\u5217\u5fc5\u987b\u4ee5 0 \u5f00\u5934\u3002\u4f8b\u5982 n = 2\uff0c\u4f1a\u5f97\u5230 4 \u4e2a\u7f16\u7801 \\begin{matrix} 00 & \\rightarrow & 0 \\\\ 01 & \\rightarrow & 1 \\\\ 11 & \\rightarrow & 3 \\\\ 10 & \\rightarrow & 2 \\end{matrix} \\begin{matrix} 00 & \\rightarrow & 0 \\\\ 01 & \\rightarrow & 1 \\\\ 11 & \\rightarrow & 3 \\\\ 10 & \\rightarrow & 2 \\end{matrix} \u300c\u5206\u6790\u300d \u683c\u96f7\u7f16\u7801\u7684\u516c\u5f0f \\text{GrayCode}(i) = i \\text{ XOR } \\left \\lfloor \\frac{i}{2} \\right \\rfloor \\text{GrayCode}(i) = i \\text{ XOR } \\left \\lfloor \\frac{i}{2} \\right \\rfloor 1 2 3 4 5 6 7 vector < int > grayCode ( int n ) { vector < int > ans ( 1 << n , 0 ); for ( int i = 1 ; i < ( 1 << n ); i ++ ) { ans [ i ] = i ^ ( i >> 1 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4fe1\u606f\u8bba \u00b6 \u53ef\u601c\u7684\u5c0f\u732a \u00b6 \u6709 buckets \u6876\u6db2\u4f53\uff0c\u5176\u4e2d \u6b63\u597d \u6709\u4e00\u6876\u542b\u6709\u6bd2\u836f\uff0c\u5176\u4f59\u88c5\u7684\u90fd\u662f\u6c34\u3002\u5b83\u4eec\u4ece\u5916\u89c2\u770b\u8d77\u6765\u90fd\u4e00\u6837\u3002\u4e3a\u4e86\u5f04\u6e05\u695a\u54ea\u53ea\u6c34\u6876\u542b\u6709\u6bd2\u836f\uff0c\u4f60\u53ef\u4ee5\u5582\u4e00\u4e9b\u732a\u559d\uff0c\u901a\u8fc7\u89c2\u5bdf\u732a\u662f\u5426\u4f1a\u6b7b\u8fdb\u884c\u5224\u65ad\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u4f60\u53ea\u6709 minutesToTest \u5206\u949f\u65f6\u95f4\u6765\u786e\u5b9a\u54ea\u6876\u6db2\u4f53\u662f\u6709\u6bd2\u7684\u3002 \u5582\u732a\u7684\u89c4\u5219\u5982\u4e0b\uff1a \u9009\u62e9\u82e5\u5e72\u6d3b\u732a\u8fdb\u884c\u5582\u517b \u53ef\u4ee5\u5141\u8bb8\u5c0f\u732a\u540c\u65f6\u996e\u7528\u4efb\u610f\u6570\u91cf\u7684\u6876\u4e2d\u7684\u6c34\uff0c\u5e76\u4e14\u8be5\u8fc7\u7a0b\u4e0d\u9700\u8981\u65f6\u95f4\u3002 \u5c0f\u732a\u559d\u5b8c\u6c34\u540e\uff0c\u5fc5\u987b\u6709 minutesToDie \u5206\u949f\u7684\u51b7\u5374\u65f6\u95f4\u3002\u5728\u8fd9\u6bb5\u65f6\u95f4\u91cc\uff0c\u4f60\u53ea\u80fd\u89c2\u5bdf\uff0c\u800c\u4e0d\u5141\u8bb8\u7ee7\u7eed\u5582\u732a\u3002 \u8fc7\u4e86 minutesToDie \u5206\u949f\u540e\uff0c\u6240\u6709\u559d\u5230\u6bd2\u836f\u7684\u732a\u90fd\u4f1a\u6b7b\u53bb\uff0c\u5176\u4ed6\u6240\u6709\u732a\u90fd\u4f1a\u6d3b\u4e0b\u6765\u3002 \u91cd\u590d\u8fd9\u4e00\u8fc7\u7a0b\uff0c\u76f4\u5230\u65f6\u95f4\u7528\u5b8c\u3002 \u7ed9\u4f60\u6876\u7684\u6570\u76ee buckets \uff0cminutesToDie \u548c minutesToTest \uff0c\u8fd4\u56de\u5728\u89c4\u5b9a\u65f6\u95f4\u5185\u5224\u65ad\u54ea\u4e2a\u6876\u6709\u6bd2\u6240\u9700\u7684 \u6700\u5c0f \u732a\u6570\u3002 \u300c\u5206\u6790\u300d \u8bbe m \u4e2a\u5c0f\u732a\uff0c\u5b9e\u9a8c\u8f6e\u6570 n = \\left \\lfloor \\frac{\\text{minutesToTest}}{\\text{minutesToDie}} \\right \\rfloor \\left \\lfloor \\frac{\\text{minutesToTest}}{\\text{minutesToDie}} \\right \\rfloor \uff0c\u90a3\u4e48\u5bf9\u4e00\u4e2a\u5c0f\u732a\u800c\u8a00\uff0c\u4ece\u5b9e\u9a8c\u5f00\u59cb\u5230\u5b9e\u9a8c\u7ed3\u675f\u4e00\u5171\u6709 (1 + n) \u4e2a\u72b6\u6001\u3002\u8fd9\u91cc\u7684 1 \u6307\u7684\u662f\u521d\u59cb\u72b6\u6001\uff0c\u4e4b\u540e\u6bcf\u4e00\u8f6e\u5b9e\u9a8c\u90fd\u4f1a\u6709\u4e00\u4e2a\u72b6\u6001\u3002\u56e0\u6b64 buckets \u4e2a\u6876\u786e\u5b9a\u6709\u4e00\u4e2a\u662f\u6bd2\u836f\uff0c\u6240\u4ee5\uff0c\u6bd2\u836f\u7684\u72b6\u6001\u6570\u662f buckets\u3002\u56e0\u6b64\uff0c (n + 1)^{m} \\geq \\text{buckets} (n + 1)^{m} \\geq \\text{buckets} \u53ef\u4ee5\u89e3\u51fa\u6765 m \u7684\u6700\u5c0f\u503c m = \\left \\lceil \\log_{n + 1}\\text{buckets} \\right \\rceil m = \\left \\lceil \\log_{n + 1}\\text{buckets} \\right \\rceil 1 2 3 int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ceil ( log ( buckets ) / log ( minutesToTest / minutesToDie + 1 )); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6570\u5b66"},{"location":"algo/math/#_1","text":"","title":"\u6700\u5927\u516c\u7ea6\u6570 &amp; \u6700\u5c0f\u516c\u500d\u6570"},{"location":"algo/math/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Brutal force: enumerate all numbers from 1 to min(a, b), save the greatest. */ int GCD_enumerate ( int a , int b ) { int c = ( a < b ? a : b ); int gcd = 1 ; for ( int i = 1 ; i <= c ; i ++ ) { if ( a % i == 0 && b % i == 0 ) { gcd = i ; } } return gcd ; } int GCD_Euclidean_Algorithm_divide ( int a , int b ) { while ( a * b ) { if ( a < b ) { b %= a ; } else { a %= b ; } } return ( a > b ? a : b ); } int GCD_Euclidean_Algorithm_subtract ( int a , int b ) { while ( a * b ) { if ( a < b ) { b -= a ; } else { a -= b ; } } return ( a > b ? a : b ); }","title":"\u4e24\u6570\u6700\u5927\u516c\u7ea6\u6570"},{"location":"algo/math/#_3","text":"1 2 3 4 5 6 7 8 9 int GCD_Array ( vector < int > arr ) { int n = int ( arr . size ()); if ( n == 1 ) { return arr [ 0 ]; } int gcd = GCD_Euclidean_Algorithm_divide ( arr [ 0 ], arr [ 1 ]); for ( int i = 2 ; i < n ; i ++ ) { gcd = GCD_Euclidean_Algorithm_divide ( gcd , arr [ i ]); } return gcd ; }","title":"\u6570\u7ec4\u7684\u6700\u5927\u516c\u7ea6\u6570"},{"location":"algo/math/#_4","text":"\\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} \\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} 1 2 3 4 int LCM ( int a , int b ) { int gcd = GCD_Euclidean_Algorithm_divide ( a , b ); return ( a * b ) / gcd ; }","title":"\u6700\u5c0f\u516c\u500d\u6570"},{"location":"algo/math/#_5","text":"\u4e24\u4e2a\u6574\u6570a\u3001b\uff0c\u8bbe d \u662f\u5b83\u4eec\u7684\u6700\u5927\u516c\u7ea6\u6570\uff0c\u90a3\u4e48 ax + by = m \u6709\u6574\u6570\u89e3\uff08x\uff0cy\uff09\u7684\u5145\u8981\u6761\u4ef6\u662f m \u662f d \u7684\u6574\u6570\u500d\u3002\u5f53 m = 1\u65f6\uff0ca \u4e0e b \u4e92\u8d28\u3002 \u63a8\u5e7f\u5230\u4e00\u7ec4\u6574\u6570 \\{a_{1}, a_{2}, \\cdots, a_{n}\\} \\{a_{1}, a_{2}, \\cdots, a_{n}\\} \uff0cd \u662f\u5b83\u4eec\u7684\u6700\u5927\u516c\u7ea6\u6570\uff0c\u65b9\u7a0b \\sum_{i = 1}^{n} a_{i} x_{i} = m \\sum_{i = 1}^{n} a_{i} x_{i} = m \u6709\u6574\u6570\u89e3 (x_{1}, x_{2}, \\cdots, x_{n}) (x_{1}, x_{2}, \\cdots, x_{n}) \u7684\u5145\u8981\u6761\u4ef6\u662f m \u662f d \u7684\u6574\u6570\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int get_gcd ( int x , int y ) { while ( x != 0 && y != 0 ) { if ( abs ( x ) > abs ( y )) { x = x % y ; } else { y = y % x ; } } return x + y ; } bool isGoodArray ( vector < int >& nums ) { if ( nums . empty ()) { return false ; } int gcd = nums [ 0 ]; for ( int num : nums ) { gcd = get_gcd ( gcd , num ); } return gcd == 1 ; }","title":"\u88f4\u8700\u5b9a\u7406"},{"location":"algo/math/#_6","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6c34\u58f6\uff0c\u5bb9\u91cf\u662f a \u548c b\uff0c\u73b0\u6709\u4e0d\u9650\u4f9b\u5e94\u7684\u6c34\uff0c\u8bf7\u95ee\u80fd\u5426\u7528\u8fd9\u4e24\u4e2a\u6c34\u58f6\u91cf\u51fa\u6070\u597d\u5bb9\u91cf\u4e3a c \u7684\u6c34\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool canMeasureWater ( int jug1Capacity , int jug2Capacity , int targetCapacity ) { if ( jug1Capacity + jug2Capacity < targetCapacity ) { return false ; } while ( jug1Capacity != 0 && jug2Capacity != 0 ) { if ( jug1Capacity > jug2Capacity ) { jug1Capacity %= jug2Capacity ; } else { jug2Capacity %= jug1Capacity ; } } return targetCapacity % ( jug1Capacity + jug2Capacity ) == 0 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log \\max(jug1Capacity, jug2Capacity)) O(\\log \\max(jug1Capacity, jug2Capacity)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6c34\u58f6\u95ee\u9898"},{"location":"algo/math/#_7","text":"","title":"\u4f4d\u8fd0\u7b97"},{"location":"algo/math/#_8","text":"\u300c\u539f\u7801\u300d \u7b2c\u4e00\u4f4d\u662f\u7b26\u53f7\u4f4d\uff0c\u5176\u4f59\u8868\u793a\u503c \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} 8 \u4f4d\u4e8c\u8fdb\u5236\u539f\u7801\u7684\u53ef\u4ee5\u8868\u793a\u7684\u8303\u56f4\u662f [1111 111, 0111 111] \u5373 [-127, 127] \u300c\u53cd\u7801\u300d \u6b63\u6570\u7684\u53cd\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u53cd\u7801\u662f\u7b26\u53f7\u4f4d\u4e0d\u53d8\uff0c\u5176\u4f59\u4f4d\u7f6e\u9010\u4e2a\u53d6\u53cd\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \u300c\u8865\u7801\u300d \u6b63\u6570\u7684\u8865\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u8865\u7801\u5728\u5176\u53cd\u7801\u7684\u6700\u540e\u4e00\u4f4d\u52a0 1\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \u300c\u5f15\u5165\u53cd\u7801\u7684\u539f\u56e0\u300d \u8ba1\u7b97\u673a\u4e8c\u8fdb\u5236\u8fd0\u7b97\u505a\u52a0\u51cf\u4e58\u9664\u8ba1\u7b97\u65f6\uff0c\u5e0c\u671b\u5176\u8bbe\u8ba1\u6a21\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u4f46\u662f\u5bf9\u4e8e\u8d1f\u6570\u800c\u8a00\uff0c\u539f\u7801\u5b58\u5728\u7b26\u53f7\u4f4d\uff0c\u5982\u679c\u53c2\u4e0e\u4e8c\u8fdb\u5236\u8ba1\u7b97\u7684\u8bdd\uff0c\u5bb9\u6613\u51fa\u73b0\u9519\u8bef\u7b54\u6848\u3002 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \u6240\u4ee5\u9700\u8981\u5f15\u5165\u53cd\u7801 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \u4e3a\u4e86\u89e3\u51b3 -0 \u95ee\u9898\uff0c\u8865\u7801\u5e94\u8fd0\u800c\u751f \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \u6b64\u5916[1000 0000]\u8868\u793a -128 \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \u56e0\u6b64 8 \u4f4d\u4e8c\u8fdb\u5236\u53ef\u4ee5\u8868\u793a\u7684\u6570\u5b57\u8303\u56f4\u662f [-128, 127]\u3002","title":"\u539f\u7801 \u53cd\u7801 \u8865\u7801"},{"location":"algo/math/#xor","text":"\u6309\u4f4d\u5f02\u6216 (XOR) \u5bf9\u4e8e\u4e8c\u8fdb\u5236\u7684\u4e24\u4e2a\u6570a\uff0c b\u5728\u76f8\u540c\u4f4d\u7f6e\u4e0a\u7684\u505a\u4f4d\u8fd0\u7b97\uff1a\u540c\u4e3a 1 \u6216\u8005\u540c\u4e3a 0 \u5219\u4e3a 0\uff1b \u53cd\u4e4b\u4e3a 1\u3002 \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \u4e24\u4e2a\u6027\u8d28 \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \u300c\u9898\u76ee\u300d \u300cLeetcode 1734. \u89e3\u7801\u5f02\u6216\u540e\u7684\u6392\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 perm \uff0c\u5b83\u662f\u524d n \u4e2a\u6b63\u6574\u6570\u7684\u6392\u5217\uff0c\u4e14 n \u662f\u4e2a \u5947\u6570 \u3002 \u5b83\u88ab\u52a0\u5bc6\u6210\u53e6\u4e00\u4e2a\u957f\u5ea6\u4e3a n - 1 \u7684\u6574\u6570\u6570\u7ec4 encoded \uff0c\u6ee1\u8db3 encoded[i] = perm[i] XOR perm[i + 1] \u3002\u6bd4\u65b9\u8bf4\uff0c\u5982\u679c perm = [1,3,2] \uff0c \u90a3\u4e48 encoded = [2,1] \u3002 \u7ed9\u4f60 encoded \u6570\u7ec4\uff0c\u8bf7\u4f60\u8fd4\u56de\u539f\u59cb\u6570\u7ec4 perm \u3002\u9898\u76ee\u4fdd\u8bc1\u7b54\u6848\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aencoded = [3,1] \u8f93\u51fa\uff1a[1,2,3] \u89e3\u91ca\uff1a\u5982\u679c perm = [1,2,3] \uff0c\u90a3\u4e48 encoded = [1 XOR 2,2 XOR 3] = [3,1] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aencoded = [6,5,4,6] \u8f93\u51fa\uff1a[2,4,1,5,3] */ /* perm\u5305\u542b\u4e861-n+1\u7684\u6240\u6709\u6570\u5b57\uff0cn\u4e3aencoded\u7684\u957f\u5ea6 total = perm[0] ^ ... ^ perm[n-1] perm[0] ^ perm[1] = encoded[0] perm[1] ^ perm[2] = encoded[1] perm[2] ^ perm[3] = encoded[2] perm[3] ^ perm[4] = encoded[3] \u6240\u4ee5\uff0cencoded\u6570\u7ec4\u4e2d\u5947\u6570\u4f4d\u7f6e\u7684\u5143\u7d20XOR\uff0c\u5bf9\u5e94\u4e86perm1-n\u7684XOR\uff0c \u7531\u6b64\uff0c\u53ef\u4ee5\u6c42\u5f97perm[0]\u7684\u5927\u5c0f */ vector < int > decode ( vector < int >& encoded ) { int n = ( int ) encoded . size (); vector < int > perm ; int total = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { total ^= i ; } int odd = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { odd ^= encoded [ i ]; } perm . emplace_back ( total ^ odd ); for ( int i = 0 ; i < n ; i ++ ) { perm . emplace_back ( perm . back () ^ encoded [ i ]); } return perm ; } \u300cLeetcode 810. \u9ed1\u677f\u5f02\u6216\u6e38\u620f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* \u9ed1\u677f\u4e0a\u5199\u7740\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums[i] \u3002Alice \u548c Bob \u8f6e\u6d41\u4ece\u9ed1\u677f\u4e0a\u64e6\u6389\u4e00\u4e2a\u6570\u5b57\uff0cAlice \u5148\u624b\u3002 \u5982\u679c\u64e6\u9664\u4e00\u4e2a\u6570\u5b57\u540e\uff0c\u5269\u4f59\u7684\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u51fa\u7684\u7ed3\u679c\u7b49\u4e8e 0 \u7684\u8bdd\uff0c\u5f53\u524d\u73a9\u5bb6\u6e38\u620f\u5931\u8d25\u3002 (\u53e6\u5916\uff0c\u5982\u679c\u53ea\u5269\u4e00\u4e2a\u6570\u5b57\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u5230\u5b83\u672c\u8eab\uff1b\u5982\u679c\u65e0\u6570\u5b57\u5269\u4f59\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u4e3a 0\u3002\uff09 \u6362\u79cd\u8bf4\u6cd5\u5c31\u662f\uff0c\u8f6e\u5230\u67d0\u4e2a\u73a9\u5bb6\u65f6\uff0c\u5982\u679c\u5f53\u524d\u9ed1\u677f\u4e0a\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u7b49\u4e8e 0\uff0c\u8fd9\u4e2a\u73a9\u5bb6\u83b7\u80dc\u3002 \u5047\u8bbe\u4e24\u4e2a\u73a9\u5bb6\u6bcf\u6b65\u90fd\u4f7f\u7528\u6700\u4f18\u89e3\uff0c\u5f53\u4e14\u4ec5\u5f53 Alice \u83b7\u80dc\u65f6\u8fd4\u56de true\u3002 \u793a\u4f8b\uff1a \u8f93\u5165: nums = [1, 1, 2] \u8f93\u51fa: false \u89e3\u91ca: Alice \u6709\u4e24\u4e2a\u9009\u62e9: \u64e6\u6389\u6570\u5b57 1 \u6216 2\u3002 \u5982\u679c\u64e6\u6389 1, \u6570\u7ec4\u53d8\u6210 [1, 2]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 2 = 3\u3002\u90a3\u4e48 Bob \u53ef\u4ee5\u64e6\u6389\u4efb\u610f\u6570\u5b57\uff0c \u56e0\u4e3a Alice \u4f1a\u6210\u4e3a\u64e6\u6389\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u7684\u4eba\uff0c\u5979\u603b\u662f\u4f1a\u8f93\u3002 \u5982\u679c Alice \u64e6\u6389 2\uff0c\u90a3\u4e48\u6570\u7ec4\u53d8\u6210[1, 1]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 1 = 0\u3002Alice \u4ecd\u7136\u4f1a\u8f93 \u6389\u6e38\u620f\u3002 */ /* \u5206\u6790\uff1a \u5728\u67d0\u4e00\u56de\u5408\u4e2d\uff0c\u5f53\u524d\u5269\u4f59\u7684\u4e2a\u6570 n \u662f\u5076\u6570\u7684\u65f6\u5019\uff0c\u4e0d\u8bba Alice \u9009\u53d6\u54ea\u4e00\u4e2a\u503c\uff0c\u5f97\u5230\u7684\u5269\u4f59\u548c\u90fd\u4e0d\u53ef\u80fd\u4e3a 0\uff0c \u5e76\u4e14\u6b64\u65f6\uff0c\u5269\u4f59\u5947\u6570\u4e2a\u6570\u5b57 n-1\uff0c\u90a3\u4e48 Bob \u9762\u5bf9\u7684\u5c40\u9762\u5c31\u662f\uff1a\uff081\uff09\u5f53\u524d\u5f02\u6216\u548c\u4e3a 0 \uff0c\u6216\u8005\uff082\uff09\u8fdb\u5165\u4e0b\u4e00\u56de \u5408\u3002\u5f53\u8fdb\u5165\u4e0b\u4e00\u56de\u5408\u65f6\uff0c Alice \u53c8\u4f1a\u9762\u4e34\u76f8\u540c\u7684\u5c40\u9762\uff0c\u6240\u4ee5\uff0cn \u4e3a\u5076\u6570\u65f6\uff0cAlice \u4e0d\u4f1a\u8f93\u3002 \u5f53 n \u4e3a\u5947\u6570\u65f6\uff0c\u89d2\u8272\u53cd\u8f6c\uff0cBob \u80af\u5b9a\u4f1a\u8d62\u3002 */ bool xorGame ( vector < int >& nums ) { int n = ( int ) nums . size (); if ( n % 2 == 0 ) { return true ; } int sum = 0 ; for ( int num : nums ) { sum ^= num ; } return sum == 0 ; }","title":"XOR"},{"location":"algo/math/#brian-kernighan","text":"\u8ba1\u7b97\u4e00\u4e2a\u6574\u6570\u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b 1 \u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 int cnt = 0 ; while ( num ) { num &= ( num - 1 ); cnt ++ ; } return cnt ; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(\\log C) O(\\log C) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u5176\u4e2d C \u4e3a\u88ab\u8ba1\u7b97\u7684\u6574\u6570\u503c\u3002","title":"Brian Kernighan \u7b97\u6cd5"},{"location":"algo/math/#_9","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 n \uff0c\u5bf9\u4e8e 0 <= i <= n \u4e2d\u7684\u6bcf\u4e2a i \uff0c\u8ba1\u7b97\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d 1 \u7684\u4e2a\u6570 \uff0c\u8fd4\u56de\u4e00\u4e2a\u957f\u5ea6\u4e3a n + 1 \u7684\u6570\u7ec4 ans \u4f5c\u4e3a\u7b54\u6848\u3002\u4f8b\u5982\uff0cn = 5\uff0c\u8fd4\u56de [0,1,1,2,1,2]\uff0c\u8868\u793a 0 - 5 \u8fd9\u516d\u4e2a\u6570\u5b57\u5728\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u5206\u522b\u542b\u6709 1 \u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u5bf9\u6bcf\u4e00\u4e2a\u6570\u5b57\uff0c\u53ef\u4ee5\u7528\u6c49\u660e\u65b9\u6cd5\uff08C++ \u4e2d\u7684 __builtin_popcount\uff09\u5728 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0b\u6c42\u7684\u3002\u4f46\u8003\u8651\u9012\u63a8\u5173\u7cfb\u65f6\uff0c\u53ef\u4ee5\u964d\u4f4e\u5230\u7ebf\u5f62\u3002\u4e00\u4e2a\u6570\u5b57 x\u3002\u53f3\u79fb\u4e00\u4f4d\u7684\u5230 y\uff0c\u90a3\u4e48 x \u548c y \u6240\u542b\u6709\u7684 1 \u7684\u4e2a\u6570\u5dee\u53d6\u51b3\u4e8e x \u7684\u6700\u4f4e\u4f4d\u662f\u5426\u4e3a 1\u3002 1 2 3 4 5 6 7 vector < int > countBits ( int num ) { vector < int > ans ( num + 1 , 0 ); for ( int i = 1 ; i <= num ; i ++ ) { ans [ i ] = ans [ i / 2 ] + i % 2 ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6bd4\u7279\u4f4d\u8ba1\u6570"},{"location":"algo/math/#_10","text":"\u4e24\u4e2a\u6574\u6570\u4e4b\u95f4\u7684\u6c49\u660e\u8ddd\u79bb\uff08Hamming Distance\uff09\u6307\u7684\u662f\u8fd9\u4e24\u4e2a\u6570\u5b57\u5bf9\u5e94\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u540c\u7684\u4f4d\u7f6e\u7684\u6570\u76ee\u3002 \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \u300c\u5206\u6790\u300d \u6309\u7167\u5b9a\u4e49\uff0c\u6c49\u660e\u8ddd\u79bb\u662f\u4e8c\u8fdb\u5236\u4e0d\u540c\u7684\u4f4d\u7f6e\u6570\u76ee\u548c\uff0c\u8fd9\u4e0e\u5f02\u6216\u8fd0\u7b97\u6070\u597d\u543b\u5408\u3002\u6211\u4eec\u53ef\u4ee5\u7387\u5148\u8ba1\u7b97\u5f02\u6216\u7684\u7ed3\u679c\uff0c\u7136\u540e\u4f7f\u7528 Brian Kernighan \u7b97\u6cd5\u6c42\u8fd9\u6570\u503c\u7684\u4e8c\u8fdb\u5236\u4e2a\u6570\u3002C++ \u4e2d\u6709\u5185\u7f6e\u51fd\u6570 __builtin_popcount() \uff0c\u53ef\u4ee5\u8c03\u7528\u3002 1 2 3 int hammingDistance ( int x , int y ) { return __builtin_popcount ( x ^ y ); } \u300c\u62d3\u5c55\u300d \u5982\u679c\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e 10000\uff0c\u6c42\u6570\u7ec4\u5185\u4efb\u610f\u4e24\u4e2a\u6570\u7684\u6c49\u540d\u8ddd\u79bb\u548c\u3002\u4f8b\u5982 arr = [4, 14, 2], \u5176\u6c49\u660e\u8ddd\u79bb\u548c\u662f\uff084\uff0c14\uff09+\uff084\uff0c2\uff09+\uff0814\uff0c2\uff09= 2 + 2 + 2 = 6 1 2 3 4 5 6 7 8 9 10 11 12 int totalHammingDistance ( vector < int >& nums ) { int n = ( int ) nums . size (); int ans = 0 ; for ( int i = 0 ; i < 30 ; i ++ ) { int cnt = 0 ; for ( int num : nums ) { cnt += ( num >> i ) & 1 ; } ans += cnt * ( n - cnt ); } return ans ; }","title":"\u6c49\u660e\u8ddd\u79bb"},{"location":"algo/math/#_11","text":"\u7ed9\u5b9a\u4e00\u4e2a\u533a\u95f4 [left, right] \u6c42\u8fd9\u4e2a\u533a\u95f4\u6240\u6709\u503c\u7684\u6309\u4f4d\u4e0e\uff0c\u5305\u62ec\u7aef\u70b9\u503c\u3002 \u300c\u5206\u6790\u300d \u3010Brian Kernighan \u7b97\u6cd5\u3011\u5bf9\u4e8e [left, right] \u533a\u95f4\u5185\u7684\u6240\u6709\u503c\uff0c\u6309\u7167\u9898\u610f\u7ed3\u679c\u5e94\u4e3a \\text{res = left & left+1 &} \\cdots \\text{& right-1 & right} \\text{res = left & left+1 &} \\cdots \\text{& right-1 & right} \u4e24\u4e2a\u6570\u6309\u4f4d\u4e0e\u7684\u7ed3\u679c\u52bf\u5fc5\u4e0d\u8d85\u8fc7\u4e24\u6570\u4e2d\u8f83\u5c0f\u7684\u90a3\u4e2a\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u53f3\u7aef\u70b9\u5f00\u59cb\u4e0d\u65ad\u6c42\u4e24\u76f8\u90bb\u6570\u7684\u6309\u4f4d\u4e0e 1 2 3 4 5 6 int rangeBitwiseAnd ( int left , int right ) { while ( left < right ) { right &= right - 1 ; } return right ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log (right - left)) O(\\log (right - left)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u533a\u95f4\u6309\u4f4d\u4e0e"},{"location":"algo/math/#_12","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570a\u3001b\uff0c\u5728\u4e0d\u4f7f\u7528 +\u3001- \u7684\u60c5\u51b5\u4e0b\uff0c\u6c42 a + b \u300c\u5206\u6790\u300d \u5c06 a\u3001b\u8f6c\u5316\u4e3a\u4e8c\u8fdb\u5236\u6570\u503c\u8fdb\u884c\u8fd0\u7b97 1 2 3 4 5 6 7 8 9 int getSum ( int a , int b ) { while ( true ) { unsigned pos = unsigned ( a & b ); if ( pos == 0 ) { break ; } a ^= b ; b = pos << 1 ; } return a ^ b ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log \\min(\\left \\| a \\right \\|, \\left \\| b \\right \\|)) O(\\log \\min(\\left \\| a \\right \\|, \\left \\| b \\right \\|)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u4e0d\u4f7f\u7528\u52a0\u51cf\u8fd0\u7b97\u7b26\u6c42\u4e24\u6570\u4e4b\u548c"},{"location":"algo/math/#_13","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 A = [1, 2, 3] \u548c B = [5, 6]\uff0cA \u548c B \u7684\u5143\u7d20\u4e24\u4e24\u6309\u4f4d\u4e0e\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u5f62\u6210\u4e00\u4e2a len(A) * len(B) \u7684\u6570\u7ec4\uff0c\u6c42\u8fd9\u4e2a\u6570\u7ec4\u5143\u7d20\u7684\u5f02\u6216\u548c\u3002 \u300c\u5206\u6790\u300d \u3010\u4f4d\u8fd0\u7b97\u3011\u5047\u8bbe\u6700\u540e\u7684\u7ed3\u679c\u6709 m \u4f4d\uff0c\u5728\u6240\u6709\u7684\u6309\u4f4d\u4e0e\u7ed3\u679c\u4e2d\uff0c\u7b2c k \u4f4d\u4e0a\uff0c\u5fc5\u987b\u6709\u5947\u6570\u4e2a 1\uff0c\u6700\u7ec8\u7b54\u6848\u7684\u7b2c k \u4f4d\u624d\u4f1a\u662f 1\u3002\u56e0\u4e3a len(A) * len(B) \u662f\u5947\u6570\uff0c\u90a3\u4e48 len(A) \u548c len(B) \u90fd\u662f\u5947\u6570\uff0c\u6240\u6709 A \u548c B \u7684\u5f02\u6216\u548c\u7684\u7b2c k \u4f4d\u5fc5\u987b\u662f 1\u3002 1 2 3 4 5 6 7 8 9 10 int getXORSum ( vector < int >& arr1 , vector < int >& arr2 ) { int sum1 = 0 , sum2 = 0 ; for ( int num : arr1 ) { sum1 ^= num ; } for ( int num : arr2 ) { sum2 ^= num ; } return sum1 & sum2 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6309\u4f4d\u4e0e\u540e\u7684\u5f02\u6216\u548c"},{"location":"algo/math/#_14","text":"\u7ed9\u4f60\u4e00\u4e2a\u975e\u7a7a\u6574\u6570\u6570\u7ec4 nums \uff0c\u9664\u4e86\u67d0\u4e2a\u5143\u7d20\u53ea\u51fa\u73b0\u4e00\u6b21\u4ee5\u5916\uff0c\u5176\u4f59\u6bcf\u4e2a\u5143\u7d20\u5747\u51fa\u73b0\u4e24\u6b21\u3002\u627e\u51fa\u90a3\u4e2a\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\u7684\u5143\u7d20\u3002\u8981\u6c42\u7ebf\u5f62\u65f6\u95f4\u590d\u6742\u5ea6\u548c\u5e38\u6570\u7a7a\u95f4\u590d\u6742\u5ea6\u3002\u4f8b\u5982\uff0cnums = [4,1,2,1,2]\uff0c\u6700\u540e\u8fd4\u56de 4\u3002 \u300c\u5206\u6790\u300d \u4e24\u4e2a\u76f8\u7b49\u7684\u6570\u8fdb\u884c\u300c\u5f02\u6216\u300d\u64cd\u4f5c\u4f1a\u53d8\u62100\u3002 1 2 3 4 5 6 7 int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int & ele : nums ) { ans ^= ele ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57"},{"location":"algo/math/#i","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 2, 2, 3] \u53ea\u6709\u4e24\u4e2a\u6570\u7ec4\u51fa\u73b0 1 \u6b21\uff0c\u5176\u4f59\u90fd\u51fa\u73b0\u4e24\u6b21\uff0c\u6c42\u8fd9\u4e2a\u4e24\u4e2a\u6570\u5b57 \u300c\u5206\u6790\u300d \u3010\u5f02\u6216\u8fd0\u7b97\u3011\u4e24\u4e2a\u76f8\u540c\u7684\u6570\u5f02\u6216\u7ed3\u679c\u662f 0\u3002\u6839\u636e\u6574\u4e2a\u6570\u7ec4\u7684\u5f02\u6216\u548c res \u7684\u6700\u9ad8\u4f4d\u6765\u533a\u5206\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u5355\u6b21\u51fa\u73b0\u7684\u6570\u5b57\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < int > singleNumbers ( vector < int >& nums ) { vector < int > ans ; int XOR = 0 ; for ( int num : nums ) { XOR ^= num ; } int pos = 0 ; while ( XOR >> 1 ) { pos ++ ; XOR >>= 1 ; } int a = 0 , b = 0 ; for ( int num : nums ) { ( num >> pos ) & 1 ? a ^= num : b ^= num ; } return vector < int > { a , b }; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 I"},{"location":"algo/math/#ii","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [4, 3, 3, 3]\uff0c\u53ea\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u4e00\u6b21\uff0c\u5176\u4f59\u90fd\u51fa\u73b0\u4e09\u6b21\uff0c\u7528\u7ebf\u6027\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u548c\u5e38\u6570\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u627e\u5230\u8fd9\u4e2a\u6570\u5b57\u3002 \u300c\u5206\u6790\u300d \u3010\u4f4d\u8fd0\u7b97\u3011\u6bcf\u4e00\u4f4d\u4e0a\u7684 1 \u7684\u6570\u76ee\u4e00\u5b9a\u662f 3 \u7684\u500d\u6570\u52a0\u4e00\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int singleNumber ( vector < int >& nums ) { int ans = 0 ; vector < int > bits ( 32 , 0 ); for ( int num : nums ) { for ( int i = 0 ; ( 1l << i ) <= num && i < 32 ; i ++ ) { bits [ i ] += ( num >> i ) & 1 ; } } for ( int i = 0 ; i < 32 ; i ++ ) { ans |= ( 1 << i ) * ( bits [ i ] % 3 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 II"},{"location":"algo/math/#_15","text":"\u4e00\u4e2a\u516c\u5f0f\uff1a(A * B) % k = ((A % k) * (B % k)) % k","title":"\u53d6\u6a21"},{"location":"algo/math/#_16","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 a = 2 \u548c \u4e00\u4e2a\u6570\u7ec4 b = [1, 0] \u8868\u793a\u5e42\u4e3a 10\uff0c\u6c42 a^{b} a^{b} \u5bf9 1337 \u53d6\u6a21\u3002 \u300c\u5206\u6790\u300d \u4ee5\u7ed9\u51fa\u7684 a \u548c b \u4e3a\u4f8b a^{b} = 2^{[1, 0]} = (2^{[1]})^{10} \\cdot 2^{0} a^{b} = 2^{[1, 0]} = (2^{[1]})^{10} \\cdot 2^{0} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int mod = 1337 ; int pow ( int a , int p ) { int ans = 1 ; while ( p > 0 ) { if ( p & 1 ) { ans = (( ans % mod ) * ( a % mod )) % mod ; } p >>= 1 ; a = (( a % mod ) * ( a % mod )) % mod ; } return ans ; } int superPow ( int a , vector < int >& b ) { if ( b . empty ()) { return 1 ; } int res1 = pow ( a , b . back ()); b . pop_back (); int res2 = pow ( superPow ( a , b ), 10 ); return (( res1 % mod ) * ( res2 % mod )) % mod ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cn \u662f b \u7684\u957f\u5ea6","title":"\u5e42\u6307\u6570\u53d6\u6a21"},{"location":"algo/math/#_17","text":"","title":"\u9636\u4e58"},{"location":"algo/math/#0","text":"\u8ba1\u7b97 n \u7684\u9636\u4e58\u6709\u591a\u5c11\u4e2a\u5c3e0\u3002 \u300c\u5206\u6790\u300d \u4e00\u4e2a\u6570\u7684\u5c3e0\u4e2a\u6570\u4ee3\u8868\u80fd\u591f\u5bf9 10 \u53d6\u4f59\u6570\u7684\u6b21\u6570\u300210 = 2 * 5\uff0c\u56e0\u6b64\u662f\u6c42 2 \u548c 5 \u6574\u9664\u7684\u4e2a\u6570\uff0c\u5e76\u4e14\u88ab 5 \u6574\u9664\u7684\u4e2a\u6570\u662f\u5c11\u4e8e\u88ab 2 \u6574\u9664\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 int trailingZeroes ( int n ) { int ans = 0 ; while ( n >= 5 ) { n /= 5 ; ans += n ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u9636\u4e58\u5c3e\u65700\u7684\u4e2a\u6570"},{"location":"algo/math/#_18","text":"","title":"\u6570\u5b57"},{"location":"algo/math/#_19","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6570 n \u548c\u4e00\u4e2a 1 - 9 \u7684\u6570\u5b57 digit\uff0c\u7edf\u8ba1 1 - n \u6240\u6709\u6570\u5b57\u4e2d digit \u51fa\u73b0\u7684\u6b21\u6570\u3002\u4f8b\u5982 n = 13\uff0cdigit = 1\uff0c\u5305\u542b 1 \u7684\u6570\u5b57\u6709\uff1a1\u300110\u300111\u300112\u300113\uff0c1 \u51fa\u73b0\u4e86 6 \u6b21\u3002 \u300c\u5206\u6790\u300d \u8fd9\u662f\u4e00\u4e2a\u6570\u5b66\u9898\u76ee\uff0c\u4ee5 n = 2593\uff0cdigit = 5 \u4e3a\u4f8b \u4f4d \u5546 \u4f59\u6570 digit = '5' \u4e2a\u6570 \u4e2a\u4f4d i = 1 Quotient = 2593 / (10 * i) = 259 Mod = 2593 % (10 * i) = 3 259 * i + (3 > 5) * i = 259 \u4e2a\u4f4d i = 10 Quotient = 2593 / (10 * i) = 25 Mod = 2593 % (10 * i) = 93 25 * i + (9 > 5) * i = 260 \u4e2a\u4f4d i = 100 Quotient = 2593 / (10 * i) = 2 Mod = 2593 % (10 * i) = 593 2 * i + (5 == 5) * (93 + 1) = 294 \u4e2a\u4f4d i = 1000 Quotient = 2593 / (10 * i) = 0 Mod = 2593 % (10 * i) = 2593 0 * i + (2 > 5) * i = 0 \u603b\u8ba1 '5' \u7684\u4e2a\u6570\uff1a 259 + 260 + 294 = 813. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int countDigitOne ( int n , int digit = 1 ) { int ans = 0 ; for ( unsigned int i = 1 ; i <= n ; i *= 10 ) { int quo = n / ( 10ll * i ), mod = n % ( 10ll * i ); ans += quo * i ; if ( mod / i > digit ) { ans += i ; } else if ( mod / i == digit ) { ans += mod % i + 1 ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u7edf\u8ba1\u67d0\u4e2a\u6570\u5b57\u7684\u51fa\u73b0\u4e2a\u6570"},{"location":"algo/math/#_20","text":"","title":"\u7edd\u5bf9\u503c"},{"location":"algo/math/#_21","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 arr1 = [1, -2, -5, 0, 10], arr2 = [0, -2, -1, -7, -4]\uff0c\u6c42\u4e0b\u5f0f\u7684\u6700\u5927\u503c \\max_{i, j \\in [0, n)} \\left | i - j \\right | + \\left | \\text{A[ i ]} - \\text{A[ j ]} \\right | + \\left | \\text{B[ i ]} - \\text{B[ j ]} \\right | \\max_{i, j \\in [0, n)} \\left | i - j \\right | + \\left | \\text{A[ i ]} - \\text{A[ j ]} \\right | + \\left | \\text{B[ i ]} - \\text{B[ j ]} \\right | \u300c\u5206\u6790\u300d \u5982\u679c\u6c42 |A[ i ] - A[ j ]| \u7684\u6700\u5927\u503c\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u7684\u77e5\u9053\u7b49\u4ef7\u4e8e max(A) - min(A) \u3002\u540c\u6837\u5730\u5bf9\u4e8e\u4e09\u4e2a\u7edd\u5bf9\u503c \\begin{aligned} & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(A[ i ] + B[ i ] + i) - (A[ j ] + B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(A[ i ] + B[ i ] - i) - (A[ j ] + B[ j ] - j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(A[ i ] - B[ i ] + i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(A[ i ] - B[ i ] - i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(- A[ i ] + B[ i ] + i) - (- A[ j ] + B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(- A[ i ] + B[ i ] - i) - (- A[ j ] + B[ j ] - j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(- A[ i ] - B[ i ] + i) - (- A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(- A[ i ] - B[ i ] - i) - (- A[ j ] - B[ j ] + j)} \\end{aligned} \\begin{aligned} & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(A[ i ] + B[ i ] + i) - (A[ j ] + B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(A[ i ] + B[ i ] - i) - (A[ j ] + B[ j ] - j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(A[ i ] - B[ i ] + i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{A[ i ] - A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(A[ i ] - B[ i ] - i) - (A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] + i - j} = \\text{(- A[ i ] + B[ i ] + i) - (- A[ j ] + B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] + B[ i ] - B[ j ] - i + j} = \\text{(- A[ i ] + B[ i ] - i) - (- A[ j ] + B[ j ] - j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] + i - j} = \\text{(- A[ i ] - B[ i ] + i) - (- A[ j ] - B[ j ] + j)} \\\\ & \\text{- A[ i ] + A[ j ] - B[ i ] + B[ j ] - i + j} = \\text{(- A[ i ] - B[ i ] - i) - (- A[ j ] - B[ j ] + j)} \\end{aligned} \u56e0\u6b64\u53ef\u4ee5\u5c06\u4e0a\u5f0f\u5b50\u5f52\u7eb3\u6210 \\begin{aligned} & p = \\text{A[ i ] + B[ i ] + i} \\\\ & Q = \\text{A[ i ] + B[ i ] - i} \\\\ & M = \\text{A[ i ] - B[ i ] + i} \\\\ & N = \\text{A[ i ] - B[ i ] - i} \\end{aligned} \\begin{aligned} & p = \\text{A[ i ] + B[ i ] + i} \\\\ & Q = \\text{A[ i ] + B[ i ] - i} \\\\ & M = \\text{A[ i ] - B[ i ] + i} \\\\ & N = \\text{A[ i ] - B[ i ] - i} \\end{aligned} \u6700\u7ec8\u7684\u7ed3\u679c\u4e3a \\max \\begin{cases} \\max(P) - \\min(P) \\\\ \\max(Q) - \\min(Q) \\\\ \\max(M) - \\min(M) \\\\ \\max(N) - \\min(N) \\end{cases} \\max \\begin{cases} \\max(P) - \\min(P) \\\\ \\max(Q) - \\min(Q) \\\\ \\max(M) - \\min(M) \\\\ \\max(N) - \\min(N) \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int maxAbsValExpr ( vector < int >& arr1 , vector < int >& arr2 ) { int n = ( int ) arr1 . size (), ans = 0 ; vector < vector < int >> max_min ( 4 , vector < int > { INT_MIN , INT_MAX }); for ( int i = 0 ; i < n ; i ++ ) { max_min [ 0 ][ 0 ] = max ( max_min [ 0 ][ 0 ], arr1 [ i ] + arr2 [ i ] + i ); max_min [ 0 ][ 1 ] = min ( max_min [ 0 ][ 1 ], arr1 [ i ] + arr2 [ i ] + i ); max_min [ 1 ][ 0 ] = max ( max_min [ 1 ][ 0 ], arr1 [ i ] + arr2 [ i ] - i ); max_min [ 1 ][ 1 ] = min ( max_min [ 1 ][ 1 ], arr1 [ i ] + arr2 [ i ] - i ); max_min [ 2 ][ 0 ] = max ( max_min [ 2 ][ 0 ], arr1 [ i ] - arr2 [ i ] + i ); max_min [ 2 ][ 1 ] = min ( max_min [ 2 ][ 1 ], arr1 [ i ] - arr2 [ i ] + i ); max_min [ 3 ][ 0 ] = max ( max_min [ 3 ][ 0 ], arr1 [ i ] - arr2 [ i ] - i ); max_min [ 3 ][ 1 ] = min ( max_min [ 3 ][ 1 ], arr1 [ i ] - arr2 [ i ] - i ); } for ( int i = 0 ; i < 4 ; i ++ ) { ans = max ( ans , max_min [ i ][ 0 ] - max_min [ i ][ 1 ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u7edd\u5bf9\u503c\u5dee\u7684\u6700\u5927\u548c"},{"location":"algo/math/#_22","text":"\u5982\u679c\u4e00\u4e2a\u6574\u6570\uff0c\u5b83\u7684\u8d28\u56e0\u5b50\u53ea\u5728 2\u30013\u30015 \u4e4b\u4e2d\uff0c\u90a3\u4e48\u5c31\u662f\u4e11\u6570\u3002\u5982 15 = 3 * 5","title":"\u4e11\u6570"},{"location":"algo/math/#i_1","text":"\u5224\u65ad\u662f\u5426\u662f\u4e11\u6570 1 2 3 4 5 6 7 bool isUgly ( int n ) { if ( n <= 0 ) { return false ; } while ( n % 2 == 0 ) { n /= 2 ; } while ( n % 3 == 0 ) { n /= 3 ; } while ( n % 5 == 0 ) { n /= 5 ; } return n == 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u4e11\u6570 I"},{"location":"algo/math/#ii_1","text":"\u6c42\u7b2c n \u4e2a\u4e11\u6570 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 \u662f\u524d 10 \u4e2a\u4e11\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 int nthUglyNumber ( int n ) { if ( n == 0 ) { return 1 ; } vector < int > dp ( n , 0 ); int f2 = 0 , f3 = 0 , f5 = 0 ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ f2 ] * 2 , min ( dp [ f3 ] * 3 , dp [ f5 ] * 5 )); if ( dp [ i ] == dp [ f2 ] * 2 ) { f2 ++ ; } if ( dp [ i ] == dp [ f3 ] * 3 ) { f3 ++ ; } if ( dp [ i ] == dp [ f5 ] * 5 ) { f5 ++ ; } } return dp [ n - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u4e11\u6570 II"},{"location":"algo/math/#iii","text":"\u7ed9\u5b9a\u4e00\u4e2a\u8d28\u6570\u6570\u7ec4 primes = [2, 7, 13, 19]\uff0c\u6c42\u7b2c n \u4e2a\u8d85\u7ea7\u4e11\u6570\uff0c\u6ee1\u8db3\u6240\u6709\u7684\u8d28\u56e0\u5b50\u90fd\u5728\u8fd9\u4e2a primes \u6570\u7ec4\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int nthSuperUglyNumber ( int n , vector < int >& primes ) { int m = ( int ) primes . size (); vector < int > dp ( n , 0 ), f ( m , 0 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int minVal = INT_MAX ; for ( int j = 0 ; j < m ; j ++ ) { minVal = min ( minVal , dp [ f [ j ]] * primes [ j ]); } dp [ i ] = minVal ; for ( int j = 0 ; j < m ; j ++ ) { if ( dp [ f [ j ]] * primes [ j ] == dp [ i ]) { f [ j ] ++ ; } } } return dp [ n - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) \uff0cm \u662f primes \u7684\u957f\u5ea6","title":"\u4e11\u6570 III"},{"location":"algo/math/#iv","text":"\u7ed9\u5b9a\u56db\u4e2a\u6574\u6570\uff0cn = 1000000000, a = 2, b = 217983653, c = 336916467\uff0c\u6c42\u7b2c n \u4e2a\u6570\uff0c\u8fd9\u4e2a\u6570\u53ef\u4ee5\u6574\u9664 a\u3001b\u3001c\u5176\u4e2d\u7684\u4e00\u4e2a\u6216\u591a\u4e2a\u3002 \u300c\u5206\u6790\u300d [1, X] \u4e4b\u95f4\uff0c\u6709\u591a\u5c11\u4e2a\u6570\u53ef\u4ee5\u88ab a e.g. \u6574\u9664\uff1f\u7b54\u6848\u662f\uff1a \\left \\lfloor \\frac{X}{a} \\right \\rfloor \\left \\lfloor \\frac{X}{a} \\right \\rfloor \uff0c\u90a3\u4e48\u5bf9\u4e8e a\u3001b\u3001c \u4e09\u4e2a\u9664\u6570\u800c\u8a00\uff0c[1, X] \u533a\u95f4\u4e2d\u7b26\u5408\u6761\u4ef6\u7684\u4e2a\u6570\u662f \\begin{aligned} \\text{ans} =& \\left \\lfloor \\frac{X}{a} \\right \\rfloor + \\left \\lfloor \\frac{X}{b} \\right \\rfloor + \\left \\lfloor \\frac{X}{c} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(a, b)} \\right \\rfloor - \\left \\lfloor \\frac{X}{\\text{LCM}(a, c)} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(b, c)} \\right \\rfloor + \\left \\lfloor \\frac{X}{\\text{LCM}(a, b, c)} \\right \\rfloor \\end{aligned} \\begin{aligned} \\text{ans} =& \\left \\lfloor \\frac{X}{a} \\right \\rfloor + \\left \\lfloor \\frac{X}{b} \\right \\rfloor + \\left \\lfloor \\frac{X}{c} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(a, b)} \\right \\rfloor - \\left \\lfloor \\frac{X}{\\text{LCM}(a, c)} \\right \\rfloor \\\\ &- \\left \\lfloor \\frac{X}{\\text{LCM}(b, c)} \\right \\rfloor + \\left \\lfloor \\frac{X}{\\text{LCM}(a, b, c)} \\right \\rfloor \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 long lcm ( int a , int b ) { long mul = ( long ) a * b ; while ( a != 0 && b != 0 ) { if ( a > b ) { a %= b ; } else { b %= a ; } } return mul / ( a + b ); } int nthUglyNumber ( int n , int a , int b , int c ) { long ab = lcm ( a , b ), bc = lcm ( b , c ), ac = lcm ( a , c ); long abc = lcm ( ab , c ), l = 0 , r = INT_MAX ; while ( l < r ) { long m = ( l + r ) >> 1 ; long res = m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc ; if ( res < n ) { l = m + 1 ; } else { r = m ; } } return ( int ) l ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log INT_MAX) O(\\log INT_MAX) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u4e11\u6570 IV"},{"location":"algo/math/#_23","text":"\u6469\u5c14\u6295\u7968\u6cd5\u662f\u4e00\u79cd\u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u7684\u7b97\u6cd5\uff0c\u7528\u6765\u627e\u5230\u4e00\u4e2a\u6570\u7ec4\u7684\u591a\u6570\u5143\u7d20\u3002\u8fd9\u91cc\u7684\u591a\u6570\uff0c\u53ef\u4ee5\u662f\u8d85\u8fc7\u6574\u4e2a\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u4e5f\u53ef\u4ee5\u662f\u8d85\u8fc7\u6574\u4e2a\u6570\u7ec4\u7684\u2153\u3002 \u7b97\u6cd5\u7684\u601d\u60f3\u662f\u7528\u4e00\u4e2a\u5143\u7d20\u4e0e\u53e6\u4e00\u4e2a\u5143\u7d20\u62b5\u6d88\u3002","title":"\u6469\u5c14\u6295\u7968\u6cd5"},{"location":"algo/math/#_24","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int majorityElement ( vector < int >& nums ) { int n = int ( nums . size ()); int count = 0 , maj = - 1 ; for ( int num : nums ) { if ( count == 0 ) { maj = num ; count = 1 ; continue ; } if ( num == maj ) { count ++ ; } else { count -- ; } } return maj ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u627e\u5230\u8d85\u8fc7\u4e00\u534a\u7684\u5143\u7d20"},{"location":"algo/math/#_25","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; if ( nums . empty ()) { return ans ; } int cddt1 = nums [ 0 ], cddt2 = nums [ 0 ], cnt1 = 0 , cnt2 = 0 ; for ( int num : nums ) { if ( cddt1 == num ) { cnt1 ++ ; continue ; } if ( cddt2 == num ) { cnt2 ++ ; continue ; } if ( cnt1 == 0 ) { cnt1 ++ ; cddt1 = num ; continue ; } if ( cnt2 == 0 ) { cnt2 ++ ; cddt2 = num ; continue ; } cnt1 -- ; cnt2 -- ; } cnt1 = 0 ; cnt2 = 0 ; for ( int num : nums ) { if ( cddt1 == num ) { cnt1 ++ ; } else if ( cddt2 == num ) { cnt2 ++ ; } } if ( cnt1 > nums . size () / 3 ) { ans . emplace_back ( cddt1 ); } if ( cnt2 > nums . size () / 3 ) { ans . emplace_back ( cddt2 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u627e\u5230\u8d85\u8fc7\u4e09\u5206\u4e4b\u4e00\u7684\u5143\u7d20\uff08\u4eec\uff09"},{"location":"algo/math/#_26","text":"","title":"\u7f16\u7801"},{"location":"algo/math/#_27","text":"\u683c\u96f7\u7f16\u7801\u662f\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\u5b57\u7cfb\u7edf\uff0c\u5728\u8be5\u7cfb\u7edf\u4e2d\uff0c\u4e24\u4e2a\u8fde\u7eed\u7684\u6570\u503c\u4ec5\u6709\u4e00\u4e2a\u4f4d\u6570\u7684\u5dee\u5f02\u3002\u7ed9\u5b9a\u4e00\u4e2a\u4ee3\u8868\u7f16\u7801\u603b\u4f4d\u6570\u7684\u975e\u8d1f\u6574\u6570 n\uff0c\u6253\u5370\u5176\u683c\u96f7\u7f16\u7801\u5e8f\u5217\u3002\u5373\u4f7f\u6709\u591a\u4e2a\u4e0d\u540c\u7b54\u6848\uff0c\u4f60\u4e5f\u53ea\u9700\u8981\u8fd4\u56de\u5176\u4e2d\u4e00\u79cd\u3002\u683c\u96f7\u7f16\u7801\u5e8f\u5217\u5fc5\u987b\u4ee5 0 \u5f00\u5934\u3002\u4f8b\u5982 n = 2\uff0c\u4f1a\u5f97\u5230 4 \u4e2a\u7f16\u7801 \\begin{matrix} 00 & \\rightarrow & 0 \\\\ 01 & \\rightarrow & 1 \\\\ 11 & \\rightarrow & 3 \\\\ 10 & \\rightarrow & 2 \\end{matrix} \\begin{matrix} 00 & \\rightarrow & 0 \\\\ 01 & \\rightarrow & 1 \\\\ 11 & \\rightarrow & 3 \\\\ 10 & \\rightarrow & 2 \\end{matrix} \u300c\u5206\u6790\u300d \u683c\u96f7\u7f16\u7801\u7684\u516c\u5f0f \\text{GrayCode}(i) = i \\text{ XOR } \\left \\lfloor \\frac{i}{2} \\right \\rfloor \\text{GrayCode}(i) = i \\text{ XOR } \\left \\lfloor \\frac{i}{2} \\right \\rfloor 1 2 3 4 5 6 7 vector < int > grayCode ( int n ) { vector < int > ans ( 1 << n , 0 ); for ( int i = 1 ; i < ( 1 << n ); i ++ ) { ans [ i ] = i ^ ( i >> 1 ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u683c\u96f7\u7f16\u7801"},{"location":"algo/math/#_28","text":"","title":"\u4fe1\u606f\u8bba"},{"location":"algo/math/#_29","text":"\u6709 buckets \u6876\u6db2\u4f53\uff0c\u5176\u4e2d \u6b63\u597d \u6709\u4e00\u6876\u542b\u6709\u6bd2\u836f\uff0c\u5176\u4f59\u88c5\u7684\u90fd\u662f\u6c34\u3002\u5b83\u4eec\u4ece\u5916\u89c2\u770b\u8d77\u6765\u90fd\u4e00\u6837\u3002\u4e3a\u4e86\u5f04\u6e05\u695a\u54ea\u53ea\u6c34\u6876\u542b\u6709\u6bd2\u836f\uff0c\u4f60\u53ef\u4ee5\u5582\u4e00\u4e9b\u732a\u559d\uff0c\u901a\u8fc7\u89c2\u5bdf\u732a\u662f\u5426\u4f1a\u6b7b\u8fdb\u884c\u5224\u65ad\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u4f60\u53ea\u6709 minutesToTest \u5206\u949f\u65f6\u95f4\u6765\u786e\u5b9a\u54ea\u6876\u6db2\u4f53\u662f\u6709\u6bd2\u7684\u3002 \u5582\u732a\u7684\u89c4\u5219\u5982\u4e0b\uff1a \u9009\u62e9\u82e5\u5e72\u6d3b\u732a\u8fdb\u884c\u5582\u517b \u53ef\u4ee5\u5141\u8bb8\u5c0f\u732a\u540c\u65f6\u996e\u7528\u4efb\u610f\u6570\u91cf\u7684\u6876\u4e2d\u7684\u6c34\uff0c\u5e76\u4e14\u8be5\u8fc7\u7a0b\u4e0d\u9700\u8981\u65f6\u95f4\u3002 \u5c0f\u732a\u559d\u5b8c\u6c34\u540e\uff0c\u5fc5\u987b\u6709 minutesToDie \u5206\u949f\u7684\u51b7\u5374\u65f6\u95f4\u3002\u5728\u8fd9\u6bb5\u65f6\u95f4\u91cc\uff0c\u4f60\u53ea\u80fd\u89c2\u5bdf\uff0c\u800c\u4e0d\u5141\u8bb8\u7ee7\u7eed\u5582\u732a\u3002 \u8fc7\u4e86 minutesToDie \u5206\u949f\u540e\uff0c\u6240\u6709\u559d\u5230\u6bd2\u836f\u7684\u732a\u90fd\u4f1a\u6b7b\u53bb\uff0c\u5176\u4ed6\u6240\u6709\u732a\u90fd\u4f1a\u6d3b\u4e0b\u6765\u3002 \u91cd\u590d\u8fd9\u4e00\u8fc7\u7a0b\uff0c\u76f4\u5230\u65f6\u95f4\u7528\u5b8c\u3002 \u7ed9\u4f60\u6876\u7684\u6570\u76ee buckets \uff0cminutesToDie \u548c minutesToTest \uff0c\u8fd4\u56de\u5728\u89c4\u5b9a\u65f6\u95f4\u5185\u5224\u65ad\u54ea\u4e2a\u6876\u6709\u6bd2\u6240\u9700\u7684 \u6700\u5c0f \u732a\u6570\u3002 \u300c\u5206\u6790\u300d \u8bbe m \u4e2a\u5c0f\u732a\uff0c\u5b9e\u9a8c\u8f6e\u6570 n = \\left \\lfloor \\frac{\\text{minutesToTest}}{\\text{minutesToDie}} \\right \\rfloor \\left \\lfloor \\frac{\\text{minutesToTest}}{\\text{minutesToDie}} \\right \\rfloor \uff0c\u90a3\u4e48\u5bf9\u4e00\u4e2a\u5c0f\u732a\u800c\u8a00\uff0c\u4ece\u5b9e\u9a8c\u5f00\u59cb\u5230\u5b9e\u9a8c\u7ed3\u675f\u4e00\u5171\u6709 (1 + n) \u4e2a\u72b6\u6001\u3002\u8fd9\u91cc\u7684 1 \u6307\u7684\u662f\u521d\u59cb\u72b6\u6001\uff0c\u4e4b\u540e\u6bcf\u4e00\u8f6e\u5b9e\u9a8c\u90fd\u4f1a\u6709\u4e00\u4e2a\u72b6\u6001\u3002\u56e0\u6b64 buckets \u4e2a\u6876\u786e\u5b9a\u6709\u4e00\u4e2a\u662f\u6bd2\u836f\uff0c\u6240\u4ee5\uff0c\u6bd2\u836f\u7684\u72b6\u6001\u6570\u662f buckets\u3002\u56e0\u6b64\uff0c (n + 1)^{m} \\geq \\text{buckets} (n + 1)^{m} \\geq \\text{buckets} \u53ef\u4ee5\u89e3\u51fa\u6765 m \u7684\u6700\u5c0f\u503c m = \\left \\lceil \\log_{n + 1}\\text{buckets} \\right \\rceil m = \\left \\lceil \\log_{n + 1}\\text{buckets} \\right \\rceil 1 2 3 int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ceil ( log ( buckets ) / log ( minutesToTest / minutesToDie + 1 )); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u53ef\u601c\u7684\u5c0f\u732a"},{"location":"algo/matrix/","text":"\u65b9\u9635\u65cb\u8f6c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u65b9\u9635 n \\times n n \\times n \uff0c\u5c06\u5176\u6309\u7167\u987a\u65f6\u9488\u7684\u65b9\u5411\u65cb\u8f6c 90\u02da\u3002\u8981\u6c42\u4f7f\u7528\u5e38\u6570\u7a7a\u95f4\u3002 \u300c\u5206\u6790\u300d \u76f4\u63a5\u6309\u7167\u9898\u610f\u8fdb\u884c\u6a21\u62df\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u4e00\u6b21\u65cb\u8f6c 90\u02da \u76f8\u5f53\u4e8e\u6240\u6709\u7684\u5143\u7d20\u987a\u65f6\u9488\u8f6c\u52a8\u4e00\u6b21\uff0c\u4f8b\u5982 (0, 0) -> (0, n-1) -> (n-1, n-1) -> (n-1, 0) -> (0, 0)\u3002\u5e76\u4e14\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u5916\u5708\u7684\u5143\u7d20\u5747\u662f\u5982\u6b64\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 void rotate ( vector < vector < int >>& matrix ) { int n = ( int ) matrix . size (); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - i - 1 ; j ++ ) { int tmp = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ n - 1 - j ][ i ]; matrix [ n - 1 - j ][ i ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ j ][ n - 1 - i ]; matrix [ j ][ n - 1 - i ] = tmp ; } } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u77e9\u9635"},{"location":"algo/matrix/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u65b9\u9635 n \\times n n \\times n \uff0c\u5c06\u5176\u6309\u7167\u987a\u65f6\u9488\u7684\u65b9\u5411\u65cb\u8f6c 90\u02da\u3002\u8981\u6c42\u4f7f\u7528\u5e38\u6570\u7a7a\u95f4\u3002 \u300c\u5206\u6790\u300d \u76f4\u63a5\u6309\u7167\u9898\u610f\u8fdb\u884c\u6a21\u62df\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u4e00\u6b21\u65cb\u8f6c 90\u02da \u76f8\u5f53\u4e8e\u6240\u6709\u7684\u5143\u7d20\u987a\u65f6\u9488\u8f6c\u52a8\u4e00\u6b21\uff0c\u4f8b\u5982 (0, 0) -> (0, n-1) -> (n-1, n-1) -> (n-1, 0) -> (0, 0)\u3002\u5e76\u4e14\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u5916\u5708\u7684\u5143\u7d20\u5747\u662f\u5982\u6b64\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 void rotate ( vector < vector < int >>& matrix ) { int n = ( int ) matrix . size (); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - i - 1 ; j ++ ) { int tmp = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ n - 1 - j ][ i ]; matrix [ n - 1 - j ][ i ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ j ][ n - 1 - i ]; matrix [ j ][ n - 1 - i ] = tmp ; } } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u65b9\u9635\u65cb\u8f6c"},{"location":"algo/prefix-sum/","text":"\u7b80\u4ecb \u00b6 \u524d\u7f00\u548c\uff0c\u987e\u540d\u601d\u4e49\uff0c\u5c06\u4e00\u4e2a\u5e8f\u5217\u7684\u524d n \u4e2a\u5143\u7d20\u7d2f\u52a0\u8d77\u6765\u3002 \u9898\u76ee \u00b6 \u548c\u4e3aK\u7684\u5b50\u6570\u7ec4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u548c\u4e00\u4e2a k \u503c\uff0c\u6c42\u6240\u6709\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u7b49\u4e8e k \u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u66b4\u529b\u679a\u4e3e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\u8fbe n^{3} n^{3} \uff0c\u5229\u7528\u524d\u7f00\u548c\u7684\u590d\u6742\u5ea6\u4e5f\u4f1a\u8fbe\u5230 n^{2} n^{2} \uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u524d\u7f00\u548c + \u54c8\u5e0c\u8868\u8fdb\u4e00\u6b65\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 int ans = 0 , sum = 0 ; unordered_map < int , int > cnt ; for ( int num : nums ) { sum += num ; if ( sum == k ) { ans ++ ; } if ( cnt . count ( sum - k )) { ans += cnt [ sum - k ]; } cnt [ sum ] ++ ; } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002 \u5143\u7d20\u548c\u4e3a\u76ee\u6807\u503c\u7684\u5b50\u77e9\u9635\u6570\u91cf \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u77e9\u9635 matrix \uff08 m \\times n m \\times n \uff09 \u548c\u4e00\u4e2a\u76ee\u6807\u503c target\uff0c\u8ba1\u7b97\u51fa\u6240\u6709\u7684\u5b50\u77e9\u9635\u548c\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u9898\u76ee\u8981\u6c42\u662f\u77e9\u9635\u548c\uff0c\u5f88\u5bb9\u6613\u8054\u60f3\u5230\u524d\u7f00\u548c\u3002\u4f46\u662f\u5982\u679c\u5728\u524d\u7f00\u548c\u7684\u57fa\u7840\u4e0a\uff0c\u66b4\u529b\u5faa\u73af\u6c42\u89e3\u7684\u8bdd\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(m^{2}n^{2}) O(m^{2}n^{2}) \uff0c\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u4e3a\u4e86\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u6211\u4eec\u4f7f\u7528\u54c8\u5e0c\u8868\u7684\u65b9\u6cd5\u3002\u5177\u4f53\u5730\uff0c\u4e00\u4e2a\u77e9\u5f62\u6709\u56db\u4e2a\u8fb9\u957f\uff0c\u6211\u4eec\u9996\u5148\u786e\u5b9a\u4e0a\u8fb9\u548c\u4e0b\u8fb9\uff0c\u5728\u4f9d\u6b21\u904d\u5386\u5de6\u8fb9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6b64\u65f6\u7684\u5b50\u77e9\u9635\u7684\u548c\u53ca\u51fa\u73b0\u7684\u9891\u7387\uff0c\u5982\u679c\u540e\u7eed\u7684\u66f4\u5927\u77e9\u9635\u548c\u4e0e\u76ee\u6807\u503c\u7684\u5dee\u503c\u5b58\u5728\u4e0e\u54c8\u5e0c\u8868\u4e2d\uff0c\u90a3\u4e48\u53ef\u4ee5\u5c06\u5177\u6709\u8fd9\u4e9b\u77e9\u9635\u548c\u7684\u4e2a\u6570\u7d2f\u52a0\u8d77\u6765\u3002 \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 vector < vector < int >> sum ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { sum [ i ][ j ] = sum [ i + 1 ][ j ] + sum [ i ][ j + 1 ] - sum [ i + 1 ][ j + 1 ] + matrix [ i ][ j ]; } } for ( int tot = nRow - 1 ; tot >= 0 ; tot -- ) { for ( int bot = nRow - 1 ; bot >= tot ; bot -- ) { unordered_map < int , int > cnt ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { int curSum = sum [ tot ][ j ] - sum [ bot + 1 ][ j ]; if ( curSum == target ) { ans ++ ; } if ( cnt . count ( curSum - target )) { ans += cnt [ curSum - target ]; } cnt [ curSum ] ++ ; } } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{2}n) O(m^{2}n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(mn) O(mn) \uff0cm \u4e3a\u77e9\u9635\u7684\u884c\u6570\uff0cn \u4e3a\u77e9\u9635\u7684\u5217\u6570 \u8fde\u7eed\u7684\u5b50\u6570\u7ec4\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u5982 [23, 2, 4, 6, 7] \u548c\u4e00\u4e2a\u6574\u6570 k \u5982 6\uff0c\u5148\u5224\u65ad\u8fd9\u4e2a\u6570\u7ec4\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\uff0c\u5176\u548c\u662f k \u7684\u6574\u6570\u500d\u3002\u8fd9\u91cc\u8981\u6c42\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u81f3\u5c11\u4e3a 2\u3002 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c\u5bf9 k \u7684\u4f59\u6570 + \u54c8\u5e0c\u8868 \u5b58\u5728\u8fd9\u6837\u4e00\u4e2a\u5173\u7cfb\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u5bf9\u540c\u4e00\u4e2a\u6570 k \u53d6\u4f59\u7684\u503c\u76f8\u540c\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2a\u503c\u7684\u5dee\u503c\u4e00\u5b9a\u662f\u8fd9\u4e2a k \u7684\u6574\u6570\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n = ( int ) nums . size (); if ( n < 2 ) { return false ; } unordered_map < int , int > dict ; int sum = 0 ; dict [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += nums [ i ]; int remainder = sum % k ; if ( dict . count ( remainder )) { if ( i - dict [ remainder ] >= 2 ) { return true ; } } else { dict [ remainder ] = i ; } } return false ; \u6700\u957f01\u7b49\u91cf\u5b50\u4e32 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b0\u548c1\u7684\u5b57\u7b26\u4e32\u5982\"0010011001001010110\"\uff0c\u6c42\u5176\u6700\u957f\u5b50\u4e32\uff0c\u8fd9\u4e2a\u5b50\u4e32\u4e2d0\u548c1\u7684\u4e2a\u6570\u76f8\u7b49\uff0c\u7ed9\u51fa\u7684\u4f8b\u5b50\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\u4e3a 16 \u7684 01 \u5b50\u4e32 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c + \u54c8\u5e0c\u8868 \u6211\u4eec\u6309\u7167\u987a\u5e8f\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u8ba1\u7b97\u5f53\u524d\u65f6\u523b\u7684 01 \u4e2a\u6570\u5dee\u522b\uff0c\u5e76\u5c06\u8fd9\u5dee\u503c\u4fdd\u5b58\u5728\u4e00\u4e2a\u54c8\u5e0c\u8868\u503c\uff0c\u5982\u679c\u540e\u7eed\u518d\u6b21\u51fa\u73b0\u76f8\u540c\u7684\u5dee\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5feb\u901f\u7684\u8ba1\u7b97\u51fa\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u5e76\u4e14\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u5b50\u4e32\u4e00\u5b9a\u662f 01 \u7b49\u957f\u7684\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e0d\u8981\u9057\u5fd8\u7a7a\u5b57\u7b26\u4e32\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getLongest01SubstrLen ( string str ) { int len = 0 , n = ( int ) str . length (); vector < int > dp ( n + 1 , 0 ); unordered_map < int , int > dict ; dict [ 0 ] = n ; int pos = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { dp [ i ] = dp [ i + 1 ] + 1 ; } else { dp [ i ] = dp [ i + 1 ] - 1 ; } if ( dict . find ( dp [ i ]) != dict . end ()) { len = max ( len , dict [ dp [ i ]] - i ); pos = i ; } else { dict [ dp [ i ]] = i ; } } printf ( \"maxLenSubstr = %s \\n \" , str . substr ( pos , len ). c_str ()); return len ; } \u7edf\u8ba1\u7b49\u91cf\u8fde\u7eed 01 \u7684\u8fde\u7eed\u5b50\u5b57\u7b26 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26 s = '00110011'\uff0c\u6c42 s \u7684\u6240\u6709\u8fde\u7eed\u5b50\u5b57\u7b26\u4e32\u4e2d\uff0c\u20180\u2019 \u548c \u20191\u2018 \u7684\u6570\u91cf\u76f8\u7b49\u5e76\u4e14 \u20180\u2019 \u548c \u20181\u2019 \u8fde\u7eed\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u4e0e\u7edf\u8ba1 01 \u7b49\u91cf\u7684\u8fde\u7eed\u5b50\u5b57\u7b26\u4e32\u4e0d\u540c\uff0c\u672c\u9898\u8981\u6c42\u6240\u6709\u7684\u5b50\u5b57\u7b26\u4e32\u4e2d\u7684 \u20180\u2019 \u548c \u20181\u2019 \u4e5f\u8981\u8fde\u7eed\uff0c\u5373 \u20180101\u2019 \u867d\u7136\u7b49\u91cf\uff0c\u4f46\u662f\u6240\u6709\u7684 \u20180\u2019 \u548c\u6240\u6709\u7684 \u20181\u2019 \u5e76\u975e\u8fde\u7eed\u3002\u4e00\u4e2a\u89e3\u51b3\u529e\u6cd5\u662f\uff1a\u5c06\u540c\u7c7b\u7684\u5b57\u7b26\u5206\u5757\u7edf\u8ba1\u540e\u7d2f\u52a0\u76f8\u90bb\u4e24\u5757\u5185\u5bb9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int countBinarySubstrings ( string s ) { int ans = 0 , n = ( int ) s . length (); int cnt = 0 , last = 0 ; char lastChar = ' ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( lastChar == s [ i ]) { cnt ++ ; } else { ans += min ( last , cnt ); last = cnt ; cnt = 1 ; lastChar = s [ i ]; } } ans += min ( last , cnt ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u822a\u73ed\u9884\u5b9a\u7edf\u8ba1 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 bookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]] \u8868\u793a\u4ece i \u5230 j \u7684\u822a\u73ed\u9884\u5b9a\u4eba\u6570\uff0c\u53e6\u7ed9\u4e00\u4e2a\u6574\u6570 n \u8868\u793a\u822a\u73ed\u6570\uff08\u4ece 1 \u5f00\u59cb\uff09\uff0c\u6c42\u6bcf\u4e00\u822a\u73ed\u7684\u9884\u5b9a\u4eba\u6570\u4e4b\u548c\u3002 \\begin{matrix} \\text{flight num} & 1 & 2 & 3 & 4 & 5 \\\\ \\text{booking 1} & 10 & 10 \\\\ \\text{booking 2} & & 20 & 20 \\\\ \\text{booking 3} & & 25 & 25 & 25 & 25 \\\\ \\text{total sum} & 10 & 55 & 45 & 25 & 25 \\end{matrix} \\begin{matrix} \\text{flight num} & 1 & 2 & 3 & 4 & 5 \\\\ \\text{booking 1} & 10 & 10 \\\\ \\text{booking 2} & & 20 & 20 \\\\ \\text{booking 3} & & 25 & 25 & 25 & 25 \\\\ \\text{total sum} & 10 & 55 & 45 & 25 & 25 \\end{matrix} \u300c\u5206\u6790\u300d \u3010\u5dee\u5206 + \u524d\u7f00\u548c\u3011 \u4e00\u4e2a\u6570\u7ec4\u7684\u3010\u5dee\u5206\u3011\u548c\u3010\u524d\u7f00\u548c\u3011\u4e92\u4e3a\u9006\u8fd0\u7b97\uff0c\u9898\u76ee\u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e2a\u6761\u9884\u5b9a\u4fe1\u606f [i, j, booking]\uff0c\u90a3\u4e48\u5728 [i, j] \u9488\u5bf9\u8fd9\u4e2a\u533a\u95f4\u6c42\u5dee\u5206\uff0c\u53ea\u6709\u7b2c i \u4e2a\u4f4d\u7f6e\u662f booking\uff0c\u5176\u4ed6\u4f4d\u7f6e\u662f 0\uff0c\u4f46\u662f\u4e3a\u4e86\u907f\u514d\u65e0\u9650\u5236\u7d2f\u52a0\uff0c\u5728\u7b2c j+1 \u7684\u4f4d\u7f6e\u9700\u8981\u3010\u51cf\u53bb\u3011booking\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n , 0 ); for ( auto booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) { ans [ booking [ 1 ]] -= booking [ 2 ]; } } for ( int i = 1 ; i < n ; i ++ ) { ans [ i ] += ans [ i - 1 ]; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u822a\u73ed\u6570\uff0cm \u662f\u9884\u5b9a\u6570 \u5206\u5272\u6570\u7ec4\u7684\u6700\u591a\u65b9\u6848\u6570 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u4e0b\u6807\u4ece 0 \u5f00\u59cb\u4e14\u957f\u5ea6\u4e3a n \u7684\u6574\u6570\u6570\u7ec4 nums \u3002\u5206\u5272 \u6570\u7ec4 nums \u7684\u65b9\u6848\u6570\u5b9a\u4e49\u4e3a\u7b26\u5408\u4ee5\u4e0b\u4e24\u4e2a\u6761\u4ef6\u7684 pivot \u6570\u76ee\uff1a 1) 1 <= pivot < n 2) nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1] \u540c\u65f6\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 k \u3002\u4f60\u53ef\u4ee5\u5c06 nums \u4e2d \u4e00\u4e2a \u5143\u7d20\u53d8\u4e3a k \u6216 \u4e0d\u6539\u53d8 \u6570\u7ec4\u3002 \u8bf7\u4f60\u8fd4\u56de\u5728 \u81f3\u591a \u6539\u53d8\u4e00\u4e2a\u5143\u7d20\u7684\u524d\u63d0\u4e0b\uff0c\u6700\u591a \u6709\u591a\u5c11\u79cd\u65b9\u6cd5 \u5206\u5272 nums \u4f7f\u5f97\u4e0a\u8ff0\u4e24\u4e2a\u6761\u4ef6\u90fd\u6ee1\u8db3\u3002 \u300c\u5206\u6790\u300d \u3010\u524d\u7f00\u548c + \u5de6\u53f3\u54c8\u5e0c\u3011\u5047\u8bbe\u4e00\u4e2a\u6570\u7ec4\u7684\u548c\u4e3a tot\uff0c\u4ece\u67d0\u4e00\u4e2a\u4f4d\u7f6e\u5c06\u6570\u7ec4\u5207\u5206\uff0c\u4f7f\u5f97\u5de6\u53f3\u4e24\u90e8\u5206\u7684\u548c\u76f8\u7b49\uff0c\u90a3\u4e48 tot \u4e00\u5b9a\u662f\u4e00\u4e2a\u5076\u6570\uff0c\u5e76\u4e14\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u524d\u7f00\u548c\u662f tot / 2\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u8bb0\u5f55\u6240\u6709\u524d\u7f00\u548c\u51fa\u73b0\u7684\u6b21\u6570\u3002\u9488\u5bf9\u66ff\u6362\u5143\u7d20\u7684\u60c5\u51b5\uff0c\u5982\u679c\u7b2c i \u4e2a\u5143\u7d20\u88ab\u66ff\u6362\uff0c\u90a3\u4e48\u6570\u503c\u7684\u53d8\u5316\u91cf\u662f d = k - nums[ i ]\uff0c\u6b64\u65f6\uff0c\u5207\u5206\u70b9 j \u7684\u4f4d\u7f6e\u6709\u4e24\u79cd\uff1a1\uff09\u5728 i \u7684\u5de6\u4fa7\uff0cpresum[ j ] + d = tot - presum[ j ]\uff0c\u5f97 presum[ j ] = (tot + d) / 2\uff1b2\uff09j \u5728 i \u7684\u53f3\u4fa7\uff08\u5305\u542b\uff09\uff0cpresum[ j ] = tot + d - presum[ j ]\uff0c\u5f97 presum[ j ] = (tot - d) / 2\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u679a\u4e3e nums \u4e2d\u7684\u6bcf\u4e00\u4e2a num\uff0c\u7528\u4e24\u4e2a\u54c8\u5e0c\u8868\uff0c\u8bb0\u5f55 num \u5de6\u53f3\u4e24\u4fa7\u7684\u524d\u7f00\u548c\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int waysToPartition ( vector < int >& nums , int k ) { int ans = 0 ; long tot = 0 , sum = 0 ; unordered_map < int , int > cnt_left , cnt_right ; for ( int num : nums ) { tot += num ; cnt_right [ tot ] ++ ; } cnt_right [ tot ] -- ; if ( tot % 2 == 0 ) { ans = cnt_right [ tot / 2 ]; } for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ]; int d = k - nums [ i ]; int left = 0 , right = 0 ; if (( tot + d ) % 2 == 0 ) { left = cnt_left [( tot + d ) / 2 ]; } if (( tot - d ) % 2 == 0 ) { right = cnt_right [( tot - d ) / 2 ]; } ans = max ( ans , left + right ); cnt_left [ sum ] ++ ; cnt_right [ sum ] -- ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u7816\u5899 \u00b6 \u4f60\u7684\u9762\u524d\u6709\u4e00\u5835\u77e9\u5f62\u7684\u3001\u7531 n \u884c\u7816\u5757\u7ec4\u6210\u7684\u7816\u5899\u3002\u8fd9\u4e9b\u7816\u5757\u9ad8\u5ea6\u76f8\u540c\uff08\u4e5f\u5c31\u662f\u4e00\u4e2a\u5355\u4f4d\u9ad8\uff09\u4f46\u662f\u5bbd\u5ea6\u4e0d\u540c\u3002\u6bcf\u4e00\u884c\u7816\u5757\u7684\u5bbd\u5ea6\u4e4b\u548c\u76f8\u7b49\u3002\u4f60\u73b0\u5728\u8981\u753b\u4e00\u6761 \u81ea\u9876\u5411\u4e0b \u7684\u3001\u7a7f\u8fc7 \u6700\u5c11 \u7816\u5757\u7684\u5782\u7ebf\u3002\u5982\u679c\u4f60\u753b\u7684\u7ebf\u53ea\u662f\u4ece\u7816\u5757\u7684\u8fb9\u7f18\u7ecf\u8fc7\uff0c\u5c31\u4e0d\u7b97\u7a7f\u8fc7\u8fd9\u5757\u7816\u3002\u4f60\u4e0d\u80fd\u6cbf\u7740\u5899\u7684\u4e24\u4e2a\u5782\u76f4\u8fb9\u7f18\u4e4b\u4e00\u753b\u7ebf\uff0c\u8fd9\u6837\u663e\u7136\u662f\u6ca1\u6709\u7a7f\u8fc7\u4e00\u5757\u7816\u7684\u3002\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 wall \uff0c\u8be5\u6570\u7ec4\u5305\u542b\u8fd9\u5835\u5899\u7684\u76f8\u5173\u4fe1\u606f\u3002\u5176\u4e2d\uff0cwall[i] \u662f\u4e00\u4e2a\u4ee3\u8868\u4ece\u5de6\u81f3\u53f3\u6bcf\u5757\u7816\u7684\u5bbd\u5ea6\u7684\u6570\u7ec4\u3002\u4f60\u9700\u8981\u627e\u51fa\u600e\u6837\u753b\u624d\u80fd\u4f7f\u8fd9\u6761\u7ebf \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf\u6700\u5c11 \uff0c\u5e76\u4e14\u8fd4\u56de \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf \u3002 \u300c\u5206\u6790\u300d \u300c\u524d\u7f00\u548c + \u54c8\u5e0c\u300d\u7a7f\u8fc7\u6700\u5c11\u7684\u7816\u5757\u7b49\u4ef7\u4e8e\u7a7f\u8fc7\u6700\u591a\u7684\u8fb9\u754c\u3002\u56e0\u4e3a\u7816\u5757\u662f\u65e0\u7f1d\u8d34\u5408\u7684\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u7816\u5757\u7684\u8fb9\u754c\uff0c\u627e\u5230\u8fb9\u754c\u6700\u591a\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* \u8f93\u5165\uff1awall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] \u8f93\u51fa\uff1a2 */ int leastBricks ( vector < vector < int >>& wall ) { int ans = 0 ; unordered_map < int , int > cnt ; for ( vector < int > row : wall ) { int sum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; i ++ ) { sum += row [ i ]; cnt [ sum ] ++ ; } } for ( auto it = cnt . begin (); it != cnt . end (); it ++ ) { ans = max ( ans , it -> second ); } return wall . size () - ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u8fd9\u91cc\uff0cn \u662f wall \u7684\u957f\u5ea6\uff0cm \u662f\u6bcf\u4e00\u884c\u7684\u5e73\u5747\u957f\u5ea6\u3002","title":"\u524d\u7f00\u548c"},{"location":"algo/prefix-sum/#_1","text":"\u524d\u7f00\u548c\uff0c\u987e\u540d\u601d\u4e49\uff0c\u5c06\u4e00\u4e2a\u5e8f\u5217\u7684\u524d n \u4e2a\u5143\u7d20\u7d2f\u52a0\u8d77\u6765\u3002","title":"\u7b80\u4ecb"},{"location":"algo/prefix-sum/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/prefix-sum/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u548c\u4e00\u4e2a k \u503c\uff0c\u6c42\u6240\u6709\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u7b49\u4e8e k \u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u66b4\u529b\u679a\u4e3e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\u8fbe n^{3} n^{3} \uff0c\u5229\u7528\u524d\u7f00\u548c\u7684\u590d\u6742\u5ea6\u4e5f\u4f1a\u8fbe\u5230 n^{2} n^{2} \uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u524d\u7f00\u548c + \u54c8\u5e0c\u8868\u8fdb\u4e00\u6b65\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 int ans = 0 , sum = 0 ; unordered_map < int , int > cnt ; for ( int num : nums ) { sum += num ; if ( sum == k ) { ans ++ ; } if ( cnt . count ( sum - k )) { ans += cnt [ sum - k ]; } cnt [ sum ] ++ ; } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002","title":"\u548c\u4e3aK\u7684\u5b50\u6570\u7ec4"},{"location":"algo/prefix-sum/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u77e9\u9635 matrix \uff08 m \\times n m \\times n \uff09 \u548c\u4e00\u4e2a\u76ee\u6807\u503c target\uff0c\u8ba1\u7b97\u51fa\u6240\u6709\u7684\u5b50\u77e9\u9635\u548c\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u9898\u76ee\u8981\u6c42\u662f\u77e9\u9635\u548c\uff0c\u5f88\u5bb9\u6613\u8054\u60f3\u5230\u524d\u7f00\u548c\u3002\u4f46\u662f\u5982\u679c\u5728\u524d\u7f00\u548c\u7684\u57fa\u7840\u4e0a\uff0c\u66b4\u529b\u5faa\u73af\u6c42\u89e3\u7684\u8bdd\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(m^{2}n^{2}) O(m^{2}n^{2}) \uff0c\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u4e3a\u4e86\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u6211\u4eec\u4f7f\u7528\u54c8\u5e0c\u8868\u7684\u65b9\u6cd5\u3002\u5177\u4f53\u5730\uff0c\u4e00\u4e2a\u77e9\u5f62\u6709\u56db\u4e2a\u8fb9\u957f\uff0c\u6211\u4eec\u9996\u5148\u786e\u5b9a\u4e0a\u8fb9\u548c\u4e0b\u8fb9\uff0c\u5728\u4f9d\u6b21\u904d\u5386\u5de6\u8fb9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6b64\u65f6\u7684\u5b50\u77e9\u9635\u7684\u548c\u53ca\u51fa\u73b0\u7684\u9891\u7387\uff0c\u5982\u679c\u540e\u7eed\u7684\u66f4\u5927\u77e9\u9635\u548c\u4e0e\u76ee\u6807\u503c\u7684\u5dee\u503c\u5b58\u5728\u4e0e\u54c8\u5e0c\u8868\u4e2d\uff0c\u90a3\u4e48\u53ef\u4ee5\u5c06\u5177\u6709\u8fd9\u4e9b\u77e9\u9635\u548c\u7684\u4e2a\u6570\u7d2f\u52a0\u8d77\u6765\u3002 \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 vector < vector < int >> sum ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { sum [ i ][ j ] = sum [ i + 1 ][ j ] + sum [ i ][ j + 1 ] - sum [ i + 1 ][ j + 1 ] + matrix [ i ][ j ]; } } for ( int tot = nRow - 1 ; tot >= 0 ; tot -- ) { for ( int bot = nRow - 1 ; bot >= tot ; bot -- ) { unordered_map < int , int > cnt ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { int curSum = sum [ tot ][ j ] - sum [ bot + 1 ][ j ]; if ( curSum == target ) { ans ++ ; } if ( cnt . count ( curSum - target )) { ans += cnt [ curSum - target ]; } cnt [ curSum ] ++ ; } } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{2}n) O(m^{2}n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(mn) O(mn) \uff0cm \u4e3a\u77e9\u9635\u7684\u884c\u6570\uff0cn \u4e3a\u77e9\u9635\u7684\u5217\u6570","title":"\u5143\u7d20\u548c\u4e3a\u76ee\u6807\u503c\u7684\u5b50\u77e9\u9635\u6570\u91cf"},{"location":"algo/prefix-sum/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u5982 [23, 2, 4, 6, 7] \u548c\u4e00\u4e2a\u6574\u6570 k \u5982 6\uff0c\u5148\u5224\u65ad\u8fd9\u4e2a\u6570\u7ec4\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\uff0c\u5176\u548c\u662f k \u7684\u6574\u6570\u500d\u3002\u8fd9\u91cc\u8981\u6c42\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u81f3\u5c11\u4e3a 2\u3002 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c\u5bf9 k \u7684\u4f59\u6570 + \u54c8\u5e0c\u8868 \u5b58\u5728\u8fd9\u6837\u4e00\u4e2a\u5173\u7cfb\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u5bf9\u540c\u4e00\u4e2a\u6570 k \u53d6\u4f59\u7684\u503c\u76f8\u540c\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2a\u503c\u7684\u5dee\u503c\u4e00\u5b9a\u662f\u8fd9\u4e2a k \u7684\u6574\u6570\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n = ( int ) nums . size (); if ( n < 2 ) { return false ; } unordered_map < int , int > dict ; int sum = 0 ; dict [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += nums [ i ]; int remainder = sum % k ; if ( dict . count ( remainder )) { if ( i - dict [ remainder ] >= 2 ) { return true ; } } else { dict [ remainder ] = i ; } } return false ;","title":"\u8fde\u7eed\u7684\u5b50\u6570\u7ec4\u548c"},{"location":"algo/prefix-sum/#01","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b0\u548c1\u7684\u5b57\u7b26\u4e32\u5982\"0010011001001010110\"\uff0c\u6c42\u5176\u6700\u957f\u5b50\u4e32\uff0c\u8fd9\u4e2a\u5b50\u4e32\u4e2d0\u548c1\u7684\u4e2a\u6570\u76f8\u7b49\uff0c\u7ed9\u51fa\u7684\u4f8b\u5b50\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\u4e3a 16 \u7684 01 \u5b50\u4e32 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c + \u54c8\u5e0c\u8868 \u6211\u4eec\u6309\u7167\u987a\u5e8f\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u8ba1\u7b97\u5f53\u524d\u65f6\u523b\u7684 01 \u4e2a\u6570\u5dee\u522b\uff0c\u5e76\u5c06\u8fd9\u5dee\u503c\u4fdd\u5b58\u5728\u4e00\u4e2a\u54c8\u5e0c\u8868\u503c\uff0c\u5982\u679c\u540e\u7eed\u518d\u6b21\u51fa\u73b0\u76f8\u540c\u7684\u5dee\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5feb\u901f\u7684\u8ba1\u7b97\u51fa\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u5e76\u4e14\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u5b50\u4e32\u4e00\u5b9a\u662f 01 \u7b49\u957f\u7684\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e0d\u8981\u9057\u5fd8\u7a7a\u5b57\u7b26\u4e32\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getLongest01SubstrLen ( string str ) { int len = 0 , n = ( int ) str . length (); vector < int > dp ( n + 1 , 0 ); unordered_map < int , int > dict ; dict [ 0 ] = n ; int pos = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { dp [ i ] = dp [ i + 1 ] + 1 ; } else { dp [ i ] = dp [ i + 1 ] - 1 ; } if ( dict . find ( dp [ i ]) != dict . end ()) { len = max ( len , dict [ dp [ i ]] - i ); pos = i ; } else { dict [ dp [ i ]] = i ; } } printf ( \"maxLenSubstr = %s \\n \" , str . substr ( pos , len ). c_str ()); return len ; }","title":"\u6700\u957f01\u7b49\u91cf\u5b50\u4e32"},{"location":"algo/prefix-sum/#01_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26 s = '00110011'\uff0c\u6c42 s \u7684\u6240\u6709\u8fde\u7eed\u5b50\u5b57\u7b26\u4e32\u4e2d\uff0c\u20180\u2019 \u548c \u20191\u2018 \u7684\u6570\u91cf\u76f8\u7b49\u5e76\u4e14 \u20180\u2019 \u548c \u20181\u2019 \u8fde\u7eed\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u4e0e\u7edf\u8ba1 01 \u7b49\u91cf\u7684\u8fde\u7eed\u5b50\u5b57\u7b26\u4e32\u4e0d\u540c\uff0c\u672c\u9898\u8981\u6c42\u6240\u6709\u7684\u5b50\u5b57\u7b26\u4e32\u4e2d\u7684 \u20180\u2019 \u548c \u20181\u2019 \u4e5f\u8981\u8fde\u7eed\uff0c\u5373 \u20180101\u2019 \u867d\u7136\u7b49\u91cf\uff0c\u4f46\u662f\u6240\u6709\u7684 \u20180\u2019 \u548c\u6240\u6709\u7684 \u20181\u2019 \u5e76\u975e\u8fde\u7eed\u3002\u4e00\u4e2a\u89e3\u51b3\u529e\u6cd5\u662f\uff1a\u5c06\u540c\u7c7b\u7684\u5b57\u7b26\u5206\u5757\u7edf\u8ba1\u540e\u7d2f\u52a0\u76f8\u90bb\u4e24\u5757\u5185\u5bb9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int countBinarySubstrings ( string s ) { int ans = 0 , n = ( int ) s . length (); int cnt = 0 , last = 0 ; char lastChar = ' ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( lastChar == s [ i ]) { cnt ++ ; } else { ans += min ( last , cnt ); last = cnt ; cnt = 1 ; lastChar = s [ i ]; } } ans += min ( last , cnt ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u7edf\u8ba1\u7b49\u91cf\u8fde\u7eed 01 \u7684\u8fde\u7eed\u5b50\u5b57\u7b26"},{"location":"algo/prefix-sum/#_5","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 bookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]] \u8868\u793a\u4ece i \u5230 j \u7684\u822a\u73ed\u9884\u5b9a\u4eba\u6570\uff0c\u53e6\u7ed9\u4e00\u4e2a\u6574\u6570 n \u8868\u793a\u822a\u73ed\u6570\uff08\u4ece 1 \u5f00\u59cb\uff09\uff0c\u6c42\u6bcf\u4e00\u822a\u73ed\u7684\u9884\u5b9a\u4eba\u6570\u4e4b\u548c\u3002 \\begin{matrix} \\text{flight num} & 1 & 2 & 3 & 4 & 5 \\\\ \\text{booking 1} & 10 & 10 \\\\ \\text{booking 2} & & 20 & 20 \\\\ \\text{booking 3} & & 25 & 25 & 25 & 25 \\\\ \\text{total sum} & 10 & 55 & 45 & 25 & 25 \\end{matrix} \\begin{matrix} \\text{flight num} & 1 & 2 & 3 & 4 & 5 \\\\ \\text{booking 1} & 10 & 10 \\\\ \\text{booking 2} & & 20 & 20 \\\\ \\text{booking 3} & & 25 & 25 & 25 & 25 \\\\ \\text{total sum} & 10 & 55 & 45 & 25 & 25 \\end{matrix} \u300c\u5206\u6790\u300d \u3010\u5dee\u5206 + \u524d\u7f00\u548c\u3011 \u4e00\u4e2a\u6570\u7ec4\u7684\u3010\u5dee\u5206\u3011\u548c\u3010\u524d\u7f00\u548c\u3011\u4e92\u4e3a\u9006\u8fd0\u7b97\uff0c\u9898\u76ee\u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e2a\u6761\u9884\u5b9a\u4fe1\u606f [i, j, booking]\uff0c\u90a3\u4e48\u5728 [i, j] \u9488\u5bf9\u8fd9\u4e2a\u533a\u95f4\u6c42\u5dee\u5206\uff0c\u53ea\u6709\u7b2c i \u4e2a\u4f4d\u7f6e\u662f booking\uff0c\u5176\u4ed6\u4f4d\u7f6e\u662f 0\uff0c\u4f46\u662f\u4e3a\u4e86\u907f\u514d\u65e0\u9650\u5236\u7d2f\u52a0\uff0c\u5728\u7b2c j+1 \u7684\u4f4d\u7f6e\u9700\u8981\u3010\u51cf\u53bb\u3011booking\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n , 0 ); for ( auto booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) { ans [ booking [ 1 ]] -= booking [ 2 ]; } } for ( int i = 1 ; i < n ; i ++ ) { ans [ i ] += ans [ i - 1 ]; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u822a\u73ed\u6570\uff0cm \u662f\u9884\u5b9a\u6570","title":"\u822a\u73ed\u9884\u5b9a\u7edf\u8ba1"},{"location":"algo/prefix-sum/#_6","text":"\u7ed9\u4f60\u4e00\u4e2a\u4e0b\u6807\u4ece 0 \u5f00\u59cb\u4e14\u957f\u5ea6\u4e3a n \u7684\u6574\u6570\u6570\u7ec4 nums \u3002\u5206\u5272 \u6570\u7ec4 nums \u7684\u65b9\u6848\u6570\u5b9a\u4e49\u4e3a\u7b26\u5408\u4ee5\u4e0b\u4e24\u4e2a\u6761\u4ef6\u7684 pivot \u6570\u76ee\uff1a 1) 1 <= pivot < n 2) nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1] \u540c\u65f6\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 k \u3002\u4f60\u53ef\u4ee5\u5c06 nums \u4e2d \u4e00\u4e2a \u5143\u7d20\u53d8\u4e3a k \u6216 \u4e0d\u6539\u53d8 \u6570\u7ec4\u3002 \u8bf7\u4f60\u8fd4\u56de\u5728 \u81f3\u591a \u6539\u53d8\u4e00\u4e2a\u5143\u7d20\u7684\u524d\u63d0\u4e0b\uff0c\u6700\u591a \u6709\u591a\u5c11\u79cd\u65b9\u6cd5 \u5206\u5272 nums \u4f7f\u5f97\u4e0a\u8ff0\u4e24\u4e2a\u6761\u4ef6\u90fd\u6ee1\u8db3\u3002 \u300c\u5206\u6790\u300d \u3010\u524d\u7f00\u548c + \u5de6\u53f3\u54c8\u5e0c\u3011\u5047\u8bbe\u4e00\u4e2a\u6570\u7ec4\u7684\u548c\u4e3a tot\uff0c\u4ece\u67d0\u4e00\u4e2a\u4f4d\u7f6e\u5c06\u6570\u7ec4\u5207\u5206\uff0c\u4f7f\u5f97\u5de6\u53f3\u4e24\u90e8\u5206\u7684\u548c\u76f8\u7b49\uff0c\u90a3\u4e48 tot \u4e00\u5b9a\u662f\u4e00\u4e2a\u5076\u6570\uff0c\u5e76\u4e14\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u524d\u7f00\u548c\u662f tot / 2\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u8bb0\u5f55\u6240\u6709\u524d\u7f00\u548c\u51fa\u73b0\u7684\u6b21\u6570\u3002\u9488\u5bf9\u66ff\u6362\u5143\u7d20\u7684\u60c5\u51b5\uff0c\u5982\u679c\u7b2c i \u4e2a\u5143\u7d20\u88ab\u66ff\u6362\uff0c\u90a3\u4e48\u6570\u503c\u7684\u53d8\u5316\u91cf\u662f d = k - nums[ i ]\uff0c\u6b64\u65f6\uff0c\u5207\u5206\u70b9 j \u7684\u4f4d\u7f6e\u6709\u4e24\u79cd\uff1a1\uff09\u5728 i \u7684\u5de6\u4fa7\uff0cpresum[ j ] + d = tot - presum[ j ]\uff0c\u5f97 presum[ j ] = (tot + d) / 2\uff1b2\uff09j \u5728 i \u7684\u53f3\u4fa7\uff08\u5305\u542b\uff09\uff0cpresum[ j ] = tot + d - presum[ j ]\uff0c\u5f97 presum[ j ] = (tot - d) / 2\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u679a\u4e3e nums \u4e2d\u7684\u6bcf\u4e00\u4e2a num\uff0c\u7528\u4e24\u4e2a\u54c8\u5e0c\u8868\uff0c\u8bb0\u5f55 num \u5de6\u53f3\u4e24\u4fa7\u7684\u524d\u7f00\u548c\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int waysToPartition ( vector < int >& nums , int k ) { int ans = 0 ; long tot = 0 , sum = 0 ; unordered_map < int , int > cnt_left , cnt_right ; for ( int num : nums ) { tot += num ; cnt_right [ tot ] ++ ; } cnt_right [ tot ] -- ; if ( tot % 2 == 0 ) { ans = cnt_right [ tot / 2 ]; } for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ]; int d = k - nums [ i ]; int left = 0 , right = 0 ; if (( tot + d ) % 2 == 0 ) { left = cnt_left [( tot + d ) / 2 ]; } if (( tot - d ) % 2 == 0 ) { right = cnt_right [( tot - d ) / 2 ]; } ans = max ( ans , left + right ); cnt_left [ sum ] ++ ; cnt_right [ sum ] -- ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u5206\u5272\u6570\u7ec4\u7684\u6700\u591a\u65b9\u6848\u6570"},{"location":"algo/prefix-sum/#_7","text":"\u4f60\u7684\u9762\u524d\u6709\u4e00\u5835\u77e9\u5f62\u7684\u3001\u7531 n \u884c\u7816\u5757\u7ec4\u6210\u7684\u7816\u5899\u3002\u8fd9\u4e9b\u7816\u5757\u9ad8\u5ea6\u76f8\u540c\uff08\u4e5f\u5c31\u662f\u4e00\u4e2a\u5355\u4f4d\u9ad8\uff09\u4f46\u662f\u5bbd\u5ea6\u4e0d\u540c\u3002\u6bcf\u4e00\u884c\u7816\u5757\u7684\u5bbd\u5ea6\u4e4b\u548c\u76f8\u7b49\u3002\u4f60\u73b0\u5728\u8981\u753b\u4e00\u6761 \u81ea\u9876\u5411\u4e0b \u7684\u3001\u7a7f\u8fc7 \u6700\u5c11 \u7816\u5757\u7684\u5782\u7ebf\u3002\u5982\u679c\u4f60\u753b\u7684\u7ebf\u53ea\u662f\u4ece\u7816\u5757\u7684\u8fb9\u7f18\u7ecf\u8fc7\uff0c\u5c31\u4e0d\u7b97\u7a7f\u8fc7\u8fd9\u5757\u7816\u3002\u4f60\u4e0d\u80fd\u6cbf\u7740\u5899\u7684\u4e24\u4e2a\u5782\u76f4\u8fb9\u7f18\u4e4b\u4e00\u753b\u7ebf\uff0c\u8fd9\u6837\u663e\u7136\u662f\u6ca1\u6709\u7a7f\u8fc7\u4e00\u5757\u7816\u7684\u3002\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 wall \uff0c\u8be5\u6570\u7ec4\u5305\u542b\u8fd9\u5835\u5899\u7684\u76f8\u5173\u4fe1\u606f\u3002\u5176\u4e2d\uff0cwall[i] \u662f\u4e00\u4e2a\u4ee3\u8868\u4ece\u5de6\u81f3\u53f3\u6bcf\u5757\u7816\u7684\u5bbd\u5ea6\u7684\u6570\u7ec4\u3002\u4f60\u9700\u8981\u627e\u51fa\u600e\u6837\u753b\u624d\u80fd\u4f7f\u8fd9\u6761\u7ebf \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf\u6700\u5c11 \uff0c\u5e76\u4e14\u8fd4\u56de \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf \u3002 \u300c\u5206\u6790\u300d \u300c\u524d\u7f00\u548c + \u54c8\u5e0c\u300d\u7a7f\u8fc7\u6700\u5c11\u7684\u7816\u5757\u7b49\u4ef7\u4e8e\u7a7f\u8fc7\u6700\u591a\u7684\u8fb9\u754c\u3002\u56e0\u4e3a\u7816\u5757\u662f\u65e0\u7f1d\u8d34\u5408\u7684\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u7816\u5757\u7684\u8fb9\u754c\uff0c\u627e\u5230\u8fb9\u754c\u6700\u591a\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* \u8f93\u5165\uff1awall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] \u8f93\u51fa\uff1a2 */ int leastBricks ( vector < vector < int >>& wall ) { int ans = 0 ; unordered_map < int , int > cnt ; for ( vector < int > row : wall ) { int sum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; i ++ ) { sum += row [ i ]; cnt [ sum ] ++ ; } } for ( auto it = cnt . begin (); it != cnt . end (); it ++ ) { ans = max ( ans , it -> second ); } return wall . size () - ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u8fd9\u91cc\uff0cn \u662f wall \u7684\u957f\u5ea6\uff0cm \u662f\u6bcf\u4e00\u884c\u7684\u5e73\u5747\u957f\u5ea6\u3002","title":"\u7816\u5899"},{"location":"algo/search/","text":"DFS \u00b6 \u300c\u7b80\u4ecb\u300d \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08Depth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u5b50\u8282\u70b9\uff0c\u5982\u679c\u53ef\u4ee5\u641c\u7d22\u5230\u76ee\u6807\uff0c\u5373\u505c\u6b62\u6216\u5c06\u7ed3\u679c\u4fdd\u5b58\u8d77\u6765\uff1b\u53cd\u4e4b\uff0c\u56de\u6eaf\u5230\u5206\u53c9\u5904\uff0c\u4f9d\u6b21\u904d\u5386\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002 \u5168\u6392\u5217 \u00b6 \u300c\u5e8f\u5217\u5143\u7d20\u4e0d\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [1, 2, 3] ,\u5143\u7d20\u4e92\u4e0d\u76f8\u540c\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void dfs ( vector < int > & nums , int n , int idx , vector < vector < int >> & ans ) { if ( idx == n ) { ans . emplace_back ( nums ); return ; } for ( int i = idx ; i < n ; i ++ ) { swap ( nums [ i ], nums [ idx ]); dfs ( nums , n , idx + 1 , ans ); swap ( nums [ i ], nums [ idx ]); } } vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } dfs ( nums , n , 0 , ans ); return ans ; } \u300c\u5e8f\u5217\u5143\u7d20\u6709\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [3, 3, 0, 3] \uff0c\u5143\u7d20\u6709\u91cd\u590d\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void dfs ( vector < vector < int >> & ans , vector < int > & nums , int n , int idx , bool * vis , vector < int > & arr ) { if ( idx == n ) { ans . emplace_back ( arr ); return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! vis [ i - 1 ])) { continue ; } vis [ i ] = true ; arr . emplace_back ( nums [ i ]); dfs ( ans , nums , n , idx + 1 , vis , arr ); arr . pop_back (); vis [ i ] = false ; } } vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } sort ( nums . begin (), nums . end ()); vector < int > arr ; bool * vis = new bool [ n ]{}; dfs ( ans , nums , n , 0 , vis , arr ); delete [] vis ; return ans ; } \u7ec4\u5408\u603b\u548c \u00b6 \u300c\u53ea\u80fd\u4f7f\u7528\u4e00\u6b21\u300d \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 candidates \u548c\u4e00\u4e2a\u76ee\u6807\u6570 target \uff0c\u627e\u51fa candidates \u4e2d\u6240\u6709\u53ef\u4ee5\u4f7f\u6570\u5b57\u548c\u4e3a target \u7684\u7ec4\u5408\u3002candidates \u4e2d\u7684\u6bcf\u4e2a\u6570\u5b57\u5728\u6bcf\u4e2a\u7ec4\u5408\u4e2d\u53ea\u80fd\u4f7f\u7528\u4e00\u6b21\u3002\u89e3\u96c6\u4e0d\u80fd\u5305\u542b\u91cd\u590d\u7684\u7ec4\u5408\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* \u793a\u4f8b: \u8f93\u5165: candidates = [2,5,2,1,2], target = 5, \u6240\u6c42\u89e3\u96c6\u4e3a: [ [1,2,2], [5] ] */ vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> res ; vector < int > arr ; int n = int ( candidates . size ()); if ( n == 0 ) { return res ; } map < int , int > dict ; map < int , int >:: iterator iter ; for ( int num : candidates ) { iter = dict . find ( num ); if ( iter == dict . end ()) { dict [ num ] = 1 ; } else { dict [ num ] ++ ; } } vector < pair < int , int >> nums ; int size = 0 ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { nums . emplace_back ( iter -> first , iter -> second ); size ++ ; } DFS ( res , arr , candidates , target , 0 , size , nums ); return res ; } void DFS ( vector < vector < int >> & res , vector < int > & arr , vector < int > candidates , int target , int idx , int size , vector < pair < int , int >> nums ) { if ( target <= 0 || idx >= size ) { if ( target == 0 ) { res . push_back ( arr ); } return ; } for ( int j = 1 ; j <= nums [ idx ]. second ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { arr . push_back ( nums [ idx ]. first ); } DFS ( res , arr , candidates , target - j * nums [ idx ]. first , idx + 1 , size , nums ); for ( int k = 0 ; k < j ; k ++ ) { arr . pop_back (); } } DFS ( res , arr , candidates , target , idx + 1 , size , nums ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u300c\u65e0\u9650\u4f7f\u7528\u300d \u7ed9\u5b9a\u4e00\u4e2a\u65e0\u91cd\u590d\u5143\u7d20\u7684\u6570\u7ec4 candidates \u548c\u4e00\u4e2a\u76ee\u6807\u6570 target \uff0c\u627e\u51fa candidates \u4e2d\u6240\u6709\u53ef\u4ee5\u4f7f\u6570\u5b57\u548c\u4e3a target \u7684\u7ec4\u5408\u3002candidates \u4e2d\u7684\u6570\u5b57\u53ef\u4ee5\u65e0\u9650\u5236\u91cd\u590d\u88ab\u9009\u53d6\u3002\u89e3\u96c6\u4e0d\u80fd\u5305\u542b\u91cd\u590d\u7684\u7ec4\u5408\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u793a\u4f8b\uff1a \u8f93\u5165\uff1acandidates = [2,3,6,7], target = 7, \u6240\u6c42\u89e3\u96c6\u4e3a\uff1a [ [7], [2,2,3] ] */ vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> res ; vector < int > arr ; int n = int ( candidates . size ()); if ( n == 0 ) { return res ; } DFS ( res , arr , candidates , n , target , 0 ); return res ; } void DFS ( vector < vector < int >> & res , vector < int > & arr , vector < int > candidates , int n , int target , int idx ) { if ( target == 0 ) { res . push_back ( arr ); return ; } for ( int i = idx ; i < n ; i ++ ) { if ( target - candidates [ i ] >= 0 ) { arr . push_back ( candidates [ i ]); DFS ( res , arr , candidates , n , target - candidates [ i ], i ); arr . resize ( arr . size () - 1 ); } } } \u65f6\u95f4\u590d\u6742\u5ea6 O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u5b50\u96c6 \u00b6 \u300c\u5e8f\u5217\u5143\u7d20\u4e0d\u91cd\u590d\u300d \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u4e92\u4e0d\u76f8\u540c \u3002\u8fd4\u56de\u8be5\u6570\u7ec4\u6240\u6709\u53ef\u80fd\u7684\u5b50\u96c6\uff08\u5e42\u96c6\uff09\u3002\u4f8b\u5982\uff0cnums = [1,2,3]\uff0c\u8fd4\u56de [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); vector < int > arr ; dfs ( ans , arr , nums , n , 0 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int n , int idx ) { if ( idx == n ) { ans . emplace_back ( arr ); return ; } arr . emplace_back ( nums [ idx ]); dfs ( ans , arr , nums , n , idx + 1 ); arr . pop_back (); dfs ( ans , arr , nums , n , idx + 1 ); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \u3002 \u300c\u5e8f\u5217\u5143\u7d20\u6709\u91cd\u590d\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] */ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); sort ( nums . begin (), nums . end ()); vector < int > arr ; dfs ( ans , arr , nums , 0 , n ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int idx , int n ) { for ( int i = idx ; i < n ; i ++ ) { if ( i > idx && nums [ i ] == nums [ i - 1 ]) { continue ; } arr . emplace_back ( nums [ i ]); dfs ( ans , arr , nums , i + 1 , n ); arr . pop_back (); } ans . emplace_back ( arr ); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \u3002 \u4e8c\u53c9\u6811\u67d0\u4e00\u8282\u70b9\u6240\u6709\u8ddd\u79bb\u4e3a k \u7684\u8282\u70b9 \u00b6 \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u548c\u8282\u70b9 target\uff0c\u6c42\u6240\u6709\u7684\u8ddd\u79bb target \u4e3a k \u7684\u8282\u70b9\u3002\u8fd9\u91cc\u7684\u8ddd\u79bb\u6307\u7684\u662f\u8fb9\u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u5982\u679c\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u5305\u542b\u4e86\u7236\u8282\u70b9\u7684\u4fe1\u606f\uff0c\u76f4\u63a5 dfs \u904d\u5386\uff1b\u5982\u679c\u4e0d\u5305\u542b\u7236\u8282\u70b9\u4fe1\u606f\uff0c\u5219\u5148\u7528\u54c8\u5e0c\u8868\u4fdd\u5b58\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684\u7236\u8282\u70b9\uff0c\u518d\u7528 dfs \u641c\u7d22\u3002\u6ce8\u610f\u904d\u5386\u65f6\u4fdd\u5b58\u5df2\u7ecf\u8bbf\u95ee\u7684\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 unordered_map < TreeNode * , TreeNode *> par ; unordered_set < TreeNode *> vis ; void findParNode ( TreeNode * root ) { if ( root != nullptr ) { if ( root -> left != nullptr ) { par [ root -> left ] = root ; } if ( root -> right != nullptr ) { par [ root -> right ] = root ; } findParNode ( root -> left ); findParNode ( root -> right ); } } void dfs ( TreeNode * curNode , int k , vector < int > & ans ) { if ( curNode == nullptr || vis . count ( curNode )) { return ; } if ( k == 0 ) { ans . emplace_back ( curNode -> val ); return ; } vis . insert ( curNode ); dfs ( par [ curNode ], k - 1 , ans ); dfs ( curNode -> left , k - 1 , ans ); dfs ( curNode -> right , k - 1 , ans ); } vector < int > distanceK ( TreeNode * root , TreeNode * target , int k ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } par [ root ] = nullptr ; findParNode ( root ); dfs ( target , k , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u6211\u80fd\u8d62\u6e38\u620f \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6b63\u6574\u6570 a = 10\uff0cb = 11\uff0c\u4e24\u4e2a\u73a9\u5bb6\uff0c\u6bcf\u4eba\u4f9d\u6b21\u51fa\u4e00\u4e2a\u6570\u5b57\uff081 - a\u4e4b\u95f4\uff09\uff0c\u7d2f\u52a0\u548c\u5148\u5230 b \u7684\u83b7\u80dc\uff0c\u8bd5\u95ee\uff0c\u5148\u624b\u80fd\u8d62\u4e48\uff1f \u300c\u5206\u6790\u300d \u3010\u72b6\u6001\u538b\u7f29+ DFS\u8bb0\u5fc6\u4f18\u5316\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 unordered_map < int , bool > memo ; bool dfs ( int n , int m , int state ) { if ( memo . count ( state )) { return memo [ state ]; } for ( int i = 1 ; i <= n ; i ++ ) { if ( state & ( 1 << i )) { continue ; } if ( i >= m ) { memo [ state | ( 1 << i )] = true ; return true ; } else { bool oppo_win = dfs ( n , m - i , state | ( 1 << i )); if ( ! oppo_win ) { memo [ state ] = true ; return true ; } } } memo [ state ] = false ; return false ; } bool canIWin ( int maxChoosableInteger , int desiredTotal ) { if ( maxChoosableInteger >= desiredTotal ) { return true ; } if (( 1 + maxChoosableInteger ) * maxChoosableInteger < 2 * desiredTotal ) { return false ; } bool ans = dfs ( maxChoosableInteger , desiredTotal , 0 ); return ans ; } \u627e\u8def \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 obstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] \u8868\u793a\u4e00\u4e2a\u7f51\u683c\uff0c\u5176\u4e2d 1 \u4e3a\u969c\u788d\uff0c\u4e0d\u80fd\u901a\u8fc7\u3002\u5f00\u59cb\u4f4d\u7f6e\u662f\u5de6\u4e0a\u89d2\uff0c\u7ed3\u675f\u4f4d\u7f6e\u662f\u53f3\u4e0b\u89d2\u3002\u8fd4\u56de\u4e00\u6761\u53ef\u884c\u7684\u8def\u5f84\uff08\u5982\u679c\u5b58\u5728\uff09\u3002 \u300c\u5206\u6790\u300d \u3010DFS + \u526a\u679d\u3011\u4e00\u65e6\u627e\u5230\u4e00\u6761\u8def\u5f84\u5373\u8fd4\u56de\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 bool dfs ( vector < vector < int >> & grid , int n , int m , int i , int j , vector < vector < int >> & ans ) { if ( i == n || j == m || grid [ i ][ j ] == 1 ) { return false ; } grid [ i ][ j ] = 1 ; ans . emplace_back ( vector < int > { i , j }); if ( i == n - 1 && j == m - 1 ) { return true ; } if ( dfs ( grid , n , m , i + 1 , j , ans )) { return true ; } if ( dfs ( grid , n , m , i , j + 1 , ans )) { return true ; } ans . pop_back (); return false ; } vector < vector < int >> pathWithObstacles ( vector < vector < int >>& obstacleGrid ) { vector < vector < int >> ans ; int n = ( int ) obstacleGrid . size (), m = ( int ) obstacleGrid [ 0 ]. size (); dfs ( obstacleGrid , n , m , 0 , 0 , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \u62ec\u53f7\u751f\u6210 \u00b6 \u6570\u5b57 n \u4ee3\u8868\u751f\u6210\u62ec\u53f7\u7684\u5bf9\u6570\uff0c\u8bf7\u4f60\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u4e8e\u80fd\u591f\u751f\u6210\u6240\u6709\u53ef\u80fd\u7684\u5e76\u4e14 \u6709\u6548\u7684 \u62ec\u53f7\u7ec4\u5408\u3002\u4f8b\u5982\uff0cn = 3\uff0c\u8fd4\u56de [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\u3002 \u300c\u5206\u6790\u300d \u300cDFS\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void dfs ( vector < string > & ans , string s , int n , int a , int b ) { if ( a == n && b == n ) { ans . emplace_back ( s ); return ; } if ( a > n || b > n ) { return ; } if ( a == b ) { dfs ( ans , s + \"(\" , n , a + 1 , b ); } else if ( a > b ) { dfs ( ans , s + \"(\" , n , a + 1 , b ); dfs ( ans , s + \")\" , n , a , b + 1 ); } } vector < string > generateParenthesis ( int n ) { vector < string > ans ; dfs ( ans , \"\" , n , 0 , 0 ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 BFS \u00b6 \u300c\u7b80\u4ecb\u300d \u5bbd\u5ea6\u4f18\u5148\u641c\u7d22\uff08Breadth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u6240\u6709\u76f4\u63a5\u90bb\u5c45\u8282\u70b9\uff0c\u4e00\u822c\u800c\u8a00\uff0cBFS \u9002\u7528\u4e8e\u6c42\u89e3\u6700\u77ed\u957f\u5ea6\u7684\u95ee\u9898\u3002\u5728\u6c42\u89e3\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u901a\u5e38\u4f9d\u8d56 queue \u8fd9\u4e00\u6570\u636e\u7ed3\u6784\u3002 BFS \u6709\u5355\u5411\u548c\u53cc\u5411\u4e24\u79cd\u65b9\u5f0f\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u533a\u522b\uff0c\u4f46\u53cc\u5411\u5728\u65f6\u95f4\u6548\u7387\u4e0a\u5177\u6709\u4f18\u52bf\u3002 \u4f8b\u5982\uff0c\u73b0\u6709\u4e00\u5f20\u5730\u56fe\uff0c\u7531 0 \u548c 1 \u7ec4\u6210\uff0c\u6bcf\u6b21\u79fb\u52a8\u53ef\u4ee5\u671d\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u3001\u4e0a\u5de6\u3001\u4e0a\u53f3\u3001\u4e0b\u5de6\u548c\u4e0b\u53f3\u8fd9\u516b\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u5e76\u53ea\u5141\u8bb8\u843d\u5165 0 \u7684\u683c\u5b50\uff0c\u6c42\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u5982\u679c\u4e0d\u80fd\u5230\u8fbe\uff0c\u8fd4\u56de -1\u3002 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \u6700\u77ed\u7684\u957f\u5ea6\u662f 11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int shortestPathBinaryMatrix ( vector < vector < int >>& grid ) { int nRow = ( int ) grid . size (); if ( nRow == 0 ) { return - 1 ; } if ( nRow == 1 ) { return 1 ; } int nCol = ( int ) grid [ 0 ]. size (); int direction [ 8 ][ 2 ] = { { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 }, { 0 , - 1 }, { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 } }; if ( grid [ 0 ][ 0 ] || grid [ nRow - 1 ][ nCol - 1 ]) { return - 1 ; } queue < vector < int >> q1 , q2 ; q1 . push ({ 0 , 0 }); q2 . push ({ nRow - 1 , nCol - 1 }); int ans = 0 ; while ( ! q1 . empty () && ! q2 . empty ()) { int size1 = ( int ) q1 . size (); while ( size1 -- ) { int x = q1 . front ()[ 0 ]; int y = q1 . front ()[ 1 ]; q1 . pop (); if ( grid [ x ][ y ] == 3 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 2 ) { continue ; } grid [ x ][ y ] = 2 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 2 ) { continue ; } q1 . push ({ nx , ny }); } } ans ++ ; int size2 = ( int ) q2 . size (); while ( size2 -- ) { int x = q2 . front ()[ 0 ]; int y = q2 . front ()[ 1 ]; q2 . pop (); if ( grid [ x ][ y ] == 2 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 3 ) { continue ; } grid [ x ][ y ] = 3 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 3 ) { continue ; } q2 . push ({ nx , ny }); } } ans ++ ; } return - 1 ; } \u8bbf\u95ee\u6240\u6709\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u65e0\u5411\u8fde\u901a\u56fe G\uff0c\u627e\u5230\u4e00\u6761\u6700\u77ed\u7684\u8def\u5f84\uff0c\u6ee1\u8db3\u6240\u6709\u7684\u5373\u8282\u70b9\u90fd\u88ab\u8bbf\u95ee\u5230\u3002\u4f8b\u5982\uff0cgraph = [[1, 2, 3], [ 0 ], [ 0 ], [ 0 ]]\uff0cgraph[ i ] \u8868\u793a\u4e0e i \u76f8\u90bb\u7684\u8282\u70b9\u5217\u8868\uff0c\u6700\u77ed\u8def\u5f84\u662f 1 -> 0 -> 2 -> 0 -> 3\uff0c\u957f\u5ea6\u662f 4 \u300c\u5206\u6790\u300d \u3010\u72b6\u6001\u538b\u7f29 + BFS\u641c\u7d22\u3011\uff0c\u8bbe\u7f6e\u4e00\u4e2a\u4e09\u5143\u7ec4 (u, mask, dist) \u8868\u793a\u8282\u70b9\u7f16\u53f7\u3001\u5df2\u8bbf\u95ee\u8282\u70b9\u7684\u538b\u7f29\u72b6\u6001\u3001\u5f53\u524d\u8282\u70b9\u7684\u8ddd\u79bb\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int shortestPathLength ( vector < vector < int >>& graph ) { int n = ( int ) graph . size (), ans = 0 ; queue < vector < int >> q ; bool ** vis = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { vis [ i ] = new bool [ 1 << n ]{}; } for ( int i = 0 ; i < n ; i ++ ) { vis [ i ][ 1 << i ] = true ; q . push ({ i , 1 << i , 0 }); } while ( ! q . empty ()) { auto tpl = q . front (); q . pop (); if ( tpl [ 1 ] == ( 1 << n ) - 1 ) { ans = tpl [ 2 ]; break ; } for ( int i : graph [ tpl [ 0 ]]) { int mask = tpl [ 1 ] | ( 1 << i ); if ( ! vis [ i ][ mask ]) { vis [ i ][ mask ] = true ; q . push ({ i , mask , tpl [ 2 ] + 1 }); } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n} n^{2}) O(2^{n} n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n 2^{n}) O(n 2^{n}) \u6700\u5c0f\u9ad8\u5ea6\u6811 \u00b6 \u6811\u662f\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u5176\u4e2d\u4efb\u4f55\u4e24\u4e2a\u9876\u70b9\u53ea\u901a\u8fc7\u4e00\u6761\u8def\u5f84\u8fde\u63a5\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u4e00\u4e2a\u4efb\u4f55\u6ca1\u6709\u7b80\u5355\u73af\u8def\u7684\u8fde\u901a\u56fe\u90fd\u662f\u4e00\u68f5\u6811\u3002 \u7ed9\u4f60\u4e00\u68f5\u5305\u542b n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6807\u8bb0\u4e3a 0 \u5230 n - 1 \u3002\u7ed9\u5b9a\u6570\u5b57 n \u548c\u4e00\u4e2a\u6709 n - 1 \u6761\u65e0\u5411\u8fb9\u7684 edges \u5217\u8868\uff08\u6bcf\u4e00\u4e2a\u8fb9\u90fd\u662f\u4e00\u5bf9\u6807\u7b7e\uff09\uff0c\u5176\u4e2d edges[i] = [ai, bi] \u8868\u793a\u6811\u4e2d\u8282\u70b9 ai \u548c bi \u4e4b\u95f4\u5b58\u5728\u4e00\u6761\u65e0\u5411\u8fb9\u3002 \u53ef\u9009\u62e9\u6811\u4e2d\u4efb\u4f55\u4e00\u4e2a\u8282\u70b9\u4f5c\u4e3a\u6839\u3002\u5f53\u9009\u62e9\u8282\u70b9 x \u4f5c\u4e3a\u6839\u8282\u70b9\u65f6\uff0c\u8bbe\u7ed3\u679c\u6811\u7684\u9ad8\u5ea6\u4e3a h \u3002\u5728\u6240\u6709\u53ef\u80fd\u7684\u6811\u4e2d\uff0c\u5177\u6709\u6700\u5c0f\u9ad8\u5ea6\u7684\u6811\uff08\u5373\uff0cmin(h)\uff09\u88ab\u79f0\u4e3a \u6700\u5c0f\u9ad8\u5ea6\u6811 \u3002 \u8bf7\u4f60\u627e\u5230\u6240\u6709\u7684 \u6700\u5c0f\u9ad8\u5ea6\u6811 \u5e76\u6309 \u4efb\u610f\u987a\u5e8f \u8fd4\u56de\u5b83\u4eec\u7684\u6839\u8282\u70b9\u6807\u7b7e\u5217\u8868\u3002 \u6811\u7684 \u9ad8\u5ea6 \u662f\u6307\u6839\u8282\u70b9\u548c\u53f6\u5b50\u8282\u70b9\u4e4b\u95f4\u6700\u957f\u5411\u4e0b\u8def\u5f84\u4e0a\u8fb9\u7684\u6570\u91cf\u3002 \\begin{matrix} & & & 1 \\\\ & & & \\uparrow\\\\ & & & 0 \\\\ & & \\swarrow & & \\searrow \\\\ & 2 & & & & 3 \\end{matrix} \\begin{matrix} & & & 1 \\\\ & & & \\uparrow\\\\ & & & 0 \\\\ & & \\swarrow & & \\searrow \\\\ & 2 & & & & 3 \\end{matrix} \u6700\u5c0f\u7684\u9ad8\u5ea6\u4e3a 1\uff0c\u6839\u8282\u70b9\u662f 0 \u300c\u5206\u6790\u300d \u3010BFS + \u62d3\u6251\u6392\u5e8f\u3011\u5bf9\u4e8e\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u627e\u5230\u6240\u6709\u5ea6\u4e3a 1 \u7684\u8282\u70b9\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\u4e0d\u65ad\u5411\u5185\u8513\u5ef6\uff0c\u76f4\u5230\u6700\u5185\u4e00\u5c42\u7684\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 vector < int > findMinHeightTrees ( int n , vector < vector < int >>& edges ) { vector < int > ans , degree ( n , 0 ); if ( n == 1 ) { return { 0 }; } unordered_map < int , vector < int >> neighbors ; for ( vector < int > edge : edges ) { neighbors [ edge [ 0 ]]. emplace_back ( edge [ 1 ]); neighbors [ edge [ 1 ]]. emplace_back ( edge [ 0 ]); degree [ edge [ 0 ]] ++ ; degree [ edge [ 1 ]] ++ ; } unordered_set < int > vis ; queue < int > q ; for ( int i = 0 ; i < n ; i ++ ) { if ( degree [ i ] == 1 ) { vis . emplace ( i ); q . push ( i ); degree [ i ] -- ; } } while ( ! q . empty ()) { ans . clear (); size_t q_size = q . size (); for ( int _ = 0 ; _ < q_size ; _ ++ ) { int front = q . front (); q . pop (); ans . emplace_back ( front ); for ( int neighbor : neighbors [ front ]) { if ( vis . count ( neighbor )) { continue ; } degree [ neighbor ] -- ; if ( degree [ neighbor ] == 1 ) { q . push ( neighbor ); vis . emplace ( neighbor ); } } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u6253\u5f00\u8f6c\u76d8\u9501 \u00b6 \u4f60\u6709\u4e00\u4e2a\u5e26\u6709\u56db\u4e2a\u5706\u5f62\u62e8\u8f6e\u7684\u8f6c\u76d8\u9501\u3002\u6bcf\u4e2a\u62e8\u8f6e\u90fd\u670910\u4e2a\u6570\u5b57\uff1a '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' \u3002\u6bcf\u4e2a\u62e8\u8f6e\u53ef\u4ee5\u81ea\u7531\u65cb\u8f6c\uff1a\u4f8b\u5982\u628a '9' \u53d8\u4e3a '0'\uff0c'0' \u53d8\u4e3a '9' \u3002\u6bcf\u6b21\u65cb\u8f6c\u90fd\u53ea\u80fd\u65cb\u8f6c\u4e00\u4e2a\u62e8\u8f6e\u7684\u4e00\u4f4d\u6570\u5b57\u3002\u9501\u7684\u521d\u59cb\u6570\u5b57\u4e3a '0000' \uff0c\u4e00\u4e2a\u4ee3\u8868\u56db\u4e2a\u62e8\u8f6e\u7684\u6570\u5b57\u7684\u5b57\u7b26\u4e32\u3002\u5217\u8868 deadends \u5305\u542b\u4e86\u4e00\u7ec4\u6b7b\u4ea1\u6570\u5b57\uff0c\u4e00\u65e6\u62e8\u8f6e\u7684\u6570\u5b57\u548c\u5217\u8868\u91cc\u7684\u4efb\u4f55\u4e00\u4e2a\u5143\u7d20\u76f8\u540c\uff0c\u8fd9\u4e2a\u9501\u5c06\u4f1a\u88ab\u6c38\u4e45\u9501\u5b9a\uff0c\u65e0\u6cd5\u518d\u88ab\u65cb\u8f6c\u3002\u5b57\u7b26\u4e32 target \u4ee3\u8868\u53ef\u4ee5\u89e3\u9501\u7684\u6570\u5b57\uff0c\u4f60\u9700\u8981\u7ed9\u51fa\u89e3\u9501\u9700\u8981\u7684\u6700\u5c0f\u65cb\u8f6c\u6b21\u6570\uff0c\u5982\u679c\u65e0\u8bba\u5982\u4f55\u4e0d\u80fd\u89e3\u9501\uff0c\u8fd4\u56de -1 \u3002 \u300c\u5206\u6790\u300d \u300cBFS\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int openLock ( vector < string >& deadends , string target ) { string init = \"0000\" ; int n = int ( init . length ()), ans = 0 ; unordered_set < string > vis ; for ( string & str : deadends ) { vis . insert ( str ); } if ( vis . find ( init ) != vis . end ()) { return - 1 ; } queue < string > qLock ; qLock . push ( init ); while ( ! qLock . empty ()) { int num = int ( qLock . size ()); while ( num -- ) { string str = qLock . front (); qLock . pop (); if ( str == target ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { string tmp = str ; for ( int d = - 1 ; d <= 1 ; d += 2 ) { tmp [ i ] = ( str [ i ] - '0' + 10 + d ) % 10 + '0' ; if ( vis . find ( tmp ) == vis . end ()) { vis . insert ( tmp ); qLock . push ( tmp ); } } } } ans ++ ; } return - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u641c\u7d22"},{"location":"algo/search/#dfs","text":"\u300c\u7b80\u4ecb\u300d \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08Depth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u5b50\u8282\u70b9\uff0c\u5982\u679c\u53ef\u4ee5\u641c\u7d22\u5230\u76ee\u6807\uff0c\u5373\u505c\u6b62\u6216\u5c06\u7ed3\u679c\u4fdd\u5b58\u8d77\u6765\uff1b\u53cd\u4e4b\uff0c\u56de\u6eaf\u5230\u5206\u53c9\u5904\uff0c\u4f9d\u6b21\u904d\u5386\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002","title":"DFS"},{"location":"algo/search/#_1","text":"\u300c\u5e8f\u5217\u5143\u7d20\u4e0d\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [1, 2, 3] ,\u5143\u7d20\u4e92\u4e0d\u76f8\u540c\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void dfs ( vector < int > & nums , int n , int idx , vector < vector < int >> & ans ) { if ( idx == n ) { ans . emplace_back ( nums ); return ; } for ( int i = idx ; i < n ; i ++ ) { swap ( nums [ i ], nums [ idx ]); dfs ( nums , n , idx + 1 , ans ); swap ( nums [ i ], nums [ idx ]); } } vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } dfs ( nums , n , 0 , ans ); return ans ; } \u300c\u5e8f\u5217\u5143\u7d20\u6709\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [3, 3, 0, 3] \uff0c\u5143\u7d20\u6709\u91cd\u590d\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void dfs ( vector < vector < int >> & ans , vector < int > & nums , int n , int idx , bool * vis , vector < int > & arr ) { if ( idx == n ) { ans . emplace_back ( arr ); return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! vis [ i - 1 ])) { continue ; } vis [ i ] = true ; arr . emplace_back ( nums [ i ]); dfs ( ans , nums , n , idx + 1 , vis , arr ); arr . pop_back (); vis [ i ] = false ; } } vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } sort ( nums . begin (), nums . end ()); vector < int > arr ; bool * vis = new bool [ n ]{}; dfs ( ans , nums , n , 0 , vis , arr ); delete [] vis ; return ans ; }","title":"\u5168\u6392\u5217"},{"location":"algo/search/#_2","text":"\u300c\u53ea\u80fd\u4f7f\u7528\u4e00\u6b21\u300d \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 candidates \u548c\u4e00\u4e2a\u76ee\u6807\u6570 target \uff0c\u627e\u51fa candidates \u4e2d\u6240\u6709\u53ef\u4ee5\u4f7f\u6570\u5b57\u548c\u4e3a target \u7684\u7ec4\u5408\u3002candidates \u4e2d\u7684\u6bcf\u4e2a\u6570\u5b57\u5728\u6bcf\u4e2a\u7ec4\u5408\u4e2d\u53ea\u80fd\u4f7f\u7528\u4e00\u6b21\u3002\u89e3\u96c6\u4e0d\u80fd\u5305\u542b\u91cd\u590d\u7684\u7ec4\u5408\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* \u793a\u4f8b: \u8f93\u5165: candidates = [2,5,2,1,2], target = 5, \u6240\u6c42\u89e3\u96c6\u4e3a: [ [1,2,2], [5] ] */ vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> res ; vector < int > arr ; int n = int ( candidates . size ()); if ( n == 0 ) { return res ; } map < int , int > dict ; map < int , int >:: iterator iter ; for ( int num : candidates ) { iter = dict . find ( num ); if ( iter == dict . end ()) { dict [ num ] = 1 ; } else { dict [ num ] ++ ; } } vector < pair < int , int >> nums ; int size = 0 ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { nums . emplace_back ( iter -> first , iter -> second ); size ++ ; } DFS ( res , arr , candidates , target , 0 , size , nums ); return res ; } void DFS ( vector < vector < int >> & res , vector < int > & arr , vector < int > candidates , int target , int idx , int size , vector < pair < int , int >> nums ) { if ( target <= 0 || idx >= size ) { if ( target == 0 ) { res . push_back ( arr ); } return ; } for ( int j = 1 ; j <= nums [ idx ]. second ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { arr . push_back ( nums [ idx ]. first ); } DFS ( res , arr , candidates , target - j * nums [ idx ]. first , idx + 1 , size , nums ); for ( int k = 0 ; k < j ; k ++ ) { arr . pop_back (); } } DFS ( res , arr , candidates , target , idx + 1 , size , nums ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u300c\u65e0\u9650\u4f7f\u7528\u300d \u7ed9\u5b9a\u4e00\u4e2a\u65e0\u91cd\u590d\u5143\u7d20\u7684\u6570\u7ec4 candidates \u548c\u4e00\u4e2a\u76ee\u6807\u6570 target \uff0c\u627e\u51fa candidates \u4e2d\u6240\u6709\u53ef\u4ee5\u4f7f\u6570\u5b57\u548c\u4e3a target \u7684\u7ec4\u5408\u3002candidates \u4e2d\u7684\u6570\u5b57\u53ef\u4ee5\u65e0\u9650\u5236\u91cd\u590d\u88ab\u9009\u53d6\u3002\u89e3\u96c6\u4e0d\u80fd\u5305\u542b\u91cd\u590d\u7684\u7ec4\u5408\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u793a\u4f8b\uff1a \u8f93\u5165\uff1acandidates = [2,3,6,7], target = 7, \u6240\u6c42\u89e3\u96c6\u4e3a\uff1a [ [7], [2,2,3] ] */ vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> res ; vector < int > arr ; int n = int ( candidates . size ()); if ( n == 0 ) { return res ; } DFS ( res , arr , candidates , n , target , 0 ); return res ; } void DFS ( vector < vector < int >> & res , vector < int > & arr , vector < int > candidates , int n , int target , int idx ) { if ( target == 0 ) { res . push_back ( arr ); return ; } for ( int i = idx ; i < n ; i ++ ) { if ( target - candidates [ i ] >= 0 ) { arr . push_back ( candidates [ i ]); DFS ( res , arr , candidates , n , target - candidates [ i ], i ); arr . resize ( arr . size () - 1 ); } } } \u65f6\u95f4\u590d\u6742\u5ea6 O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002","title":"\u7ec4\u5408\u603b\u548c"},{"location":"algo/search/#_3","text":"\u300c\u5e8f\u5217\u5143\u7d20\u4e0d\u91cd\u590d\u300d \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u4e92\u4e0d\u76f8\u540c \u3002\u8fd4\u56de\u8be5\u6570\u7ec4\u6240\u6709\u53ef\u80fd\u7684\u5b50\u96c6\uff08\u5e42\u96c6\uff09\u3002\u4f8b\u5982\uff0cnums = [1,2,3]\uff0c\u8fd4\u56de [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); vector < int > arr ; dfs ( ans , arr , nums , n , 0 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int n , int idx ) { if ( idx == n ) { ans . emplace_back ( arr ); return ; } arr . emplace_back ( nums [ idx ]); dfs ( ans , arr , nums , n , idx + 1 ); arr . pop_back (); dfs ( ans , arr , nums , n , idx + 1 ); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \u3002 \u300c\u5e8f\u5217\u5143\u7d20\u6709\u91cd\u590d\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] */ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); sort ( nums . begin (), nums . end ()); vector < int > arr ; dfs ( ans , arr , nums , 0 , n ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int idx , int n ) { for ( int i = idx ; i < n ; i ++ ) { if ( i > idx && nums [ i ] == nums [ i - 1 ]) { continue ; } arr . emplace_back ( nums [ i ]); dfs ( ans , arr , nums , i + 1 , n ); arr . pop_back (); } ans . emplace_back ( arr ); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \u3002","title":"\u5b50\u96c6"},{"location":"algo/search/#k","text":"\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u548c\u8282\u70b9 target\uff0c\u6c42\u6240\u6709\u7684\u8ddd\u79bb target \u4e3a k \u7684\u8282\u70b9\u3002\u8fd9\u91cc\u7684\u8ddd\u79bb\u6307\u7684\u662f\u8fb9\u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u5982\u679c\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u5305\u542b\u4e86\u7236\u8282\u70b9\u7684\u4fe1\u606f\uff0c\u76f4\u63a5 dfs \u904d\u5386\uff1b\u5982\u679c\u4e0d\u5305\u542b\u7236\u8282\u70b9\u4fe1\u606f\uff0c\u5219\u5148\u7528\u54c8\u5e0c\u8868\u4fdd\u5b58\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684\u7236\u8282\u70b9\uff0c\u518d\u7528 dfs \u641c\u7d22\u3002\u6ce8\u610f\u904d\u5386\u65f6\u4fdd\u5b58\u5df2\u7ecf\u8bbf\u95ee\u7684\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 unordered_map < TreeNode * , TreeNode *> par ; unordered_set < TreeNode *> vis ; void findParNode ( TreeNode * root ) { if ( root != nullptr ) { if ( root -> left != nullptr ) { par [ root -> left ] = root ; } if ( root -> right != nullptr ) { par [ root -> right ] = root ; } findParNode ( root -> left ); findParNode ( root -> right ); } } void dfs ( TreeNode * curNode , int k , vector < int > & ans ) { if ( curNode == nullptr || vis . count ( curNode )) { return ; } if ( k == 0 ) { ans . emplace_back ( curNode -> val ); return ; } vis . insert ( curNode ); dfs ( par [ curNode ], k - 1 , ans ); dfs ( curNode -> left , k - 1 , ans ); dfs ( curNode -> right , k - 1 , ans ); } vector < int > distanceK ( TreeNode * root , TreeNode * target , int k ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } par [ root ] = nullptr ; findParNode ( root ); dfs ( target , k , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u4e8c\u53c9\u6811\u67d0\u4e00\u8282\u70b9\u6240\u6709\u8ddd\u79bb\u4e3a k \u7684\u8282\u70b9"},{"location":"algo/search/#_4","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6b63\u6574\u6570 a = 10\uff0cb = 11\uff0c\u4e24\u4e2a\u73a9\u5bb6\uff0c\u6bcf\u4eba\u4f9d\u6b21\u51fa\u4e00\u4e2a\u6570\u5b57\uff081 - a\u4e4b\u95f4\uff09\uff0c\u7d2f\u52a0\u548c\u5148\u5230 b \u7684\u83b7\u80dc\uff0c\u8bd5\u95ee\uff0c\u5148\u624b\u80fd\u8d62\u4e48\uff1f \u300c\u5206\u6790\u300d \u3010\u72b6\u6001\u538b\u7f29+ DFS\u8bb0\u5fc6\u4f18\u5316\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 unordered_map < int , bool > memo ; bool dfs ( int n , int m , int state ) { if ( memo . count ( state )) { return memo [ state ]; } for ( int i = 1 ; i <= n ; i ++ ) { if ( state & ( 1 << i )) { continue ; } if ( i >= m ) { memo [ state | ( 1 << i )] = true ; return true ; } else { bool oppo_win = dfs ( n , m - i , state | ( 1 << i )); if ( ! oppo_win ) { memo [ state ] = true ; return true ; } } } memo [ state ] = false ; return false ; } bool canIWin ( int maxChoosableInteger , int desiredTotal ) { if ( maxChoosableInteger >= desiredTotal ) { return true ; } if (( 1 + maxChoosableInteger ) * maxChoosableInteger < 2 * desiredTotal ) { return false ; } bool ans = dfs ( maxChoosableInteger , desiredTotal , 0 ); return ans ; }","title":"\u6211\u80fd\u8d62\u6e38\u620f"},{"location":"algo/search/#_5","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 obstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] \u8868\u793a\u4e00\u4e2a\u7f51\u683c\uff0c\u5176\u4e2d 1 \u4e3a\u969c\u788d\uff0c\u4e0d\u80fd\u901a\u8fc7\u3002\u5f00\u59cb\u4f4d\u7f6e\u662f\u5de6\u4e0a\u89d2\uff0c\u7ed3\u675f\u4f4d\u7f6e\u662f\u53f3\u4e0b\u89d2\u3002\u8fd4\u56de\u4e00\u6761\u53ef\u884c\u7684\u8def\u5f84\uff08\u5982\u679c\u5b58\u5728\uff09\u3002 \u300c\u5206\u6790\u300d \u3010DFS + \u526a\u679d\u3011\u4e00\u65e6\u627e\u5230\u4e00\u6761\u8def\u5f84\u5373\u8fd4\u56de\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 bool dfs ( vector < vector < int >> & grid , int n , int m , int i , int j , vector < vector < int >> & ans ) { if ( i == n || j == m || grid [ i ][ j ] == 1 ) { return false ; } grid [ i ][ j ] = 1 ; ans . emplace_back ( vector < int > { i , j }); if ( i == n - 1 && j == m - 1 ) { return true ; } if ( dfs ( grid , n , m , i + 1 , j , ans )) { return true ; } if ( dfs ( grid , n , m , i , j + 1 , ans )) { return true ; } ans . pop_back (); return false ; } vector < vector < int >> pathWithObstacles ( vector < vector < int >>& obstacleGrid ) { vector < vector < int >> ans ; int n = ( int ) obstacleGrid . size (), m = ( int ) obstacleGrid [ 0 ]. size (); dfs ( obstacleGrid , n , m , 0 , 0 , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm)","title":"\u627e\u8def"},{"location":"algo/search/#_6","text":"\u6570\u5b57 n \u4ee3\u8868\u751f\u6210\u62ec\u53f7\u7684\u5bf9\u6570\uff0c\u8bf7\u4f60\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u4e8e\u80fd\u591f\u751f\u6210\u6240\u6709\u53ef\u80fd\u7684\u5e76\u4e14 \u6709\u6548\u7684 \u62ec\u53f7\u7ec4\u5408\u3002\u4f8b\u5982\uff0cn = 3\uff0c\u8fd4\u56de [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\u3002 \u300c\u5206\u6790\u300d \u300cDFS\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void dfs ( vector < string > & ans , string s , int n , int a , int b ) { if ( a == n && b == n ) { ans . emplace_back ( s ); return ; } if ( a > n || b > n ) { return ; } if ( a == b ) { dfs ( ans , s + \"(\" , n , a + 1 , b ); } else if ( a > b ) { dfs ( ans , s + \"(\" , n , a + 1 , b ); dfs ( ans , s + \")\" , n , a , b + 1 ); } } vector < string > generateParenthesis ( int n ) { vector < string > ans ; dfs ( ans , \"\" , n , 0 , 0 ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u62ec\u53f7\u751f\u6210"},{"location":"algo/search/#bfs","text":"\u300c\u7b80\u4ecb\u300d \u5bbd\u5ea6\u4f18\u5148\u641c\u7d22\uff08Breadth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u6240\u6709\u76f4\u63a5\u90bb\u5c45\u8282\u70b9\uff0c\u4e00\u822c\u800c\u8a00\uff0cBFS \u9002\u7528\u4e8e\u6c42\u89e3\u6700\u77ed\u957f\u5ea6\u7684\u95ee\u9898\u3002\u5728\u6c42\u89e3\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u901a\u5e38\u4f9d\u8d56 queue \u8fd9\u4e00\u6570\u636e\u7ed3\u6784\u3002 BFS \u6709\u5355\u5411\u548c\u53cc\u5411\u4e24\u79cd\u65b9\u5f0f\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u533a\u522b\uff0c\u4f46\u53cc\u5411\u5728\u65f6\u95f4\u6548\u7387\u4e0a\u5177\u6709\u4f18\u52bf\u3002 \u4f8b\u5982\uff0c\u73b0\u6709\u4e00\u5f20\u5730\u56fe\uff0c\u7531 0 \u548c 1 \u7ec4\u6210\uff0c\u6bcf\u6b21\u79fb\u52a8\u53ef\u4ee5\u671d\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u3001\u4e0a\u5de6\u3001\u4e0a\u53f3\u3001\u4e0b\u5de6\u548c\u4e0b\u53f3\u8fd9\u516b\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u5e76\u53ea\u5141\u8bb8\u843d\u5165 0 \u7684\u683c\u5b50\uff0c\u6c42\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u5982\u679c\u4e0d\u80fd\u5230\u8fbe\uff0c\u8fd4\u56de -1\u3002 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \u6700\u77ed\u7684\u957f\u5ea6\u662f 11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int shortestPathBinaryMatrix ( vector < vector < int >>& grid ) { int nRow = ( int ) grid . size (); if ( nRow == 0 ) { return - 1 ; } if ( nRow == 1 ) { return 1 ; } int nCol = ( int ) grid [ 0 ]. size (); int direction [ 8 ][ 2 ] = { { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 }, { 0 , - 1 }, { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 } }; if ( grid [ 0 ][ 0 ] || grid [ nRow - 1 ][ nCol - 1 ]) { return - 1 ; } queue < vector < int >> q1 , q2 ; q1 . push ({ 0 , 0 }); q2 . push ({ nRow - 1 , nCol - 1 }); int ans = 0 ; while ( ! q1 . empty () && ! q2 . empty ()) { int size1 = ( int ) q1 . size (); while ( size1 -- ) { int x = q1 . front ()[ 0 ]; int y = q1 . front ()[ 1 ]; q1 . pop (); if ( grid [ x ][ y ] == 3 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 2 ) { continue ; } grid [ x ][ y ] = 2 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 2 ) { continue ; } q1 . push ({ nx , ny }); } } ans ++ ; int size2 = ( int ) q2 . size (); while ( size2 -- ) { int x = q2 . front ()[ 0 ]; int y = q2 . front ()[ 1 ]; q2 . pop (); if ( grid [ x ][ y ] == 2 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 3 ) { continue ; } grid [ x ][ y ] = 3 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 3 ) { continue ; } q2 . push ({ nx , ny }); } } ans ++ ; } return - 1 ; }","title":"BFS"},{"location":"algo/search/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u65e0\u5411\u8fde\u901a\u56fe G\uff0c\u627e\u5230\u4e00\u6761\u6700\u77ed\u7684\u8def\u5f84\uff0c\u6ee1\u8db3\u6240\u6709\u7684\u5373\u8282\u70b9\u90fd\u88ab\u8bbf\u95ee\u5230\u3002\u4f8b\u5982\uff0cgraph = [[1, 2, 3], [ 0 ], [ 0 ], [ 0 ]]\uff0cgraph[ i ] \u8868\u793a\u4e0e i \u76f8\u90bb\u7684\u8282\u70b9\u5217\u8868\uff0c\u6700\u77ed\u8def\u5f84\u662f 1 -> 0 -> 2 -> 0 -> 3\uff0c\u957f\u5ea6\u662f 4 \u300c\u5206\u6790\u300d \u3010\u72b6\u6001\u538b\u7f29 + BFS\u641c\u7d22\u3011\uff0c\u8bbe\u7f6e\u4e00\u4e2a\u4e09\u5143\u7ec4 (u, mask, dist) \u8868\u793a\u8282\u70b9\u7f16\u53f7\u3001\u5df2\u8bbf\u95ee\u8282\u70b9\u7684\u538b\u7f29\u72b6\u6001\u3001\u5f53\u524d\u8282\u70b9\u7684\u8ddd\u79bb\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int shortestPathLength ( vector < vector < int >>& graph ) { int n = ( int ) graph . size (), ans = 0 ; queue < vector < int >> q ; bool ** vis = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { vis [ i ] = new bool [ 1 << n ]{}; } for ( int i = 0 ; i < n ; i ++ ) { vis [ i ][ 1 << i ] = true ; q . push ({ i , 1 << i , 0 }); } while ( ! q . empty ()) { auto tpl = q . front (); q . pop (); if ( tpl [ 1 ] == ( 1 << n ) - 1 ) { ans = tpl [ 2 ]; break ; } for ( int i : graph [ tpl [ 0 ]]) { int mask = tpl [ 1 ] | ( 1 << i ); if ( ! vis [ i ][ mask ]) { vis [ i ][ mask ] = true ; q . push ({ i , mask , tpl [ 2 ] + 1 }); } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n} n^{2}) O(2^{n} n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n 2^{n}) O(n 2^{n})","title":"\u8bbf\u95ee\u6240\u6709\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84"},{"location":"algo/search/#_8","text":"\u6811\u662f\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u5176\u4e2d\u4efb\u4f55\u4e24\u4e2a\u9876\u70b9\u53ea\u901a\u8fc7\u4e00\u6761\u8def\u5f84\u8fde\u63a5\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u4e00\u4e2a\u4efb\u4f55\u6ca1\u6709\u7b80\u5355\u73af\u8def\u7684\u8fde\u901a\u56fe\u90fd\u662f\u4e00\u68f5\u6811\u3002 \u7ed9\u4f60\u4e00\u68f5\u5305\u542b n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6807\u8bb0\u4e3a 0 \u5230 n - 1 \u3002\u7ed9\u5b9a\u6570\u5b57 n \u548c\u4e00\u4e2a\u6709 n - 1 \u6761\u65e0\u5411\u8fb9\u7684 edges \u5217\u8868\uff08\u6bcf\u4e00\u4e2a\u8fb9\u90fd\u662f\u4e00\u5bf9\u6807\u7b7e\uff09\uff0c\u5176\u4e2d edges[i] = [ai, bi] \u8868\u793a\u6811\u4e2d\u8282\u70b9 ai \u548c bi \u4e4b\u95f4\u5b58\u5728\u4e00\u6761\u65e0\u5411\u8fb9\u3002 \u53ef\u9009\u62e9\u6811\u4e2d\u4efb\u4f55\u4e00\u4e2a\u8282\u70b9\u4f5c\u4e3a\u6839\u3002\u5f53\u9009\u62e9\u8282\u70b9 x \u4f5c\u4e3a\u6839\u8282\u70b9\u65f6\uff0c\u8bbe\u7ed3\u679c\u6811\u7684\u9ad8\u5ea6\u4e3a h \u3002\u5728\u6240\u6709\u53ef\u80fd\u7684\u6811\u4e2d\uff0c\u5177\u6709\u6700\u5c0f\u9ad8\u5ea6\u7684\u6811\uff08\u5373\uff0cmin(h)\uff09\u88ab\u79f0\u4e3a \u6700\u5c0f\u9ad8\u5ea6\u6811 \u3002 \u8bf7\u4f60\u627e\u5230\u6240\u6709\u7684 \u6700\u5c0f\u9ad8\u5ea6\u6811 \u5e76\u6309 \u4efb\u610f\u987a\u5e8f \u8fd4\u56de\u5b83\u4eec\u7684\u6839\u8282\u70b9\u6807\u7b7e\u5217\u8868\u3002 \u6811\u7684 \u9ad8\u5ea6 \u662f\u6307\u6839\u8282\u70b9\u548c\u53f6\u5b50\u8282\u70b9\u4e4b\u95f4\u6700\u957f\u5411\u4e0b\u8def\u5f84\u4e0a\u8fb9\u7684\u6570\u91cf\u3002 \\begin{matrix} & & & 1 \\\\ & & & \\uparrow\\\\ & & & 0 \\\\ & & \\swarrow & & \\searrow \\\\ & 2 & & & & 3 \\end{matrix} \\begin{matrix} & & & 1 \\\\ & & & \\uparrow\\\\ & & & 0 \\\\ & & \\swarrow & & \\searrow \\\\ & 2 & & & & 3 \\end{matrix} \u6700\u5c0f\u7684\u9ad8\u5ea6\u4e3a 1\uff0c\u6839\u8282\u70b9\u662f 0 \u300c\u5206\u6790\u300d \u3010BFS + \u62d3\u6251\u6392\u5e8f\u3011\u5bf9\u4e8e\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u627e\u5230\u6240\u6709\u5ea6\u4e3a 1 \u7684\u8282\u70b9\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\u4e0d\u65ad\u5411\u5185\u8513\u5ef6\uff0c\u76f4\u5230\u6700\u5185\u4e00\u5c42\u7684\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 vector < int > findMinHeightTrees ( int n , vector < vector < int >>& edges ) { vector < int > ans , degree ( n , 0 ); if ( n == 1 ) { return { 0 }; } unordered_map < int , vector < int >> neighbors ; for ( vector < int > edge : edges ) { neighbors [ edge [ 0 ]]. emplace_back ( edge [ 1 ]); neighbors [ edge [ 1 ]]. emplace_back ( edge [ 0 ]); degree [ edge [ 0 ]] ++ ; degree [ edge [ 1 ]] ++ ; } unordered_set < int > vis ; queue < int > q ; for ( int i = 0 ; i < n ; i ++ ) { if ( degree [ i ] == 1 ) { vis . emplace ( i ); q . push ( i ); degree [ i ] -- ; } } while ( ! q . empty ()) { ans . clear (); size_t q_size = q . size (); for ( int _ = 0 ; _ < q_size ; _ ++ ) { int front = q . front (); q . pop (); ans . emplace_back ( front ); for ( int neighbor : neighbors [ front ]) { if ( vis . count ( neighbor )) { continue ; } degree [ neighbor ] -- ; if ( degree [ neighbor ] == 1 ) { q . push ( neighbor ); vis . emplace ( neighbor ); } } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u6700\u5c0f\u9ad8\u5ea6\u6811"},{"location":"algo/search/#_9","text":"\u4f60\u6709\u4e00\u4e2a\u5e26\u6709\u56db\u4e2a\u5706\u5f62\u62e8\u8f6e\u7684\u8f6c\u76d8\u9501\u3002\u6bcf\u4e2a\u62e8\u8f6e\u90fd\u670910\u4e2a\u6570\u5b57\uff1a '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' \u3002\u6bcf\u4e2a\u62e8\u8f6e\u53ef\u4ee5\u81ea\u7531\u65cb\u8f6c\uff1a\u4f8b\u5982\u628a '9' \u53d8\u4e3a '0'\uff0c'0' \u53d8\u4e3a '9' \u3002\u6bcf\u6b21\u65cb\u8f6c\u90fd\u53ea\u80fd\u65cb\u8f6c\u4e00\u4e2a\u62e8\u8f6e\u7684\u4e00\u4f4d\u6570\u5b57\u3002\u9501\u7684\u521d\u59cb\u6570\u5b57\u4e3a '0000' \uff0c\u4e00\u4e2a\u4ee3\u8868\u56db\u4e2a\u62e8\u8f6e\u7684\u6570\u5b57\u7684\u5b57\u7b26\u4e32\u3002\u5217\u8868 deadends \u5305\u542b\u4e86\u4e00\u7ec4\u6b7b\u4ea1\u6570\u5b57\uff0c\u4e00\u65e6\u62e8\u8f6e\u7684\u6570\u5b57\u548c\u5217\u8868\u91cc\u7684\u4efb\u4f55\u4e00\u4e2a\u5143\u7d20\u76f8\u540c\uff0c\u8fd9\u4e2a\u9501\u5c06\u4f1a\u88ab\u6c38\u4e45\u9501\u5b9a\uff0c\u65e0\u6cd5\u518d\u88ab\u65cb\u8f6c\u3002\u5b57\u7b26\u4e32 target \u4ee3\u8868\u53ef\u4ee5\u89e3\u9501\u7684\u6570\u5b57\uff0c\u4f60\u9700\u8981\u7ed9\u51fa\u89e3\u9501\u9700\u8981\u7684\u6700\u5c0f\u65cb\u8f6c\u6b21\u6570\uff0c\u5982\u679c\u65e0\u8bba\u5982\u4f55\u4e0d\u80fd\u89e3\u9501\uff0c\u8fd4\u56de -1 \u3002 \u300c\u5206\u6790\u300d \u300cBFS\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int openLock ( vector < string >& deadends , string target ) { string init = \"0000\" ; int n = int ( init . length ()), ans = 0 ; unordered_set < string > vis ; for ( string & str : deadends ) { vis . insert ( str ); } if ( vis . find ( init ) != vis . end ()) { return - 1 ; } queue < string > qLock ; qLock . push ( init ); while ( ! qLock . empty ()) { int num = int ( qLock . size ()); while ( num -- ) { string str = qLock . front (); qLock . pop (); if ( str == target ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { string tmp = str ; for ( int d = - 1 ; d <= 1 ; d += 2 ) { tmp [ i ] = ( str [ i ] - '0' + 10 + d ) % 10 + '0' ; if ( vis . find ( tmp ) == vis . end ()) { vis . insert ( tmp ); qLock . push ( tmp ); } } } } ans ++ ; } return - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6253\u5f00\u8f6c\u76d8\u9501"},{"location":"algo/two-pointers/","text":"\u57fa\u7840 \u00b6 \u53cc\u6307\u9488\u662f\u4e00\u79cd O(n) O(n) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u7b97\u6cd5\uff0c\u901a\u5e38\u914d\u5408\u6392\u5e8f\u7b97\u6cd5\u548c\u54c8\u5e0c\u8868\u4e00\u8d77\u4f7f\u7528\u3002 \u9898\u76ee \u00b6 \u63a5\u96e8\u6c34 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\uff0c\u8868\u793a\u5730\u9636\u7684\u9ad8\u5ea6\uff0c\u8bd5\u95ee\u80fd\u63a5\u5230\u6700\u591a\u7684\u96e8\u6c34\u91cf\u662f\u591a\u5c11\uff1f\u7ed9\u51fa\u7684\u4f8b\u5b50\u5bf9\u5e94\u7b54\u6848\u662f 6\u3002 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u80fd\u5426\u63a5\u5230\u96e8\u6c34\uff0c\u53d6\u51b3\u4e8e\u5de6\u53f3\u4e24\u4fa7\u7684\u9ad8\u5ea6\u662f\u5426\u5747\u5927\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u9ad8\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int trap ( vector < int >& height ) { int ans = 0 , n = int ( height . size ()); if ( n < 3 ) { return ans ; } int i = 0 , j = n - 1 ; int leftMax = 0 , rightMax = 0 ; while ( i < j ) { if ( height [ i ] < height [ j ]) { if ( height [ i ] >= leftMax ) { leftMax = height [ i ]; } else { ans += leftMax - height [ i ]; } i ++ ; } else { if ( height [ j ] >= rightMax ) { rightMax = height [ j ]; } else { ans += rightMax - height [ j ]; } j -- ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4e09\u6570\u4e4b\u548c\u5c0f\u4e8e target \u7684\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 nums = [0, 1, -2, 3] \u548c\u4e00\u4e2a\u6574\u6570 target = 2\uff0c\u4ece nums \u4e2d\u627e\u51fa\u4e09\u4e2a\u4e0b\u6807 0 \\leq i < j < k < n 0 \\leq i < j < k < n \u6ee1\u8db3\u5bf9\u5e94\u7684\u5143\u7d20\u4e4b\u548c\u5c0f\u4e8e target\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u7ec4\u5408\u6570\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011\u5c06 nums \u6392\u5e8f\uff0c\u5916\u5c42\u5faa\u73af\u63a7\u5236 i\uff0c\u5185\u5c42\u5faa\u73af\u63a7\u5236 j\u3001k\uff0c\u5f53 nums[ i ] + nums[ j ] + nums[ k ] < target \u65f6\uff0c\u6240\u6709\u7684 (j, k] \u4e5f\u90fd\u6ee1\u8db3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int threeSumSmaller ( vector < int >& nums , int target ) { int n = ( int ) nums . size (), ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( nums [ i ] + nums [ j ] + nums [ k ] < target ) { ans += k - j ; j ++ ; } else { k -- ; } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s = \"abcabcbb\"\uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u4e0d\u542b\u6709\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u7684\u957f\u5ea6\u3002 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488 + \u54c8\u5e0c\u53bb\u91cd\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lengthOfLongestSubstring ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } int i = 0 , j = 0 , maxLen = 0 ; unordered_set < char > hash ; while ( j < n ) { if ( hash . count ( s [ j ])) { hash . erase ( s [ i ++ ]); } else { hash . insert ( s [ j ++ ]); maxLen = max ( maxLen , j - i ); } } return maxLen ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u4e09\u6570\u4e4b\u548c \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u5305\u542b n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums\uff0c\u5224\u65ad nums \u4e2d\u662f\u5426\u5b58\u5728\u4e09\u4e2a\u5143\u7d20a\uff0cb\uff0cc \uff0c\u4f7f\u5f97 a + b + c = 0 \uff1f\u8bf7\u4f60\u627e\u51fa\u6240\u6709\u548c\u4e3a 0 \u4e14\u4e0d\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002\u7b54\u6848\u4e2d\u4e0d\u53ef\u4ee5\u5305\u542b\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488 + \u6392\u5e8f\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < vector < int >> threeSum ( vector < int >& nums ) { int n = int ( nums . size ()); vector < vector < int >> ans ; if ( n < 3 ) { return ans ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) { j ++ ; } else if ( sum > 0 ) { k -- ; } else { while ( i < k && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < k && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( j < k && nums [ k ] == nums [ k - 1 ]) { k -- ; } ans . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); j ++ ; k -- ; } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4e58\u79ef\u5c0f\u4e8e k \u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6570\u7ec4 nums = [10, 5, 2, 6] \u548c\u4e00\u4e2a\u6574\u6570 k\uff0c\u6c42\u6240\u6709\u8fde\u7eed\u5b50\u6570\u7ec4\u4e58\u79ef\u5c0f\u4e8e k \u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011\u5982\u679c\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u8fde\u7eed\u6570\u7ec4\u4e58\u79ef\u5c0f\u4e8e k\uff0c\u90a3\u4e48\u6ee1\u8db3\u6761\u4ef6\u7684\u5b50\u6570\u7ec4\u4e2a\u6570\u662f \\frac{n(n + 1)}{2} \\frac{n(n + 1)}{2} \uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u7528 i\u3001j \u4e24\u4e2a\u6307\u9488\uff0ci \u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u6ee1\u8db3\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\u5c31\u52a0\u3010i - j + 1\u3011 1 2 3 4 5 6 7 8 9 10 11 int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { int n = ( int ) nums . size (), prod = 1 , ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { prod *= nums [ i ]; while ( j <= i && prod >= k ) { prod /= nums [ j ++ ]; } ans += i - j + 1 ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u6700\u591a\u8fde\u7eed 1 \u7684\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b 0 \u548c 1 \u7684\u6570\u7ec4 nusm = [1,1,1,0,0,0,1,1,1,1,0]\uff0c\u5982\u679c\u6700\u591a k \u6b21\u5c06 0 \u53d8\u6210 1\uff0c\u8bd5\u95ee\uff0c\u6570\u7ec4\u4e2d\u8fde\u7eed 1 \u5b50\u4e32\u6700\u5927\u957f\u5ea6\u662f\u591a\u5c11 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int longestOnes ( vector < int >& nums , int k ) { int ans = 0 ; for ( int i = 0 , j = 0 , cnt = 0 ; j < nums . size () && i < nums . size (); ) { if ( nums [ j ] == 1 ) { j ++ ; } else if ( cnt < k ) { cnt ++ ; j ++ ; } else { cnt -= nums [ i ++ ] == 0 ; } ans = max ( ans , j - i ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u6392\u5e8f\u6570\u7ec4\u5185\u67e5\u627e\u4e24\u6570\u548c\u4e3an\u7684\u6240\u6709\u4e0b\u6807 \u00b6 \u4f8b\u5982\uff1anums = [2,2,2,3,3,3,4,4,4], n = 6\uff0c\u5e94\u5f53\u8fd4\u56de [0, 6], [0, 7], [0, 8], [1, 6], [1, 7], [1, 8], [2, 6], [2, 7], [2, 8], [3, 4], [3, 5], [4, 5] \u300c\u5206\u6790\u300d \u4f7f\u7528\u53cc\u6307\u9488\uff0c\u6ce8\u610f\u7279\u6b8acase\uff0c\u5373\u8fde\u7eed\u76f8\u540c\u7684\u6570\u5b57\uff0c\u9700\u8981\u5206\u522b\u627e\u5230\u8fd9\u4e00\u6bb5\u533a\u95f4t1\u548ct2\uff0c\u5e76\u7528\u8fd9\u4e24\u533a\u95f4\u5185\u7684\u4e0b\u8868\uff0c\u4e24\u4e24\u914d\u5bf9\uff0c\u540c\u65f6\u907f\u514d\u91cd\u590d\u5bf9\uff0ce.g. (1, 3) \u548c (3, 1)\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 vector < vector < int >> func ( vector < int > & nums , int n ) { vector < vector < int >> ans ; int i = 0 , j = ( int ) nums . size () - 1 ; while ( i < j ) { if ( nums [ i ] + nums [ j ] < n ) { i ++ ; } else if ( nums [ i ] + nums [ j ] > n ) { j -- ; } else { int x = i , y = j ; while ( i <= y && nums [ i ] == nums [ x ]) { i ++ ; } while ( x <= j && nums [ j ] == nums [ y ]) { j -- ; } for ( int p = x ; p < i ; p ++ ) { for ( int q = y ; q > j ; q -- ) { if ( p >= q ) { continue ; } ans . emplace_back ( vector < int > { p , q }); } } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u5e73\u65b9\u6570\u4e4b\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 c \uff0c\u4f60\u8981\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6574\u6570 a \u548c b\uff0c\u4f7f\u5f97 a^{2} + b^{2} = c a^{2} + b^{2} = c \u3002\u4f8b\u5982\uff0cc = 5\uff0c\u8fd4\u56de true\uff0c\u56e0\u4e3a 1^{2} + 2^{2} = 5 1^{2} + 2^{2} = 5 \u300c\u5206\u6790\u300d \u300c\u53cc\u6307\u9488\u300d\u4e0d\u59a8\u8bbe a <= b\uff0c\u90a3\u4e48 b \u7684\u6700\u5927\u503c\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt{c} \\sqrt{c} 1 2 3 4 5 6 7 8 9 10 bool judgeSquareSum ( int c ) { long l = 0 , r = ( long ) sqrt ( c ); while ( l <= r ) { long sqaureSum = l * l + r * r ; if ( sqaureSum == c ) { return true ; } else if ( sqaureSum < c ) { l ++ ; } else { r -- ; } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\sqrt{c}) O(\\sqrt{c}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u53cc\u6307\u9488"},{"location":"algo/two-pointers/#_1","text":"\u53cc\u6307\u9488\u662f\u4e00\u79cd O(n) O(n) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u7b97\u6cd5\uff0c\u901a\u5e38\u914d\u5408\u6392\u5e8f\u7b97\u6cd5\u548c\u54c8\u5e0c\u8868\u4e00\u8d77\u4f7f\u7528\u3002","title":"\u57fa\u7840"},{"location":"algo/two-pointers/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/two-pointers/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\uff0c\u8868\u793a\u5730\u9636\u7684\u9ad8\u5ea6\uff0c\u8bd5\u95ee\u80fd\u63a5\u5230\u6700\u591a\u7684\u96e8\u6c34\u91cf\u662f\u591a\u5c11\uff1f\u7ed9\u51fa\u7684\u4f8b\u5b50\u5bf9\u5e94\u7b54\u6848\u662f 6\u3002 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u80fd\u5426\u63a5\u5230\u96e8\u6c34\uff0c\u53d6\u51b3\u4e8e\u5de6\u53f3\u4e24\u4fa7\u7684\u9ad8\u5ea6\u662f\u5426\u5747\u5927\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u9ad8\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int trap ( vector < int >& height ) { int ans = 0 , n = int ( height . size ()); if ( n < 3 ) { return ans ; } int i = 0 , j = n - 1 ; int leftMax = 0 , rightMax = 0 ; while ( i < j ) { if ( height [ i ] < height [ j ]) { if ( height [ i ] >= leftMax ) { leftMax = height [ i ]; } else { ans += leftMax - height [ i ]; } i ++ ; } else { if ( height [ j ] >= rightMax ) { rightMax = height [ j ]; } else { ans += rightMax - height [ j ]; } j -- ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u63a5\u96e8\u6c34"},{"location":"algo/two-pointers/#target","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 nums = [0, 1, -2, 3] \u548c\u4e00\u4e2a\u6574\u6570 target = 2\uff0c\u4ece nums \u4e2d\u627e\u51fa\u4e09\u4e2a\u4e0b\u6807 0 \\leq i < j < k < n 0 \\leq i < j < k < n \u6ee1\u8db3\u5bf9\u5e94\u7684\u5143\u7d20\u4e4b\u548c\u5c0f\u4e8e target\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u7ec4\u5408\u6570\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011\u5c06 nums \u6392\u5e8f\uff0c\u5916\u5c42\u5faa\u73af\u63a7\u5236 i\uff0c\u5185\u5c42\u5faa\u73af\u63a7\u5236 j\u3001k\uff0c\u5f53 nums[ i ] + nums[ j ] + nums[ k ] < target \u65f6\uff0c\u6240\u6709\u7684 (j, k] \u4e5f\u90fd\u6ee1\u8db3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int threeSumSmaller ( vector < int >& nums , int target ) { int n = ( int ) nums . size (), ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( nums [ i ] + nums [ j ] + nums [ k ] < target ) { ans += k - j ; j ++ ; } else { k -- ; } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u4e09\u6570\u4e4b\u548c\u5c0f\u4e8e target \u7684\u4e2a\u6570"},{"location":"algo/two-pointers/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s = \"abcabcbb\"\uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u4e0d\u542b\u6709\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u7684\u957f\u5ea6\u3002 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488 + \u54c8\u5e0c\u53bb\u91cd\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lengthOfLongestSubstring ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } int i = 0 , j = 0 , maxLen = 0 ; unordered_set < char > hash ; while ( j < n ) { if ( hash . count ( s [ j ])) { hash . erase ( s [ i ++ ]); } else { hash . insert ( s [ j ++ ]); maxLen = max ( maxLen , j - i ); } } return maxLen ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32"},{"location":"algo/two-pointers/#_5","text":"\u7ed9\u4f60\u4e00\u4e2a\u5305\u542b n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums\uff0c\u5224\u65ad nums \u4e2d\u662f\u5426\u5b58\u5728\u4e09\u4e2a\u5143\u7d20a\uff0cb\uff0cc \uff0c\u4f7f\u5f97 a + b + c = 0 \uff1f\u8bf7\u4f60\u627e\u51fa\u6240\u6709\u548c\u4e3a 0 \u4e14\u4e0d\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002\u7b54\u6848\u4e2d\u4e0d\u53ef\u4ee5\u5305\u542b\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488 + \u6392\u5e8f\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < vector < int >> threeSum ( vector < int >& nums ) { int n = int ( nums . size ()); vector < vector < int >> ans ; if ( n < 3 ) { return ans ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) { j ++ ; } else if ( sum > 0 ) { k -- ; } else { while ( i < k && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < k && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( j < k && nums [ k ] == nums [ k - 1 ]) { k -- ; } ans . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); j ++ ; k -- ; } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u4e09\u6570\u4e4b\u548c"},{"location":"algo/two-pointers/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6570\u7ec4 nums = [10, 5, 2, 6] \u548c\u4e00\u4e2a\u6574\u6570 k\uff0c\u6c42\u6240\u6709\u8fde\u7eed\u5b50\u6570\u7ec4\u4e58\u79ef\u5c0f\u4e8e k \u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011\u5982\u679c\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u8fde\u7eed\u6570\u7ec4\u4e58\u79ef\u5c0f\u4e8e k\uff0c\u90a3\u4e48\u6ee1\u8db3\u6761\u4ef6\u7684\u5b50\u6570\u7ec4\u4e2a\u6570\u662f \\frac{n(n + 1)}{2} \\frac{n(n + 1)}{2} \uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u7528 i\u3001j \u4e24\u4e2a\u6307\u9488\uff0ci \u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u6ee1\u8db3\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\u5c31\u52a0\u3010i - j + 1\u3011 1 2 3 4 5 6 7 8 9 10 11 int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { int n = ( int ) nums . size (), prod = 1 , ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { prod *= nums [ i ]; while ( j <= i && prod >= k ) { prod /= nums [ j ++ ]; } ans += i - j + 1 ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u4e58\u79ef\u5c0f\u4e8e k \u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u4e2a\u6570"},{"location":"algo/two-pointers/#1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b 0 \u548c 1 \u7684\u6570\u7ec4 nusm = [1,1,1,0,0,0,1,1,1,1,0]\uff0c\u5982\u679c\u6700\u591a k \u6b21\u5c06 0 \u53d8\u6210 1\uff0c\u8bd5\u95ee\uff0c\u6570\u7ec4\u4e2d\u8fde\u7eed 1 \u5b50\u4e32\u6700\u5927\u957f\u5ea6\u662f\u591a\u5c11 \u300c\u5206\u6790\u300d \u3010\u53cc\u6307\u9488\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int longestOnes ( vector < int >& nums , int k ) { int ans = 0 ; for ( int i = 0 , j = 0 , cnt = 0 ; j < nums . size () && i < nums . size (); ) { if ( nums [ j ] == 1 ) { j ++ ; } else if ( cnt < k ) { cnt ++ ; j ++ ; } else { cnt -= nums [ i ++ ] == 0 ; } ans = max ( ans , j - i ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6700\u591a\u8fde\u7eed 1 \u7684\u4e2a\u6570"},{"location":"algo/two-pointers/#n","text":"\u4f8b\u5982\uff1anums = [2,2,2,3,3,3,4,4,4], n = 6\uff0c\u5e94\u5f53\u8fd4\u56de [0, 6], [0, 7], [0, 8], [1, 6], [1, 7], [1, 8], [2, 6], [2, 7], [2, 8], [3, 4], [3, 5], [4, 5] \u300c\u5206\u6790\u300d \u4f7f\u7528\u53cc\u6307\u9488\uff0c\u6ce8\u610f\u7279\u6b8acase\uff0c\u5373\u8fde\u7eed\u76f8\u540c\u7684\u6570\u5b57\uff0c\u9700\u8981\u5206\u522b\u627e\u5230\u8fd9\u4e00\u6bb5\u533a\u95f4t1\u548ct2\uff0c\u5e76\u7528\u8fd9\u4e24\u533a\u95f4\u5185\u7684\u4e0b\u8868\uff0c\u4e24\u4e24\u914d\u5bf9\uff0c\u540c\u65f6\u907f\u514d\u91cd\u590d\u5bf9\uff0ce.g. (1, 3) \u548c (3, 1)\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 vector < vector < int >> func ( vector < int > & nums , int n ) { vector < vector < int >> ans ; int i = 0 , j = ( int ) nums . size () - 1 ; while ( i < j ) { if ( nums [ i ] + nums [ j ] < n ) { i ++ ; } else if ( nums [ i ] + nums [ j ] > n ) { j -- ; } else { int x = i , y = j ; while ( i <= y && nums [ i ] == nums [ x ]) { i ++ ; } while ( x <= j && nums [ j ] == nums [ y ]) { j -- ; } for ( int p = x ; p < i ; p ++ ) { for ( int q = y ; q > j ; q -- ) { if ( p >= q ) { continue ; } ans . emplace_back ( vector < int > { p , q }); } } } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u6392\u5e8f\u6570\u7ec4\u5185\u67e5\u627e\u4e24\u6570\u548c\u4e3an\u7684\u6240\u6709\u4e0b\u6807"},{"location":"algo/two-pointers/#_6","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 c \uff0c\u4f60\u8981\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6574\u6570 a \u548c b\uff0c\u4f7f\u5f97 a^{2} + b^{2} = c a^{2} + b^{2} = c \u3002\u4f8b\u5982\uff0cc = 5\uff0c\u8fd4\u56de true\uff0c\u56e0\u4e3a 1^{2} + 2^{2} = 5 1^{2} + 2^{2} = 5 \u300c\u5206\u6790\u300d \u300c\u53cc\u6307\u9488\u300d\u4e0d\u59a8\u8bbe a <= b\uff0c\u90a3\u4e48 b \u7684\u6700\u5927\u503c\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt{c} \\sqrt{c} 1 2 3 4 5 6 7 8 9 10 bool judgeSquareSum ( int c ) { long l = 0 , r = ( long ) sqrt ( c ); while ( l <= r ) { long sqaureSum = l * l + r * r ; if ( sqaureSum == c ) { return true ; } else if ( sqaureSum < c ) { l ++ ; } else { r -- ; } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\sqrt{c}) O(\\sqrt{c}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5e73\u65b9\u6570\u4e4b\u548c"},{"location":"algo/dp/basis/","text":"\u7b80\u4ecb \u00b6 \u52a8\u6001\u89c4\u5212\uff08Dynamic programming\uff0c\u7b80\u79f0 DP\uff09\u5c06\u539f\u95ee\u9898\u62c6\u5206\u6210\u82e5\u5e72\u5b50\u95ee\u9898\uff08\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff09\uff0c\u901a\u8fc7\u5206\u522b\u6c42\u89e3\u5b50\u95ee\u9898\uff0c\u5f97\u5230\u539f\u95ee\u9898\u89e3\u7684\u4e00\u79cd\u7b97\u6cd5\u3002 \u8981\u7d20 \u00b6 \u5982\u679c\u4e00\u4e2a\u95ee\u9898\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7\u52a8\u6001\u89c4\u5212\u7684\u65b9\u6cd5\u6c42\u89e3 \u6700\u4f18\u5b50\u7ed3\u6784\uff08optimal structure\uff09 \u539f\u95ee\u9898\u7684\u89e3\u662f\u53ef\u4ee5\u7531\u5b50\u95ee\u9898\u5f97\u5230\u7684\uff08\u9012\u63a8\u6216\u8005\u9012\u5f52\uff09\uff0c\u53cd\u4e4b\uff0c\u4e0d\u80fd\u79f0\u4e4b\u4e3a\u5177\u6709\u6700\u4f18\u5b50\u7ed3\u6784 \u91cd\u53e0\u5b50\u95ee\u9898\uff08overlap subproblem\uff09 \u5f53\u67d0\u4e9b\u5b50\u95ee\u9898\u88ab\u91cd\u590d\u904d\u5386\uff08\u6216\u8005\u539f\u95ee\u9898\u88ab\u5206\u89e3\u6210\u591a\u4e2a\u76f8\u540c\u7684\u5b50\u95ee\u9898\uff09\u65f6\uff0c\u8fd9\u79cd\u60c5\u51b5\u79f0\u4e3a\u91cd\u53e0\u5b50\u95ee\u9898 \u8ba1\u7b97\u6b65\u9aa4 \u00b6 \uff081\uff09 \u63cf\u8ff0\u6700\u4f18\u89e3\u7684\u7ed3\u6784\uff0c\u5373\u7528\u4e00\u4e2a\u72b6\u6001\u8868\u793a\u6700\u4f18\u89e3 \uff082\uff09 \u4ee5\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u7684\u5f62\u5f0f\uff0c\u9012\u5f52\u5730\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \uff083\uff09 \u81ea\u4e0b\u800c\u4e0a\uff08bottom-top\uff09\u6216\u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u5730\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \uff084\uff09 \u6839\u636e\uff083\uff09\u4e2d\u7684\u8fc7\u7a0b\u503c\uff0c\u6784\u9020\u6700\u4f18\u89e3\uff1b\u5982\u679c\u53ea\u9700\u8981\u6700\u4f18\u89e3\u7684\u503c\uff0c\u5219\u65e0\u9700\u672c\u6b65\u9aa4 \u52a8\u6001\u89c4\u5212\u7684\u7279\u70b9 \u00b6 \u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff1a\u4fdd\u5b58\u4e86\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4e2d\u95f4\u503c\uff0c\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97 \u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u6216\u8005\u9012\u5f52\u662f\u4e00\u79cd\u5907\u5fd8\u5f55\uff08memorization\uff09\u65b9\u6cd5 \u4e25\u683c\u6765\u8bf4\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6709\u81ea\u4e0b\u800c\u4e0a\u7684\u65b9\u5f0f\uff1b\u5982\u679c\u6240\u6709\u7684\u5b50\u95ee\u9898\u90fd\u4f1a\u88ab\u8ba1\u7b97\u4e00\u6b21\uff0c\u90a3\u4e48\u52a8\u6001\u89c4\u5212\u5177\u6709\u4f18\u52bf\uff0c\u53cd\u4e4b\uff08\u526a\u679d\u60c5\u51b5\uff09\uff0c\u5907\u5fd8\u5f55\u6cd5\u5177\u6709\u4f18\u52bf \u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5fc3\u7684\u6bd4\u8f83 \u00b6 \u76f8\u540c\u70b9\uff1a \u5177\u5907\u6700\u4f18\u5b50\u7ed3\u6784 \u4e0d\u540c\u70b9\uff1a \u52a8\u6001\u89c4\u5212\u7684\u5b50\u95ee\u9898\u662f\u91cd\u53e0\u7684\uff0c\u8d2a\u5fc3\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0 \u52a8\u6001\u89c4\u5212\u4e0d\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u7684\u6027\u8d28 \u8d2a\u5fc3\u7684\u524d\u8fdb\u8def\u7ebf\u662f\u4e00\u6761\u7ebf\uff0c\u52a8\u6001\u89c4\u5212\u662f\u4e00\u4e2aDAG","title":"\u57fa\u7840"},{"location":"algo/dp/basis/#_1","text":"\u52a8\u6001\u89c4\u5212\uff08Dynamic programming\uff0c\u7b80\u79f0 DP\uff09\u5c06\u539f\u95ee\u9898\u62c6\u5206\u6210\u82e5\u5e72\u5b50\u95ee\u9898\uff08\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff09\uff0c\u901a\u8fc7\u5206\u522b\u6c42\u89e3\u5b50\u95ee\u9898\uff0c\u5f97\u5230\u539f\u95ee\u9898\u89e3\u7684\u4e00\u79cd\u7b97\u6cd5\u3002","title":"\u7b80\u4ecb"},{"location":"algo/dp/basis/#_2","text":"\u5982\u679c\u4e00\u4e2a\u95ee\u9898\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7\u52a8\u6001\u89c4\u5212\u7684\u65b9\u6cd5\u6c42\u89e3 \u6700\u4f18\u5b50\u7ed3\u6784\uff08optimal structure\uff09 \u539f\u95ee\u9898\u7684\u89e3\u662f\u53ef\u4ee5\u7531\u5b50\u95ee\u9898\u5f97\u5230\u7684\uff08\u9012\u63a8\u6216\u8005\u9012\u5f52\uff09\uff0c\u53cd\u4e4b\uff0c\u4e0d\u80fd\u79f0\u4e4b\u4e3a\u5177\u6709\u6700\u4f18\u5b50\u7ed3\u6784 \u91cd\u53e0\u5b50\u95ee\u9898\uff08overlap subproblem\uff09 \u5f53\u67d0\u4e9b\u5b50\u95ee\u9898\u88ab\u91cd\u590d\u904d\u5386\uff08\u6216\u8005\u539f\u95ee\u9898\u88ab\u5206\u89e3\u6210\u591a\u4e2a\u76f8\u540c\u7684\u5b50\u95ee\u9898\uff09\u65f6\uff0c\u8fd9\u79cd\u60c5\u51b5\u79f0\u4e3a\u91cd\u53e0\u5b50\u95ee\u9898","title":"\u8981\u7d20"},{"location":"algo/dp/basis/#_3","text":"\uff081\uff09 \u63cf\u8ff0\u6700\u4f18\u89e3\u7684\u7ed3\u6784\uff0c\u5373\u7528\u4e00\u4e2a\u72b6\u6001\u8868\u793a\u6700\u4f18\u89e3 \uff082\uff09 \u4ee5\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u7684\u5f62\u5f0f\uff0c\u9012\u5f52\u5730\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \uff083\uff09 \u81ea\u4e0b\u800c\u4e0a\uff08bottom-top\uff09\u6216\u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u5730\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \uff084\uff09 \u6839\u636e\uff083\uff09\u4e2d\u7684\u8fc7\u7a0b\u503c\uff0c\u6784\u9020\u6700\u4f18\u89e3\uff1b\u5982\u679c\u53ea\u9700\u8981\u6700\u4f18\u89e3\u7684\u503c\uff0c\u5219\u65e0\u9700\u672c\u6b65\u9aa4","title":"\u8ba1\u7b97\u6b65\u9aa4"},{"location":"algo/dp/basis/#_4","text":"\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff1a\u4fdd\u5b58\u4e86\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4e2d\u95f4\u503c\uff0c\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97 \u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u6216\u8005\u9012\u5f52\u662f\u4e00\u79cd\u5907\u5fd8\u5f55\uff08memorization\uff09\u65b9\u6cd5 \u4e25\u683c\u6765\u8bf4\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6709\u81ea\u4e0b\u800c\u4e0a\u7684\u65b9\u5f0f\uff1b\u5982\u679c\u6240\u6709\u7684\u5b50\u95ee\u9898\u90fd\u4f1a\u88ab\u8ba1\u7b97\u4e00\u6b21\uff0c\u90a3\u4e48\u52a8\u6001\u89c4\u5212\u5177\u6709\u4f18\u52bf\uff0c\u53cd\u4e4b\uff08\u526a\u679d\u60c5\u51b5\uff09\uff0c\u5907\u5fd8\u5f55\u6cd5\u5177\u6709\u4f18\u52bf","title":"\u52a8\u6001\u89c4\u5212\u7684\u7279\u70b9"},{"location":"algo/dp/basis/#_5","text":"\u76f8\u540c\u70b9\uff1a \u5177\u5907\u6700\u4f18\u5b50\u7ed3\u6784 \u4e0d\u540c\u70b9\uff1a \u52a8\u6001\u89c4\u5212\u7684\u5b50\u95ee\u9898\u662f\u91cd\u53e0\u7684\uff0c\u8d2a\u5fc3\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0 \u52a8\u6001\u89c4\u5212\u4e0d\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u7684\u6027\u8d28 \u8d2a\u5fc3\u7684\u524d\u8fdb\u8def\u7ebf\u662f\u4e00\u6761\u7ebf\uff0c\u52a8\u6001\u89c4\u5212\u662f\u4e00\u4e2aDAG","title":"\u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5fc3\u7684\u6bd4\u8f83"},{"location":"algo/dp/digits/","text":"\u57fa\u7840 \u00b6 \u6570\u4f4d\u578b\u52a8\u6001\u89c4\u5212\u901a\u5e38\u9488\u5bf9\u4f4d\u6570\u8f83\u591a\u7684\u6574\u6570\uff0c\u4e00\u822c\u662f\u4e8c\u8fdb\u5236\u3001\u5341\u8fdb\u5236\u3002 \u81f3\u5c11\u6709 1 \u4f4d\u91cd\u590d\u7684\u6570\u5b57 \u00b6 \u7ed9\u5b9a\u6b63\u6574\u6570 n\uff0c\u8fd4\u56de\u5728 [1, n] \u8303\u56f4\u5185\u5177\u6709 \u81f3\u5c11 1 \u4f4d \u91cd\u590d\u6570\u5b57\u7684\u6b63\u6574\u6570\u7684\u4e2a\u6570\u3002\u5982\uff0cn = 20\uff0c\u5177\u6709\u81f3\u5c11 1 \u4f4d\u91cd\u590d\u6570\u5b57\u7684\u6b63\u6570\uff08<= 20\uff09\u53ea\u6709 11\uff0c\u5e94\u5f53\u8fd4\u56de 1\u3002 \u300c\u5206\u6790\u300d \u9898\u76ee\u7684\u8981\u6c42\u662f\u6c42\u81f3\u5c11\u6709\u4e00\u4e2a\u4f4d\u7f6e\u91cd\u590d\uff0c\u53ef\u4ee5\u8f6c\u5316\u4e3an - \u65e0\u91cd\u590d\u6570\u5b57\u7684\u4e2a\u6570\u3002\u6570\u636e\u8303\u56f4\u662f [1, 1e9]\uff0c\u7528\u66b4\u529b\u65b9\u6cd5\u6613\u8d85\u65f6\uff0c\u8003\u8651\u4f7f\u7528\u6570\u4f4dDP\u3002\u8bbe\u60f3\u4e00\u4e2a\u6574\u6570a\u7684\u4f4d\u6570\u5927\u4e8e10\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4f4d\u53ea\u80fd\u662f0-9\u4e2d\u7684\u4e00\u4e2a\u6570\u586b\u5145\uff0c\u90a3\u4e48a\u4e00\u5b9a\u662f\u4e00\u4e2a\u6709\u91cd\u590d\u7684\u6570\u5b57\u3002\u8fd9\u91cc\u7684\u601d\u8def\u5982\u4e0b\uff1a\u5c06n\u8f6c\u5316\u6210\u5b57\u7b26\u4e32s\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\u6bcf\u4e00\u4e2a\u4f4d\u7f6ei\uff0c\u540c\u65f6\u679a\u4e3e\u6b64\u4f4d\u7f6e\u4e0a\u7684\u6240\u6709\u53ef\u80fd\u6570\u5b57\uff08\u4e0d\u8d85\u8fc7s[i]\uff09\uff0c\u540c\u65f6\u8bb0\u5f55\u7b26\u5408\u6761\u4ef6\u7684\u65b9\u6848\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u6ce8\u610f\u7684\u5730\u65b9\uff0c\u6211\u4eec\u5e94\u8be5\u8986\u76d61-n\u7684\u6240\u6709\u53ef\u80fd\uff0c\u5047\u8bbe n = 123\uff0c\u90a3\u4e48\u8f6c\u5316\u6210\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u5c31\u662f3\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u767e\u4f4d\u679a\u4e3e\uff0c\u4e5f\u53ef\u4ee5\u4ece\u5341\u4f4d\u6216\u8005\u4e2a\u4f4d\u679a\u4e3e\uff0c\u8fd9\u6837\u80fd\u4fdd\u8bc1[1, n]\u533a\u95f4\u7684\u6240\u6709\u503c\u3002 \u4e3a\u4e86\u68c0\u67e5\u5f53\u524d\u5b57\u7b26\u4e32\u7684\u6240\u6709\u6570\u5b57\u4e0d\u91cd\u590d\uff0c\u537310\u4e2a\u6570\u5b57\u65e0\u91cd\u590d\uff0c\u6211\u4eec\u4f7f\u7528 2^{10} 2^{10} \u957f\u5ea6\u7684\u6574\u6570\u81f3mask\u8bb0\u5f55\u3002\u4f8b\u5982\uff0c\u60f3\u77e5\u9053\u300c3\u300d\u8fd9\u4e2a\u6570\u5b57\u6709\u88ab\u4f7f\u7528\u8fc7\u4e86\uff0c\u53ea\u9700\u8981 \\text{mask} \\And (1 << 3) \\text{mask} \\And (1 << 3) \u662f\u5426\u4f4d1\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int dfs ( string & s , vector < vector < int >> & M , int i , int mask , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum ; } if ( ! isLim && M [ i ][ mask ] != - 1 ) { return M [ i ][ mask ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( s , M , i + 1 , mask , false , isNum ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { if ( mask >> d & 1 ) { continue ; } ans += dfs ( s , M , i + 1 , mask | ( 1 << d ), d == up && isLim , true ); } M [ i ][ mask ] = ans ; return ans ; } int numDupDigitsAtMostN ( int n ) { string s = to_string ( n ); vector < vector < int >> M ( s . length (), vector < int > ( 1 << 10 , - 1 )); return n - dfs ( s , M , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(mD2^{D}) O(mD2^{D}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m2^{D}) O(m2^{D}) \uff0c\u8fd9\u91cc m \u662fn\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0cD = 10\uff0c\u8868\u793a\u6240\u6709\u6570\u5b57\u7684\u96c6\u5408\u5927\u5c0f 2\u51fa\u73b0\u7684\u6b21\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u81ea\u7136\u6570 n\uff08n <= 10^9\uff09\uff0c\u8ba1\u7b97\u4ece 0 \u5230 n (\u542b n) \u4e2d\u6570\u5b57 2 \u51fa\u73b0\u7684\u6b21\u6570\u3002\u5982 n = 25\uff0c\u8fd4\u56de9(2, 12, 20, 21, 22, 23, 24, 25)(\u6ce8\u610f 22 \u5e94\u8be5\u7b97\u4f5c\u4e24\u6b21)\u3002 \u300c\u5206\u6790\u300d \u8bb0\u5fc6\u5316\u641c\u7d22\uff0cM[i][cnt] \u8868\u793a\u957f\u5ea6\u4e3ai\u65f6\u7684\u6570\u5b57\u542b\u6709cnt\u4e2a2\u7684\u6570\u5b57\u4e2a\u6570\u3002isLim \u8868\u793a\u5f53\u524d\u7684\u6570\u5b57\u662f\u5426\u53d7\u9650\uff0c\u56e0\u4e3a\u6211\u4eec\u6784\u9020\u7684\u6570\u5b57\u4e0d\u80fd\u5927\u4e8en\u3002\u901a\u5e38\u8bb0\u5fc6\u5316DP\u5c06\u4e00\u4e2a\u5927\u95ee\u9898\uff0c\u9010\u6b65\u62c6\u5206\u6210\u5c0f\u95ee\u9898\uff0c\u5e76\u5c06\u5c0f\u95ee\u9898\u7684\u7ed3\u679c\u4fdd\u5b58\u4e0b\u6765\uff0c\u907f\u514d\u91cd\u590d\u8ba1\u7b97\u3002\u8fd9\u91cc\u4ece\u5de6\u5230\u53f3\u6784\u9020\u6570\u5b57\uff0c\u770b\u4e0a\u53bb\u4e0d\u7b26\u5408\u8bb0\u5fc6\u5316DP\u7684\u8fc7\u7a0b\uff0c\u4f46\u662f\u56e0\u4e3a\u6211\u4eec\u52a0\u5165\u4e86isNum\uff0c\u4f18\u5148\u904d\u5386\u9ad8\u4f4d\u6570\u5b57\u4e0d\u586b\u5145\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u8fd9\u91cc\u76f8\u5f53\u4e8e\u5b50\u95ee\u9898\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int dfs ( vector < vector < int >> & M , string & s , int i , int cnt , bool isLim , bool isNum ) { if ( i == s . length ()) { if ( isNum ) { return cnt ; } return 0 ; } if ( ! isLim && M [ i ][ cnt ] != - 1 ) { return M [ i ][ cnt ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( M , s , i + 1 , cnt , false , isNum ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { ans += dfs ( M , s , i + 1 , cnt + ( d == 2 ), isLim && d == up , true ); } M [ i ][ cnt ] = ans ; return ans ; } int numberOf2sInRange ( int n ) { string s = to_string ( n ); vector < vector < int >> M ( s . length (), vector < int > ( s . length (), - 1 )); return dfs ( M , s , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{3}) O(m^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m^{2}) O(m^{2}) \uff0cm \u662fn\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\u3002 \u4e0d\u542b\u8fde\u7eed1\u7684\u975e\u8d1f\u6574\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n \uff0c\u8bf7\u4f60\u7edf\u8ba1\u5728 [0, n] \u8303\u56f4\u7684\u975e\u8d1f\u6574\u6570\u4e2d\uff0c\u6709\u591a\u5c11\u4e2a\u6574\u6570\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u4e0d\u5b58\u5728 \u8fde\u7eed\u7684 1 \u3002\u4f8b\u5982\uff0cn = 5\uff0c\u5728 [0, 5] \u7684\u975e\u8d1f\u6574\u6570\u4e2d\uff0c\u53ea\u6709 3 \u7684\u4e8c\u8fdb\u5236\u8868\u793a\u542b\u6709\u8fde\u7eed\u76841\uff0c\u56e0\u6b64\u7b54\u6848\u662f 5\u3002 \u300c\u5206\u6790\u300d \u5c06\u6574\u6570 n \u8f6c\u6362\u6210\u4e8c\u8fdb\u5236\u7684\u5b57\u7b26\u4e32\u5f62\u5f0f\uff0c\u4e4b\u540e\u5957\u7528\u6a21\u7248\u3002mark \u8868\u793a\u524d\u4e00\u4e2a\u5f53\u524d\u6784\u9020\u7684\uff08\u4e8c\u8fdb\u5236\uff09\u6570\u5b57\u7684\u6700\u540e\u4e00\u4f4d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int dfs ( string & s , vector < vector < int >> & M , int mark , int i , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum ; } if ( ! isLim && M [ i ][ mark ] != - 1 ) { return M [ i ][ mark ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( s , M , 0 , i + 1 , false , false ); } int up = isLim ? s [ i ] - '0' : 1 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { if ( d == 1 && mark == 1 ) { continue ; } ans += dfs ( s , M , d , i + 1 , isLim && ( d == up ), true ); } if ( ! isLim && isNum ) { M [ i ][ mark ] = ans ; } return ans ; } int findIntegers ( int n ) { string s = \"\" ; int tmp = n ; while ( tmp > 0 ) { int r = tmp % 2 ; s . push_back ( r + '0' ); tmp >>= 1 ; } reverse ( s . begin (), s . end ()); vector < vector < int >> M ( s . size (), vector < int > ( 2 , - 1 )); return 1 + dfs ( s , M , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(m) O(m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m) O(m) \uff0cm \u662fn\u8f6c\u5316\u4e3a\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\u3002 \u8303\u56f4\u4e2d\u7f8e\u4e3d\u6574\u6570\u7684\u6570\u76ee \u00b6 \u7ed9\u4f60\u6b63\u6574\u6570 low \uff0chigh \u548c k \u3002\u5982\u679c\u4e00\u4e2a\u6570\u6ee1\u8db3\u4ee5\u4e0b\u4e24\u4e2a\u6761\u4ef6\uff0c\u90a3\u4e48\u5b83\u662f \u7f8e\u4e3d\u7684 \uff1a 1)\u5076\u6570\u6570\u4f4d\u7684\u6570\u76ee\u4e0e\u5947\u6570\u6570\u4f4d\u7684\u6570\u76ee\u76f8\u540c\u3002 2)\u8fd9\u4e2a\u6574\u6570\u53ef\u4ee5\u88ab k \u6574\u9664\u3002 \u4f8b\u5982\uff0clow = 10, high = 20, k = 3\uff0c\u7ed9\u5b9a\u8303\u56f4\u4e2d\u6709 2 \u4e2a\u7f8e\u4e3d\u6570\u5b57\uff1a[12,18] - 12 \u662f\u7f8e\u4e3d\u6574\u6570\uff0c\u56e0\u4e3a\u5b83\u6709 1 \u4e2a\u5947\u6570\u6570\u4f4d\u548c 1 \u4e2a\u5076\u6570\u6570\u4f4d\uff0c\u800c\u4e14\u53ef\u4ee5\u88ab k = 3 \u6574\u9664\u3002 - 18 \u662f\u7f8e\u4e3d\u6574\u6570\uff0c\u56e0\u4e3a\u5b83\u6709 1 \u4e2a\u5947\u6570\u6570\u4f4d\u548c 1 \u4e2a\u5076\u6570\u6570\u4f4d\uff0c\u800c\u4e14\u53ef\u4ee5\u88ab k = 3 \u6574\u9664\u3002 15 \u4e0d\u662f\u7f8e\u4e3d\u6574\u6570\uff0c\u56e0\u4e3a\u5b83\u7684\u5947\u6570\u6570\u4f4d\u548c\u5076\u6570\u6570\u4f4d\u7684\u6570\u76ee\u4e0d\u76f8\u7b49\u3002 \u8bf7\u8fd4\u56de\u8303\u56f4 [low, high] \u4e2d\u7f8e\u4e3d\u6574\u6570\u7684\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d M[i][mask][diff] \u8868\u793a\u6211\u4eec\u6784\u9020\u7b2c i \u4f4d\u6570\u5b57\uff0c\u8fd9\u4e2a\u6570\u5b57\u5bf9 k \u53d6\u4f59\u6570\u4f4d mask\uff0c\u4e14\u6570\u5b57\u5404\u6570\u4f4d\u7684\u5947\u5076\u5dee\u4e3a diff \u65f6\uff0c\u7f8e\u4e3d\u6570\u7684\u65b9\u6848\u6570\u76ee\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int dfs ( string & s , vector < vector < vector < int >>> & M , int mask , int diff , int i , int k , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum && mask == 0 && diff == s . length (); } if ( ! isLim && M [ i ][ mask ][ diff ] != - 1 ) { return M [ i ][ mask ][ diff ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( s , M , mask , diff , i + 1 , k , false , false ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { ans += dfs ( s , M , ( mask * 10 + d ) % k , diff + ( d % 2 ) * 2 - 1 , i + 1 , k , isLim && ( d == up ), true ); } if ( ! isLim && isNum ) { M [ i ][ mask ][ diff ] = ans ; } return ans ; } int calc ( int num , int k ) { int ans = 0 ; string s = to_string ( num ); vector < vector < vector < int >>> M ( s . length (), vector < vector < int >> ( k , vector < int > ( 2 * s . length () + 1 , - 1 ))); ans = dfs ( s , M , 0 , ( int ) s . length (), 0 , k , true , false ); return ans ; } int numberOfBeautifulIntegers ( int low , int high , int k ) { return calc ( high , k ) - calc ( low - 1 , k ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{2}kD) O(m^{2}kD) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m^{2}k) O(m^{2}k) \uff0cm \u662fn\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\uff0ck\u662f\u4f59\u6570\uff0cD=10\u3002 \u6700\u5927\u4e3a N \u7684\u6570\u5b57\u7ec4\u5408 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6309 \u975e\u9012\u51cf\u987a\u5e8f \u6392\u5217\u7684\u6570\u5b57\u6570\u7ec4 digits \u3002\u4f60\u53ef\u4ee5\u7528\u4efb\u610f\u6b21\u6570 digits[i] \u6765\u5199\u7684\u6570\u5b57\u3002\u4f8b\u5982\uff0c\u5982\u679c digits = ['1','3','5']\uff0c\u6211\u4eec\u53ef\u4ee5\u5199\u6570\u5b57\uff0c\u5982 '13', '551', \u548c '1351315'\u3002\u8fd4\u56de \u53ef\u4ee5\u751f\u6210\u7684\u5c0f\u4e8e\u6216\u7b49\u4e8e\u7ed9\u5b9a\u6574\u6570 n \u7684\u6b63\u6574\u6570\u7684\u4e2a\u6570 \u3002 \u300c\u5206\u6790\u300d M[i] \u8868\u793a\u6211\u4eec\u6784\u9020\u7b2c i \u4f4d\u6570\u5b57\u65f6\uff0c\u751f\u6210\u7b26\u5408\u6761\u4ef6\u7684\u6570\u76ee\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int dfs ( string & s , vector < int > & digits , vector < int > & M , int mask , int i , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum ; } if ( ! isLim && M [ i ] != - 1 ) { return M [ i ]; } int ans = 0 ; if ( ! isNum ) { ans += dfs ( s , digits , M , mask , i + 1 , false , false ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d : digits ) { if ( d > up ) { continue ; } ans += dfs ( s , digits , M , d , i + 1 , isLim && d == up , true ); } if ( ! isLim && isNum ) { M [ i ] = ans ; } return ans ; } int atMostNGivenDigitSet ( vector < string >& digits , int n ) { string s = to_string ( n ); vector < int > nums ; for ( string d : digits ) { nums . emplace_back ( stoi ( d )); } vector < int > M ( s . length (), - 1 ); return dfs ( s , nums , M , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(mk) O(mk) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m) O(m) \uff0cm \u662fn\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\uff0ck\u662fdigits\u7684\u957f\u5ea6\u3002","title":"\u6570\u4f4d\u578b"},{"location":"algo/dp/digits/#_1","text":"\u6570\u4f4d\u578b\u52a8\u6001\u89c4\u5212\u901a\u5e38\u9488\u5bf9\u4f4d\u6570\u8f83\u591a\u7684\u6574\u6570\uff0c\u4e00\u822c\u662f\u4e8c\u8fdb\u5236\u3001\u5341\u8fdb\u5236\u3002","title":"\u57fa\u7840"},{"location":"algo/dp/digits/#1","text":"\u7ed9\u5b9a\u6b63\u6574\u6570 n\uff0c\u8fd4\u56de\u5728 [1, n] \u8303\u56f4\u5185\u5177\u6709 \u81f3\u5c11 1 \u4f4d \u91cd\u590d\u6570\u5b57\u7684\u6b63\u6574\u6570\u7684\u4e2a\u6570\u3002\u5982\uff0cn = 20\uff0c\u5177\u6709\u81f3\u5c11 1 \u4f4d\u91cd\u590d\u6570\u5b57\u7684\u6b63\u6570\uff08<= 20\uff09\u53ea\u6709 11\uff0c\u5e94\u5f53\u8fd4\u56de 1\u3002 \u300c\u5206\u6790\u300d \u9898\u76ee\u7684\u8981\u6c42\u662f\u6c42\u81f3\u5c11\u6709\u4e00\u4e2a\u4f4d\u7f6e\u91cd\u590d\uff0c\u53ef\u4ee5\u8f6c\u5316\u4e3an - \u65e0\u91cd\u590d\u6570\u5b57\u7684\u4e2a\u6570\u3002\u6570\u636e\u8303\u56f4\u662f [1, 1e9]\uff0c\u7528\u66b4\u529b\u65b9\u6cd5\u6613\u8d85\u65f6\uff0c\u8003\u8651\u4f7f\u7528\u6570\u4f4dDP\u3002\u8bbe\u60f3\u4e00\u4e2a\u6574\u6570a\u7684\u4f4d\u6570\u5927\u4e8e10\uff0c\u56e0\u4e3a\u6bcf\u4e00\u4f4d\u53ea\u80fd\u662f0-9\u4e2d\u7684\u4e00\u4e2a\u6570\u586b\u5145\uff0c\u90a3\u4e48a\u4e00\u5b9a\u662f\u4e00\u4e2a\u6709\u91cd\u590d\u7684\u6570\u5b57\u3002\u8fd9\u91cc\u7684\u601d\u8def\u5982\u4e0b\uff1a\u5c06n\u8f6c\u5316\u6210\u5b57\u7b26\u4e32s\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\u6bcf\u4e00\u4e2a\u4f4d\u7f6ei\uff0c\u540c\u65f6\u679a\u4e3e\u6b64\u4f4d\u7f6e\u4e0a\u7684\u6240\u6709\u53ef\u80fd\u6570\u5b57\uff08\u4e0d\u8d85\u8fc7s[i]\uff09\uff0c\u540c\u65f6\u8bb0\u5f55\u7b26\u5408\u6761\u4ef6\u7684\u65b9\u6848\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u6ce8\u610f\u7684\u5730\u65b9\uff0c\u6211\u4eec\u5e94\u8be5\u8986\u76d61-n\u7684\u6240\u6709\u53ef\u80fd\uff0c\u5047\u8bbe n = 123\uff0c\u90a3\u4e48\u8f6c\u5316\u6210\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u5c31\u662f3\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u767e\u4f4d\u679a\u4e3e\uff0c\u4e5f\u53ef\u4ee5\u4ece\u5341\u4f4d\u6216\u8005\u4e2a\u4f4d\u679a\u4e3e\uff0c\u8fd9\u6837\u80fd\u4fdd\u8bc1[1, n]\u533a\u95f4\u7684\u6240\u6709\u503c\u3002 \u4e3a\u4e86\u68c0\u67e5\u5f53\u524d\u5b57\u7b26\u4e32\u7684\u6240\u6709\u6570\u5b57\u4e0d\u91cd\u590d\uff0c\u537310\u4e2a\u6570\u5b57\u65e0\u91cd\u590d\uff0c\u6211\u4eec\u4f7f\u7528 2^{10} 2^{10} \u957f\u5ea6\u7684\u6574\u6570\u81f3mask\u8bb0\u5f55\u3002\u4f8b\u5982\uff0c\u60f3\u77e5\u9053\u300c3\u300d\u8fd9\u4e2a\u6570\u5b57\u6709\u88ab\u4f7f\u7528\u8fc7\u4e86\uff0c\u53ea\u9700\u8981 \\text{mask} \\And (1 << 3) \\text{mask} \\And (1 << 3) \u662f\u5426\u4f4d1\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int dfs ( string & s , vector < vector < int >> & M , int i , int mask , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum ; } if ( ! isLim && M [ i ][ mask ] != - 1 ) { return M [ i ][ mask ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( s , M , i + 1 , mask , false , isNum ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { if ( mask >> d & 1 ) { continue ; } ans += dfs ( s , M , i + 1 , mask | ( 1 << d ), d == up && isLim , true ); } M [ i ][ mask ] = ans ; return ans ; } int numDupDigitsAtMostN ( int n ) { string s = to_string ( n ); vector < vector < int >> M ( s . length (), vector < int > ( 1 << 10 , - 1 )); return n - dfs ( s , M , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(mD2^{D}) O(mD2^{D}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m2^{D}) O(m2^{D}) \uff0c\u8fd9\u91cc m \u662fn\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0cD = 10\uff0c\u8868\u793a\u6240\u6709\u6570\u5b57\u7684\u96c6\u5408\u5927\u5c0f","title":"\u81f3\u5c11\u6709 1 \u4f4d\u91cd\u590d\u7684\u6570\u5b57"},{"location":"algo/dp/digits/#2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u81ea\u7136\u6570 n\uff08n <= 10^9\uff09\uff0c\u8ba1\u7b97\u4ece 0 \u5230 n (\u542b n) \u4e2d\u6570\u5b57 2 \u51fa\u73b0\u7684\u6b21\u6570\u3002\u5982 n = 25\uff0c\u8fd4\u56de9(2, 12, 20, 21, 22, 23, 24, 25)(\u6ce8\u610f 22 \u5e94\u8be5\u7b97\u4f5c\u4e24\u6b21)\u3002 \u300c\u5206\u6790\u300d \u8bb0\u5fc6\u5316\u641c\u7d22\uff0cM[i][cnt] \u8868\u793a\u957f\u5ea6\u4e3ai\u65f6\u7684\u6570\u5b57\u542b\u6709cnt\u4e2a2\u7684\u6570\u5b57\u4e2a\u6570\u3002isLim \u8868\u793a\u5f53\u524d\u7684\u6570\u5b57\u662f\u5426\u53d7\u9650\uff0c\u56e0\u4e3a\u6211\u4eec\u6784\u9020\u7684\u6570\u5b57\u4e0d\u80fd\u5927\u4e8en\u3002\u901a\u5e38\u8bb0\u5fc6\u5316DP\u5c06\u4e00\u4e2a\u5927\u95ee\u9898\uff0c\u9010\u6b65\u62c6\u5206\u6210\u5c0f\u95ee\u9898\uff0c\u5e76\u5c06\u5c0f\u95ee\u9898\u7684\u7ed3\u679c\u4fdd\u5b58\u4e0b\u6765\uff0c\u907f\u514d\u91cd\u590d\u8ba1\u7b97\u3002\u8fd9\u91cc\u4ece\u5de6\u5230\u53f3\u6784\u9020\u6570\u5b57\uff0c\u770b\u4e0a\u53bb\u4e0d\u7b26\u5408\u8bb0\u5fc6\u5316DP\u7684\u8fc7\u7a0b\uff0c\u4f46\u662f\u56e0\u4e3a\u6211\u4eec\u52a0\u5165\u4e86isNum\uff0c\u4f18\u5148\u904d\u5386\u9ad8\u4f4d\u6570\u5b57\u4e0d\u586b\u5145\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u8fd9\u91cc\u76f8\u5f53\u4e8e\u5b50\u95ee\u9898\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int dfs ( vector < vector < int >> & M , string & s , int i , int cnt , bool isLim , bool isNum ) { if ( i == s . length ()) { if ( isNum ) { return cnt ; } return 0 ; } if ( ! isLim && M [ i ][ cnt ] != - 1 ) { return M [ i ][ cnt ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( M , s , i + 1 , cnt , false , isNum ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { ans += dfs ( M , s , i + 1 , cnt + ( d == 2 ), isLim && d == up , true ); } M [ i ][ cnt ] = ans ; return ans ; } int numberOf2sInRange ( int n ) { string s = to_string ( n ); vector < vector < int >> M ( s . length (), vector < int > ( s . length (), - 1 )); return dfs ( M , s , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{3}) O(m^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m^{2}) O(m^{2}) \uff0cm \u662fn\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\u3002","title":"2\u51fa\u73b0\u7684\u6b21\u6570"},{"location":"algo/dp/digits/#1_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n \uff0c\u8bf7\u4f60\u7edf\u8ba1\u5728 [0, n] \u8303\u56f4\u7684\u975e\u8d1f\u6574\u6570\u4e2d\uff0c\u6709\u591a\u5c11\u4e2a\u6574\u6570\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u4e0d\u5b58\u5728 \u8fde\u7eed\u7684 1 \u3002\u4f8b\u5982\uff0cn = 5\uff0c\u5728 [0, 5] \u7684\u975e\u8d1f\u6574\u6570\u4e2d\uff0c\u53ea\u6709 3 \u7684\u4e8c\u8fdb\u5236\u8868\u793a\u542b\u6709\u8fde\u7eed\u76841\uff0c\u56e0\u6b64\u7b54\u6848\u662f 5\u3002 \u300c\u5206\u6790\u300d \u5c06\u6574\u6570 n \u8f6c\u6362\u6210\u4e8c\u8fdb\u5236\u7684\u5b57\u7b26\u4e32\u5f62\u5f0f\uff0c\u4e4b\u540e\u5957\u7528\u6a21\u7248\u3002mark \u8868\u793a\u524d\u4e00\u4e2a\u5f53\u524d\u6784\u9020\u7684\uff08\u4e8c\u8fdb\u5236\uff09\u6570\u5b57\u7684\u6700\u540e\u4e00\u4f4d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int dfs ( string & s , vector < vector < int >> & M , int mark , int i , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum ; } if ( ! isLim && M [ i ][ mark ] != - 1 ) { return M [ i ][ mark ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( s , M , 0 , i + 1 , false , false ); } int up = isLim ? s [ i ] - '0' : 1 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { if ( d == 1 && mark == 1 ) { continue ; } ans += dfs ( s , M , d , i + 1 , isLim && ( d == up ), true ); } if ( ! isLim && isNum ) { M [ i ][ mark ] = ans ; } return ans ; } int findIntegers ( int n ) { string s = \"\" ; int tmp = n ; while ( tmp > 0 ) { int r = tmp % 2 ; s . push_back ( r + '0' ); tmp >>= 1 ; } reverse ( s . begin (), s . end ()); vector < vector < int >> M ( s . size (), vector < int > ( 2 , - 1 )); return 1 + dfs ( s , M , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(m) O(m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m) O(m) \uff0cm \u662fn\u8f6c\u5316\u4e3a\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\u3002","title":"\u4e0d\u542b\u8fde\u7eed1\u7684\u975e\u8d1f\u6574\u6570"},{"location":"algo/dp/digits/#_2","text":"\u7ed9\u4f60\u6b63\u6574\u6570 low \uff0chigh \u548c k \u3002\u5982\u679c\u4e00\u4e2a\u6570\u6ee1\u8db3\u4ee5\u4e0b\u4e24\u4e2a\u6761\u4ef6\uff0c\u90a3\u4e48\u5b83\u662f \u7f8e\u4e3d\u7684 \uff1a 1)\u5076\u6570\u6570\u4f4d\u7684\u6570\u76ee\u4e0e\u5947\u6570\u6570\u4f4d\u7684\u6570\u76ee\u76f8\u540c\u3002 2)\u8fd9\u4e2a\u6574\u6570\u53ef\u4ee5\u88ab k \u6574\u9664\u3002 \u4f8b\u5982\uff0clow = 10, high = 20, k = 3\uff0c\u7ed9\u5b9a\u8303\u56f4\u4e2d\u6709 2 \u4e2a\u7f8e\u4e3d\u6570\u5b57\uff1a[12,18] - 12 \u662f\u7f8e\u4e3d\u6574\u6570\uff0c\u56e0\u4e3a\u5b83\u6709 1 \u4e2a\u5947\u6570\u6570\u4f4d\u548c 1 \u4e2a\u5076\u6570\u6570\u4f4d\uff0c\u800c\u4e14\u53ef\u4ee5\u88ab k = 3 \u6574\u9664\u3002 - 18 \u662f\u7f8e\u4e3d\u6574\u6570\uff0c\u56e0\u4e3a\u5b83\u6709 1 \u4e2a\u5947\u6570\u6570\u4f4d\u548c 1 \u4e2a\u5076\u6570\u6570\u4f4d\uff0c\u800c\u4e14\u53ef\u4ee5\u88ab k = 3 \u6574\u9664\u3002 15 \u4e0d\u662f\u7f8e\u4e3d\u6574\u6570\uff0c\u56e0\u4e3a\u5b83\u7684\u5947\u6570\u6570\u4f4d\u548c\u5076\u6570\u6570\u4f4d\u7684\u6570\u76ee\u4e0d\u76f8\u7b49\u3002 \u8bf7\u8fd4\u56de\u8303\u56f4 [low, high] \u4e2d\u7f8e\u4e3d\u6574\u6570\u7684\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d M[i][mask][diff] \u8868\u793a\u6211\u4eec\u6784\u9020\u7b2c i \u4f4d\u6570\u5b57\uff0c\u8fd9\u4e2a\u6570\u5b57\u5bf9 k \u53d6\u4f59\u6570\u4f4d mask\uff0c\u4e14\u6570\u5b57\u5404\u6570\u4f4d\u7684\u5947\u5076\u5dee\u4e3a diff \u65f6\uff0c\u7f8e\u4e3d\u6570\u7684\u65b9\u6848\u6570\u76ee\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int dfs ( string & s , vector < vector < vector < int >>> & M , int mask , int diff , int i , int k , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum && mask == 0 && diff == s . length (); } if ( ! isLim && M [ i ][ mask ][ diff ] != - 1 ) { return M [ i ][ mask ][ diff ]; } int ans = 0 ; if ( ! isNum ) { ans = dfs ( s , M , mask , diff , i + 1 , k , false , false ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d = 1 - isNum ; d <= up ; d ++ ) { ans += dfs ( s , M , ( mask * 10 + d ) % k , diff + ( d % 2 ) * 2 - 1 , i + 1 , k , isLim && ( d == up ), true ); } if ( ! isLim && isNum ) { M [ i ][ mask ][ diff ] = ans ; } return ans ; } int calc ( int num , int k ) { int ans = 0 ; string s = to_string ( num ); vector < vector < vector < int >>> M ( s . length (), vector < vector < int >> ( k , vector < int > ( 2 * s . length () + 1 , - 1 ))); ans = dfs ( s , M , 0 , ( int ) s . length (), 0 , k , true , false ); return ans ; } int numberOfBeautifulIntegers ( int low , int high , int k ) { return calc ( high , k ) - calc ( low - 1 , k ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{2}kD) O(m^{2}kD) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m^{2}k) O(m^{2}k) \uff0cm \u662fn\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\uff0ck\u662f\u4f59\u6570\uff0cD=10\u3002","title":"\u8303\u56f4\u4e2d\u7f8e\u4e3d\u6574\u6570\u7684\u6570\u76ee"},{"location":"algo/dp/digits/#n","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6309 \u975e\u9012\u51cf\u987a\u5e8f \u6392\u5217\u7684\u6570\u5b57\u6570\u7ec4 digits \u3002\u4f60\u53ef\u4ee5\u7528\u4efb\u610f\u6b21\u6570 digits[i] \u6765\u5199\u7684\u6570\u5b57\u3002\u4f8b\u5982\uff0c\u5982\u679c digits = ['1','3','5']\uff0c\u6211\u4eec\u53ef\u4ee5\u5199\u6570\u5b57\uff0c\u5982 '13', '551', \u548c '1351315'\u3002\u8fd4\u56de \u53ef\u4ee5\u751f\u6210\u7684\u5c0f\u4e8e\u6216\u7b49\u4e8e\u7ed9\u5b9a\u6574\u6570 n \u7684\u6b63\u6574\u6570\u7684\u4e2a\u6570 \u3002 \u300c\u5206\u6790\u300d M[i] \u8868\u793a\u6211\u4eec\u6784\u9020\u7b2c i \u4f4d\u6570\u5b57\u65f6\uff0c\u751f\u6210\u7b26\u5408\u6761\u4ef6\u7684\u6570\u76ee\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int dfs ( string & s , vector < int > & digits , vector < int > & M , int mask , int i , bool isLim , bool isNum ) { if ( i == s . length ()) { return isNum ; } if ( ! isLim && M [ i ] != - 1 ) { return M [ i ]; } int ans = 0 ; if ( ! isNum ) { ans += dfs ( s , digits , M , mask , i + 1 , false , false ); } int up = isLim ? s [ i ] - '0' : 9 ; for ( int d : digits ) { if ( d > up ) { continue ; } ans += dfs ( s , digits , M , d , i + 1 , isLim && d == up , true ); } if ( ! isLim && isNum ) { M [ i ] = ans ; } return ans ; } int atMostNGivenDigitSet ( vector < string >& digits , int n ) { string s = to_string ( n ); vector < int > nums ; for ( string d : digits ) { nums . emplace_back ( stoi ( d )); } vector < int > M ( s . length (), - 1 ); return dfs ( s , nums , M , 0 , 0 , true , false ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(mk) O(mk) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(m) O(m) \uff0cm \u662fn\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\u540e\u7684\u957f\u5ea6\uff0ck\u662fdigits\u7684\u957f\u5ea6\u3002","title":"\u6700\u5927\u4e3a N \u7684\u6570\u5b57\u7ec4\u5408"},{"location":"algo/dp/edit-distance/","text":"\u57fa\u7840 \u00b6 \u83b1\u6587\u65af\u7279\u8ddd\u79bb\uff08Levenshtein distance\uff09\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\u589e\u52a0\u3001\u5220\u9664\u548c\u66ff\u6362 \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} a, b denote two strings to compare. If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 , delete a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 , insert b_{j} b_{j} at a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} , replace a_{i} a_{i} with b_{j} b_{j} \u4f8b\u5982\uff1aword1 = \"horse\", word2 = \"ros\"\uff0c\u83b1\u6587\u65af\u7279\u8ddd\u79bb\u4e3a3 \u89e3\u91ca\uff1a horse -> rorse (\u5c06 'h' \u66ff\u6362\u4e3a 'r') rorse -> rose (\u5220\u9664 'r') rose -> ros (\u5220\u9664 'e') Levenshtein distance \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 void EDprocess ( string s1 , string s2 , int i , int j , int ** dp , string str ) { if ( i == 0 && j == 0 ) { return ; } else if ( i == 0 || ( j > 0 && dp [ i ][ j ] == dp [ i ][ j - 1 ] + 1 )) { string ss = str . substr ( 0 , i ); ss . push_back ( s2 [ j - 1 ]); str = ss + str . substr ( i , str . length () - i ); printf ( \"insert %c: %s \\n \" , s2 [ j - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i , j - 1 , dp , str ); } else if ( j == 0 || ( i > 0 && dp [ i ][ j ] == dp [ i - 1 ][ j ] + 1 )) { string ss = str . substr ( 0 , i - 1 ); str = ss + str . substr ( i , str . length () - i ); printf ( \"delete %c: %s \\n \" , s1 [ i - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i - 1 , j , dp , str ); } else { if ( s1 [ i - 1 ] != s2 [ j - 1 ]) { str [ i - 1 ] = s2 [ j - 1 ]; printf ( \"replace %c with %c: %s \\n \" , s1 [ i - 1 ], s2 [ j - 1 ], str . c_str ()); } EDprocess ( s1 , s2 , i - 1 , j - 1 , dp , str ); } } void printDP ( string s1 , string s2 , int n1 , int n2 , int ** dp ) { for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { printf ( \"%d \\t \" , dp [ i ][ j ]); } printf ( \" \\n \" ); } printf ( \"s1 = %s \\n \" , s1 . c_str ()); EDprocess ( s1 , s2 , n1 , n2 , dp , s1 ); printf ( \"s2 = %s \\n \" , s2 . c_str ()); } int LD ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = i > j ? i : j ; } else { int a = dp [ i - 1 ][ j ] + 1 ; int b = dp [ i ][ j - 1 ] + 1 ; int c = dp [ i - 1 ][ j - 1 ] + ( s1 [ i - 1 ] != s2 [ j - 1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } printDP ( s1 , s2 , n1 , n2 , dp ); int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } /* 0 1 2 3 4 5 6 1 0 1 2 3 4 5 2 1 0 1 2 3 4 3 2 1 1 1 2 3 4 3 2 1 2 2 3 5 4 3 2 2 3 2 6 5 4 3 3 2 3 s1 = ecoles insert e: ecolese replace e with o: ecolose delete o: eclose s2 = eclose Edit distance = 3 */ Damerau-Levenshtein distance \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \u9898\u76ee \u00b6 \u6700\u5c0f\u7f16\u8f91\u4ee3\u4ef7 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u518d\u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570ic\uff0cdc\u548crc\uff0c\u5206\u522b\u4ee3\u8868\u63d2\u5165\u3001\u5220\u9664\u548c\u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\u7684\u4ee3\u4ef7\uff0c\u8bf7\u8f93\u51fa\u5c06str1\u7f16\u8f91\u6210str2\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002\u5982\uff0c\"abc\",\"adc\",5,3,2\uff0c\u8fd4\u56de2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * min edit cost * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @param ic int\u6574\u578b insert cost * @param dc int\u6574\u578b delete cost * @param rc int\u6574\u578b replace cost * @return int\u6574\u578b */ int minEditCost ( string str1 , string str2 , int ic , int dc , int rc ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 ) { dp [ i ][ j ] = ic * j ; } else if ( j == 0 ) { dp [ i ][ j ] = dc * i ; } else { int ist = dp [ i ][ j - 1 ] + ic ; int dlt = dp [ i - 1 ][ j ] + dc ; int rpl = dp [ i - 1 ][ j - 1 ] + rc * ( str1 [ i - 1 ] != str2 [ j - 1 ]); dp [ i ][ j ] = min ( ist , min ( dlt , rpl )); } } } return dp [ n1 ][ n2 ]; }","title":"\u7f16\u8f91\u8ddd\u79bb"},{"location":"algo/dp/edit-distance/#_1","text":"\u83b1\u6587\u65af\u7279\u8ddd\u79bb\uff08Levenshtein distance\uff09\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\u589e\u52a0\u3001\u5220\u9664\u548c\u66ff\u6362 \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} a, b denote two strings to compare. If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 , delete a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 , insert b_{j} b_{j} at a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} , replace a_{i} a_{i} with b_{j} b_{j} \u4f8b\u5982\uff1aword1 = \"horse\", word2 = \"ros\"\uff0c\u83b1\u6587\u65af\u7279\u8ddd\u79bb\u4e3a3 \u89e3\u91ca\uff1a horse -> rorse (\u5c06 'h' \u66ff\u6362\u4e3a 'r') rorse -> rose (\u5220\u9664 'r') rose -> ros (\u5220\u9664 'e')","title":"\u57fa\u7840"},{"location":"algo/dp/edit-distance/#levenshtein-distance","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 void EDprocess ( string s1 , string s2 , int i , int j , int ** dp , string str ) { if ( i == 0 && j == 0 ) { return ; } else if ( i == 0 || ( j > 0 && dp [ i ][ j ] == dp [ i ][ j - 1 ] + 1 )) { string ss = str . substr ( 0 , i ); ss . push_back ( s2 [ j - 1 ]); str = ss + str . substr ( i , str . length () - i ); printf ( \"insert %c: %s \\n \" , s2 [ j - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i , j - 1 , dp , str ); } else if ( j == 0 || ( i > 0 && dp [ i ][ j ] == dp [ i - 1 ][ j ] + 1 )) { string ss = str . substr ( 0 , i - 1 ); str = ss + str . substr ( i , str . length () - i ); printf ( \"delete %c: %s \\n \" , s1 [ i - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i - 1 , j , dp , str ); } else { if ( s1 [ i - 1 ] != s2 [ j - 1 ]) { str [ i - 1 ] = s2 [ j - 1 ]; printf ( \"replace %c with %c: %s \\n \" , s1 [ i - 1 ], s2 [ j - 1 ], str . c_str ()); } EDprocess ( s1 , s2 , i - 1 , j - 1 , dp , str ); } } void printDP ( string s1 , string s2 , int n1 , int n2 , int ** dp ) { for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { printf ( \"%d \\t \" , dp [ i ][ j ]); } printf ( \" \\n \" ); } printf ( \"s1 = %s \\n \" , s1 . c_str ()); EDprocess ( s1 , s2 , n1 , n2 , dp , s1 ); printf ( \"s2 = %s \\n \" , s2 . c_str ()); } int LD ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = i > j ? i : j ; } else { int a = dp [ i - 1 ][ j ] + 1 ; int b = dp [ i ][ j - 1 ] + 1 ; int c = dp [ i - 1 ][ j - 1 ] + ( s1 [ i - 1 ] != s2 [ j - 1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } printDP ( s1 , s2 , n1 , n2 , dp ); int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } /* 0 1 2 3 4 5 6 1 0 1 2 3 4 5 2 1 0 1 2 3 4 3 2 1 1 1 2 3 4 3 2 1 2 2 3 5 4 3 2 2 3 2 6 5 4 3 3 2 3 s1 = ecoles insert e: ecolese replace e with o: ecolose delete o: eclose s2 = eclose Edit distance = 3 */ Damerau-Levenshtein distance \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases}","title":"Levenshtein distance"},{"location":"algo/dp/edit-distance/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/dp/edit-distance/#_3","text":"\u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u518d\u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570ic\uff0cdc\u548crc\uff0c\u5206\u522b\u4ee3\u8868\u63d2\u5165\u3001\u5220\u9664\u548c\u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\u7684\u4ee3\u4ef7\uff0c\u8bf7\u8f93\u51fa\u5c06str1\u7f16\u8f91\u6210str2\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002\u5982\uff0c\"abc\",\"adc\",5,3,2\uff0c\u8fd4\u56de2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * min edit cost * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @param ic int\u6574\u578b insert cost * @param dc int\u6574\u578b delete cost * @param rc int\u6574\u578b replace cost * @return int\u6574\u578b */ int minEditCost ( string str1 , string str2 , int ic , int dc , int rc ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 ) { dp [ i ][ j ] = ic * j ; } else if ( j == 0 ) { dp [ i ][ j ] = dc * i ; } else { int ist = dp [ i ][ j - 1 ] + ic ; int dlt = dp [ i - 1 ][ j ] + dc ; int rpl = dp [ i - 1 ][ j - 1 ] + rc * ( str1 [ i - 1 ] != str2 [ j - 1 ]); dp [ i ][ j ] = min ( ist , min ( dlt , rpl )); } } } return dp [ n1 ][ n2 ]; }","title":"\u6700\u5c0f\u7f16\u8f91\u4ee3\u4ef7"},{"location":"algo/dp/interval/","text":"\u5220\u9664\u5b50\u4e32\u7684\u6700\u5c0f\u64cd\u4f5c\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caaabbcbaa\u201d\uff0c\u6bcf\u4e00\u6b21\u53ef\u4ee5\u5220\u9664\u4e00\u4e2a\u7531\u540c\u4e00\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\uff0c\u5220\u9664\u540e\u5269\u4f59\u90e8\u5206\u81ea\u52a8\u62fc\u63a5\u3002\u91cd\u590d\u8fdb\u884c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u7684\u5220\u9664\u6b21\u6570\u3002\u4e3e\u4f8b\u5982\u4e0b\uff1a \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u5220\u9664\u6709\u76f8\u540c\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\u7684\u6700\u5c0f\u6b21\u6570\u3002\u5982\u679c\u4e24\u7aef\u7684\u5b57\u7b26\u76f8\u540c\uff0c\u90a3\u4e48\u72b6\u6001\u8df3\u8f6c\u5230 s[i : j - 1]\uff1b\u5982\u679c\u4e24\u7aef\u5b57\u7b26\u4e32\u4e0d\u60f3\u7b49\uff0c\u90a3\u4e48\u6211\u4eec\u5bfb\u627e\u4e00\u4e2a\u6700\u4f73\u5207\u5206\u70b9 k \uff0c\u4f7f\u5207\u5206\u51fa\u6765\u7684\u4e24\u6bb5\u548c\u6700\u5c0f\u3002\u7279\u522b\u5730\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5355\u5b57\u7b26\uff0c\u6700\u5c0f\u5207\u5272\u6b21\u6570\u662f 1 \u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < vector < int >> dp ( n , vector < int > ( n , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i ][ j - 1 ]; } else { int _min = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { _min = min ( _min , dp [ i ][ k ] + dp [ k + 1 ][ j ]); } dp [ i ][ j ] = _min ; } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \u5220\u9664\u56de\u6587\u4e32\u7684\u6700\u5c0f\u6b21\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caabc\u201d\uff0c\u6bcf\u4e00\u6b21\u5220\u9664\u4e00\u4e2a\u56de\u6587\u5b50\u4e32\uff0c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u7684\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002\u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\u90fd\u4f1a\u9762\u4e34\u4e0b\u9762\u7684\u4e24\u79cd\u60c5\u51b5 \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} case 1 \u53ea\u5220\u9664\u4e00\u4e2a\u5b57\u7b26\uff0ccase 2 \u5220\u9664\u4e00\u4e2a\u533a\u95f4\u7684\u5b57\u7b26 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 , 0 )); dp [ n - 1 ][ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; dp [ i ][ i + 1 ] = 1 + ( s [ i ] != s [ i + 1 ]); for ( int j = i + 2 ; j < n ; j ++ ) { dp [ i ][ j ] = 1 + dp [ i + 1 ][ j ]; if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], 1 + dp [ i + 2 ][ j ]); } for ( int k = i + 2 ; k <= j ; k ++ ) { if ( s [ i ] == s [ k ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i + 1 ][ k - 1 ] + dp [ k + 1 ][ j ]); } } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \u6233\u6c14\u7403 \u00b6 \u6709 n \u4e2a\u6c14\u7403\uff0c\u7f16\u53f7\u4e3a0 \u5230 n - 1\uff0c\u6bcf\u4e2a\u6c14\u7403\u4e0a\u90fd\u6807\u6709\u4e00\u4e2a\u6570\u5b57\uff0c\u8fd9\u4e9b\u6570\u5b57\u5b58\u5728\u6570\u7ec4 nums \u4e2d\u3002\u73b0\u5728\u8981\u6c42\u4f60\u6233\u7834\u6240\u6709\u7684\u6c14\u7403\u3002\u6233\u7834\u7b2c i \u4e2a\u6c14\u7403\uff0c\u4f60\u53ef\u4ee5\u83b7\u5f97 nums[i - 1] * nums[i] * nums[i + 1] \u679a\u786c\u5e01\u3002 \u8fd9\u91cc\u7684 i - 1 \u548c i + 1 \u4ee3\u8868\u548c i \u76f8\u90bb\u7684\u4e24\u4e2a\u6c14\u7403\u7684\u5e8f\u53f7\u3002\u5982\u679c i - 1\u6216 i + 1 \u8d85\u51fa\u4e86\u6570\u7ec4\u7684\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u5f53\u5b83\u662f\u4e00\u4e2a\u6570\u5b57\u4e3a 1 \u7684\u6c14\u7403\u3002\u6c42\u6240\u80fd\u83b7\u5f97\u786c\u5e01\u7684\u6700\u5927\u6570\u91cf\u3002 \u300c\u5206\u6790\u300d \u300c\u533a\u95f4\u578b\u300d\u8bbe dp[i][j] \u4e3a\u6570\u7ec4 nums[i:j] \u8fd9\u4e2a\u533a\u95f4\u5185\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u5206\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 */ int maxCoins ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ n + 2 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { dp [ i ] = new int [ n + 2 ]{}; } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i + 2 ; j <= n + 1 ; j ++ ) { int MAX = 0 ; for ( int k = i + 1 ; k < j ; k ++ ) { int left = ( i == 0 ? 1 : nums [ i - 1 ]); int mid = nums [ k - 1 ]; int right = ( j == n + 1 ? 1 : nums [ j - 1 ]); int prod = left * mid * right ; MAX = max ( MAX , dp [ i ][ k ] + prod + dp [ k ][ j ]); } dp [ i ][ j ] = MAX ; } } int ans = dp [ 0 ][ n + 1 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3002","title":"\u533a\u95f4\u578b"},{"location":"algo/dp/interval/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caaabbcbaa\u201d\uff0c\u6bcf\u4e00\u6b21\u53ef\u4ee5\u5220\u9664\u4e00\u4e2a\u7531\u540c\u4e00\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\uff0c\u5220\u9664\u540e\u5269\u4f59\u90e8\u5206\u81ea\u52a8\u62fc\u63a5\u3002\u91cd\u590d\u8fdb\u884c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u7684\u5220\u9664\u6b21\u6570\u3002\u4e3e\u4f8b\u5982\u4e0b\uff1a \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u5220\u9664\u6709\u76f8\u540c\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\u7684\u6700\u5c0f\u6b21\u6570\u3002\u5982\u679c\u4e24\u7aef\u7684\u5b57\u7b26\u76f8\u540c\uff0c\u90a3\u4e48\u72b6\u6001\u8df3\u8f6c\u5230 s[i : j - 1]\uff1b\u5982\u679c\u4e24\u7aef\u5b57\u7b26\u4e32\u4e0d\u60f3\u7b49\uff0c\u90a3\u4e48\u6211\u4eec\u5bfb\u627e\u4e00\u4e2a\u6700\u4f73\u5207\u5206\u70b9 k \uff0c\u4f7f\u5207\u5206\u51fa\u6765\u7684\u4e24\u6bb5\u548c\u6700\u5c0f\u3002\u7279\u522b\u5730\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5355\u5b57\u7b26\uff0c\u6700\u5c0f\u5207\u5272\u6b21\u6570\u662f 1 \u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < vector < int >> dp ( n , vector < int > ( n , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i ][ j - 1 ]; } else { int _min = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { _min = min ( _min , dp [ i ][ k ] + dp [ k + 1 ][ j ]); } dp [ i ][ j ] = _min ; } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2})","title":"\u5220\u9664\u5b50\u4e32\u7684\u6700\u5c0f\u64cd\u4f5c\u6570"},{"location":"algo/dp/interval/#_2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caabc\u201d\uff0c\u6bcf\u4e00\u6b21\u5220\u9664\u4e00\u4e2a\u56de\u6587\u5b50\u4e32\uff0c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u7684\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002\u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\u90fd\u4f1a\u9762\u4e34\u4e0b\u9762\u7684\u4e24\u79cd\u60c5\u51b5 \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} case 1 \u53ea\u5220\u9664\u4e00\u4e2a\u5b57\u7b26\uff0ccase 2 \u5220\u9664\u4e00\u4e2a\u533a\u95f4\u7684\u5b57\u7b26 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 , 0 )); dp [ n - 1 ][ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; dp [ i ][ i + 1 ] = 1 + ( s [ i ] != s [ i + 1 ]); for ( int j = i + 2 ; j < n ; j ++ ) { dp [ i ][ j ] = 1 + dp [ i + 1 ][ j ]; if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], 1 + dp [ i + 2 ][ j ]); } for ( int k = i + 2 ; k <= j ; k ++ ) { if ( s [ i ] == s [ k ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i + 1 ][ k - 1 ] + dp [ k + 1 ][ j ]); } } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2})","title":"\u5220\u9664\u56de\u6587\u4e32\u7684\u6700\u5c0f\u6b21\u6570"},{"location":"algo/dp/interval/#_3","text":"\u6709 n \u4e2a\u6c14\u7403\uff0c\u7f16\u53f7\u4e3a0 \u5230 n - 1\uff0c\u6bcf\u4e2a\u6c14\u7403\u4e0a\u90fd\u6807\u6709\u4e00\u4e2a\u6570\u5b57\uff0c\u8fd9\u4e9b\u6570\u5b57\u5b58\u5728\u6570\u7ec4 nums \u4e2d\u3002\u73b0\u5728\u8981\u6c42\u4f60\u6233\u7834\u6240\u6709\u7684\u6c14\u7403\u3002\u6233\u7834\u7b2c i \u4e2a\u6c14\u7403\uff0c\u4f60\u53ef\u4ee5\u83b7\u5f97 nums[i - 1] * nums[i] * nums[i + 1] \u679a\u786c\u5e01\u3002 \u8fd9\u91cc\u7684 i - 1 \u548c i + 1 \u4ee3\u8868\u548c i \u76f8\u90bb\u7684\u4e24\u4e2a\u6c14\u7403\u7684\u5e8f\u53f7\u3002\u5982\u679c i - 1\u6216 i + 1 \u8d85\u51fa\u4e86\u6570\u7ec4\u7684\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u5f53\u5b83\u662f\u4e00\u4e2a\u6570\u5b57\u4e3a 1 \u7684\u6c14\u7403\u3002\u6c42\u6240\u80fd\u83b7\u5f97\u786c\u5e01\u7684\u6700\u5927\u6570\u91cf\u3002 \u300c\u5206\u6790\u300d \u300c\u533a\u95f4\u578b\u300d\u8bbe dp[i][j] \u4e3a\u6570\u7ec4 nums[i:j] \u8fd9\u4e2a\u533a\u95f4\u5185\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u5206\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 */ int maxCoins ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ n + 2 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { dp [ i ] = new int [ n + 2 ]{}; } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i + 2 ; j <= n + 1 ; j ++ ) { int MAX = 0 ; for ( int k = i + 1 ; k < j ; k ++ ) { int left = ( i == 0 ? 1 : nums [ i - 1 ]); int mid = nums [ k - 1 ]; int right = ( j == n + 1 ? 1 : nums [ j - 1 ]); int prod = left * mid * right ; MAX = max ( MAX , dp [ i ][ k ] + prod + dp [ k ][ j ]); } dp [ i ][ j ] = MAX ; } } int ans = dp [ 0 ][ n + 1 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3002","title":"\u6233\u6c14\u7403"},{"location":"algo/dp/knapsack/","text":"01 \u80cc\u5305 \u00b6 \u4e00\u4e2a\u80cc\u5305\u6709\u4e00\u5b9a\u7684\u627f\u91cd W\uff0c\u6709N\u4ef6\u7269\u54c1\uff0c\u6bcf\u4ef6\u90fd\u6709\u81ea\u5df1\u7684\u4ef7\u503c\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 v \u4e2d\uff0c\u4e5f\u90fd\u6709\u81ea\u5df1\u7684\u91cd\u91cf\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 w \u4e2d\uff0c\u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u9009\u62e9\u8981\u88c5\u5165\u80cc\u5305\u8fd8\u662f\u4e0d\u88c5\u5165\u80cc\u5305\uff0c\u8981\u6c42\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u7684\u524d\u63d0\u4e0b\uff0c\u9009\u51fa\u7269\u54c1\u7684\u603b\u4ef7\u503c\u6700\u5927\u3002\u4f8b\u5982\uff0c \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \u6700\u5927\u7684\u4ef7\u503c\u4e3a 5\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u5728\u80cc\u5305\u5bb9\u91cf\u4e3a j \u4e0b\u7684\u6700\u5927\u4ef7\u503c\u3002\u6b64\u65f6\u7684\u72b6\u6001\u53ea\u4f1a\u6709\u4e24\u4e2a\uff1a\uff081\uff09\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\uff082\uff09\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \uff081\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j\uff1b\uff082\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u4e86\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j - w[ i ]\uff0c\u8fd9\u91cc\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u52a0\u5165\u540e\uff0c\u603b\u91cd\u91cf\u5c06\u4f1a\u8fbe\u5230 j\uff0c\u90a3\u4e48\u52a0\u5165\u4e4b\u524d\u7684\u91cd\u91cf\u81ea\u7136\u5c31\u7b49\u4e8e j - w[ i ]\u3002\u5f53\u7136\uff0c\u5728\u8ba1\u7b97\u7684\u65f6\u5019\u9700\u8981\u5224\u5b9a\uff0c\u5f53\u524d\u7684\u603b\u91cd\u91cf j \u662f\u5426\u5927\u4e8e\u7b2c i \u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u3002 \u300c\u7ebf\u6027\u7a7a\u95f4\u300d \u56e0\u4e3a\u72b6\u6001\u7684\u8f6c\u79fb\u53ea\u53d1\u751f\u5728\u76f8\u90bb\u7269\u54c1\u4e4b\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u5f97\u4ee5\u4f18\u5316\uff0c\u4f46\u7528\u4e00\u7ef4\u7684\u7a7a\u95f4\u65f6\uff0c\u5e94\u5bf9\u5bb9\u91cf w \u8fdb\u884c \u5012\u5e8f\u904d\u5386 \u3002 1 2 3 4 5 6 7 8 9 10 int knapsack01 ( vector < int > v , vector < int > w , int W ) { int N = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\times W) O(N \\times W) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(W) O(W) \uff0cN \u4e3a\u7269\u54c1\u7684\u6570\u76ee\uff0cW \u4e3a\u9650\u5b9a\u7684\u91cd\u91cf \u300c\u91cd\u6784\u6700\u4f18\u89e3\u300d \u9664\u4e86\u5f97\u5230\u6700\u7ec8\u7684\u603b\u4ef7\u503c\uff0c\u6211\u4eec\u4e5f\u5e0c\u671b\u83b7\u77e5\u80cc\u5305\u7684\u65b9\u6848\uff0c\u5373\u6311\u9009\u54ea\u4e9b\u7269\u54c1\u653e\u5165\u80cc\u5305\u4e2d\u3002\u5728\u8fd9\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u4e8c\u7ef4\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e00\u6b65\u7684\u8fed\u4ee3\u3002\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ea\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u52a0\u5165\u80cc\u5305\u548c\u4e0d\u52a0\u5165\u80cc\u5305\uff0c\u5e76\u4e14\uff0c\u5f53\u524d\u7684\u7269\u54c1\u53ea\u4e0e\u540e\uff08\u524d\uff09\u4e00\u4ef6\u7269\u54c1\u6709\u5173\u7cfb\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053 dp[ i ][ j ] \u662f\u7b49\u4e8e dp[i + 1][ j ] \u8fd8\u662f\u7b49\u4e8e dp[i + 1][j - w[ i ]] + v[ i ]\u3002\u5982\u679c\u662f\u540e\u8005\uff0c\u8bf4\u660e\u7b2c i \u4ef6\u7269\u54c1\u88ab\u653e\u5165\uff0c\u53cd\u4e4b\uff0c\u5219\u672a\u88ab\u653e\u5165\u3002\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u54ea\u4e9b\u7269\u54c1\u88ab\u653e\u5165\u5373\u53ef\uff0c\u540c\u65f6\u66f4\u65b0 j\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int knapsack ( vector < int > w , vector < int > v , int W ) { int n = ( int ) w . size (); vector < vector < int >> G ( n + 1 , vector < int > ( W + 1 , 0 )); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } G [ i ] = dp ; } vector < int > idx ; for ( int i = 0 , j = W ; i < n && j >= 0 ; i ++ ) { if ( G [ i ][ j ] == G [ i + 1 ][ j - w [ i ]] + v [ i ]) { idx . emplace_back ( i ); j -= w [ i ]; } } for ( int id : idx ) { printf ( \"w[%d]=%d \\n \" , id , w [ id ]); } return dp [ W ]; } \u300c\u521d\u59cb\u5316\u7ec6\u8282\u300d \u4e00\u4e2a\u5bb9\u91cf\u4e3a W \u7684\u80cc\u5305\uff0c\u6709\u4e24\u79cd\u4e0d\u540c\u7684\u8981\u6c42\uff1a\uff081\uff09\u80cc\u5305\u8981\u88ab\u88c5\u6ee1\u548c\uff082\uff09\u80cc\u5305\u53ef\u4ee5\u4e0d\u6ee1\u3002\u8fd9\u4e24\u79cd\u7684\u521d\u59cb\u5316\u662f\u4e0d\u540c\u7684\u3002 \u5bf9\u4e8e\uff081\uff09\uff0cdp[ 0 ] \u88ab\u8bbe\u7f6e\u4e3a 0\uff0cdp[1 : W] \u88ab\u8bbe\u7f6e\u4e3a -\\infty -\\infty \uff1b\u5bf9\u4e8e\uff082\uff09\uff0cdp[0 : W] \u90fd\u4e3a 0\u3002\u53ef\u4ee5\u8fd9\u6837\u7406\u89e3\uff0c\u6761\u4ef6\uff081\uff09\u8981\u6c42\u80cc\u5305\u88c5\u6ee1\uff0c\u90a3\u4e48 W = 0 \u662f\u6ee1\u8db3\u7684\uff0c\u56e0\u4e3a\u7a7a\u80cc\u5305\u7684\u5bb9\u91cf\u5c31\u662f 0\uff0c\u4f46\u662f\u4e00\u65e6\u80cc\u5305\u7684\u5bb9\u91cf\u4e0d\u662f 0\uff0c\u90a3\u4e48\u672a\u88c5\u4efb\u4f55\u7269\u54c1\uff08\u7a7a\u8f7d\uff09\u662f\u4e0d\u7b26\u5408\u80cc\u5305\u88c5\u6ee1\u7684\u8981\u6c42\uff0c -\\infty -\\infty \u8868\u793a\u65e0\u5408\u6cd5\u7684\u89e3\uff1b\u53cd\u89c2\u6761\u4ef6\uff082\uff09\uff0c\u7a7a\u8f7d\u5bf9\u4e8e\u4efb\u610f\u7684 W \u90fd\u662f\u4e00\u4e2a\u5408\u6cd5\u89e3\uff0c\u56e0\u6b64\u7a7a\u8f7d\u80cc\u5305\u7684\u4ef7\u503c\u5c31\u662f 0\u3002 \u8fd9\u91cc\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0cv = [4, 3, 7, 5]\uff0cw = [2, 3, 5, 7]\uff0cW = 9\u3002\u5982\u679c\u8981\u6c42\u88c5\u6ee1\u80cc\u5305\uff0c\u7ed3\u679c\u662f 9\uff1b\u53cd\u4e4b\u662f 11\u3002 \u76ee\u6807\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4, \u5982 nums = [1, 1, 1, 1, 1] \u548c\u4e00\u4e2a\u76ee\u6807\u503c target = 3\u3002\u5bf9\u4e8e\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u524d\u65b9\u653e\u7f6e\u4e00\u4e2a\u8fd0\u7b97\u7b26 + \u6216\u8005 - \u6765\u6784\u6210\u4e00\u4e2a\u8ba1\u7b97\u8868\u8fbe\u5f0f\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\u7ed3\u679c\u6070\u597d\u4e3a target \u7684\u4e2a\u6570\u4e3a\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u9898\u610f\u53ef\u4ee5\u88ab\u89e3\u91ca\u4e3a\uff0c\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u7ec4\uff0c\u5176\u4e2d\u4e00\u7ec4\u5168\u90e8\u4e3a\u6807\u5fd7\u4e3a\u6b63\u6570\uff0c\u53e6\u4e00\u7ec4\u6807\u5fd7\u4e3a\u8d1f\u6570\uff0c\u8fd9\u6837\u6c42\u548c\u7ed3\u679c\u4e3a target\u3002\u672c\u9898\u662f 01 \u80cc\u5305\u95ee\u9898\u6c42\u65b9\u6848\u6570\u95ee\u9898\u3002\u5047\u8bbe\u6570\u7ec4\u548c\u4e3a sum\uff0c\u6b63\u6570\u7ec4\u7684\u548c\u4e3a pos\uff0c\u8d1f\u6570\u7ec4\u7684\u548c\u4e3a neg\uff08\u7edd\u5bf9\u503c\uff09\uff0c\u53ef\u4ee5\u5f97\u5230\u5982\u4e0b\u5173\u7cfb \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \u6240\u4ee5\uff0csum \u5fc5\u987b\u4e0d\u5c0f\u4e8e target\uff0c\u5e76\u4e14 sum - targte \u5fc5\u987b\u662f\u5076\u6570\u3002 \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5230\u6700\u540e\u4e00\u4e2a\u6570\u4e2d\u6c42\u548c\u7b49\u4e8e j \u7684\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u5173\u6ce8\u8fb9\u754c\u6761\u4ef6\uff1a\u5982\u679c j = 0\uff0c\u5373\u8d1f\u6570\u548c\u7684\u7edd\u5bf9\u503c\u4e3a 0\uff0c\u8868\u660e\u6211\u4eec\u5e94\u8be5\u4e0d\u9009\u53d6\u4efb\u4f55\u5143\u7d20\uff0c\u56e0\u6b64 dp[ i ][ 0 ] = 1\uff0c\u8fd9\u91cc i \u4ece 0 \u5230 n - 1\u3002\u5f53 i == n\uff0c\u5373\u5f53\u524d\u6570\u7ec4\u6ca1\u6709\u5143\u7d20\uff0c\u53ea\u6709 j == 0 \u65f6\uff0c\u65b9\u6848\u6570\u76ee\u624d\u4e3a 1\u3002\u5982\u679c\u4ece\u540e\u5411\u524d\u9012\u63a8\uff0c\u6700\u7ec8\u7684\u7b54\u6848\u662f dp[ 0 ][ target ]\u3002\u4f18\u5316\u540e\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u662f\u7ebf\u6027\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int findTargetSumWays ( vector < int >& nums , int target ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( target > sum || ( sum - target ) % 2 != 0 ) { return 0 ; } int neg = ( sum - target ) >> 1 ; vector < int > dp ( neg + 1 , 0 ); dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int j = neg ; j >= num ; j -- ) { dp [ j ] += dp [ j - num ]; } } return dp [ neg ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(target \\times n) O(target \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(target) O(target) \uff0c\u8fd9\u91cc target \u662f\u76ee\u6807\u503c\u5927\u5c0f\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002 \u5206\u5272\u7b49\u548c\u5b50\u96c6 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6784\u6210\u7684\u6570\u7ec4\uff0c\u5982 nums = [1, 5, 11, 5]\uff0c\u5224\u65ad\u80fd\u5426\u5c06\u6b64\u6570\u7ec4\u5206\u5272\u6210\u4e24\u4e2a\u6570\u7ec4\uff08\u4e0d\u8981\u6c42\u8fde\u7eed\uff09\uff0c\u4f7f\u4e24\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u76f8\u7b49\u3002\u7ed9\u51fa\u7684\u4f8b\u5b50\u53ef\u4ee5\u88ab\u5206\u6210 [1, 5, 5] \u548c [ 11 ] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u6211\u4eec\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u4e2a\u90e8\u5206\uff0c\u53ef\u4ee5\u7406\u89e3\u6210\u9009\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u5176\u548c\u662f\u539f\u6570\u7ec4\u548c\u7684\u4e00\u534a\u3002\u56e0\u6b64\uff0c\u53ef\u4ee5\u5c06\u6b64\u9898\u8f6c\u6362\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\u503c\uff0c\u5176\u548c\u662f\u5426\u7b49\u4e8e j\u3002\u5982\u679c\u539f\u6570\u7ec4\u7684\u548c sum \u662f\u5947\u6570\uff0c\u90a3\u4e48\u76f4\u63a5\u8fd4\u56de false\uff0c\u56e0\u4e3a\u4e24\u4e2a\u76f8\u7b49\u6570\u7684\u548c\u4e00\u5b9a\u662f\u5076\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u5f53 j == 0 \u65f6\uff0c\u8bf4\u660e\u4e24\u4e2a\u6570\u7ec4\u5747\u4e3a\u7a7a\uff0c\u90a3\u4e48\u6574\u4e2a\u6570\u7ec4\u5e94\u8be5\u4e3a\u7a7a\uff0c\u5bf9\u5e94\u7684 i == n \uff08\u4ece\u540e\u5f80\u524d\u9012\u63a8\uff09\u3002\u6700\u540e\u7684\u7b54\u6848\u5e94\u8be5\u4e3a dp[ 0 ][ sum / 2 ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool canPartition ( vector < int >& nums ) { int n = ( int ) nums . size (), sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; vector < vector < bool >> dp ( n + 1 , vector < bool > ( sum + 1 , 0 )); dp [ n ][ 0 ] = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= sum ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= nums [ i ]) { dp [ i ][ j ] = dp [ i ][ j ] || dp [ i + 1 ][ j - nums [ i ]]; } } } return dp [ 0 ][ sum ]; } \u7a7a\u95f4\u4f18\u5316\u540e\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool canPartition ( vector < int >& nums ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; bool * dp = new bool [ sum + 1 ]{}; dp [ 0 ] = true ; for ( int num : nums ) { for ( int j = sum ; j >= num ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - num ]; } } return dp [ sum ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(sum \\times n) O(sum \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(sum) O(sum) \uff0c\u8fd9\u91cc sum \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002 \u6700\u540e\u4e00\u5757\u77f3\u5934\u7684\u91cd\u91cf \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 stones = [2, 7, 4, 1, 8, 1] \u8868\u793a\u4e00\u7ec4\u77f3\u5934\u7684\u91cd\u91cf\u3002\u4ece\u5f53\u524d\u7684\u77f3\u5934\u91cc\u4efb\u53d6\u4e24\u4e2a\uff0c\u8d28\u91cf\u662f x \u548c y\uff0c\u5982\u679c\u4e24\u5757\u8d28\u91cf\u76f8\u7b49\u5373 x = y\uff0c\u90a3\u4e48\u8fd9\u4e24\u5757\u77f3\u5934\u88ab\u79fb\u9664\uff1b\u53cd\u4e4b\uff0c\u79fb\u9664\u8f83\u5c0f\u7684\u90a3\u4e00\u5757\uff0c\u5e76\u4e14\u8f83\u5927\u7684\u90a3\u4e00\u5757\u53d8\u6210\u8fd9\u4e24\u5757\u8d28\u91cf\u7684\u5dee\u503c\uff08\u7edd\u5bf9\u503c\uff09\u3002\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u76f4\u5230\u5269\u4f59\u4e00\u5757\u6216\u8005\u65e0\u5269\u4f59\uff0c\u6c42\u5269\u4f59\u7684\u6700\u5c0f\u8d28\u91cf\u662f\u591a\u5c11\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u53ef\u4ee5\u539f\u6570\u7ec4\u5206\u5272\u6210\u4e24\u7ec4 + \u548c -\uff0c\u6211\u4eec\u7528 + \u8fd9\u4e00\u7ec4\u51cf\u53bb - \u8fd9\u4e00\u7ec4\uff0c\u6240\u5f97\u7ed3\u679c\u7684\u6700\u5c0f\u503c\u662f\u6700\u7ec8\u7ed3\u679c\uff0c\u8fd9\u6837\u95ee\u9898\u8f6c\u5316\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe neg \u4e3a - \u8fd9\u4e00\u7ec4\u7684\u548c\uff0cpos \u4e3a + \u8fd9\u4e00\u7ec4\u7684\u548c\u3002\u6ee1\u8db3\u4e0b\u5217\u65b9\u7a0b\u7ec4 \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u6210\uff0c\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u503c\uff0c\u5176\u548c\u7b49\u4e8e neg\uff0c\u5e76\u4e14\u4f7f\u5f97 \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5b57\u5230\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\uff0c\u5b83\u4eec\u7684\u548c\u5728\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u503c\u662f\u591a\u5c11\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 int lastStoneWeightII ( vector < int >& stones ) { int sum = 0 ; for ( int stone : stones ) { sum += stone ; } int tar = ( sum >> 1 ); vector < int > dp ( tar + 1 , 0 ); for ( int stone : stones ) { for ( int j = tar ; j >= stone ; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - stone ] + stone ); } } return sum - 2 * dp [ tar ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(tar \\times n) O(tar \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(tar) O(tar) \uff0c\u8fd9\u91cc tar \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002 \u76c8\u5229\u8ba1\u5212 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 n \u4ee3\u8868\u4eba\u6570\uff0cminProfit \u4ee3\u8868\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u4e00\u4e32\u5de5\u4f5c\u9700\u8981\u7684\u4eba\u6570 group = [2, 2]\uff0c\u6bcf\u9879\u5de5\u4f5c\u5bf9\u5e94\u7684\u5229\u6da6 profit = [2, 3]\u3002\u8981\u6c42\u5b9e\u73b0\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u5e76\u4e14\u6295\u5165\u7684\u4eba\u6570\u548c\u4e0d\u80fd\u8d85\u8fc7 n\uff0c\u8fd9\u6837\u7684\u5206\u914d\u65b9\u6848\u6570\u76ee\u6709\u591a\u5c11\u4e2a\uff1f \u300c\u5206\u6790\u300d \u5728 01 \u80cc\u5305\u95ee\u9898\u7684\u57fa\u7840\u4e0a\uff0c\u672c\u9898\u589e\u52a0\u4e86\u6700\u4f4e\u76c8\u5229\u989d\u7684\u9650\u5236\u3002\u8bbe dp[ i ][ j ][ k ] \u4e3a\u4ece i \u5f00\u59cb\u7684\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u4e9b\u5de5\u4f5c\u6295\u5165\u4eba\u529b\uff0c\u5728\u6070\u597d j \u4e2a\u4eba\u4e14\u76c8\u5229\u989d\u4e0d\u4f4e\u4e8e k \u7684\u60c5\u51b5\u4e0b\uff0c\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \u8fb9\u754c\u6761\u4ef6 dp[ len ][ 0 ][ 0 ] = 1\uff0c\u8868\u660e\u4e0d\u9009\u4efb\u4f55\u5de5\u4f5c\u65f6\uff0c\u6295\u5165\u7684\u4eba\u6570\u662f 0\uff0c\u6700\u4f4e\u7684\u76c8\u5229\u989d\u4e5f\u662f 0\uff0c\u6b64\u65f6\u4e5f\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\u4e00\u79cd\u65b9\u6848\u3002\u8fdb\u4e00\u6b65\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c\u5f53 k = 0 \u5373\u6700\u4f4e\u76c8\u5229\u989d\u4e3a 0\uff0c\u90a3\u4e48\u4e0d\u8bba i \u548c j \u4e3a\u4f55\u503c\uff0cdp[ i ][ j ][ 0 ] \u5747\u4e3a 1\u3002 \\text{k - profit[ i ]} \\text{k - profit[ i ]} \u4e3a\u8d1f\u6570\uff0c\u8bf4\u660e\u7b2c i \u4e2a\u5de5\u4f5c\u7684\u5229\u6da6\u672c\u8eab\u5c31\u8d85\u8fc7 minProfit\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728\u9009\u62e9\u7b2c i \u4e2a\u5de5\u4f5c\u524d\uff0c\u6700\u4f4e\u76c8\u5229\u53ef\u4ee5\u4e3a 0\uff0c\u8fd9\u4e2a\u65f6\u5019\u53ea\u8981\u6295\u5165\u7684\u4eba\u6570\u4e0d\u8d85\u8fc7 j - group[ i ]\uff0c\u90fd\u88ab\u89c6\u4e3a\u6ee1\u8db3\u8981\u6c42\u7684\u65b9\u6848\u3002\u76f8\u53cd\uff0c\u5982\u679c\u6211\u4eec\u7ea6\u675f \\text{k} \\geq \\text{profit[ i ]} \\text{k} \\geq \\text{profit[ i ]} \uff0c\u6211\u4eec\u6700\u7ec8\u5f97\u5230\u7684\u7ed3\u679c\u662f \u6070\u597d\u7b49\u4e8e minProfit \u7684\u65b9\u6848\u6570\uff0c\u56e0\u4e3a k - profit[ i ] \u53ea\u4f1a\u8f6c\u79fb\u5230\u7b2c\u4e09\u7ef4\u6210\u4e3a 0 \u7684\u72b6\u6001\u3002 \u6700\u7ec8\u7684\u7b54\u6848\u662f\u8003\u5bdf\u6240\u6709\u7684\u5de5\u4f5c\u4e14\u6ee1\u8db3\u6700\u4f4e\u76c8\u5229\u989d\u7684\u6761\u4ef6\u4e0b\uff0c\u5bf9\u6295\u5165\u7684\u4eba\u6570\u904d\u5386 \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); dp [ 0 ][ 0 ] = 1 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = 0 ; k <= minProfit ; k ++ ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } int ans = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { ans += dp [ j ][ minProfit ]; ans %= MOD ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(len \\times n \\times minProfit) O(len \\times n \\times minProfit) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n \\times minProfit) O(n \\times minProfit) \uff0c\u8fd9\u91cc len \u662f\u5de5\u4f5c\u7684\u4e2a\u6570 / \u5229\u6da6\u6570\u7ec4\u7684\u957f\u5ea6\uff0cn \u662f\u603b\u4eba\u6570\uff0cminProfit \u662f\u6700\u4f4e\u76c8\u5229\u989d\u3002 \u8fd9\u4e2a\u9898\u76ee\u4e5f\u53ef\u4ee5\u5b9a\u4e49\u6210 dp[ i ][ j ][ k ] \u4ece\u7b2c i \u4e2a\u5de5\u4f5c\u5230\u6700\u540e\u4e00\u4e2a\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\uff0c\u5728\u6295\u5165\u4e0d\u8d85\u8fc7 j \u4e2a\u4eba\u4e14\u5229\u6da6\u4e0d\u4f4e\u4e8e k \u7684\u6761\u4ef6\u4e0b\u7684\u65b9\u6848\u6570\u76ee\u3002\u5bf9\u5e94\u7684\u521d\u59cb\u5316\u5e94\u8be5\u6539\u6210 dp[ i ][ j ][ 0 ] = 1\uff0c\u6700\u540e\u7684\u7ed3\u679c\u662f dp[ 0 ][ n ][ minProfit ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); for ( int j = 0 ; j <= n ; j ++ ) { dp [ j ][ 0 ] = 1 ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = minProfit ; k >= 0 ; k -- ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } return dp [ n ][ minProfit ]; } \u6570\u7ec4\u7684\u5747\u503c\u5206\u5272 \u00b6 \u7ed9\u5b9a\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums\u3002\u6211\u4eec\u8981\u5c06 nums \u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u79fb\u52a8\u5230 A \u6570\u7ec4 \u6216\u8005 B \u6570\u7ec4\u4e2d\uff0c\u4f7f\u5f97 A \u6570\u7ec4\u548c B \u6570\u7ec4\u4e0d\u4e3a\u7a7a\uff0c\u5e76\u4e14 average(A) == average(B) \u3002\u5982\u679c\u53ef\u4ee5\u5b8c\u6210\u5219\u8fd4\u56detrue \uff0c \u5426\u5219\u8fd4\u56de false \u3002\u4f8b\u5982\uff0c nums = [1,2,3,4,5,6,7,8]\uff0c\u8fd4\u56de true\uff1bnums = [3,1]\uff0c\u8fd4\u56de false\u3002nums \u7684\u957f\u5ea6\u4e0d\u8d85\u8fc730\u3002 \u300c\u5206\u6790\u300d \u5047\u8bbenums\u53ef\u4ee5\u88ab\u5206\u6210\u4e24\u4e2a\u6570\u7ec4\uff0c\u90a3\u4e48\u4e24\u4e2a\u5b57\u6570\u7ec4\u7684\u5747\u503c\u548cnums\u7684\u5747\u503c\u662f\u4e00\u6837\u7684 \\frac{S_{A}}{n_{A}} = \\frac{S_{B}}{n_{B}} = \\frac{S}{n} = \\text{avg} \\frac{S_{A}}{n_{A}} = \\frac{S_{B}}{n_{B}} = \\frac{S}{n} = \\text{avg} \u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u63d0\u524d\u68c0\u67e5\uff0c\u662f\u5426\u5b58\u5728 {n_{A}} {n_{A}} \u80fd\u591f\u6ee1\u8db3\u4e0a\u5f0f\u3002\u4e4b\u540e\u5c31\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u5316\u4e3a0-1\u80cc\u5305\u95ee\u9898\uff0cdp[ i ][ j ][ k ] \u8868\u793a\u524d i \u4e2a\u5143\u7d20\u4e2d\uff0c\u9009\u62e9 j \u4e2a\u6570\u5b57\uff0c\u5176\u548c\u662f\u5426\u7b49\u4e8e k\u3002\u540c\u65f6\u9700\u8981\u68c0\u67e5 j * sum \u662f\u5426\u7b49\u4e8e k * n\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool splitArraySameAverage ( vector < int >& nums ) { int sum = 0 , n = ( int ) nums . size (), m = n / 2 ; int min_val = INT_MAX ; for ( int num : nums ) { sum += num ; min_val = min ( min_val , num ); } bool check = false ; for ( int i = 1 ; i <= m ; i ++ ) { if ( sum * i % n == 0 ) { check = true ; break ; } } if ( ! check ) { return false ; } vector < unordered_set < int >> dp ( m + 1 ); dp [ 0 ]. emplace ( 0 ); for ( int num : nums ) { for ( int j = m ; j >= 1 ; j -- ) { for ( int x : dp [ j - 1 ]) { int cur = x + num ; if ( cur * n == sum * j ) { return true ; } dp [ j ]. emplace ( cur ); } } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO( n^{2}\\sum\\text{nums} n^{2}\\sum\\text{nums} )\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO( n\\sum\\text{nums} n\\sum\\text{nums} )\u3002 \u5b8c\u5168\u80cc\u5305 \u00b6 \u4e00\u4e2a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u662f W\uff0c\u6709 N \u79cd\u7269\u54c1\uff0c\u6bcf\u4e00\u4ef6\u6709\u81ea\u5df1\u7684\u4ef7\u503c v_{i} v_{i} \u548c \u91cd\u91cf w_{i} w_{i} \uff0c\u6bcf\u4e00\u79cd\u7c7b\u7684\u7269\u54c1\u65e0\u9650\u4f9b\u5e94\uff0c\u8bd5\u95ee\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u603b\u91cf\u4e0b\uff0c\u80cc\u5305\u7684\u4ef7\u503c\u6700\u5927\u3002 \u300c\u5206\u6790\u300d \u5b8c\u5168\u80cc\u5305\u95ee\u9898\u79cd\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u7684\u4f9b\u5e94\u662f\u65e0\u9650\u7684\uff0c\u4f46\u56e0\u4e3a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u6709\u9650\uff0c\u53ef\u4ee5\u653e\u5165\u7684\u6570\u76ee\u4f9d\u7136\u6709\u9650 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} \uff0c\u90a3\u4e48\u6211\u4eec\u4f9d\u7136\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u4e2d\u9009\u53d6\u82e5\u5e72\u4ef6\uff0c\u5728\u91cd\u91cf\u548c\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u4ef7\u503c\u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \u5728 01 \u80cc\u5305\u95ee\u9898\u4e2d\uff0cdp[ i ][ j ] \u662f\u7531 dp[i + 1][j - w[ i ]] + v[ i ] \u8f6c\u79fb\u800c\u6765\uff0c\u8868\u8fbe\u4e86\u9996\u6b21\u5c06\u7b2c i \u4ef6\u7269\u54c1\u52a0\u5165\u5230\u80cc\u5305\u4e2d\u3002\u4f46\u662f\u5728\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u91cc\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u662f\u53ef\u4ee5\u591a\u6b21\u653e\u5165\u7684\uff0c\u90a3\u4e48 dp[ i ][j - w[ i ]] + v[ i ] \u5c31\u5df2\u7ecf\u5305\u542b\u4e86 dp[i + 1][j - w[ i ]] + v[ i ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < vector < int >> dp ( n + 1 , vector < int > ( W + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= W ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= w [ i ]) { dp [ i ][ j ] = max ( dp [ i ][ j ], max ( dp [ i + 1 ][ j - w [ i ]], dp [ i ][ j - w [ i ]]) + v [ i ]); } } } return dp [ 0 ][ W ]; } \u7a7a\u95f4\u4e0a\u8fdb\u884c\u4f18\u5316 \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) 1 2 3 4 5 6 7 8 9 10 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = w [ i ]; j <= W ; j ++ ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u8fd9\u91cc\u4e0e 01 \u80cc\u5305\u7684\u4ee3\u7801\u53ea\u6709\u4e00\u884c\u4e0d\u540c\uff0c\u5373 j \u7684\u904d\u5386\u65b9\u5411\u4e0a\u3002\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u662f\u6709\u5c0f\u5230\u5927\u904d\u5386\uff0c\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ef\u4ee5\u88ab\u591a\u6b21\u653e\u5165\uff1b\u53cd\u800c 01 \u80cc\u5305\u95ee\u9898\u5bf9\u4efb\u4e00\u4ef6\u7269\u54c1\u6700\u591a\u53ea\u5141\u8bb8\u653e\u5165\u4e00\u6b21\u3002 \u6362\u96f6\u94b1 I \u00b6 \u7ed9\u5b9a\u4e00\u7ec4\u786c\u5e01\u7684\u9762\u503c coins = [186, 419, 83, 408] \u548c\u4e00\u4e2a\u603b\u91cf amount = 6249\uff0c\u8bd5\u95ee\u7528\u6700\u5c11\u7684\u786c\u5e01\u4e2a\u6570\u53ef\u4ee5\u7ec4\u6210\u8fd9\u4e2a amount\u3002\u5982\u679c\u4e0d\u80fd\u627e\u5230\u96f6\u94b1\u7ec4\u5408\uff0c\u8fd4\u56de -1\u3002 \u300c\u5206\u6790\u300d \u672c\u9898\u53ef\u4ee5\u88ab\u7406\u89e3\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u6bcf\u4e00\u679a\u786c\u5e01\u7684\u4ef7\u503c\u4e3a 1\uff0c\u6c42\u6700\u5c0f\u7684\u4ef7\u503c\u3002\u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u6784\u6210 j \u6570\u989d\u7684\u6700\u5c11\u786c\u5e01\u4e2a\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \u56e0\u4e3a\u6c42\u89e3\u7684\u662f\u6700\u5c0f\u4e2a\u6570\uff0c\u90a3\u4e48\u6570\u7ec4\u521d\u59cb\u5316\u6210\u6700\u5927\u503c\uff0c\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528 amount + 1 \u4f5c\u4e3a\u6700\u5927\u503c\uff0c\u56e0\u4e3a\uff0c\u6700\u5c0f\u7684\u96f6\u94b1\u662f 1\u3002\u90a3\u4e48\u6700\u591a\u7684\u786c\u5e01\u4e2a\u6570\u4e5f\u4e0d\u4f1a\u8d85\u8fc7 amount\u3002\u5f53 anount = 0 \u65f6\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u786c\u5e01\uff0c\u5373 0\u3002 1 2 3 4 5 6 7 8 9 10 int coinChange ( vector < int >& coins , int amount ) { vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - coin ] + 1 ); } } return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002 \u6362\u96f6\u94b1 II \u00b6 \u540c\u4e0a\u9898\u80cc\u666f\uff0c\u6c42\u80fd\u591f\u7ec4\u5408\u51fa\u7ed9\u5b9a\u91d1\u989d\u7684\u96f6\u94b1\u65b9\u6848\u6570\u76ee \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u7ec4\u6210\u91d1\u989d\u662f j \u7684\u65b9\u6848\u6570\u76ee \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 int coinChange ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] += dp [ j - coin ]; } } return dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\text{n} \\times \\text{amount}) O(\\text{n} \\times \\text{amount}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\text{amount}) O(\\text{amount}) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002 \u6362\u96f6\u94b1 III \u00b6 \u540c\u4e0a\u9898\u80cc\u666f\uff0c\u4f9d\u7136\u6c42\u65b9\u6848\u6570\u76ee\uff0c\u4f46\u8981\u6c42\u786c\u5e01\u5177\u6709\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982 coins = [1, 2, 3]\uff0c\u7ec4\u6210 amount = 3 \u7684\u65b9\u6848\u6709 [1, 1, 1]\uff0c[1, 2]\uff0c[2, 1]\uff0c[ 3 ] 4 \u79cd\uff0c\u6ce8\u610f\u5230 [1, 2] \u548c [2, 1] \u662f\u4e0d\u4e00\u6837\u7684\u65b9\u6848\u3002 \u300c\u5206\u6790\u300d \u540c\u4e0a\u9898\uff0c\u8bbe dp[ j ] \u4e3a \u91d1\u989d\u4e3a j \u7684\u65b9\u6848\u6570\u76ee\u3002\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u4e24\u5c42\u5faa\u73af\u7684\u4f4d\u7f6e\u3002 \u7269\u54c1\u5faa\u73af\u5728\u5916\u4fa7\uff0c\u6570\u91cf\u5faa\u73af\u5728\u5185\u6d4b\u65f6\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u7ec4\u5408\u60c5\u51b5\uff1b\u53cd\u4e4b\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u6392\u5217\u60c5\u51b5 1 2 3 4 5 6 7 8 9 10 11 12 int combinationSum41 ( vector < int >& coins , int amount ) { vector < unsigned int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int i = 0 ; i <= amount ; i ++ ) { for ( int coin : coins ) { if ( i >= coin ) { dp [ i ] += dp [ i - coin ]; } } } return dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002 \u5e73\u65b9\u6570\u7684\u6700\u5c0f\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6570 n = 13\uff0c\u5b83\u53ef\u4ee5\u7531\u82e5\u5e72\u4e2a\u5e73\u65b9\u6570\u76f8\u52a0\u800c\u5f97\uff0c\u8fd4\u56de\u8fd9\u4e9b\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u7684\u6700\u5c0f\u503c\u300213 = 4 + 9\uff0c\u5373\u6700\u5c0f\u503c\u4e3a 2. \u300c\u5206\u6790\u300d \u65b9\u6cd5 1\uff1a\u8f6c\u5316\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u7edf\u8ba1 1 - n \u4e4b\u95f4\u6240\u6709\u7684\u5e73\u65b9\u6570\uff0c\u4e4b\u540e\u6309\u7167\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u89e3\u6cd5\u6c42\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int numSquares ( int n ) { if ( n <= 0 ) { return 0 ; } vector < int > square ; for ( int i = 1 ; i <= n ; i ++ ) { int root = ( int ) sqrt ( i ); if ( root * root == i ) { square . emplace_back ( i ); } } vector < int > dp ( n + 1 , n + 1 ); dp [ 0 ] = 0 ; for ( int s : square ) { for ( int j = s ; j <= n ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - s ] + 1 ); } } return dp [ n ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\sqrt{n}) O(n \\sqrt{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002 \u65b9\u6cd5 2\uff1a\u8bbe dp[ i ] \u4e3a\u6784\u6210 i \u7684\u6700\u5c0f\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u3002 \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int numSquares ( int n ) { if ( n < 1 ) { return 0 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i <= n ) { dp [ i * i ] = 1 ; } if ( dp [ i ]) { continue ; } int min = INT_MAX ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( min > dp [ j ] + dp [ i - j ]) { min = dp [ j ] + dp [ i - j ]; } } dp [ i ] = min ; } int ans = dp [ n ]; delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002","title":"\u80cc\u5305\u95ee\u9898"},{"location":"algo/dp/knapsack/#01","text":"\u4e00\u4e2a\u80cc\u5305\u6709\u4e00\u5b9a\u7684\u627f\u91cd W\uff0c\u6709N\u4ef6\u7269\u54c1\uff0c\u6bcf\u4ef6\u90fd\u6709\u81ea\u5df1\u7684\u4ef7\u503c\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 v \u4e2d\uff0c\u4e5f\u90fd\u6709\u81ea\u5df1\u7684\u91cd\u91cf\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 w \u4e2d\uff0c\u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u9009\u62e9\u8981\u88c5\u5165\u80cc\u5305\u8fd8\u662f\u4e0d\u88c5\u5165\u80cc\u5305\uff0c\u8981\u6c42\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u7684\u524d\u63d0\u4e0b\uff0c\u9009\u51fa\u7269\u54c1\u7684\u603b\u4ef7\u503c\u6700\u5927\u3002\u4f8b\u5982\uff0c \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \u6700\u5927\u7684\u4ef7\u503c\u4e3a 5\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u5728\u80cc\u5305\u5bb9\u91cf\u4e3a j \u4e0b\u7684\u6700\u5927\u4ef7\u503c\u3002\u6b64\u65f6\u7684\u72b6\u6001\u53ea\u4f1a\u6709\u4e24\u4e2a\uff1a\uff081\uff09\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\uff082\uff09\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \uff081\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j\uff1b\uff082\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u4e86\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j - w[ i ]\uff0c\u8fd9\u91cc\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u52a0\u5165\u540e\uff0c\u603b\u91cd\u91cf\u5c06\u4f1a\u8fbe\u5230 j\uff0c\u90a3\u4e48\u52a0\u5165\u4e4b\u524d\u7684\u91cd\u91cf\u81ea\u7136\u5c31\u7b49\u4e8e j - w[ i ]\u3002\u5f53\u7136\uff0c\u5728\u8ba1\u7b97\u7684\u65f6\u5019\u9700\u8981\u5224\u5b9a\uff0c\u5f53\u524d\u7684\u603b\u91cd\u91cf j \u662f\u5426\u5927\u4e8e\u7b2c i \u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u3002 \u300c\u7ebf\u6027\u7a7a\u95f4\u300d \u56e0\u4e3a\u72b6\u6001\u7684\u8f6c\u79fb\u53ea\u53d1\u751f\u5728\u76f8\u90bb\u7269\u54c1\u4e4b\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u5f97\u4ee5\u4f18\u5316\uff0c\u4f46\u7528\u4e00\u7ef4\u7684\u7a7a\u95f4\u65f6\uff0c\u5e94\u5bf9\u5bb9\u91cf w \u8fdb\u884c \u5012\u5e8f\u904d\u5386 \u3002 1 2 3 4 5 6 7 8 9 10 int knapsack01 ( vector < int > v , vector < int > w , int W ) { int N = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\times W) O(N \\times W) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(W) O(W) \uff0cN \u4e3a\u7269\u54c1\u7684\u6570\u76ee\uff0cW \u4e3a\u9650\u5b9a\u7684\u91cd\u91cf \u300c\u91cd\u6784\u6700\u4f18\u89e3\u300d \u9664\u4e86\u5f97\u5230\u6700\u7ec8\u7684\u603b\u4ef7\u503c\uff0c\u6211\u4eec\u4e5f\u5e0c\u671b\u83b7\u77e5\u80cc\u5305\u7684\u65b9\u6848\uff0c\u5373\u6311\u9009\u54ea\u4e9b\u7269\u54c1\u653e\u5165\u80cc\u5305\u4e2d\u3002\u5728\u8fd9\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u4e8c\u7ef4\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e00\u6b65\u7684\u8fed\u4ee3\u3002\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ea\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u52a0\u5165\u80cc\u5305\u548c\u4e0d\u52a0\u5165\u80cc\u5305\uff0c\u5e76\u4e14\uff0c\u5f53\u524d\u7684\u7269\u54c1\u53ea\u4e0e\u540e\uff08\u524d\uff09\u4e00\u4ef6\u7269\u54c1\u6709\u5173\u7cfb\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053 dp[ i ][ j ] \u662f\u7b49\u4e8e dp[i + 1][ j ] \u8fd8\u662f\u7b49\u4e8e dp[i + 1][j - w[ i ]] + v[ i ]\u3002\u5982\u679c\u662f\u540e\u8005\uff0c\u8bf4\u660e\u7b2c i \u4ef6\u7269\u54c1\u88ab\u653e\u5165\uff0c\u53cd\u4e4b\uff0c\u5219\u672a\u88ab\u653e\u5165\u3002\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u54ea\u4e9b\u7269\u54c1\u88ab\u653e\u5165\u5373\u53ef\uff0c\u540c\u65f6\u66f4\u65b0 j\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int knapsack ( vector < int > w , vector < int > v , int W ) { int n = ( int ) w . size (); vector < vector < int >> G ( n + 1 , vector < int > ( W + 1 , 0 )); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } G [ i ] = dp ; } vector < int > idx ; for ( int i = 0 , j = W ; i < n && j >= 0 ; i ++ ) { if ( G [ i ][ j ] == G [ i + 1 ][ j - w [ i ]] + v [ i ]) { idx . emplace_back ( i ); j -= w [ i ]; } } for ( int id : idx ) { printf ( \"w[%d]=%d \\n \" , id , w [ id ]); } return dp [ W ]; } \u300c\u521d\u59cb\u5316\u7ec6\u8282\u300d \u4e00\u4e2a\u5bb9\u91cf\u4e3a W \u7684\u80cc\u5305\uff0c\u6709\u4e24\u79cd\u4e0d\u540c\u7684\u8981\u6c42\uff1a\uff081\uff09\u80cc\u5305\u8981\u88ab\u88c5\u6ee1\u548c\uff082\uff09\u80cc\u5305\u53ef\u4ee5\u4e0d\u6ee1\u3002\u8fd9\u4e24\u79cd\u7684\u521d\u59cb\u5316\u662f\u4e0d\u540c\u7684\u3002 \u5bf9\u4e8e\uff081\uff09\uff0cdp[ 0 ] \u88ab\u8bbe\u7f6e\u4e3a 0\uff0cdp[1 : W] \u88ab\u8bbe\u7f6e\u4e3a -\\infty -\\infty \uff1b\u5bf9\u4e8e\uff082\uff09\uff0cdp[0 : W] \u90fd\u4e3a 0\u3002\u53ef\u4ee5\u8fd9\u6837\u7406\u89e3\uff0c\u6761\u4ef6\uff081\uff09\u8981\u6c42\u80cc\u5305\u88c5\u6ee1\uff0c\u90a3\u4e48 W = 0 \u662f\u6ee1\u8db3\u7684\uff0c\u56e0\u4e3a\u7a7a\u80cc\u5305\u7684\u5bb9\u91cf\u5c31\u662f 0\uff0c\u4f46\u662f\u4e00\u65e6\u80cc\u5305\u7684\u5bb9\u91cf\u4e0d\u662f 0\uff0c\u90a3\u4e48\u672a\u88c5\u4efb\u4f55\u7269\u54c1\uff08\u7a7a\u8f7d\uff09\u662f\u4e0d\u7b26\u5408\u80cc\u5305\u88c5\u6ee1\u7684\u8981\u6c42\uff0c -\\infty -\\infty \u8868\u793a\u65e0\u5408\u6cd5\u7684\u89e3\uff1b\u53cd\u89c2\u6761\u4ef6\uff082\uff09\uff0c\u7a7a\u8f7d\u5bf9\u4e8e\u4efb\u610f\u7684 W \u90fd\u662f\u4e00\u4e2a\u5408\u6cd5\u89e3\uff0c\u56e0\u6b64\u7a7a\u8f7d\u80cc\u5305\u7684\u4ef7\u503c\u5c31\u662f 0\u3002 \u8fd9\u91cc\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0cv = [4, 3, 7, 5]\uff0cw = [2, 3, 5, 7]\uff0cW = 9\u3002\u5982\u679c\u8981\u6c42\u88c5\u6ee1\u80cc\u5305\uff0c\u7ed3\u679c\u662f 9\uff1b\u53cd\u4e4b\u662f 11\u3002","title":"01 \u80cc\u5305"},{"location":"algo/dp/knapsack/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4, \u5982 nums = [1, 1, 1, 1, 1] \u548c\u4e00\u4e2a\u76ee\u6807\u503c target = 3\u3002\u5bf9\u4e8e\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u524d\u65b9\u653e\u7f6e\u4e00\u4e2a\u8fd0\u7b97\u7b26 + \u6216\u8005 - \u6765\u6784\u6210\u4e00\u4e2a\u8ba1\u7b97\u8868\u8fbe\u5f0f\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\u7ed3\u679c\u6070\u597d\u4e3a target \u7684\u4e2a\u6570\u4e3a\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u9898\u610f\u53ef\u4ee5\u88ab\u89e3\u91ca\u4e3a\uff0c\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u7ec4\uff0c\u5176\u4e2d\u4e00\u7ec4\u5168\u90e8\u4e3a\u6807\u5fd7\u4e3a\u6b63\u6570\uff0c\u53e6\u4e00\u7ec4\u6807\u5fd7\u4e3a\u8d1f\u6570\uff0c\u8fd9\u6837\u6c42\u548c\u7ed3\u679c\u4e3a target\u3002\u672c\u9898\u662f 01 \u80cc\u5305\u95ee\u9898\u6c42\u65b9\u6848\u6570\u95ee\u9898\u3002\u5047\u8bbe\u6570\u7ec4\u548c\u4e3a sum\uff0c\u6b63\u6570\u7ec4\u7684\u548c\u4e3a pos\uff0c\u8d1f\u6570\u7ec4\u7684\u548c\u4e3a neg\uff08\u7edd\u5bf9\u503c\uff09\uff0c\u53ef\u4ee5\u5f97\u5230\u5982\u4e0b\u5173\u7cfb \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \u6240\u4ee5\uff0csum \u5fc5\u987b\u4e0d\u5c0f\u4e8e target\uff0c\u5e76\u4e14 sum - targte \u5fc5\u987b\u662f\u5076\u6570\u3002 \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5230\u6700\u540e\u4e00\u4e2a\u6570\u4e2d\u6c42\u548c\u7b49\u4e8e j \u7684\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u5173\u6ce8\u8fb9\u754c\u6761\u4ef6\uff1a\u5982\u679c j = 0\uff0c\u5373\u8d1f\u6570\u548c\u7684\u7edd\u5bf9\u503c\u4e3a 0\uff0c\u8868\u660e\u6211\u4eec\u5e94\u8be5\u4e0d\u9009\u53d6\u4efb\u4f55\u5143\u7d20\uff0c\u56e0\u6b64 dp[ i ][ 0 ] = 1\uff0c\u8fd9\u91cc i \u4ece 0 \u5230 n - 1\u3002\u5f53 i == n\uff0c\u5373\u5f53\u524d\u6570\u7ec4\u6ca1\u6709\u5143\u7d20\uff0c\u53ea\u6709 j == 0 \u65f6\uff0c\u65b9\u6848\u6570\u76ee\u624d\u4e3a 1\u3002\u5982\u679c\u4ece\u540e\u5411\u524d\u9012\u63a8\uff0c\u6700\u7ec8\u7684\u7b54\u6848\u662f dp[ 0 ][ target ]\u3002\u4f18\u5316\u540e\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u662f\u7ebf\u6027\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int findTargetSumWays ( vector < int >& nums , int target ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( target > sum || ( sum - target ) % 2 != 0 ) { return 0 ; } int neg = ( sum - target ) >> 1 ; vector < int > dp ( neg + 1 , 0 ); dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int j = neg ; j >= num ; j -- ) { dp [ j ] += dp [ j - num ]; } } return dp [ neg ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(target \\times n) O(target \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(target) O(target) \uff0c\u8fd9\u91cc target \u662f\u76ee\u6807\u503c\u5927\u5c0f\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002","title":"\u76ee\u6807\u548c"},{"location":"algo/dp/knapsack/#_2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6784\u6210\u7684\u6570\u7ec4\uff0c\u5982 nums = [1, 5, 11, 5]\uff0c\u5224\u65ad\u80fd\u5426\u5c06\u6b64\u6570\u7ec4\u5206\u5272\u6210\u4e24\u4e2a\u6570\u7ec4\uff08\u4e0d\u8981\u6c42\u8fde\u7eed\uff09\uff0c\u4f7f\u4e24\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u76f8\u7b49\u3002\u7ed9\u51fa\u7684\u4f8b\u5b50\u53ef\u4ee5\u88ab\u5206\u6210 [1, 5, 5] \u548c [ 11 ] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u6211\u4eec\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u4e2a\u90e8\u5206\uff0c\u53ef\u4ee5\u7406\u89e3\u6210\u9009\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u5176\u548c\u662f\u539f\u6570\u7ec4\u548c\u7684\u4e00\u534a\u3002\u56e0\u6b64\uff0c\u53ef\u4ee5\u5c06\u6b64\u9898\u8f6c\u6362\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\u503c\uff0c\u5176\u548c\u662f\u5426\u7b49\u4e8e j\u3002\u5982\u679c\u539f\u6570\u7ec4\u7684\u548c sum \u662f\u5947\u6570\uff0c\u90a3\u4e48\u76f4\u63a5\u8fd4\u56de false\uff0c\u56e0\u4e3a\u4e24\u4e2a\u76f8\u7b49\u6570\u7684\u548c\u4e00\u5b9a\u662f\u5076\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u5f53 j == 0 \u65f6\uff0c\u8bf4\u660e\u4e24\u4e2a\u6570\u7ec4\u5747\u4e3a\u7a7a\uff0c\u90a3\u4e48\u6574\u4e2a\u6570\u7ec4\u5e94\u8be5\u4e3a\u7a7a\uff0c\u5bf9\u5e94\u7684 i == n \uff08\u4ece\u540e\u5f80\u524d\u9012\u63a8\uff09\u3002\u6700\u540e\u7684\u7b54\u6848\u5e94\u8be5\u4e3a dp[ 0 ][ sum / 2 ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool canPartition ( vector < int >& nums ) { int n = ( int ) nums . size (), sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; vector < vector < bool >> dp ( n + 1 , vector < bool > ( sum + 1 , 0 )); dp [ n ][ 0 ] = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= sum ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= nums [ i ]) { dp [ i ][ j ] = dp [ i ][ j ] || dp [ i + 1 ][ j - nums [ i ]]; } } } return dp [ 0 ][ sum ]; } \u7a7a\u95f4\u4f18\u5316\u540e\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool canPartition ( vector < int >& nums ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; bool * dp = new bool [ sum + 1 ]{}; dp [ 0 ] = true ; for ( int num : nums ) { for ( int j = sum ; j >= num ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - num ]; } } return dp [ sum ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(sum \\times n) O(sum \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(sum) O(sum) \uff0c\u8fd9\u91cc sum \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002","title":"\u5206\u5272\u7b49\u548c\u5b50\u96c6"},{"location":"algo/dp/knapsack/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 stones = [2, 7, 4, 1, 8, 1] \u8868\u793a\u4e00\u7ec4\u77f3\u5934\u7684\u91cd\u91cf\u3002\u4ece\u5f53\u524d\u7684\u77f3\u5934\u91cc\u4efb\u53d6\u4e24\u4e2a\uff0c\u8d28\u91cf\u662f x \u548c y\uff0c\u5982\u679c\u4e24\u5757\u8d28\u91cf\u76f8\u7b49\u5373 x = y\uff0c\u90a3\u4e48\u8fd9\u4e24\u5757\u77f3\u5934\u88ab\u79fb\u9664\uff1b\u53cd\u4e4b\uff0c\u79fb\u9664\u8f83\u5c0f\u7684\u90a3\u4e00\u5757\uff0c\u5e76\u4e14\u8f83\u5927\u7684\u90a3\u4e00\u5757\u53d8\u6210\u8fd9\u4e24\u5757\u8d28\u91cf\u7684\u5dee\u503c\uff08\u7edd\u5bf9\u503c\uff09\u3002\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u76f4\u5230\u5269\u4f59\u4e00\u5757\u6216\u8005\u65e0\u5269\u4f59\uff0c\u6c42\u5269\u4f59\u7684\u6700\u5c0f\u8d28\u91cf\u662f\u591a\u5c11\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u53ef\u4ee5\u539f\u6570\u7ec4\u5206\u5272\u6210\u4e24\u7ec4 + \u548c -\uff0c\u6211\u4eec\u7528 + \u8fd9\u4e00\u7ec4\u51cf\u53bb - \u8fd9\u4e00\u7ec4\uff0c\u6240\u5f97\u7ed3\u679c\u7684\u6700\u5c0f\u503c\u662f\u6700\u7ec8\u7ed3\u679c\uff0c\u8fd9\u6837\u95ee\u9898\u8f6c\u5316\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe neg \u4e3a - \u8fd9\u4e00\u7ec4\u7684\u548c\uff0cpos \u4e3a + \u8fd9\u4e00\u7ec4\u7684\u548c\u3002\u6ee1\u8db3\u4e0b\u5217\u65b9\u7a0b\u7ec4 \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u6210\uff0c\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u503c\uff0c\u5176\u548c\u7b49\u4e8e neg\uff0c\u5e76\u4e14\u4f7f\u5f97 \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5b57\u5230\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\uff0c\u5b83\u4eec\u7684\u548c\u5728\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u503c\u662f\u591a\u5c11\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 int lastStoneWeightII ( vector < int >& stones ) { int sum = 0 ; for ( int stone : stones ) { sum += stone ; } int tar = ( sum >> 1 ); vector < int > dp ( tar + 1 , 0 ); for ( int stone : stones ) { for ( int j = tar ; j >= stone ; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - stone ] + stone ); } } return sum - 2 * dp [ tar ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(tar \\times n) O(tar \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(tar) O(tar) \uff0c\u8fd9\u91cc tar \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002","title":"\u6700\u540e\u4e00\u5757\u77f3\u5934\u7684\u91cd\u91cf"},{"location":"algo/dp/knapsack/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 n \u4ee3\u8868\u4eba\u6570\uff0cminProfit \u4ee3\u8868\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u4e00\u4e32\u5de5\u4f5c\u9700\u8981\u7684\u4eba\u6570 group = [2, 2]\uff0c\u6bcf\u9879\u5de5\u4f5c\u5bf9\u5e94\u7684\u5229\u6da6 profit = [2, 3]\u3002\u8981\u6c42\u5b9e\u73b0\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u5e76\u4e14\u6295\u5165\u7684\u4eba\u6570\u548c\u4e0d\u80fd\u8d85\u8fc7 n\uff0c\u8fd9\u6837\u7684\u5206\u914d\u65b9\u6848\u6570\u76ee\u6709\u591a\u5c11\u4e2a\uff1f \u300c\u5206\u6790\u300d \u5728 01 \u80cc\u5305\u95ee\u9898\u7684\u57fa\u7840\u4e0a\uff0c\u672c\u9898\u589e\u52a0\u4e86\u6700\u4f4e\u76c8\u5229\u989d\u7684\u9650\u5236\u3002\u8bbe dp[ i ][ j ][ k ] \u4e3a\u4ece i \u5f00\u59cb\u7684\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u4e9b\u5de5\u4f5c\u6295\u5165\u4eba\u529b\uff0c\u5728\u6070\u597d j \u4e2a\u4eba\u4e14\u76c8\u5229\u989d\u4e0d\u4f4e\u4e8e k \u7684\u60c5\u51b5\u4e0b\uff0c\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \u8fb9\u754c\u6761\u4ef6 dp[ len ][ 0 ][ 0 ] = 1\uff0c\u8868\u660e\u4e0d\u9009\u4efb\u4f55\u5de5\u4f5c\u65f6\uff0c\u6295\u5165\u7684\u4eba\u6570\u662f 0\uff0c\u6700\u4f4e\u7684\u76c8\u5229\u989d\u4e5f\u662f 0\uff0c\u6b64\u65f6\u4e5f\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\u4e00\u79cd\u65b9\u6848\u3002\u8fdb\u4e00\u6b65\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c\u5f53 k = 0 \u5373\u6700\u4f4e\u76c8\u5229\u989d\u4e3a 0\uff0c\u90a3\u4e48\u4e0d\u8bba i \u548c j \u4e3a\u4f55\u503c\uff0cdp[ i ][ j ][ 0 ] \u5747\u4e3a 1\u3002 \\text{k - profit[ i ]} \\text{k - profit[ i ]} \u4e3a\u8d1f\u6570\uff0c\u8bf4\u660e\u7b2c i \u4e2a\u5de5\u4f5c\u7684\u5229\u6da6\u672c\u8eab\u5c31\u8d85\u8fc7 minProfit\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728\u9009\u62e9\u7b2c i \u4e2a\u5de5\u4f5c\u524d\uff0c\u6700\u4f4e\u76c8\u5229\u53ef\u4ee5\u4e3a 0\uff0c\u8fd9\u4e2a\u65f6\u5019\u53ea\u8981\u6295\u5165\u7684\u4eba\u6570\u4e0d\u8d85\u8fc7 j - group[ i ]\uff0c\u90fd\u88ab\u89c6\u4e3a\u6ee1\u8db3\u8981\u6c42\u7684\u65b9\u6848\u3002\u76f8\u53cd\uff0c\u5982\u679c\u6211\u4eec\u7ea6\u675f \\text{k} \\geq \\text{profit[ i ]} \\text{k} \\geq \\text{profit[ i ]} \uff0c\u6211\u4eec\u6700\u7ec8\u5f97\u5230\u7684\u7ed3\u679c\u662f \u6070\u597d\u7b49\u4e8e minProfit \u7684\u65b9\u6848\u6570\uff0c\u56e0\u4e3a k - profit[ i ] \u53ea\u4f1a\u8f6c\u79fb\u5230\u7b2c\u4e09\u7ef4\u6210\u4e3a 0 \u7684\u72b6\u6001\u3002 \u6700\u7ec8\u7684\u7b54\u6848\u662f\u8003\u5bdf\u6240\u6709\u7684\u5de5\u4f5c\u4e14\u6ee1\u8db3\u6700\u4f4e\u76c8\u5229\u989d\u7684\u6761\u4ef6\u4e0b\uff0c\u5bf9\u6295\u5165\u7684\u4eba\u6570\u904d\u5386 \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); dp [ 0 ][ 0 ] = 1 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = 0 ; k <= minProfit ; k ++ ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } int ans = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { ans += dp [ j ][ minProfit ]; ans %= MOD ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(len \\times n \\times minProfit) O(len \\times n \\times minProfit) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n \\times minProfit) O(n \\times minProfit) \uff0c\u8fd9\u91cc len \u662f\u5de5\u4f5c\u7684\u4e2a\u6570 / \u5229\u6da6\u6570\u7ec4\u7684\u957f\u5ea6\uff0cn \u662f\u603b\u4eba\u6570\uff0cminProfit \u662f\u6700\u4f4e\u76c8\u5229\u989d\u3002 \u8fd9\u4e2a\u9898\u76ee\u4e5f\u53ef\u4ee5\u5b9a\u4e49\u6210 dp[ i ][ j ][ k ] \u4ece\u7b2c i \u4e2a\u5de5\u4f5c\u5230\u6700\u540e\u4e00\u4e2a\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\uff0c\u5728\u6295\u5165\u4e0d\u8d85\u8fc7 j \u4e2a\u4eba\u4e14\u5229\u6da6\u4e0d\u4f4e\u4e8e k \u7684\u6761\u4ef6\u4e0b\u7684\u65b9\u6848\u6570\u76ee\u3002\u5bf9\u5e94\u7684\u521d\u59cb\u5316\u5e94\u8be5\u6539\u6210 dp[ i ][ j ][ 0 ] = 1\uff0c\u6700\u540e\u7684\u7ed3\u679c\u662f dp[ 0 ][ n ][ minProfit ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); for ( int j = 0 ; j <= n ; j ++ ) { dp [ j ][ 0 ] = 1 ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = minProfit ; k >= 0 ; k -- ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } return dp [ n ][ minProfit ]; }","title":"\u76c8\u5229\u8ba1\u5212"},{"location":"algo/dp/knapsack/#_5","text":"\u7ed9\u5b9a\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums\u3002\u6211\u4eec\u8981\u5c06 nums \u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u79fb\u52a8\u5230 A \u6570\u7ec4 \u6216\u8005 B \u6570\u7ec4\u4e2d\uff0c\u4f7f\u5f97 A \u6570\u7ec4\u548c B \u6570\u7ec4\u4e0d\u4e3a\u7a7a\uff0c\u5e76\u4e14 average(A) == average(B) \u3002\u5982\u679c\u53ef\u4ee5\u5b8c\u6210\u5219\u8fd4\u56detrue \uff0c \u5426\u5219\u8fd4\u56de false \u3002\u4f8b\u5982\uff0c nums = [1,2,3,4,5,6,7,8]\uff0c\u8fd4\u56de true\uff1bnums = [3,1]\uff0c\u8fd4\u56de false\u3002nums \u7684\u957f\u5ea6\u4e0d\u8d85\u8fc730\u3002 \u300c\u5206\u6790\u300d \u5047\u8bbenums\u53ef\u4ee5\u88ab\u5206\u6210\u4e24\u4e2a\u6570\u7ec4\uff0c\u90a3\u4e48\u4e24\u4e2a\u5b57\u6570\u7ec4\u7684\u5747\u503c\u548cnums\u7684\u5747\u503c\u662f\u4e00\u6837\u7684 \\frac{S_{A}}{n_{A}} = \\frac{S_{B}}{n_{B}} = \\frac{S}{n} = \\text{avg} \\frac{S_{A}}{n_{A}} = \\frac{S_{B}}{n_{B}} = \\frac{S}{n} = \\text{avg} \u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u63d0\u524d\u68c0\u67e5\uff0c\u662f\u5426\u5b58\u5728 {n_{A}} {n_{A}} \u80fd\u591f\u6ee1\u8db3\u4e0a\u5f0f\u3002\u4e4b\u540e\u5c31\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u5316\u4e3a0-1\u80cc\u5305\u95ee\u9898\uff0cdp[ i ][ j ][ k ] \u8868\u793a\u524d i \u4e2a\u5143\u7d20\u4e2d\uff0c\u9009\u62e9 j \u4e2a\u6570\u5b57\uff0c\u5176\u548c\u662f\u5426\u7b49\u4e8e k\u3002\u540c\u65f6\u9700\u8981\u68c0\u67e5 j * sum \u662f\u5426\u7b49\u4e8e k * n\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool splitArraySameAverage ( vector < int >& nums ) { int sum = 0 , n = ( int ) nums . size (), m = n / 2 ; int min_val = INT_MAX ; for ( int num : nums ) { sum += num ; min_val = min ( min_val , num ); } bool check = false ; for ( int i = 1 ; i <= m ; i ++ ) { if ( sum * i % n == 0 ) { check = true ; break ; } } if ( ! check ) { return false ; } vector < unordered_set < int >> dp ( m + 1 ); dp [ 0 ]. emplace ( 0 ); for ( int num : nums ) { for ( int j = m ; j >= 1 ; j -- ) { for ( int x : dp [ j - 1 ]) { int cur = x + num ; if ( cur * n == sum * j ) { return true ; } dp [ j ]. emplace ( cur ); } } } return false ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO( n^{2}\\sum\\text{nums} n^{2}\\sum\\text{nums} )\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO( n\\sum\\text{nums} n\\sum\\text{nums} )\u3002","title":"\u6570\u7ec4\u7684\u5747\u503c\u5206\u5272"},{"location":"algo/dp/knapsack/#_6","text":"\u4e00\u4e2a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u662f W\uff0c\u6709 N \u79cd\u7269\u54c1\uff0c\u6bcf\u4e00\u4ef6\u6709\u81ea\u5df1\u7684\u4ef7\u503c v_{i} v_{i} \u548c \u91cd\u91cf w_{i} w_{i} \uff0c\u6bcf\u4e00\u79cd\u7c7b\u7684\u7269\u54c1\u65e0\u9650\u4f9b\u5e94\uff0c\u8bd5\u95ee\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u603b\u91cf\u4e0b\uff0c\u80cc\u5305\u7684\u4ef7\u503c\u6700\u5927\u3002 \u300c\u5206\u6790\u300d \u5b8c\u5168\u80cc\u5305\u95ee\u9898\u79cd\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u7684\u4f9b\u5e94\u662f\u65e0\u9650\u7684\uff0c\u4f46\u56e0\u4e3a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u6709\u9650\uff0c\u53ef\u4ee5\u653e\u5165\u7684\u6570\u76ee\u4f9d\u7136\u6709\u9650 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} \uff0c\u90a3\u4e48\u6211\u4eec\u4f9d\u7136\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u4e2d\u9009\u53d6\u82e5\u5e72\u4ef6\uff0c\u5728\u91cd\u91cf\u548c\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u4ef7\u503c\u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \u5728 01 \u80cc\u5305\u95ee\u9898\u4e2d\uff0cdp[ i ][ j ] \u662f\u7531 dp[i + 1][j - w[ i ]] + v[ i ] \u8f6c\u79fb\u800c\u6765\uff0c\u8868\u8fbe\u4e86\u9996\u6b21\u5c06\u7b2c i \u4ef6\u7269\u54c1\u52a0\u5165\u5230\u80cc\u5305\u4e2d\u3002\u4f46\u662f\u5728\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u91cc\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u662f\u53ef\u4ee5\u591a\u6b21\u653e\u5165\u7684\uff0c\u90a3\u4e48 dp[ i ][j - w[ i ]] + v[ i ] \u5c31\u5df2\u7ecf\u5305\u542b\u4e86 dp[i + 1][j - w[ i ]] + v[ i ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < vector < int >> dp ( n + 1 , vector < int > ( W + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= W ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= w [ i ]) { dp [ i ][ j ] = max ( dp [ i ][ j ], max ( dp [ i + 1 ][ j - w [ i ]], dp [ i ][ j - w [ i ]]) + v [ i ]); } } } return dp [ 0 ][ W ]; } \u7a7a\u95f4\u4e0a\u8fdb\u884c\u4f18\u5316 \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) 1 2 3 4 5 6 7 8 9 10 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = w [ i ]; j <= W ; j ++ ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u8fd9\u91cc\u4e0e 01 \u80cc\u5305\u7684\u4ee3\u7801\u53ea\u6709\u4e00\u884c\u4e0d\u540c\uff0c\u5373 j \u7684\u904d\u5386\u65b9\u5411\u4e0a\u3002\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u662f\u6709\u5c0f\u5230\u5927\u904d\u5386\uff0c\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ef\u4ee5\u88ab\u591a\u6b21\u653e\u5165\uff1b\u53cd\u800c 01 \u80cc\u5305\u95ee\u9898\u5bf9\u4efb\u4e00\u4ef6\u7269\u54c1\u6700\u591a\u53ea\u5141\u8bb8\u653e\u5165\u4e00\u6b21\u3002","title":"\u5b8c\u5168\u80cc\u5305"},{"location":"algo/dp/knapsack/#i","text":"\u7ed9\u5b9a\u4e00\u7ec4\u786c\u5e01\u7684\u9762\u503c coins = [186, 419, 83, 408] \u548c\u4e00\u4e2a\u603b\u91cf amount = 6249\uff0c\u8bd5\u95ee\u7528\u6700\u5c11\u7684\u786c\u5e01\u4e2a\u6570\u53ef\u4ee5\u7ec4\u6210\u8fd9\u4e2a amount\u3002\u5982\u679c\u4e0d\u80fd\u627e\u5230\u96f6\u94b1\u7ec4\u5408\uff0c\u8fd4\u56de -1\u3002 \u300c\u5206\u6790\u300d \u672c\u9898\u53ef\u4ee5\u88ab\u7406\u89e3\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u6bcf\u4e00\u679a\u786c\u5e01\u7684\u4ef7\u503c\u4e3a 1\uff0c\u6c42\u6700\u5c0f\u7684\u4ef7\u503c\u3002\u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u6784\u6210 j \u6570\u989d\u7684\u6700\u5c11\u786c\u5e01\u4e2a\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \u56e0\u4e3a\u6c42\u89e3\u7684\u662f\u6700\u5c0f\u4e2a\u6570\uff0c\u90a3\u4e48\u6570\u7ec4\u521d\u59cb\u5316\u6210\u6700\u5927\u503c\uff0c\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528 amount + 1 \u4f5c\u4e3a\u6700\u5927\u503c\uff0c\u56e0\u4e3a\uff0c\u6700\u5c0f\u7684\u96f6\u94b1\u662f 1\u3002\u90a3\u4e48\u6700\u591a\u7684\u786c\u5e01\u4e2a\u6570\u4e5f\u4e0d\u4f1a\u8d85\u8fc7 amount\u3002\u5f53 anount = 0 \u65f6\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u786c\u5e01\uff0c\u5373 0\u3002 1 2 3 4 5 6 7 8 9 10 int coinChange ( vector < int >& coins , int amount ) { vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - coin ] + 1 ); } } return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002","title":"\u6362\u96f6\u94b1 I"},{"location":"algo/dp/knapsack/#ii","text":"\u540c\u4e0a\u9898\u80cc\u666f\uff0c\u6c42\u80fd\u591f\u7ec4\u5408\u51fa\u7ed9\u5b9a\u91d1\u989d\u7684\u96f6\u94b1\u65b9\u6848\u6570\u76ee \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u7ec4\u6210\u91d1\u989d\u662f j \u7684\u65b9\u6848\u6570\u76ee \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 int coinChange ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] += dp [ j - coin ]; } } return dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\text{n} \\times \\text{amount}) O(\\text{n} \\times \\text{amount}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\text{amount}) O(\\text{amount}) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002","title":"\u6362\u96f6\u94b1 II"},{"location":"algo/dp/knapsack/#iii","text":"\u540c\u4e0a\u9898\u80cc\u666f\uff0c\u4f9d\u7136\u6c42\u65b9\u6848\u6570\u76ee\uff0c\u4f46\u8981\u6c42\u786c\u5e01\u5177\u6709\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982 coins = [1, 2, 3]\uff0c\u7ec4\u6210 amount = 3 \u7684\u65b9\u6848\u6709 [1, 1, 1]\uff0c[1, 2]\uff0c[2, 1]\uff0c[ 3 ] 4 \u79cd\uff0c\u6ce8\u610f\u5230 [1, 2] \u548c [2, 1] \u662f\u4e0d\u4e00\u6837\u7684\u65b9\u6848\u3002 \u300c\u5206\u6790\u300d \u540c\u4e0a\u9898\uff0c\u8bbe dp[ j ] \u4e3a \u91d1\u989d\u4e3a j \u7684\u65b9\u6848\u6570\u76ee\u3002\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u4e24\u5c42\u5faa\u73af\u7684\u4f4d\u7f6e\u3002 \u7269\u54c1\u5faa\u73af\u5728\u5916\u4fa7\uff0c\u6570\u91cf\u5faa\u73af\u5728\u5185\u6d4b\u65f6\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u7ec4\u5408\u60c5\u51b5\uff1b\u53cd\u4e4b\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u6392\u5217\u60c5\u51b5 1 2 3 4 5 6 7 8 9 10 11 12 int combinationSum41 ( vector < int >& coins , int amount ) { vector < unsigned int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int i = 0 ; i <= amount ; i ++ ) { for ( int coin : coins ) { if ( i >= coin ) { dp [ i ] += dp [ i - coin ]; } } } return dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002","title":"\u6362\u96f6\u94b1 III"},{"location":"algo/dp/knapsack/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6570 n = 13\uff0c\u5b83\u53ef\u4ee5\u7531\u82e5\u5e72\u4e2a\u5e73\u65b9\u6570\u76f8\u52a0\u800c\u5f97\uff0c\u8fd4\u56de\u8fd9\u4e9b\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u7684\u6700\u5c0f\u503c\u300213 = 4 + 9\uff0c\u5373\u6700\u5c0f\u503c\u4e3a 2. \u300c\u5206\u6790\u300d \u65b9\u6cd5 1\uff1a\u8f6c\u5316\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u7edf\u8ba1 1 - n \u4e4b\u95f4\u6240\u6709\u7684\u5e73\u65b9\u6570\uff0c\u4e4b\u540e\u6309\u7167\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u89e3\u6cd5\u6c42\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int numSquares ( int n ) { if ( n <= 0 ) { return 0 ; } vector < int > square ; for ( int i = 1 ; i <= n ; i ++ ) { int root = ( int ) sqrt ( i ); if ( root * root == i ) { square . emplace_back ( i ); } } vector < int > dp ( n + 1 , n + 1 ); dp [ 0 ] = 0 ; for ( int s : square ) { for ( int j = s ; j <= n ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - s ] + 1 ); } } return dp [ n ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\sqrt{n}) O(n \\sqrt{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002 \u65b9\u6cd5 2\uff1a\u8bbe dp[ i ] \u4e3a\u6784\u6210 i \u7684\u6700\u5c0f\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u3002 \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int numSquares ( int n ) { if ( n < 1 ) { return 0 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i <= n ) { dp [ i * i ] = 1 ; } if ( dp [ i ]) { continue ; } int min = INT_MAX ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( min > dp [ j ] + dp [ i - j ]) { min = dp [ j ] + dp [ i - j ]; } } dp [ i ] = min ; } int ans = dp [ n ]; delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002","title":"\u5e73\u65b9\u6570\u7684\u6700\u5c0f\u4e2a\u6570"},{"location":"algo/dp/lcs/","text":"\u5b50\u5e8f\u5217\u8fde\u7eed \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u5e8f\u5217\uff08\u6570\u7ec4\u6216\u5b57\u7b26\u4e32\uff09A = [1, 2, 3, 2, 1]\uff0c B = [3, 2, 1, 4, 7]\uff0c\u90a3\u4e48\u8fd9\u4e24\u8005\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u662f[3, 2, 1]\uff0c\u957f\u5ea6\u4e3a3 \u8bbedp[i][j]\u4e3aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4e5f\u5c31\u662f\u72b6\u6001\uff0c\u4e00\u5171n*m\u4e2a\u3002\u56e0\u4e3a\u8981\u6c42\u5b50\u6570\u7ec4\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u5f53\u524d\u72b6\u6001\u53ea\u4f1a\u4e0e\u4e0b\u4e00\u4e2a\uff08\u6216\u4e0a\u4e00\u4e2a\uff09\u72b6\u6001\u76f8\u5173\uff0c\u7531\u6b64\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002 \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \u5728\u72b6\u6001\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u8bb0\u5f55\u6700\u5927\u957f\u5ea6\u7684\u5927\u5c0f\u4ee5\u53ca\u6700\u5927\u957f\u5ea6\u7684\u4f4d\u7f6e\uff0c\u6700\u7ec8\u53ef\u8f93\u51fa\u6700\u957f\u5b50\u6570\u7ec4\u3002 \u6700\u957f\u516c\u5171\u5b50\u4e32 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2,\u8f93\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\uff0c\u4f8b\u5982\uff0c\"1AB2345CD\",\"12345EF\"\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\u662f\"2345\"\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : /** * longest common substring * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @return string\u5b57\u7b26\u4e32 */ string LCS ( string str1 , string str2 ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); int len = 1 , pos = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( str1 [ i ] == str2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; if ( len < dp [ i ][ j ]) { len = dp [ i ][ j ]; pos = i ; } } } } return str1 . substr ( pos , len ); } }; \u5b50\u5e8f\u5217\u4e0d\u8fde\u7eed \u00b6 \u5f53\u5b50\u5e8f\u5217\u4e0d\u8981\u6c42\u8fde\u7eed\u65f6\uff0c\u4f9d\u7136\u53ef\u4ee5\u7528dp[i][j]\u8868\u793aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4f46\u662f\u72b6\u6001\u7684\u8f6c\u79fb\u65b9\u7a0b\u53d1\u751f\u6539\u53d8 \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \u5982\u679c\u8981\u6c42\u8f93\u51fa\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u5219\u9700\u8981\u91cd\u65b0\u626b\u9762\u4e00\u904d\u4e24\u4e2a\u5e8f\u5217 1 2 3 4 5 6 7 8 int m = ( int ) A . length (), n = ( int ) B . length (), i = 0 , j = 0 ; while ( i < m && j < n ) { if ( A [ i ] == B [ j ]) { printf ( ' % c ' , A [ i ]); } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u8f93\u51fa\u8fde\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u8fc7\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <iostream> #include <string> #include <vector> using namespace std ; string LCS ( string s1 , string s2 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); string ans = \"\" ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( s1 [ i ] == s2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); } } } int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( s1 [ i ] == s2 [ j ]) { ans . push_back ( s1 [ i ]); i ++ ; j ++ ; } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } return dp [ 0 ][ 0 ] ? ans : \"-1\" ; } int main ( int argc , const char * argv []) { // insert code here... string s1 = \"1A2C3D4B56\" , s2 = \"B1D23CA45B6A\" ; cin >> s1 >> s2 ; printf ( \"%s \\n \" , LCS ( s1 , s2 ). c_str ()); return 0 ; } \u4ea4\u9519\u5b57\u7b26 \u00b6 \u7ed9\u5b9a\u4e09\u4e2a\u5b57\u7b26\u4e32 s1 = \u201caabcc\u201d\uff0c s2 = \u201cdbbca\u201d\u3002s3 = \u201caadbbcbcac\u201d\uff0c\u5224\u65ad s3 \u662f\u5426\u7531 s1 \u548c s2 \u4ea4\u9519\u5f62\u6210\uff0c\u5373 s1 \u548c s2 \u662f s3 \u7684\u5b50\u5e8f\u5217\u4e14\u65e0\u91cd\u53e0\u3002 \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u5982\u679c\u4f7f\u7528\u3010\u53cc\u6307\u9488\u3011\u6c42\u89e3\u672c\u9898\u7684\u8bdd\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u9519\u8bef\u7ed3\u679c\uff0c\u56e0\u4e3a\uff0c\u3010\u53cc\u6307\u9488\u3011\u4f1a\u8d2a\u5fc3\u5730\u627e\u5230\u6700\u5148\u9047\u5230\u7684\u76f8\u540c\u5b57\u7b26\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u672c\u95ee\u9898\u7684\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff0c\u6240\u6709\u4f7f\u7528\u3010\u52a8\u6001\u89c4\u5212\u3011\u3002\u8bbe dp[ i ][ j ] \u8868\u793a s1 \u7684\u524d i \u4e2a\u5b57\u7b26\u4e0e s2 \u7684\u524d j \u4e2a\u5b57\u7b26\u662f\u5426\u5f62\u6210 s3 \u7684\u524d i + j \u4e2a\u5b57\u7b26\u3002 \\begin{aligned} \\text{dp[ i ][ j ]} =& (\\text{dp[i - 1][ j ] and s1[ i ] == s3[i + j]}) \\\\ & \\text{or } (\\text{dp[ i ][j - 1] and s2[ j ] == s3[i + j]}) \\end{aligned} \\begin{aligned} \\text{dp[ i ][ j ]} =& (\\text{dp[i - 1][ j ] and s1[ i ] == s3[i + j]}) \\\\ & \\text{or } (\\text{dp[ i ][j - 1] and s2[ j ] == s3[i + j]}) \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool isInterleave ( string s1 , string s2 , string s3 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (), n3 = ( int ) s3 . length (); if ( n1 + n2 != n3 ) { return false ; } bool ** dp = new bool * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new bool [ n2 + 1 ]{}; } dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i > 0 ) { dp [ i ][ j ] |= dp [ i - 1 ][ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; } if ( j > 0 ) { dp [ i ][ j ] |= dp [ i ][ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; } } } bool ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n_{1} n_{2}) O(n_{1} n_{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n_{1} n_{2}) O(n_{1} n_{2}) \u6700\u957f\u56de\u6587\u5b50\u5e8f\u5217 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \uff0c\u627e\u51fa\u5176\u4e2d\u6700\u957f\u7684\u56de\u6587\u5b50\u5e8f\u5217\uff0c\u5e76\u8fd4\u56de\u8be5\u5e8f\u5217\u7684\u957f\u5ea6\u3002\u5b50\u5e8f\u5217\u5b9a\u4e49\u4e3a\uff1a\u4e0d\u6539\u53d8\u5269\u4f59\u5b57\u7b26\u987a\u5e8f\u7684\u60c5\u51b5\u4e0b\uff0c\u5220\u9664\u67d0\u4e9b\u5b57\u7b26\u6216\u8005\u4e0d\u5220\u9664\u4efb\u4f55\u5b57\u7b26\u5f62\u6210\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u4f8b\u5982\uff0cs = \"bbbab\" \u7684\u6700\u957f\u56de\u6587\u5b50\u5e8f\u5217\u662f \"bbbb\"\uff0c\u8fd4\u56de 4\u3002 \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u5c06 s \u53d6\u53cd\u5f97\u5230 t\uff0c\u95ee\u9898\u8f6c\u5316\u4e3a\u6c42 s \u548c t \u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int longestPalindromeSubseq ( string s ) { if ( s . empty ()) { return 0 ; } vector < vector < int >> dp ( s . length () + 1 , vector < int > ( s . length () + 1 , 0 )); string t ( s . begin (), s . end ()); reverse ( t . begin (), t . end ()); for ( int i = 1 ; i <= s . length (); i ++ ) { for ( int j = 1 ; j <= t . length (); j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); } } } return dp [ s . length ()][ t . length ()]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0cn \u662f\u5b57\u7b26\u4e32 s \u7684\u957f\u5ea6\u3002","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"algo/dp/lcs/#_1","text":"\u7ed9\u5b9a\u4e24\u4e2a\u5e8f\u5217\uff08\u6570\u7ec4\u6216\u5b57\u7b26\u4e32\uff09A = [1, 2, 3, 2, 1]\uff0c B = [3, 2, 1, 4, 7]\uff0c\u90a3\u4e48\u8fd9\u4e24\u8005\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u662f[3, 2, 1]\uff0c\u957f\u5ea6\u4e3a3 \u8bbedp[i][j]\u4e3aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4e5f\u5c31\u662f\u72b6\u6001\uff0c\u4e00\u5171n*m\u4e2a\u3002\u56e0\u4e3a\u8981\u6c42\u5b50\u6570\u7ec4\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u5f53\u524d\u72b6\u6001\u53ea\u4f1a\u4e0e\u4e0b\u4e00\u4e2a\uff08\u6216\u4e0a\u4e00\u4e2a\uff09\u72b6\u6001\u76f8\u5173\uff0c\u7531\u6b64\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002 \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \u5728\u72b6\u6001\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u8bb0\u5f55\u6700\u5927\u957f\u5ea6\u7684\u5927\u5c0f\u4ee5\u53ca\u6700\u5927\u957f\u5ea6\u7684\u4f4d\u7f6e\uff0c\u6700\u7ec8\u53ef\u8f93\u51fa\u6700\u957f\u5b50\u6570\u7ec4\u3002","title":"\u5b50\u5e8f\u5217\u8fde\u7eed"},{"location":"algo/dp/lcs/#_2","text":"\u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2,\u8f93\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\uff0c\u4f8b\u5982\uff0c\"1AB2345CD\",\"12345EF\"\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\u662f\"2345\"\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : /** * longest common substring * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @return string\u5b57\u7b26\u4e32 */ string LCS ( string str1 , string str2 ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); int len = 1 , pos = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( str1 [ i ] == str2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; if ( len < dp [ i ][ j ]) { len = dp [ i ][ j ]; pos = i ; } } } } return str1 . substr ( pos , len ); } };","title":"\u6700\u957f\u516c\u5171\u5b50\u4e32"},{"location":"algo/dp/lcs/#_3","text":"\u5f53\u5b50\u5e8f\u5217\u4e0d\u8981\u6c42\u8fde\u7eed\u65f6\uff0c\u4f9d\u7136\u53ef\u4ee5\u7528dp[i][j]\u8868\u793aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4f46\u662f\u72b6\u6001\u7684\u8f6c\u79fb\u65b9\u7a0b\u53d1\u751f\u6539\u53d8 \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \u5982\u679c\u8981\u6c42\u8f93\u51fa\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u5219\u9700\u8981\u91cd\u65b0\u626b\u9762\u4e00\u904d\u4e24\u4e2a\u5e8f\u5217 1 2 3 4 5 6 7 8 int m = ( int ) A . length (), n = ( int ) B . length (), i = 0 , j = 0 ; while ( i < m && j < n ) { if ( A [ i ] == B [ j ]) { printf ( ' % c ' , A [ i ]); } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } }","title":"\u5b50\u5e8f\u5217\u4e0d\u8fde\u7eed"},{"location":"algo/dp/lcs/#_4","text":"\u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u8f93\u51fa\u8fde\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u8fc7\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <iostream> #include <string> #include <vector> using namespace std ; string LCS ( string s1 , string s2 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); string ans = \"\" ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( s1 [ i ] == s2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); } } } int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( s1 [ i ] == s2 [ j ]) { ans . push_back ( s1 [ i ]); i ++ ; j ++ ; } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } return dp [ 0 ][ 0 ] ? ans : \"-1\" ; } int main ( int argc , const char * argv []) { // insert code here... string s1 = \"1A2C3D4B56\" , s2 = \"B1D23CA45B6A\" ; cin >> s1 >> s2 ; printf ( \"%s \\n \" , LCS ( s1 , s2 ). c_str ()); return 0 ; }","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"algo/dp/lcs/#_5","text":"\u7ed9\u5b9a\u4e09\u4e2a\u5b57\u7b26\u4e32 s1 = \u201caabcc\u201d\uff0c s2 = \u201cdbbca\u201d\u3002s3 = \u201caadbbcbcac\u201d\uff0c\u5224\u65ad s3 \u662f\u5426\u7531 s1 \u548c s2 \u4ea4\u9519\u5f62\u6210\uff0c\u5373 s1 \u548c s2 \u662f s3 \u7684\u5b50\u5e8f\u5217\u4e14\u65e0\u91cd\u53e0\u3002 \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u5982\u679c\u4f7f\u7528\u3010\u53cc\u6307\u9488\u3011\u6c42\u89e3\u672c\u9898\u7684\u8bdd\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u9519\u8bef\u7ed3\u679c\uff0c\u56e0\u4e3a\uff0c\u3010\u53cc\u6307\u9488\u3011\u4f1a\u8d2a\u5fc3\u5730\u627e\u5230\u6700\u5148\u9047\u5230\u7684\u76f8\u540c\u5b57\u7b26\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u672c\u95ee\u9898\u7684\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff0c\u6240\u6709\u4f7f\u7528\u3010\u52a8\u6001\u89c4\u5212\u3011\u3002\u8bbe dp[ i ][ j ] \u8868\u793a s1 \u7684\u524d i \u4e2a\u5b57\u7b26\u4e0e s2 \u7684\u524d j \u4e2a\u5b57\u7b26\u662f\u5426\u5f62\u6210 s3 \u7684\u524d i + j \u4e2a\u5b57\u7b26\u3002 \\begin{aligned} \\text{dp[ i ][ j ]} =& (\\text{dp[i - 1][ j ] and s1[ i ] == s3[i + j]}) \\\\ & \\text{or } (\\text{dp[ i ][j - 1] and s2[ j ] == s3[i + j]}) \\end{aligned} \\begin{aligned} \\text{dp[ i ][ j ]} =& (\\text{dp[i - 1][ j ] and s1[ i ] == s3[i + j]}) \\\\ & \\text{or } (\\text{dp[ i ][j - 1] and s2[ j ] == s3[i + j]}) \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool isInterleave ( string s1 , string s2 , string s3 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (), n3 = ( int ) s3 . length (); if ( n1 + n2 != n3 ) { return false ; } bool ** dp = new bool * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new bool [ n2 + 1 ]{}; } dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i > 0 ) { dp [ i ][ j ] |= dp [ i - 1 ][ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; } if ( j > 0 ) { dp [ i ][ j ] |= dp [ i ][ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; } } } bool ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n_{1} n_{2}) O(n_{1} n_{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n_{1} n_{2}) O(n_{1} n_{2})","title":"\u4ea4\u9519\u5b57\u7b26"},{"location":"algo/dp/lcs/#_6","text":"\u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \uff0c\u627e\u51fa\u5176\u4e2d\u6700\u957f\u7684\u56de\u6587\u5b50\u5e8f\u5217\uff0c\u5e76\u8fd4\u56de\u8be5\u5e8f\u5217\u7684\u957f\u5ea6\u3002\u5b50\u5e8f\u5217\u5b9a\u4e49\u4e3a\uff1a\u4e0d\u6539\u53d8\u5269\u4f59\u5b57\u7b26\u987a\u5e8f\u7684\u60c5\u51b5\u4e0b\uff0c\u5220\u9664\u67d0\u4e9b\u5b57\u7b26\u6216\u8005\u4e0d\u5220\u9664\u4efb\u4f55\u5b57\u7b26\u5f62\u6210\u7684\u4e00\u4e2a\u5e8f\u5217\u3002\u4f8b\u5982\uff0cs = \"bbbab\" \u7684\u6700\u957f\u56de\u6587\u5b50\u5e8f\u5217\u662f \"bbbb\"\uff0c\u8fd4\u56de 4\u3002 \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u5c06 s \u53d6\u53cd\u5f97\u5230 t\uff0c\u95ee\u9898\u8f6c\u5316\u4e3a\u6c42 s \u548c t \u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int longestPalindromeSubseq ( string s ) { if ( s . empty ()) { return 0 ; } vector < vector < int >> dp ( s . length () + 1 , vector < int > ( s . length () + 1 , 0 )); string t ( s . begin (), s . end ()); reverse ( t . begin (), t . end ()); for ( int i = 1 ; i <= s . length (); i ++ ) { for ( int j = 1 ; j <= t . length (); j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); } } } return dp [ s . length ()][ t . length ()]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0cn \u662f\u5b57\u7b26\u4e32 s \u7684\u957f\u5ea6\u3002","title":"\u6700\u957f\u56de\u6587\u5b50\u5e8f\u5217"},{"location":"algo/dp/left-right-traversal/","text":"\u57fa\u7840 \u00b6 \u5728\u67d0\u4e9b\u95ee\u9898\u91cc\uff0c\u4e00\u4e2a\u4f4d\u7f6e\u7684\u7ea6\u675f\u6761\u4ef6\u901a\u5e38\u6d89\u53ca\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u5de6\u53f3\u4e24\u4fa7\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5c06\u7ea6\u675f\u62c6\u5206\uff0c\u5206\u522b\u4ece\u5de6\u5230\u53f3\u3001\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u6700\u540e\u7ed3\u5408\u9884\u5904\u7406\u7684\u7ed3\u679c\u6c42\u89e3\u3002 \u9898\u76ee \u00b6 \u5206\u53d1\u7cd6\u679c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 ratings = [1, 0, 2] \u8868\u793a\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u7684\u5206\u6570\uff0c\u5148\u8981\u7ed9\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5206\u53d1\u7cd6\u679c\uff0c\u5982\u679c\u67d0\u4e00\u4e2a\u4f4d\u7f6e i \u7684\u8bc4\u5206\u6bd4\u4e24\u4fa7\u7684\u5206\u6570\u90fd\u9ad8\u7684\u8bdd\uff0c\u5b83\u7684\u7cd6\u679c\u6570\u76ee\u4e5f\u8981\u9ad8\u4e8e\u4e24\u4fa7\u7684\u7cd6\u679c\u6570\u76ee\u3002\u8bd5\u95ee\u6700\u5c11\u51c6\u5907\u591a\u5c11\u7cd6\u679c\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212 + \u4e24\u6b21\u904d\u5386\u3011\u6211\u4eec\u5c06\u89c4\u5219\u62c6\u5f00\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u6bd4\u8f83 i \u548c i - 1 \u7684\u5206\u6570\uff0c\u8bb0\u5f55 i \u7684\u7cd6\u679c\u6570\u76ee\uff0c\u518d\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u6bd4\u8f83 i \u548c i + 1 \u7684\u5206\u6570\uff0c\u8bb0\u5f55 i \u7684\u7cd6\u679c\u6570\u76ee\uff0c\u6700\u7ec8\u7684\u6570\u76ee\u662f max(left, right)\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int candy ( vector < int >& ratings ) { int n = ( int ) ratings . size (); vector < int > left ( n , 1 ); for ( int i = 1 ; i < n ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ]) { left [ i ] = left [ i - 1 ] + 1 ; } else { left [ i ] = 1 ; } } int right = 1 , ans = max ( left [ n - 1 ], right ); for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( ratings [ i ] > ratings [ i + 1 ]) { right ++ ; } else { right = 1 ; } ans += max ( left [ i ], right ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u6700\u5c0f\u5220\u9664\u6b21\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u7531 a \u548c b \u6784\u6210\u7684\u5b57\u7b26\u4e32 s = \"aababbab\"\uff0c\u8bd5\u95ee\u6700\u5c0f\u5220\u9664\u591a\u5c11\u4e2a\u5b57\u7b26\uff0c\u53ef\u4ee5\u4f7f\u5f97\u5220\u9664\u540e\u7684\u5b57\u7b26\u4e32\u6ee1\u8db3\u6240\u6709\u7684 a \u6392\u5728 b \u7684\u524d\u9762\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u7edf\u8ba1\u4f4d\u4e8e\u5b83\u4e4b\u524d\u7684\u6240\u6709 a \u548c\u4f4d\u4e8e\u5b83\u4e4b\u540e\u7684\u6240\u6709 b\uff0c\u6700\u7ec8\u6c42\u6700\u5927\u7684\u548c 1 2 3 4 5 6 7 8 9 10 11 12 13 int minimumDeletions ( string s ) { int ans = 0 , n = ( int ) s . length (); vector < int > left ( n , 0 ), right ( n , 0 ); for ( int i = 1 ; i < n ; i ++ ) { left [ i ] += left [ i - 1 ] + ( s [ i - 1 ] == 'a' ); right [ n - 1 - i ] += right [ n - i ] + ( s [ n - i ] == 'b' ); } for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , left [ i ] + right [ i ]); } return n - ans - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u79fb\u9664\u6240\u6709 1 \u7684\u6700\u5c0f\u65f6\u95f4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u6709 0 \u548c 1 \u7684\u5b57\u7b26\u4e32 s = \"01110\"\uff0c\u6bcf\u6b21\u53ef\u4ee5\u4ece s \u7684\u5de6\u53f3\u4e24\u7aef\u79fb\u9664\u4e00\u4e2a\u5b57\u7b26\uff0c\u82b1\u8d39 1 \u5355\u4f4d\u65f6\u95f4\uff0c\u6216\u8005\u79fb\u9664\u4e2d\u95f4\u7684\u67d0\u4e00\u4e2a\u5b57\u7b26\uff0c\u82b1\u8d39 2 \u5355\u4f4d\u65f6\u95f4\u3002\u8bd5\u95ee\uff0c\u79fb\u9664\u6240\u6709 1 \u9700\u8981\u6700\u5c11\u591a\u5c11\u65f6\u95f4\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u56e0\u4e3a\u4e24\u7aef\u79fb\u9664\u5b57\u7b26\uff0c\u56e0\u6b64\u8003\u8651\u4e24\u7aef dp\u3002\u8bbe left[ i ] \u8868\u793a\u524d i \u4e2a\u5b57\u7b26\u9700\u8981\u82b1\u8d39\u7684\u6700\u5c11\u65f6\u95f4\uff0cright[ i ] \u8868\u793a\u540e i \u4e2a\u5b57\u7b26\u9700\u8981\u82b1\u8d39\u6700\u5c11\u65f6\u95f4\u3002 \\begin{aligned} & \\text{left[ i ]} = \\begin{cases} \\text{left[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{left[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\\\ & \\text{right[ i ]} = \\begin{cases} \\text{right[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{right[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\end{aligned} \\begin{aligned} & \\text{left[ i ]} = \\begin{cases} \\text{left[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{left[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\\\ & \\text{right[ i ]} = \\begin{cases} \\text{right[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{right[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\end{aligned} \u6700\u7ec8\u5728\u67d0\u4e00\u4e2a\u4f4d\u7f6e\u53d6\u5f97\u6700\u5c0f\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int minimumTime ( string s ) { int ans = INT_MAX , n = ( int ) s . length (); vector < int > left ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { left [ i + 1 ] = left [ i ]; } else { left [ i + 1 ] = min ( left [ i ] + 2 , i + 1 ); } } vector < int > right ( n + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) { right [ i ] = right [ i + 1 ]; } else { right [ i ] = min ( right [ i + 1 ] + 2 , n - i ); } } for ( int i = 0 ; i <= n ; i ++ ) { ans = min ( ans , left [ i ] + right [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u6700\u591a\u80fd\u5b8c\u6210\u6392\u5e8f\u7684\u5757 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6574\u6570\u6570\u7ec4 arr \uff0c\u5b83\u8868\u793a\u5728 [0, n - 1] \u8303\u56f4\u5185\u7684\u6574\u6570\u7684\u6392\u5217\u3002\u6211\u4eec\u5c06 arr \u5206\u5272\u6210\u82e5\u5e72 \u5757 (\u5373\u5206\u533a)\uff0c\u5e76\u5bf9\u6bcf\u4e2a\u5757\u5355\u72ec\u6392\u5e8f\u3002\u5c06\u5b83\u4eec\u8fde\u63a5\u8d77\u6765\u540e\uff0c\u4f7f\u5f97\u8fde\u63a5\u7684\u7ed3\u679c\u548c\u6309\u5347\u5e8f\u6392\u5e8f\u540e\u7684\u539f\u6570\u7ec4\u76f8\u540c\u3002\u8fd4\u56de\u6570\u7ec4\u80fd\u5206\u6210\u7684\u6700\u591a\u5757\u6570\u91cf\u3002\u4f8b\u5982\uff0carr = [1,0,2,3,4]\uff0c\u8fd4\u56de 4\uff0c\u5373\u5206\u6210 [1, 0], [2], [3], [4] \u53ef\u4ee5\u5f97\u5230\u6700\u591a\u7684\u5757\u6570\uff0c\u5bf9\u6bcf\u4e2a\u5757\u5355\u72ec\u6392\u5e8f\u540e\uff0c\u7ed3\u679c\u4e3a [0, 1], [2], [3], [4]\u3002 \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u5bf9\u4e8e\u4e00\u4e2a\u975e\u7a7a\u7684\u6570\u7ec4\uff0c\u81f3\u5c11\u8981\u5206\u6210\u4e00\u6574\u5757\uff0c\u8fd9\u6837\u5757\u5185\u6392\u5e8f\u4e4b\u540e\uff0c\u5757\u4e4b\u95f4\u6709\u5e8f\u3002\u6570\u7ec4\u80fd\u5207\u5757\u7684\u6761\u4ef6\u662f\uff0c\u524d\u4e00\u5757\u5185\u7684\u6700\u5927\u5143\u7d20\u8981\u5c0f\u4e8e\u540e\u4e00\u5757\u7684\u6700\u5c0f\u503c\u3002\u56e0\u6b64\u626b\u63cf\u4e24\u904d\u6570\u7ec4\uff0c\u7b2c\u4e00\u904d\u4fdd\u5b58\u6bcf\u4e2a\u4f4d\u7f6e\u53f3\u4fa7\u7684\u6700\u5c0f\u503c\uff0c\u7b2c\u4e8c\u904d\u626b\u63cf\u8ba1\u7b97\u5de6\u4fa7\u7684\u6700\u5927\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int maxChunksToSorted ( vector < int >& arr ) { if ( arr . empty ()) { return 0 ; } int n = ( int ) arr . size (), ans = 1 ; vector < int > rMin ( n , 0 ); rMin [ n - 1 ] = arr . back (); for ( int i = n - 2 ; i >= 0 ; i -- ) { rMin [ i ] = min ( rMin [ i + 1 ], arr [ i ]); } int lMax = arr [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( lMax <= rMin [ i ]) { ans ++ ; } lMax = max ( lMax , arr [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u5de6\u53f3\u904d\u5386\u578b"},{"location":"algo/dp/left-right-traversal/#_1","text":"\u5728\u67d0\u4e9b\u95ee\u9898\u91cc\uff0c\u4e00\u4e2a\u4f4d\u7f6e\u7684\u7ea6\u675f\u6761\u4ef6\u901a\u5e38\u6d89\u53ca\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u5de6\u53f3\u4e24\u4fa7\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5c06\u7ea6\u675f\u62c6\u5206\uff0c\u5206\u522b\u4ece\u5de6\u5230\u53f3\u3001\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u6700\u540e\u7ed3\u5408\u9884\u5904\u7406\u7684\u7ed3\u679c\u6c42\u89e3\u3002","title":"\u57fa\u7840"},{"location":"algo/dp/left-right-traversal/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/dp/left-right-traversal/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 ratings = [1, 0, 2] \u8868\u793a\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u7684\u5206\u6570\uff0c\u5148\u8981\u7ed9\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5206\u53d1\u7cd6\u679c\uff0c\u5982\u679c\u67d0\u4e00\u4e2a\u4f4d\u7f6e i \u7684\u8bc4\u5206\u6bd4\u4e24\u4fa7\u7684\u5206\u6570\u90fd\u9ad8\u7684\u8bdd\uff0c\u5b83\u7684\u7cd6\u679c\u6570\u76ee\u4e5f\u8981\u9ad8\u4e8e\u4e24\u4fa7\u7684\u7cd6\u679c\u6570\u76ee\u3002\u8bd5\u95ee\u6700\u5c11\u51c6\u5907\u591a\u5c11\u7cd6\u679c\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212 + \u4e24\u6b21\u904d\u5386\u3011\u6211\u4eec\u5c06\u89c4\u5219\u62c6\u5f00\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u6bd4\u8f83 i \u548c i - 1 \u7684\u5206\u6570\uff0c\u8bb0\u5f55 i \u7684\u7cd6\u679c\u6570\u76ee\uff0c\u518d\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u6bd4\u8f83 i \u548c i + 1 \u7684\u5206\u6570\uff0c\u8bb0\u5f55 i \u7684\u7cd6\u679c\u6570\u76ee\uff0c\u6700\u7ec8\u7684\u6570\u76ee\u662f max(left, right)\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int candy ( vector < int >& ratings ) { int n = ( int ) ratings . size (); vector < int > left ( n , 1 ); for ( int i = 1 ; i < n ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ]) { left [ i ] = left [ i - 1 ] + 1 ; } else { left [ i ] = 1 ; } } int right = 1 , ans = max ( left [ n - 1 ], right ); for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( ratings [ i ] > ratings [ i + 1 ]) { right ++ ; } else { right = 1 ; } ans += max ( left [ i ], right ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u5206\u53d1\u7cd6\u679c"},{"location":"algo/dp/left-right-traversal/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u7531 a \u548c b \u6784\u6210\u7684\u5b57\u7b26\u4e32 s = \"aababbab\"\uff0c\u8bd5\u95ee\u6700\u5c0f\u5220\u9664\u591a\u5c11\u4e2a\u5b57\u7b26\uff0c\u53ef\u4ee5\u4f7f\u5f97\u5220\u9664\u540e\u7684\u5b57\u7b26\u4e32\u6ee1\u8db3\u6240\u6709\u7684 a \u6392\u5728 b \u7684\u524d\u9762\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u7edf\u8ba1\u4f4d\u4e8e\u5b83\u4e4b\u524d\u7684\u6240\u6709 a \u548c\u4f4d\u4e8e\u5b83\u4e4b\u540e\u7684\u6240\u6709 b\uff0c\u6700\u7ec8\u6c42\u6700\u5927\u7684\u548c 1 2 3 4 5 6 7 8 9 10 11 12 13 int minimumDeletions ( string s ) { int ans = 0 , n = ( int ) s . length (); vector < int > left ( n , 0 ), right ( n , 0 ); for ( int i = 1 ; i < n ; i ++ ) { left [ i ] += left [ i - 1 ] + ( s [ i - 1 ] == 'a' ); right [ n - 1 - i ] += right [ n - i ] + ( s [ n - i ] == 'b' ); } for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , left [ i ] + right [ i ]); } return n - ans - 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u6700\u5c0f\u5220\u9664\u6b21\u6570"},{"location":"algo/dp/left-right-traversal/#1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u6709 0 \u548c 1 \u7684\u5b57\u7b26\u4e32 s = \"01110\"\uff0c\u6bcf\u6b21\u53ef\u4ee5\u4ece s \u7684\u5de6\u53f3\u4e24\u7aef\u79fb\u9664\u4e00\u4e2a\u5b57\u7b26\uff0c\u82b1\u8d39 1 \u5355\u4f4d\u65f6\u95f4\uff0c\u6216\u8005\u79fb\u9664\u4e2d\u95f4\u7684\u67d0\u4e00\u4e2a\u5b57\u7b26\uff0c\u82b1\u8d39 2 \u5355\u4f4d\u65f6\u95f4\u3002\u8bd5\u95ee\uff0c\u79fb\u9664\u6240\u6709 1 \u9700\u8981\u6700\u5c11\u591a\u5c11\u65f6\u95f4\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u56e0\u4e3a\u4e24\u7aef\u79fb\u9664\u5b57\u7b26\uff0c\u56e0\u6b64\u8003\u8651\u4e24\u7aef dp\u3002\u8bbe left[ i ] \u8868\u793a\u524d i \u4e2a\u5b57\u7b26\u9700\u8981\u82b1\u8d39\u7684\u6700\u5c11\u65f6\u95f4\uff0cright[ i ] \u8868\u793a\u540e i \u4e2a\u5b57\u7b26\u9700\u8981\u82b1\u8d39\u6700\u5c11\u65f6\u95f4\u3002 \\begin{aligned} & \\text{left[ i ]} = \\begin{cases} \\text{left[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{left[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\\\ & \\text{right[ i ]} = \\begin{cases} \\text{right[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{right[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\end{aligned} \\begin{aligned} & \\text{left[ i ]} = \\begin{cases} \\text{left[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{left[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\\\ & \\text{right[ i ]} = \\begin{cases} \\text{right[i - 1]}, & \\quad s[ i ] == 0 \\\\ \\min(\\text{right[i - 1] + 2}, i), & \\quad \\text{otherwise} \\end{cases} \\end{aligned} \u6700\u7ec8\u5728\u67d0\u4e00\u4e2a\u4f4d\u7f6e\u53d6\u5f97\u6700\u5c0f\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int minimumTime ( string s ) { int ans = INT_MAX , n = ( int ) s . length (); vector < int > left ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { left [ i + 1 ] = left [ i ]; } else { left [ i + 1 ] = min ( left [ i ] + 2 , i + 1 ); } } vector < int > right ( n + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) { right [ i ] = right [ i + 1 ]; } else { right [ i ] = min ( right [ i + 1 ] + 2 , n - i ); } } for ( int i = 0 ; i <= n ; i ++ ) { ans = min ( ans , left [ i ] + right [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u79fb\u9664\u6240\u6709 1 \u7684\u6700\u5c0f\u65f6\u95f4"},{"location":"algo/dp/left-right-traversal/#_5","text":"\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6574\u6570\u6570\u7ec4 arr \uff0c\u5b83\u8868\u793a\u5728 [0, n - 1] \u8303\u56f4\u5185\u7684\u6574\u6570\u7684\u6392\u5217\u3002\u6211\u4eec\u5c06 arr \u5206\u5272\u6210\u82e5\u5e72 \u5757 (\u5373\u5206\u533a)\uff0c\u5e76\u5bf9\u6bcf\u4e2a\u5757\u5355\u72ec\u6392\u5e8f\u3002\u5c06\u5b83\u4eec\u8fde\u63a5\u8d77\u6765\u540e\uff0c\u4f7f\u5f97\u8fde\u63a5\u7684\u7ed3\u679c\u548c\u6309\u5347\u5e8f\u6392\u5e8f\u540e\u7684\u539f\u6570\u7ec4\u76f8\u540c\u3002\u8fd4\u56de\u6570\u7ec4\u80fd\u5206\u6210\u7684\u6700\u591a\u5757\u6570\u91cf\u3002\u4f8b\u5982\uff0carr = [1,0,2,3,4]\uff0c\u8fd4\u56de 4\uff0c\u5373\u5206\u6210 [1, 0], [2], [3], [4] \u53ef\u4ee5\u5f97\u5230\u6700\u591a\u7684\u5757\u6570\uff0c\u5bf9\u6bcf\u4e2a\u5757\u5355\u72ec\u6392\u5e8f\u540e\uff0c\u7ed3\u679c\u4e3a [0, 1], [2], [3], [4]\u3002 \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u5bf9\u4e8e\u4e00\u4e2a\u975e\u7a7a\u7684\u6570\u7ec4\uff0c\u81f3\u5c11\u8981\u5206\u6210\u4e00\u6574\u5757\uff0c\u8fd9\u6837\u5757\u5185\u6392\u5e8f\u4e4b\u540e\uff0c\u5757\u4e4b\u95f4\u6709\u5e8f\u3002\u6570\u7ec4\u80fd\u5207\u5757\u7684\u6761\u4ef6\u662f\uff0c\u524d\u4e00\u5757\u5185\u7684\u6700\u5927\u5143\u7d20\u8981\u5c0f\u4e8e\u540e\u4e00\u5757\u7684\u6700\u5c0f\u503c\u3002\u56e0\u6b64\u626b\u63cf\u4e24\u904d\u6570\u7ec4\uff0c\u7b2c\u4e00\u904d\u4fdd\u5b58\u6bcf\u4e2a\u4f4d\u7f6e\u53f3\u4fa7\u7684\u6700\u5c0f\u503c\uff0c\u7b2c\u4e8c\u904d\u626b\u63cf\u8ba1\u7b97\u5de6\u4fa7\u7684\u6700\u5927\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int maxChunksToSorted ( vector < int >& arr ) { if ( arr . empty ()) { return 0 ; } int n = ( int ) arr . size (), ans = 1 ; vector < int > rMin ( n , 0 ); rMin [ n - 1 ] = arr . back (); for ( int i = n - 2 ; i >= 0 ; i -- ) { rMin [ i ] = min ( rMin [ i + 1 ], arr [ i ]); } int lMax = arr [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( lMax <= rMin [ i ]) { ans ++ ; } lMax = max ( lMax , arr [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6700\u591a\u80fd\u5b8c\u6210\u6392\u5e8f\u7684\u5757"},{"location":"algo/dp/lis/","text":"\u57fa\u7840 \u00b6 \u7ed9\u5b9a\u6570\u7ec4arr\uff0c\u8bbe\u957f\u5ea6\u4e3an\uff0c\u8f93\u51faarr\u7684\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\u3002\uff08\u5982\u679c\u6709\u591a\u4e2a\u7b54\u6848\uff0c\u8bf7\u8f93\u51fa\u5176\u4e2d\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\uff09\u3002input: 1, 2, 8, 6, 4\u3002output: 1, 2, 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 vector < int > LIS ( vector < int >& arr ) { vector < int > ans ; int n = ( int ) arr . size (); if ( n == 0 ) { return ans ; } vector < int > dp ( n , 1 ); int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ele = arr [ i ]; if ( ans . empty () || ans . back () < ele ) { ans . emplace_back ( ele ); len ++ ; dp [ i ] = len ; } else { int l = 0 , r = len - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( ans [ m ] >= ele ) { r = m - 1 ; } else { l = m + 1 ; } } ans [ l ] = ele ; dp [ i ] = l + 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( dp [ i ] == len ) { ans [ -- len ] = arr [ i ]; } } return ans ; } vector < int > lengthOfLIS ( vector < int >& nums ) { int len = 0 ; vector < int > dp ; for ( int i = 0 ; i < nums . size (); i ++ ) { int num = nums [ i ]; if ( dp . empty () || dp . back () < num ) { dp . emplace_back ( num ); len ++ ; } else { int l = 0 , r = len ; while ( l < r ) { int m = ( l + r ) >> 1 ; if ( dp [ m ] < num ) { l = m + 1 ; } else { r = m ; } } dp [ l ] = num ; } } return dp ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u89c1\u590d\u6742\u5ea6\uff1a O(n) O(n) \u9898\u76ee \u00b6 \u6700\u5c0f\u586b\u5145\u6b21\u6570 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 target = [6, 4, 8, 1, 3, 2] \u548c arr = [4, 7, 6, 2, 3, 8, 6, 1]\uff0c\u5176\u4e2d target \u5185\u7684\u5143\u7d20\u5404\u4e0d\u76f8\u540c\uff0c\u6bcf\u6b21\u53ef\u4ee5\u5728 arr \u7684\u4efb\u610f\u4f4d\u7f6e\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\uff0c\u8bd5\u95ee\u6700\u5c11\u6dfb\u52a0\u591a\u5c11\u6b21\uff0c\u4f7f\u5f97 target \u6210\u4e3a arr \u7684\u4e00\u4e2a\u5b50\u5e8f\u5217\u3002 \u300c\u5206\u6790\u300d \u76f4\u89c2\u5730\u60f3\u6cd5\u662f\u6c42 arr \u548c target \u7684LCS\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(nm) O(nm) \uff0c\u672c\u9898\u8d85\u65f6\uff0c\u8003\u8651\u5230 targte \u4e2d\u7684\u5143\u7d20\u5404\u4e0d\u76f8\u540c\uff0c\u5982\u679c\u7ed9 targte \u6570\u5177\u6709\u552f\u4e00\u7684\u4e0b\u6807\uff0c\u90a3\u4e48\u6620\u5c04\u5230 arr \u4e0a\uff0c\u5c31\u53ef\u4ee5\u6c42 LIS\uff0c\u6700\u7ec8\u7684\u7b54\u6848\u5c31\u662f len(targte) - (len)LIS\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int LIS ( vector < int > nums ) { int n = ( int ) nums . size (); vector < int > lis ; for ( int i = 0 ; i < n ; i ++ ) { if ( lis . empty () || lis . back () < nums [ i ]) { lis . emplace_back ( nums [ i ]); } else { int l = 0 , r = ( int ) lis . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( lis [ m ] < nums [ i ]) { l = m + 1 ; } else { r = m ; } } lis [ l ] = nums [ i ]; } } return ( int ) lis . size (); } int minOperations ( vector < int >& target , vector < int >& arr ) { int n1 = ( int ) target . size (); unordered_map < int , int > idx ; for ( int i = 0 ; i < n1 ; i ++ ) { idx [ target [ i ]] = i ; } vector < int > nums ; for ( int ele : arr ) { if ( idx . count ( ele )) { nums . emplace_back ( idx [ ele ]); } } return n1 - LIS ( nums ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(m + n \\log n) O(m + n \\log n) \uff0c\u7a7a\u89c1\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cm \u662f arr \u7684\u957f\u5ea6\uff0cn \u662f target \u7684\u957f\u5ea6 \u4fc4\u7f57\u65af\u5957\u5a03\u4fe1\u5c01\u95ee\u9898 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 envelopes \uff0c\u5176\u4e2d envelopes[i] = [wi, hi] \uff0c\u8868\u793a\u7b2c i \u4e2a\u4fe1\u5c01\u7684\u5bbd\u5ea6\u548c\u9ad8\u5ea6\u3002\u5f53\u53e6\u4e00\u4e2a\u4fe1\u5c01\u7684\u5bbd\u5ea6\u548c\u9ad8\u5ea6\u90fd\u6bd4\u8fd9\u4e2a\u4fe1\u5c01\u5927\u7684\u65f6\u5019\uff0c\u8fd9\u4e2a\u4fe1\u5c01\u5c31\u53ef\u4ee5\u653e\u8fdb\u53e6\u4e00\u4e2a\u4fe1\u5c01\u91cc\uff0c\u5982\u540c\u4fc4\u7f57\u65af\u5957\u5a03\u4e00\u6837\u3002\u8bf7\u8ba1\u7b97 \u6700\u591a\u80fd\u6709\u591a\u5c11\u4e2a \u4fe1\u5c01\u80fd\u7ec4\u6210\u4e00\u7ec4\u201c\u4fc4\u7f57\u65af\u5957\u5a03\u201d\u4fe1\u5c01\uff08\u5373\u53ef\u4ee5\u628a\u4e00\u4e2a\u4fe1\u5c01\u653e\u5230\u53e6\u4e00\u4e2a\u4fe1\u5c01\u91cc\u9762\uff09\u3002\u6ce8\u610f\uff1a\u4e0d\u5141\u8bb8\u65cb\u8f6c\u4fe1\u5c01\u3002 \u4f8b\u5982\uff0cenvelopes = [[5,4],[6,4],[6,7],[2,3]]\uff0c\u8fd4\u56de 3\uff0c\u53ca\u6700\u591a\u4fe1\u5c01\u7684\u4e2a\u6570\u4e3a 3, \u7ec4\u5408\u4e3a: [2,3] => [5,4] => [6,7]\u3002 \u300c\u5206\u6790\u300d \u300cLIS\u300d\u6309\u7167\u4e00\u4e2a\u65b9\u5411\u6392\u5e8f\uff0c\u8ba1\u7b97\u53e6\u4e00\u4e2a\u65b9\u5411\u7684LIS\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int maxEnvelopes ( vector < vector < int >>& envelopes ) { int n = int ( envelopes . size ()), len = 1 ; if ( n <= 1 ) { return n ; } sort ( envelopes . begin (), envelopes . end (), []( const auto & e1 , const auto & e2 ) { return e1 [ 0 ] < e2 [ 0 ] || ( e1 [ 0 ] == e2 [ 0 ] && e1 [ 1 ] > e2 [ 1 ]); }); vector < vector < int >> dp ( n + 1 , vector < int > { 0 , 0 }); dp [ len ] = envelopes [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( envelopes [ i ][ 0 ] > dp [ len ][ 0 ] && envelopes [ i ][ 1 ] > dp [ len ][ 1 ]) { dp [ ++ len ] = envelopes [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ][ 0 ] < envelopes [ i ][ 0 ] && dp [ m ][ 1 ] < envelopes [ i ][ 1 ]) { l = m + 1 ; } else { r = m - 1 ; } } dp [ l ] = envelopes [ i ]; } } return len ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n\\log n) O(n\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217"},{"location":"algo/dp/lis/#_1","text":"\u7ed9\u5b9a\u6570\u7ec4arr\uff0c\u8bbe\u957f\u5ea6\u4e3an\uff0c\u8f93\u51faarr\u7684\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\u3002\uff08\u5982\u679c\u6709\u591a\u4e2a\u7b54\u6848\uff0c\u8bf7\u8f93\u51fa\u5176\u4e2d\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\uff09\u3002input: 1, 2, 8, 6, 4\u3002output: 1, 2, 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 vector < int > LIS ( vector < int >& arr ) { vector < int > ans ; int n = ( int ) arr . size (); if ( n == 0 ) { return ans ; } vector < int > dp ( n , 1 ); int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ele = arr [ i ]; if ( ans . empty () || ans . back () < ele ) { ans . emplace_back ( ele ); len ++ ; dp [ i ] = len ; } else { int l = 0 , r = len - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( ans [ m ] >= ele ) { r = m - 1 ; } else { l = m + 1 ; } } ans [ l ] = ele ; dp [ i ] = l + 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( dp [ i ] == len ) { ans [ -- len ] = arr [ i ]; } } return ans ; } vector < int > lengthOfLIS ( vector < int >& nums ) { int len = 0 ; vector < int > dp ; for ( int i = 0 ; i < nums . size (); i ++ ) { int num = nums [ i ]; if ( dp . empty () || dp . back () < num ) { dp . emplace_back ( num ); len ++ ; } else { int l = 0 , r = len ; while ( l < r ) { int m = ( l + r ) >> 1 ; if ( dp [ m ] < num ) { l = m + 1 ; } else { r = m ; } } dp [ l ] = num ; } } return dp ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u89c1\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u57fa\u7840"},{"location":"algo/dp/lis/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/dp/lis/#_3","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4 target = [6, 4, 8, 1, 3, 2] \u548c arr = [4, 7, 6, 2, 3, 8, 6, 1]\uff0c\u5176\u4e2d target \u5185\u7684\u5143\u7d20\u5404\u4e0d\u76f8\u540c\uff0c\u6bcf\u6b21\u53ef\u4ee5\u5728 arr \u7684\u4efb\u610f\u4f4d\u7f6e\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\uff0c\u8bd5\u95ee\u6700\u5c11\u6dfb\u52a0\u591a\u5c11\u6b21\uff0c\u4f7f\u5f97 target \u6210\u4e3a arr \u7684\u4e00\u4e2a\u5b50\u5e8f\u5217\u3002 \u300c\u5206\u6790\u300d \u76f4\u89c2\u5730\u60f3\u6cd5\u662f\u6c42 arr \u548c target \u7684LCS\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(nm) O(nm) \uff0c\u672c\u9898\u8d85\u65f6\uff0c\u8003\u8651\u5230 targte \u4e2d\u7684\u5143\u7d20\u5404\u4e0d\u76f8\u540c\uff0c\u5982\u679c\u7ed9 targte \u6570\u5177\u6709\u552f\u4e00\u7684\u4e0b\u6807\uff0c\u90a3\u4e48\u6620\u5c04\u5230 arr \u4e0a\uff0c\u5c31\u53ef\u4ee5\u6c42 LIS\uff0c\u6700\u7ec8\u7684\u7b54\u6848\u5c31\u662f len(targte) - (len)LIS\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int LIS ( vector < int > nums ) { int n = ( int ) nums . size (); vector < int > lis ; for ( int i = 0 ; i < n ; i ++ ) { if ( lis . empty () || lis . back () < nums [ i ]) { lis . emplace_back ( nums [ i ]); } else { int l = 0 , r = ( int ) lis . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( lis [ m ] < nums [ i ]) { l = m + 1 ; } else { r = m ; } } lis [ l ] = nums [ i ]; } } return ( int ) lis . size (); } int minOperations ( vector < int >& target , vector < int >& arr ) { int n1 = ( int ) target . size (); unordered_map < int , int > idx ; for ( int i = 0 ; i < n1 ; i ++ ) { idx [ target [ i ]] = i ; } vector < int > nums ; for ( int ele : arr ) { if ( idx . count ( ele )) { nums . emplace_back ( idx [ ele ]); } } return n1 - LIS ( nums ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(m + n \\log n) O(m + n \\log n) \uff0c\u7a7a\u89c1\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cm \u662f arr \u7684\u957f\u5ea6\uff0cn \u662f target \u7684\u957f\u5ea6","title":"\u6700\u5c0f\u586b\u5145\u6b21\u6570"},{"location":"algo/dp/lis/#_4","text":"\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6574\u6570\u6570\u7ec4 envelopes \uff0c\u5176\u4e2d envelopes[i] = [wi, hi] \uff0c\u8868\u793a\u7b2c i \u4e2a\u4fe1\u5c01\u7684\u5bbd\u5ea6\u548c\u9ad8\u5ea6\u3002\u5f53\u53e6\u4e00\u4e2a\u4fe1\u5c01\u7684\u5bbd\u5ea6\u548c\u9ad8\u5ea6\u90fd\u6bd4\u8fd9\u4e2a\u4fe1\u5c01\u5927\u7684\u65f6\u5019\uff0c\u8fd9\u4e2a\u4fe1\u5c01\u5c31\u53ef\u4ee5\u653e\u8fdb\u53e6\u4e00\u4e2a\u4fe1\u5c01\u91cc\uff0c\u5982\u540c\u4fc4\u7f57\u65af\u5957\u5a03\u4e00\u6837\u3002\u8bf7\u8ba1\u7b97 \u6700\u591a\u80fd\u6709\u591a\u5c11\u4e2a \u4fe1\u5c01\u80fd\u7ec4\u6210\u4e00\u7ec4\u201c\u4fc4\u7f57\u65af\u5957\u5a03\u201d\u4fe1\u5c01\uff08\u5373\u53ef\u4ee5\u628a\u4e00\u4e2a\u4fe1\u5c01\u653e\u5230\u53e6\u4e00\u4e2a\u4fe1\u5c01\u91cc\u9762\uff09\u3002\u6ce8\u610f\uff1a\u4e0d\u5141\u8bb8\u65cb\u8f6c\u4fe1\u5c01\u3002 \u4f8b\u5982\uff0cenvelopes = [[5,4],[6,4],[6,7],[2,3]]\uff0c\u8fd4\u56de 3\uff0c\u53ca\u6700\u591a\u4fe1\u5c01\u7684\u4e2a\u6570\u4e3a 3, \u7ec4\u5408\u4e3a: [2,3] => [5,4] => [6,7]\u3002 \u300c\u5206\u6790\u300d \u300cLIS\u300d\u6309\u7167\u4e00\u4e2a\u65b9\u5411\u6392\u5e8f\uff0c\u8ba1\u7b97\u53e6\u4e00\u4e2a\u65b9\u5411\u7684LIS\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int maxEnvelopes ( vector < vector < int >>& envelopes ) { int n = int ( envelopes . size ()), len = 1 ; if ( n <= 1 ) { return n ; } sort ( envelopes . begin (), envelopes . end (), []( const auto & e1 , const auto & e2 ) { return e1 [ 0 ] < e2 [ 0 ] || ( e1 [ 0 ] == e2 [ 0 ] && e1 [ 1 ] > e2 [ 1 ]); }); vector < vector < int >> dp ( n + 1 , vector < int > { 0 , 0 }); dp [ len ] = envelopes [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( envelopes [ i ][ 0 ] > dp [ len ][ 0 ] && envelopes [ i ][ 1 ] > dp [ len ][ 1 ]) { dp [ ++ len ] = envelopes [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ][ 0 ] < envelopes [ i ][ 0 ] && dp [ m ][ 1 ] < envelopes [ i ][ 1 ]) { l = m + 1 ; } else { r = m - 1 ; } } dp [ l ] = envelopes [ i ]; } } return len ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n\\log n) O(n\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u4fc4\u7f57\u65af\u5957\u5a03\u4fe1\u5c01\u95ee\u9898"},{"location":"algo/dp/matrix/","text":"\u5b50\u77e9\u9635 \u00b6 \u6700\u5927\u6b63\u65b9\u5f62 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u6784\u6210\u7684\u77e9\u9635\uff0c\u6c42\u6700\u5927\u7684\u5168 1 \u5b50\u6b63\u65b9\u5f62\u3002\u4f8b\u5982 \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \u6700\u5927\u9762\u79ef\u4e3a 4\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u77e9\u9635\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ] == '1' ) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans = max ( ans , dp [ j ] * dp [ j ]); } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u7edf\u8ba1\u5168\u4e3a 1 \u7684\u6b63\u65b9\u5f62\u5b50\u77e9\u9635 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u77e9\u9635\uff0c\u73b0\u5728\u7edf\u8ba1\u51fa\u6240\u6709\u53ea\u7531 1 \u6784\u6210\u7684\u5b50\u65b9\u9635\u7684\u4e2a\u6570\u3002 \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \u77e9\u9635\u4e2d\u5171\u6709 15 \u4e2a\u5b50\u65b9\u9635\uff0810 \u4e2a 1 \\times 1 1 \\times 1 \uff0c4 \u4e2a 2 \\times 2 2 \\times 2 \uff0c1 \u4e2a 3 \\times 3 3 \\times 3 \uff09 \u300c\u5206\u6790\u300d \u540c\u4e0a\u4e00\u9898\u76ee\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u7528\u4e00\u4e2a\u6574\u578b\u53d8\u91cf\uff0c\u5728\u904d\u5386\u8fc7\u7a0b\u4e2d\uff0c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u8fb9\u957f\u5927\u4e8e 1 \u7684\u6b63\u65b9\u5f62\uff0c\u5373\u7edf\u8ba1\u5168 1 \u6b63\u65b9\u5f62\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ]) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans += dp [ j ]; } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u6700\u5927\u8fb9\u957f\u5168\u4e3a 0 \u7684\u6b63\u65b9\u5f62 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u65b9\u9635\uff0c\u5148\u6c42\u4e00\u4e2a\u6700\u5927\u7684\u5b50\u65b9\u9635\uff0c\u5176\u56db\u4e2a\u8fb9\u957f\u5168\u90e8\u7531 0 \u6784\u6210\uff0c\u5185\u90e8\u5143\u7d20\u65e0\u8981\u6c42\u3002\u8fd4\u56de\u7ed3\u679c\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u5f62\u5982 {r, c, len}\uff0c\u5176\u4e2d r \u6700\u5c0f\uff0c\u5982\u679c r \u76f8\u7b49\u7684\u60c5\u51b5\u4e0b\uff0c\u53d6 c \u6700\u5c0f\u7684\u89e3\u3002\u5982\u4e0b\u4f8b\u5b50 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dpRight[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u53f3\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\uff0cdpDown[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u4e0b\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\u3002\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \u4f46\u662f\u4e00\u4e2a\u77e9\u9635\u6709\u56db\u6761\u8fb9\uff0c\u6240\u6709\u9700\u8981\u8003\u8651\u4ece\uff08i\uff0cj\uff09\u8fc7\u6e21\u5230\uff08i+len-1\uff0cj+len-1\uff09\u3002\u90a3\u4e48\u5982\u4f55\u786e\u5b9a\u8fb9\u957f len \u5462\uff1f \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \u8fdb\u800c\u786e\u5b9a\u4e86\u5de6\u4e0b\u65b9\u548c\u53f3\u4e0a\u65b9\u7684\u70b9 (i+len-1\uff0cj)\u3001\uff08i\uff0cj+len-1\uff09\u3002\u7d27\u63a5\u7740\uff0c\u4ece\u5de6\u4e0b\u70b9\u5411\u53f3 len - 1 \u4e2a\u5355\u4f4d\u6216\u8005\u4ece\u53f3\u4e0a\u70b9\u5411\u4e0b len - 1 \u4e2a\u5355\u4f4d\u90fd\u4f1a\u5230\u8fbe\uff08i+len-1\uff0cj+len-1\uff09\uff0c\u53ea\u9700\u8981\u786e\u5b9a\u662f\u5426\u5b58\u5728\u8fd9\u6837\u7684 len\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector < int > findSquare ( vector < vector < int >>& matrix ) { vector < int > ans { - 1 , - 1 , 0 }; int n = ( int ) matrix . size (); if ( n == 0 ) { return ans ; } vector < vector < int >> dpRight ( n + 1 , vector < int > ( n + 1 , 0 )); vector < vector < int >> dpDown ( n + 1 , vector < int > ( n + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ] == 1 ) { dpRight [ i ][ j ] = dpDown [ i ][ j ] = 0 ; } else { dpRight [ i ][ j ] = dpRight [ i ][ j + 1 ] + 1 ; dpDown [ i ][ j ] = dpDown [ i + 1 ][ j ] + 1 ; int len = min ( dpRight [ i ][ j ], dpDown [ i ][ j ]); while ( len >= ans [ 2 ]) { if ( dpRight [ i + len - 1 ][ j ] >= len && dpDown [ i ][ j + len - 1 ] >= len ) { ans = { i , j , len }; break ; } len -- ; } } } } return ans [ 0 ] == - 1 && ans [ 1 ] == - 1 ? vector < int > {} : ans ; }","title":"\u77e9\u9635\u95ee\u9898"},{"location":"algo/dp/matrix/#_1","text":"","title":"\u5b50\u77e9\u9635"},{"location":"algo/dp/matrix/#_2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u6784\u6210\u7684\u77e9\u9635\uff0c\u6c42\u6700\u5927\u7684\u5168 1 \u5b50\u6b63\u65b9\u5f62\u3002\u4f8b\u5982 \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \u6700\u5927\u9762\u79ef\u4e3a 4\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u77e9\u9635\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ] == '1' ) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans = max ( ans , dp [ j ] * dp [ j ]); } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6700\u5927\u6b63\u65b9\u5f62"},{"location":"algo/dp/matrix/#1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u77e9\u9635\uff0c\u73b0\u5728\u7edf\u8ba1\u51fa\u6240\u6709\u53ea\u7531 1 \u6784\u6210\u7684\u5b50\u65b9\u9635\u7684\u4e2a\u6570\u3002 \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \u77e9\u9635\u4e2d\u5171\u6709 15 \u4e2a\u5b50\u65b9\u9635\uff0810 \u4e2a 1 \\times 1 1 \\times 1 \uff0c4 \u4e2a 2 \\times 2 2 \\times 2 \uff0c1 \u4e2a 3 \\times 3 3 \\times 3 \uff09 \u300c\u5206\u6790\u300d \u540c\u4e0a\u4e00\u9898\u76ee\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u7528\u4e00\u4e2a\u6574\u578b\u53d8\u91cf\uff0c\u5728\u904d\u5386\u8fc7\u7a0b\u4e2d\uff0c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u8fb9\u957f\u5927\u4e8e 1 \u7684\u6b63\u65b9\u5f62\uff0c\u5373\u7edf\u8ba1\u5168 1 \u6b63\u65b9\u5f62\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ]) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans += dp [ j ]; } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u7edf\u8ba1\u5168\u4e3a 1 \u7684\u6b63\u65b9\u5f62\u5b50\u77e9\u9635"},{"location":"algo/dp/matrix/#0","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u65b9\u9635\uff0c\u5148\u6c42\u4e00\u4e2a\u6700\u5927\u7684\u5b50\u65b9\u9635\uff0c\u5176\u56db\u4e2a\u8fb9\u957f\u5168\u90e8\u7531 0 \u6784\u6210\uff0c\u5185\u90e8\u5143\u7d20\u65e0\u8981\u6c42\u3002\u8fd4\u56de\u7ed3\u679c\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u5f62\u5982 {r, c, len}\uff0c\u5176\u4e2d r \u6700\u5c0f\uff0c\u5982\u679c r \u76f8\u7b49\u7684\u60c5\u51b5\u4e0b\uff0c\u53d6 c \u6700\u5c0f\u7684\u89e3\u3002\u5982\u4e0b\u4f8b\u5b50 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dpRight[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u53f3\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\uff0cdpDown[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u4e0b\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\u3002\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \u4f46\u662f\u4e00\u4e2a\u77e9\u9635\u6709\u56db\u6761\u8fb9\uff0c\u6240\u6709\u9700\u8981\u8003\u8651\u4ece\uff08i\uff0cj\uff09\u8fc7\u6e21\u5230\uff08i+len-1\uff0cj+len-1\uff09\u3002\u90a3\u4e48\u5982\u4f55\u786e\u5b9a\u8fb9\u957f len \u5462\uff1f \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \u8fdb\u800c\u786e\u5b9a\u4e86\u5de6\u4e0b\u65b9\u548c\u53f3\u4e0a\u65b9\u7684\u70b9 (i+len-1\uff0cj)\u3001\uff08i\uff0cj+len-1\uff09\u3002\u7d27\u63a5\u7740\uff0c\u4ece\u5de6\u4e0b\u70b9\u5411\u53f3 len - 1 \u4e2a\u5355\u4f4d\u6216\u8005\u4ece\u53f3\u4e0a\u70b9\u5411\u4e0b len - 1 \u4e2a\u5355\u4f4d\u90fd\u4f1a\u5230\u8fbe\uff08i+len-1\uff0cj+len-1\uff09\uff0c\u53ea\u9700\u8981\u786e\u5b9a\u662f\u5426\u5b58\u5728\u8fd9\u6837\u7684 len\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector < int > findSquare ( vector < vector < int >>& matrix ) { vector < int > ans { - 1 , - 1 , 0 }; int n = ( int ) matrix . size (); if ( n == 0 ) { return ans ; } vector < vector < int >> dpRight ( n + 1 , vector < int > ( n + 1 , 0 )); vector < vector < int >> dpDown ( n + 1 , vector < int > ( n + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ] == 1 ) { dpRight [ i ][ j ] = dpDown [ i ][ j ] = 0 ; } else { dpRight [ i ][ j ] = dpRight [ i ][ j + 1 ] + 1 ; dpDown [ i ][ j ] = dpDown [ i + 1 ][ j ] + 1 ; int len = min ( dpRight [ i ][ j ], dpDown [ i ][ j ]); while ( len >= ans [ 2 ]) { if ( dpRight [ i + len - 1 ][ j ] >= len && dpDown [ i ][ j + len - 1 ] >= len ) { ans = { i , j , len }; break ; } len -- ; } } } } return ans [ 0 ] == - 1 && ans [ 1 ] == - 1 ? vector < int > {} : ans ; }","title":"\u6700\u5927\u8fb9\u957f\u5168\u4e3a 0 \u7684\u6b63\u65b9\u5f62"},{"location":"algo/dp/path/","text":"\u65e0\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570 \u00b6 \u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u7f51\u683c\uff08i\uff0c j\uff09\uff0c\u80fd\u591f\u5230\u8fbe\u8fd9\u4e2a\u7f51\u683c\u53ea\u6709\u4e24\u4e2a\u4f4d\u7f6e\u5373\uff08i-1\uff0cj\uff09\u548c\uff08i\uff0cj+1\uff09\u3002\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u7684\u8def\u5f84\u6761\u6570\uff0c\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002\u6ce8\u610f\u5230\uff0c\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\u6761\u6570\u4e0e\u4ece\u53f3\u4e0b\u89d2\u5230\u5de6\u4e0a\u89d2\u7684\u8def\u5f84\u6761\u6570\u662f\u7b49\u4ef7\u7684\u3002 \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5f53\u524d\u7f51\u683c\u53ea\u4e0e\u4e0a\u65b9\u7f51\u683c\u548c\u5de6\u8fb9\u7f51\u683c\u6709\u5173\uff0c\u90a3\u4e48\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 1 2 3 4 5 6 7 8 9 10 vector < int > next ( n + 1 , 0 ), cur ( n + 1 , 0 ); next [ n - 1 ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { next [ j ] += cur [ j ] + next [ j + 1 ]; } cur = next ; next = vector < int > ( n + 1 , 0 ); } return cur [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u6709\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570 \u00b6 \u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u67d0\u4e9b\u7f51\u683c\u6709\u969c\u788d\uff0c\u673a\u5668\u4eba\u4e0d\u80fd\u5230\u8fbe\u8fd9\u4e9b\u969c\u788d\u6240\u5728\u7f51\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u540c\u6837\u5730\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u4e4b\u95f4\u5730\u6709\u6548\u8def\u5f84\u6761\u6570\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector < int > dp ( n , 0 ); if ( grid [ 0 ][ 0 ]) { return 0 ; } dp [ 0 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = dp [ j - 1 ] * ( 1 - grid [ 0 ][ j ]); } for ( int i = 1 ; i < m ; i ++ ) { vector < int > pre = dp ; dp [ 0 ] = pre [ 0 ] * ( 1 - grid [ i ][ 0 ]); for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = ( pre [ j ] + dp [ j - 1 ]) * ( 1 - grid [ i ][ j ]); } } return dp [ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u6700\u5c0f\u8def\u5f84\u548c \u00b6 \u4e00\u4e2a\u5305\u542b\u975e\u8d1f\u6574\u6570\u7684 m \\times n m \\times n \u7684\u7f51\u683c\uff0c\u627e\u51fa\u4e00\u6761\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\uff0c\u4f7f\u5f97\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u548c\u6700\u5c0f\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} 1 2 3 4 5 6 7 8 9 vector < int > dp ( n + 1 , INT_MAX ); dp [ n - 1 ] = 0 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = n - 1 ; j >= 0 ; j -- ) { dp [ j ] = min ( tmp [ j ], dp [ j + 1 ]) + grid [ i ][ j ]; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u505c\u5728\u539f\u5730\u7684\u65b9\u6848\u6570 \u00b6 \u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a arrLen \u7684\u6570\u7ec4\uff0c\u5f00\u59cb\u6709\u4e00\u4e2a\u6307\u9488\u5728\u7d22\u5f15 0 \u5904\u3002\u6bcf\u4e00\u6b65\u64cd\u4f5c\u4e2d\uff0c\u4f60\u53ef\u4ee5\u5c06\u6307\u9488\u5411\u5de6\u6216\u5411\u53f3\u79fb\u52a8 1 \u6b65\uff0c\u6216\u8005\u505c\u5728\u539f\u5730\uff08\u6307\u9488\u4e0d\u80fd\u88ab\u79fb\u52a8\u5230\u6570\u7ec4\u8303\u56f4\u5916\uff09\u3002\u6c42\u5728\u6070\u597d\u6267\u884c steps \u6b21\u64cd\u4f5c\u4ee5\u540e\uff0c\u6307\u9488\u4ecd\u7136\u6307\u5411\u7d22\u5f15 0 \u5904\u7684\u65b9\u6848\u6570\u3002\u4f8b\u5982 steps = 3, arrLen = 2\uff0c\u90a3\u4e48 3 \u6b65\u540e\uff0c\u603b\u5171\u6709 4 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5206\u522b\u662f\uff1a \u5411\u53f3\uff0c\u5411\u5de6\uff0c\u4e0d\u52a8 \u4e0d\u52a8\uff0c\u5411\u53f3\uff0c\u5411\u5de6 \u5411\u53f3\uff0c\u4e0d\u52a8\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8\uff0c\u4e0d\u52a8 \u300c\u5206\u6790\u300d \u8bbe dp[ k ][ i ] \u4e3a\u7ecf\u8fc7 k \u6b65\u540e\u8df3\u5230\u7b2c i \u4e2a\u4f4d\u7f6e\u65f6\u7684\u65b9\u6cd5\u6570\uff0c\u72b6\u6001\u8f6c\u79fb\u5982\u4e0b \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u72b6\u6001\u8f6c\u79fb\u53ea\u4f1a\u53d1\u751f\u5728\u76f8\u90bb\u4e24\u6b65\u548c\u76f8\u90bb\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u4e00\u4f4d\u6570\u7ec4\u4ee3\u66ff\u4e8c\u7ef4\u6570\u7ec4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int MOD = 1000000007 ; int n = min ( arrLen , steps / 2 + 1 ); vector < int > dp ( n , 0 ); dp [ 0 ] = 1 ; while ( steps -- ) { vector < int > tmp = dp ; for ( int i = 0 ; i < n ; i ++ ) { long a = i == 0 ? 0 : tmp [ i - 1 ]; long b = i == n - 1 ? 0 : tmp [ i + 1 ]; long c = tmp [ i ]; dp [ i ] = ( a + b + c ) % MOD ; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(k \\times n) O(k \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0ck \u4e3a\u79fb\u52a8\u7684\u6b65\u6570\uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002 \u6768\u8f89\u4e09\u89d2\u8def\u5f84\u6700\u5c0f\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u627e\u51fa\u81ea\u9876\u5411\u4e0b\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u6bcf\u4e00\u6b65\u53ea\u80fd\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\uff0c\u4e14\u4e0e\u5f53\u524d\u8282\u70b9\u76f8\u90bb\u7684\u8282\u70b9 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \u300c\u5206\u6790\u300d \u6bcf\u4e00\u4e2a\u5185\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e24\u4e2a\u8282\u70b9\u76f8\u8fde\uff0c\u6bcf\u4e00\u4e2a\u8fb9\u754c\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e00\u4e2a\u8282\u70b9\u76f8\u8fde\u3002\u8bbe dp[ i ][ j ] \u8868\u793a\u4ece\u9876\u70b9\u5230\uff08i\uff0cj\uff09\u70b9\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \u6211\u4eec\u53ef\u4ee5\u7531\u4e0a\u5230\u4e0b\u5199\u52a8\u6001\u89c4\u5212\u7684\u65b9\u7a0b\uff0c\u4e5f\u53ef\u4ee5\u53cd\u8fc7\u6765\u9012\u63a8\u3002\u6211\u4eec\u89c2\u5bdf\u5230\u5f53\u524d\u5c42\u53ea\u4e0e\u4e0b\u4e00\u5c42\u7684\u4e24\u4e2a\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u6b64\u53ea\u9700\u8981 O(n) O(n) \u7684\u7a7a\u95f4\u5373\u53ef\uff0c\u4f46\u5982\u679c\u7531\u4e0b\u5230\u4e0a\u9012\u63a8\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u52a9\u4f20\u5165\u77e9\u9635\uff0c\u4e0d\u5fc5\u5f00\u8f9f\u989d\u5916\u7684\u7a7a\u95f4\uff08\u672c\u9898\u8f83\u4e3a\u7279\u6b8a\uff09\u3002 1 2 3 4 5 6 7 8 for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { triangle [ i ][ j ] = min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) + triangle [ i ][ j ]; } } return triangle [ 0 ][ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u8def\u5f84\u95ee\u9898"},{"location":"algo/dp/path/#_1","text":"\u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u7f51\u683c\uff08i\uff0c j\uff09\uff0c\u80fd\u591f\u5230\u8fbe\u8fd9\u4e2a\u7f51\u683c\u53ea\u6709\u4e24\u4e2a\u4f4d\u7f6e\u5373\uff08i-1\uff0cj\uff09\u548c\uff08i\uff0cj+1\uff09\u3002\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u7684\u8def\u5f84\u6761\u6570\uff0c\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002\u6ce8\u610f\u5230\uff0c\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\u6761\u6570\u4e0e\u4ece\u53f3\u4e0b\u89d2\u5230\u5de6\u4e0a\u89d2\u7684\u8def\u5f84\u6761\u6570\u662f\u7b49\u4ef7\u7684\u3002 \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5f53\u524d\u7f51\u683c\u53ea\u4e0e\u4e0a\u65b9\u7f51\u683c\u548c\u5de6\u8fb9\u7f51\u683c\u6709\u5173\uff0c\u90a3\u4e48\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 1 2 3 4 5 6 7 8 9 10 vector < int > next ( n + 1 , 0 ), cur ( n + 1 , 0 ); next [ n - 1 ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { next [ j ] += cur [ j ] + next [ j + 1 ]; } cur = next ; next = vector < int > ( n + 1 , 0 ); } return cur [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u65e0\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570"},{"location":"algo/dp/path/#_2","text":"\u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u67d0\u4e9b\u7f51\u683c\u6709\u969c\u788d\uff0c\u673a\u5668\u4eba\u4e0d\u80fd\u5230\u8fbe\u8fd9\u4e9b\u969c\u788d\u6240\u5728\u7f51\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u540c\u6837\u5730\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u4e4b\u95f4\u5730\u6709\u6548\u8def\u5f84\u6761\u6570\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector < int > dp ( n , 0 ); if ( grid [ 0 ][ 0 ]) { return 0 ; } dp [ 0 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = dp [ j - 1 ] * ( 1 - grid [ 0 ][ j ]); } for ( int i = 1 ; i < m ; i ++ ) { vector < int > pre = dp ; dp [ 0 ] = pre [ 0 ] * ( 1 - grid [ i ][ 0 ]); for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = ( pre [ j ] + dp [ j - 1 ]) * ( 1 - grid [ i ][ j ]); } } return dp [ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6709\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570"},{"location":"algo/dp/path/#_3","text":"\u4e00\u4e2a\u5305\u542b\u975e\u8d1f\u6574\u6570\u7684 m \\times n m \\times n \u7684\u7f51\u683c\uff0c\u627e\u51fa\u4e00\u6761\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\uff0c\u4f7f\u5f97\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u548c\u6700\u5c0f\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} 1 2 3 4 5 6 7 8 9 vector < int > dp ( n + 1 , INT_MAX ); dp [ n - 1 ] = 0 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = n - 1 ; j >= 0 ; j -- ) { dp [ j ] = min ( tmp [ j ], dp [ j + 1 ]) + grid [ i ][ j ]; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6700\u5c0f\u8def\u5f84\u548c"},{"location":"algo/dp/path/#_4","text":"\u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a arrLen \u7684\u6570\u7ec4\uff0c\u5f00\u59cb\u6709\u4e00\u4e2a\u6307\u9488\u5728\u7d22\u5f15 0 \u5904\u3002\u6bcf\u4e00\u6b65\u64cd\u4f5c\u4e2d\uff0c\u4f60\u53ef\u4ee5\u5c06\u6307\u9488\u5411\u5de6\u6216\u5411\u53f3\u79fb\u52a8 1 \u6b65\uff0c\u6216\u8005\u505c\u5728\u539f\u5730\uff08\u6307\u9488\u4e0d\u80fd\u88ab\u79fb\u52a8\u5230\u6570\u7ec4\u8303\u56f4\u5916\uff09\u3002\u6c42\u5728\u6070\u597d\u6267\u884c steps \u6b21\u64cd\u4f5c\u4ee5\u540e\uff0c\u6307\u9488\u4ecd\u7136\u6307\u5411\u7d22\u5f15 0 \u5904\u7684\u65b9\u6848\u6570\u3002\u4f8b\u5982 steps = 3, arrLen = 2\uff0c\u90a3\u4e48 3 \u6b65\u540e\uff0c\u603b\u5171\u6709 4 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5206\u522b\u662f\uff1a \u5411\u53f3\uff0c\u5411\u5de6\uff0c\u4e0d\u52a8 \u4e0d\u52a8\uff0c\u5411\u53f3\uff0c\u5411\u5de6 \u5411\u53f3\uff0c\u4e0d\u52a8\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8\uff0c\u4e0d\u52a8 \u300c\u5206\u6790\u300d \u8bbe dp[ k ][ i ] \u4e3a\u7ecf\u8fc7 k \u6b65\u540e\u8df3\u5230\u7b2c i \u4e2a\u4f4d\u7f6e\u65f6\u7684\u65b9\u6cd5\u6570\uff0c\u72b6\u6001\u8f6c\u79fb\u5982\u4e0b \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u72b6\u6001\u8f6c\u79fb\u53ea\u4f1a\u53d1\u751f\u5728\u76f8\u90bb\u4e24\u6b65\u548c\u76f8\u90bb\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u4e00\u4f4d\u6570\u7ec4\u4ee3\u66ff\u4e8c\u7ef4\u6570\u7ec4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int MOD = 1000000007 ; int n = min ( arrLen , steps / 2 + 1 ); vector < int > dp ( n , 0 ); dp [ 0 ] = 1 ; while ( steps -- ) { vector < int > tmp = dp ; for ( int i = 0 ; i < n ; i ++ ) { long a = i == 0 ? 0 : tmp [ i - 1 ]; long b = i == n - 1 ? 0 : tmp [ i + 1 ]; long c = tmp [ i ]; dp [ i ] = ( a + b + c ) % MOD ; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(k \\times n) O(k \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0ck \u4e3a\u79fb\u52a8\u7684\u6b65\u6570\uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002","title":"\u505c\u5728\u539f\u5730\u7684\u65b9\u6848\u6570"},{"location":"algo/dp/path/#_5","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u627e\u51fa\u81ea\u9876\u5411\u4e0b\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u6bcf\u4e00\u6b65\u53ea\u80fd\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\uff0c\u4e14\u4e0e\u5f53\u524d\u8282\u70b9\u76f8\u90bb\u7684\u8282\u70b9 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \u300c\u5206\u6790\u300d \u6bcf\u4e00\u4e2a\u5185\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e24\u4e2a\u8282\u70b9\u76f8\u8fde\uff0c\u6bcf\u4e00\u4e2a\u8fb9\u754c\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e00\u4e2a\u8282\u70b9\u76f8\u8fde\u3002\u8bbe dp[ i ][ j ] \u8868\u793a\u4ece\u9876\u70b9\u5230\uff08i\uff0cj\uff09\u70b9\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \u6211\u4eec\u53ef\u4ee5\u7531\u4e0a\u5230\u4e0b\u5199\u52a8\u6001\u89c4\u5212\u7684\u65b9\u7a0b\uff0c\u4e5f\u53ef\u4ee5\u53cd\u8fc7\u6765\u9012\u63a8\u3002\u6211\u4eec\u89c2\u5bdf\u5230\u5f53\u524d\u5c42\u53ea\u4e0e\u4e0b\u4e00\u5c42\u7684\u4e24\u4e2a\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u6b64\u53ea\u9700\u8981 O(n) O(n) \u7684\u7a7a\u95f4\u5373\u53ef\uff0c\u4f46\u5982\u679c\u7531\u4e0b\u5230\u4e0a\u9012\u63a8\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u52a9\u4f20\u5165\u77e9\u9635\uff0c\u4e0d\u5fc5\u5f00\u8f9f\u989d\u5916\u7684\u7a7a\u95f4\uff08\u672c\u9898\u8f83\u4e3a\u7279\u6b8a\uff09\u3002 1 2 3 4 5 6 7 8 for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { triangle [ i ][ j ] = min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) + triangle [ i ][ j ]; } } return triangle [ 0 ][ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u6768\u8f89\u4e09\u89d2\u8def\u5f84\u6700\u5c0f\u548c"},{"location":"algo/dp/rob/","text":"\u6210\u6392 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4e00\u4e2a\u5c0f\u5077\u53ef\u4ee5\u5077\u53d6\u82e5\u5e72\u623f\u5c4b\u5185\u7684\u6240\u6709\u91d1\u94b1\uff0c\u4f46\u662f\u5077\u7a83\u7684\u623f\u5c4b\u4e0d\u80fd\u76f8\u90bb\uff0c\u6c42\u53ef\u4ee5\u83b7\u5f97\u6700\u5927\u91d1\u989d\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ 0 ] \u8868\u793a\u7b2c i \u4e2a\u623f\u5c4b\u6ca1\u6709\u88ab\u76d7\u7a83\uff0cdp[ i ][ 1 ] \u4e3a\u7b2c i \u4e2a\u623f\u5c4b\u88ab\u76d7\u7a83 \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} 1 2 3 4 5 6 7 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u6210\u73af \u00b6 \u540c\u6837\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4f46\u662f\u6570\u7ec4\u7684\u9996\u5c3e\u662f\u76f8\u8fde\u7684\uff0c\u6c42\u6b64\u65f6\u7684\u6700\u5927\u91d1\u989d \u300c\u5206\u6790\u300d \u6570\u7ec4\u6210\u73af\u7684\u72b6\u6001\u4e0b\uff0c\u9996\u5c3e\u5143\u7d20\u81f3\u5c11\u6709\u4e00\u4e2a\u4e0d\u4f1a\u88ab\u76d7\u7a83\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5206\u6210\u4e24\u79cd\u60c5\u51b5\uff1a\uff081\uff09\u4e0d\u9009\u62e9\u9996\u5143\u7d20\uff0c\uff082\uff09\u4e0d\u9009\u62e9\u5c3e\u5143\u7d20\u3002\u7531\u6b64\uff0c\u5c06\u4e00\u4e2a\u6210\u73af\u95ee\u9898\u8f6c\u6362\u6210\u4e24\u4e2a\u6210\u6392\u95ee\u9898\uff0c\u5404\u81ea\u7684\u89e3\u6cd5\u5982\u4e0a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n - 1 ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } int ans = max ( dp0 , dp1 ); dp0 = 0 ; dp1 = nums [ 1 ]; for ( int i = 2 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } ans = max ( ans , max ( dp0 , dp1 )); return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u6210\u6811 \u00b6 \u8fd9\u6b21\u7684\u623f\u5c4b\u6392\u5217\u6210\u4e00\u9897\u4e8c\u53c9\u6811\uff0c\u76f8\u90bb\u7684\u623f\u5c4b\u4e0d\u80fd\u540c\u65f6\u88ab\u76d7\u7a83\uff0c\u6c42\u6700\u5927\u91d1\u989d\u3002 \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \u6700\u5927\u91d1\u989d\u662f 10\u3002 \u300c\u5206\u6790\u300d \u6784\u6210\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u60c5\u51b5\u4e0b\uff0c\u5f53\u524d\u8282\u70b9\u53ea\u4e0e\u5de6\u53f3\u5b69\u5b50\u76f8\u5173\u8054\uff08\u81ea\u5e95\u5411\u4e0a\u904d\u5386\uff09\uff0c\u8bbe f[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u4e0d\u76d7\u7a83\uff0c t[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u88ab\u76d7\u7a83\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 unordered_map < TreeNode * , int > t , f ; int rob ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } rob ( root -> left ); rob ( root -> right ); t [ root ] = f [ root -> left ] + f [ root -> right ] + root -> val ; f [ root ] = max ( f [ root -> left ], t [ root -> left ]) + max ( f [ root -> right ], t [ root -> right ]); return max ( t [ root ], f [ root ]); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6253\u5bb6\u52ab\u820d"},{"location":"algo/dp/rob/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4e00\u4e2a\u5c0f\u5077\u53ef\u4ee5\u5077\u53d6\u82e5\u5e72\u623f\u5c4b\u5185\u7684\u6240\u6709\u91d1\u94b1\uff0c\u4f46\u662f\u5077\u7a83\u7684\u623f\u5c4b\u4e0d\u80fd\u76f8\u90bb\uff0c\u6c42\u53ef\u4ee5\u83b7\u5f97\u6700\u5927\u91d1\u989d\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ 0 ] \u8868\u793a\u7b2c i \u4e2a\u623f\u5c4b\u6ca1\u6709\u88ab\u76d7\u7a83\uff0cdp[ i ][ 1 ] \u4e3a\u7b2c i \u4e2a\u623f\u5c4b\u88ab\u76d7\u7a83 \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} 1 2 3 4 5 6 7 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u6210\u6392"},{"location":"algo/dp/rob/#_2","text":"\u540c\u6837\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4f46\u662f\u6570\u7ec4\u7684\u9996\u5c3e\u662f\u76f8\u8fde\u7684\uff0c\u6c42\u6b64\u65f6\u7684\u6700\u5927\u91d1\u989d \u300c\u5206\u6790\u300d \u6570\u7ec4\u6210\u73af\u7684\u72b6\u6001\u4e0b\uff0c\u9996\u5c3e\u5143\u7d20\u81f3\u5c11\u6709\u4e00\u4e2a\u4e0d\u4f1a\u88ab\u76d7\u7a83\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5206\u6210\u4e24\u79cd\u60c5\u51b5\uff1a\uff081\uff09\u4e0d\u9009\u62e9\u9996\u5143\u7d20\uff0c\uff082\uff09\u4e0d\u9009\u62e9\u5c3e\u5143\u7d20\u3002\u7531\u6b64\uff0c\u5c06\u4e00\u4e2a\u6210\u73af\u95ee\u9898\u8f6c\u6362\u6210\u4e24\u4e2a\u6210\u6392\u95ee\u9898\uff0c\u5404\u81ea\u7684\u89e3\u6cd5\u5982\u4e0a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n - 1 ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } int ans = max ( dp0 , dp1 ); dp0 = 0 ; dp1 = nums [ 1 ]; for ( int i = 2 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } ans = max ( ans , max ( dp0 , dp1 )); return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u6210\u73af"},{"location":"algo/dp/rob/#_3","text":"\u8fd9\u6b21\u7684\u623f\u5c4b\u6392\u5217\u6210\u4e00\u9897\u4e8c\u53c9\u6811\uff0c\u76f8\u90bb\u7684\u623f\u5c4b\u4e0d\u80fd\u540c\u65f6\u88ab\u76d7\u7a83\uff0c\u6c42\u6700\u5927\u91d1\u989d\u3002 \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \u6700\u5927\u91d1\u989d\u662f 10\u3002 \u300c\u5206\u6790\u300d \u6784\u6210\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u60c5\u51b5\u4e0b\uff0c\u5f53\u524d\u8282\u70b9\u53ea\u4e0e\u5de6\u53f3\u5b69\u5b50\u76f8\u5173\u8054\uff08\u81ea\u5e95\u5411\u4e0a\u904d\u5386\uff09\uff0c\u8bbe f[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u4e0d\u76d7\u7a83\uff0c t[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u88ab\u76d7\u7a83\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 unordered_map < TreeNode * , int > t , f ; int rob ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } rob ( root -> left ); rob ( root -> right ); t [ root ] = f [ root -> left ] + f [ root -> right ] + root -> val ; f [ root ] = max ( f [ root -> left ], t [ root -> left ]) + max ( f [ root -> right ], t [ root -> right ]); return max ( t [ root ], f [ root ]); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6210\u6811"},{"location":"algo/dp/segment/","text":"M\u4e2a\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6b63\u6574\u6570M\uff0c\u8fd4\u56denums\u6570\u7ec4\u4e2dM\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u5143\u7d20\u6700\u5927\u548c \u4f8b\u5982\uff1anums = [-1, 4, -2, 3, -2, 3]\uff0cM = 2\uff0c\u6700\u5927\u548c\u4e3a8 = [ 4 ] + [3, -2, 3] dp[ i ][ j ]\u8868\u793a\uff0c\u524dj\u4e2a\u5143\u7d20\u5728i\u4e2a\u5b50\u6570\u7ec4\u4e2d\u7684\u6700\u5927\u548c\uff0c\u5176\u4e2dnums[ j ]\u843d\u5728\u7b2ci\u4e2a\u5b50\u6570\u7ec4\uff081 <= i <= M\uff0ci <= j <= n\uff09 \u72b6\u6001\u8f6c\u79fb \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \u6ce8\u610f\u5230\u5f53\u524d\u72b6\u6001dp[ i ][ j ]\u53ea\u4e0edp[ i ][j - 1]\u3001dp[i - 1][ t ]\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u4e3a\u53ef\u4ee5\u4f7f\u7528O(n)\u7684\u7a7a\u95f4\uff0cpre[ j ]\u8868\u793a\u4e0a\u4e00\u5c42\u7684\u72b6\u6001\uff0ccur[ j ]\u8868\u793a\u5f53\u524d\u72b6\u6001 \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int maxMSum ( vector < int > nums , int M ) { int n = ( int ) nums . size (), maxSum = INT_MIN ; vector < int > cur ( n + 1 , 0 ), pre ( n + 1 , 0 ); for ( int i = 1 ; i <= M ; i ++ ) { maxSum = INT_MIN ; for ( int j = i ; j <= n ; j ++ ) { cur [ j ] = max ( pre [ j - 1 ], cur [ j - 1 ]) + nums [ j - 1 ]; pre [ j - 1 ] = maxSum ; maxSum = max ( maxSum , cur [ j ]); } pre [ n ] = maxSum ; } return maxSum ; } \u5f53M = 1\u65f6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < int > getMaxSumEpisode ( vector < int > nums ) { int n = int ( nums . size ()); vector < int > ans ; if ( n == 0 ) { return ans ; } int maxSum = - ( 1ll << 31 ), curSum = 0 ; int left = 0 , right = 0 , begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; begin = i ; } if ( maxSum < curSum ) { maxSum = curSum ; left = begin ; right = i ; } } for ( int i = left ; i <= right ; i ++ ) { ans . push_back ( nums [ i ]); } return ans ; } \u4efb\u610f\u5b50\u6570\u7ec4\u548c\u7684\u7edd\u5bf9\u503c\u7684\u6700\u5927\u503c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u6c42\u5176\u5b50\u6570\u7ec4\uff08\u8fde\u7eed\uff09\u548c\u7684\u7edd\u5bf9\u503c\u6700\u5927\u503c\u3002e.g. A = [-3,-5,-3,-2,-6,3,10,-10,-8,-3]\uff0c\u5b50\u6570\u7ec4\u548c\u7684\u7edd\u5bf9\u503c\u6700\u5927\u4e3a27\u3002 \u300c\u5206\u6790\u300d \u7edd\u5bf9\u503c\u6700\u5927\u8868\u793a\u4e3a\u6700\u5927\u503c\u6216\u8005\u6700\u5c0f\u503c\u5176\u4e2d\u4e4b\u4e00\u6700\u5927\u3002\u53ef\u4ee5\u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\u6c42\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c+\u6700\u5c0f\u548c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int maxAbsoluteSum ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int sum1 = 0 , sum2 = 0 , maxSum = INT_MIN , minSum = INT_MAX ; for ( int num : nums ) { if ( sum1 > 0 ) { sum1 += num ; } else { sum1 = num ; } if ( maxSum < sum1 ) { maxSum = sum1 ; } if ( sum2 < 0 ) { sum2 += num ; } else { sum2 = num ; } if ( minSum > sum2 ) { minSum = sum2 ; } } return max ( maxSum , - minSum ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8bf7\u4f60\u627e\u51fa\u6570\u7ec4\u4e2d\u4e58\u79ef\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u8be5\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u6570\u5b57\uff09\uff0c\u5e76\u8fd4\u56de\u8be5\u5b50\u6570\u7ec4\u6240\u5bf9\u5e94\u7684\u4e58\u79ef\u3002\u8f93\u5165: [2,3,-2,4]\u3002\u8f93\u51fa: 6\u3002\u89e3\u91ca: \u5b50\u6570\u7ec4 [2,3] \u6709\u6700\u5927\u4e58\u79ef 6\u3002 1 2 3 4 5 6 7 8 9 10 11 int maxProduct ( vector < int >& nums ) { int n = int ( nums . size ()); int minF = nums [ 0 ], maxF = nums [ 0 ], ans = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _min = minF , _max = maxF ; minF = min ( nums [ i ], min ( _min * nums [ i ], _max * nums [ i ])); maxF = max ( nums [ i ], max ( _min * nums [ i ], _max * nums [ i ])); ans = max ( ans , maxF ); } return ans ; } \u5b50\u6570\u7ec4\u957f\u5ea6\u4e0d\u8d85\u8fc7 k \u7684\u6700\u5927\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 15, 7, 9, 2, 5, 10] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0c\u8868\u793a\u5c06\u6570\u7ec4\u5206\u6210\u82e5\u5e72\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\uff0c\u4f46\u662f\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7 k\uff0c\u5206\u5272\u540e\u7684\u5b50\u6570\u7ec4\u7edf\u7edf\u53d8\u6210\u5b50\u6570\u7ec4\u7684\u6700\u5927\u503c\uff0c\u6c42\u53d8\u5316\u540e\u7684\u6570\u7ec4\u548c\u3002\u4e0a\u4f8b\u5bf9\u5e94\u7684\u7b54\u6848\u662f [15, 15, 15, 9, 10, 10, 10]\uff0c\u6570\u7ec4\u548c\u662f 84\u3002 \u300c\u5206\u6790\u300d \u5bf9\u6bcf\u4e00\u4e2a\u6570\u7ec4\u5143\u7d20\u6765\u8bf4\uff0c\u5b83\u53ea\u80fd\u5904\u4e8e\u4e00\u4e2a\u533a\u95f4\u5185\u3002\u8bbe dp[ i ] \u8868\u793a\u4ece\u7b2c i \u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u5728\u9898\u76ee\u89c4\u5219\u4e0b\uff0c\u53ef\u4ee5\u5f97\u5230\u7684\u6700\u5927\u548c\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ]} = \\max_{j \\in [i, i + k)} \\{ \\text{dp[j + 1] + (j - i + 1) * } \\max(\\text{A[i : j]}) \\} \\text{dp[ i ]} = \\max_{j \\in [i, i + k)} \\{ \\text{dp[j + 1] + (j - i + 1) * } \\max(\\text{A[i : j]}) \\} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxSumAfterPartitioning ( vector < int >& arr , int k ) { int n = ( int ) arr . size (); if ( n <= k ) { return * max_element ( arr . begin (), arr . end ()) * n ; } vector < int > dp ( n + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { int _max = INT_MIN ; for ( int j = i ; j < min ( n , i + k ); j ++ ) { _max = max ( _max , arr [ j ]); dp [ i ] = max ( dp [ i ], dp [ j + 1 ] + _max * ( j - i + 1 )); } } return dp [ 0 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(kn) O(kn) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cn \u662f\u6570\u7ec4\u7684\u957f\u5ea6\u3002 \u5206\u5272\u6210 m \u4e2a\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c\u6700\u5c0f\u503c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \u548c\u4e00\u4e2a\u6574\u6570 m \uff0c\u4f60\u9700\u8981\u5c06\u8fd9\u4e2a\u6570\u7ec4\u5206\u6210 m \u4e2a\u975e\u7a7a\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u3002\u8bd5\u95ee\u8fd9 m \u4e2a\u5b50\u6570\u7ec4\u5404\u81ea\u548c\u7684\u6700\u5927\u503c\u6700\u5c0f\u3002 \u300c\u5206\u6790\u300d \u201c\u5c06\u6570\u7ec4\u5212\u5206\u6210 m \u4e2a\u5b50\u6570\u7ec4\u201d\u662f\u3010\u52a8\u6001\u89c4\u5212\u3011\u7684\u5e38\u89c1\u95ee\u6cd5\u3002\u8bbe dp[ i ][ j ] \u5c06\u6570\u7ec4 [i: end] \u7684\u6240\u6709\u5143\u7d20\u5212\u5206\u6210 j \u6bb5\u65f6\uff0c\u6240\u6709 j \u6bb5\u548c\u7684\u6700\u5c0f\u503c\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\text{dp[ i ][ j ]} = \\min_{k \\in (i, \\text{end}]} \\{ \\text{dp[ k ][j - 1]}, \\sum_{t = i}^{k - 1} \\text{A[ t ]} \\} \\text{dp[ i ][ j ]} = \\min_{k \\in (i, \\text{end}]} \\{ \\text{dp[ k ][j - 1]}, \\sum_{t = i}^{k - 1} \\text{A[ t ]} \\} \u8fd9\u91cc\uff0c\u6211\u4eec\u8ba4\u4e3a\u7b2c i \u4e2a\u5143\u7d20\u662f\u5c5e\u4e8e\u7b2c j \u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u4ece [i + 1, end] \u904d\u5386\u5207\u5206\u70b9 k\uff0c\u4f7f\u5f97 [i, k] \u5c5e\u4e8e j \u533a\u95f4\uff0c[k + 1, end] \u5c5e\u4e8e\u524d j - 1 \u4e2a\u533a\u95f4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int splitArray ( vector < int >& nums , int m ) { int n = ( int ) nums . size (); vector < vector < int >> dp ( n + 1 , vector < int > ( m + 1 , INT_MAX )); vector < int > sum ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { sum [ i + 1 ] = sum [ i ] + nums [ i ]; } dp [ n ][ 0 ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= min ( m , n - i ); j ++ ) { for ( int k = n ; k > i ; k -- ) { dp [ i ][ j ] = min ( dp [ i ][ j ], max ( dp [ k ][ j - 1 ], sum [ k ] - sum [ i ])); } } } return dp [ 0 ][ m ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}m) O(n^{2}m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \u201c\u4f7f...\u7684\u6700\u5927\u503c\u6700\u5c0f\u201d\u662f\u3010\u4e8c\u5206\u6cd5\u3011\u7684\u5e38\u89c1\u95ee\u6cd5\u3002\u5982\u679c\u6211\u4eec\u9009\u53d6\u4e00\u4e2a\u6570 val \u6700\u4e3a\u5212\u5206\u503c\uff0c\u540c\u4e00\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u4e0d\u8d85\u8fc7 val\uff0c\u5982\u679c val \u8f83\u5c0f\uff0c\u6240\u5f97\u7684\u5b50\u6570\u7ec4\u4e2a\u6570\u4f1a\u8d85\u8fc7 m\uff1b\u53cd\u4e4b\uff0c\u5b50\u6570\u7ec4\u4e2a\u6570\u4e0d\u8db3 m\u3002\u7531\u6b64\u6211\u4eec\u5f97\u5230\u4e00\u4e2a\u5355\u8c03\u5e8f\u5217\uff0c\u53ef\u4ee5\u4f7f\u7528\u3010\u4e8c\u5206\u6cd5\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int splitArray ( vector < int >& nums , int m ) { int r = 0 , l = 0 ; for ( int num : nums ) { r += num ; l = max ( l , num ); } while ( l < r ) { int val = ( l + r ) >> 1 ; int segs = 1 , tot = 0 ; for ( int num : nums ) { if ( tot + num > val ) { tot = num ; segs ++ ; } else { tot += num ; } } if ( segs > m ) { l = val + 1 ; } else { r = val ; } } return l ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log (sum - max)) O(n \\log (sum - max)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0csum \u8868\u793a\u6570\u7ec4\u7684\u548c\uff0cmax \u8868\u793a\u6570\u7ec4\u7684\u6700\u5927\u503c \u5220\u9664\u4e00\u6b21\u5f97\u5230\u5b50\u6570\u7ec4\u6700\u5927\u548c \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u67d0\u4e2a\u975e\u7a7a\u5b50\u6570\u7ec4\uff08\u8fde\u7eed\u5143\u7d20\uff09\u5728\u6267\u884c\u4e00\u6b21\u53ef\u9009\u7684\u5220\u9664\u64cd\u4f5c\u540e\uff0c\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u5143\u7d20\u603b\u548c\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u53ef\u4ee5\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u51fa\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5e76\u53ef\u4ee5\u51b3\u5b9a\u8981\u4e0d\u8981\u4ece\u4e2d\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff08\u53ea\u80fd\u5220\u4e00\u6b21\u54e6\uff09\uff0c\uff08\u5220\u9664\u540e\uff09\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5e94\u5f53\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8be5\u5b50\u6570\u7ec4\uff08\u5269\u4e0b\uff09\u7684\u5143\u7d20\u603b\u548c\u662f\u6240\u6709\u5b50\u6570\u7ec4\u4e4b\u4e2d\u6700\u5927\u7684\u3002\u6ce8\u610f\uff0c\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u5b50\u6570\u7ec4 \u4e0d\u80fd\u4e3a\u7a7a\u3002e.g. A = [1,-2,0,3]\uff0c\u6700\u5927\u5b50\u6570\u7ec4\u548c\u662f 4\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ k ] \u662f\u6570\u7ec4\u5728\u7b2c i \u5904\u7ed3\u5c3e\u65f6\uff0c\u6070\u597d\u5220\u6389\u4e86 k \u4e2a\u5143\u7d20\u7684\u6700\u5927\u5b50\u6570\u7ec4\u4e4b\u548c\uff0c\u8fd9\u91cc k \u53ea\u80fd\u53d6 0 \u548c 1\u3002\u72b6\u6001 dp[ i ][ 1 ] \u7684\u4e0a\u6e38\u72b6\u6001\u662f dp[i - 1][ 0 ] \u548c dp[i - 1][ 1 ] + A[ i ]\uff0c\u8868\u793a i - 1 \u65f6\u5220\u4e86\u4e00\u4e2a\u540e\uff0ci \u5904\u7684\u5143\u7d20\u9700\u8981\u52a0\u4e0a\uff1b\u53cd\u4e4b\u5219\u4e0d\u52a0\u3002\u72b6\u6001 dp[ i ][ 0 ] \u7684\u4e0a\u6e38\u72b6\u6001\u662f dp[i - 1][ 0 ] + A[ i ] \u548c A[ i ]\u3002\u72b6\u6001\u8f6c\u79fb\u5982\u4e0b\uff1a \\begin{aligned} & dp[i][0] = \\max(dp[i-1][0], 0) + A[i] \\\\ & dp[i][1] = \\max(dp[i-1][0], dp[i-1][1] + A[i]) \\end{aligned} \\begin{aligned} & dp[i][0] = \\max(dp[i-1][0], 0) + A[i] \\\\ & dp[i][1] = \\max(dp[i-1][0], dp[i-1][1] + A[i]) \\end{aligned} \u8fd9\u91cc\u53ef\u80fd\u6709\u7591\u95ee\uff0c\u4e3a\u4ec0\u4e48 dp[ i ][ 1 ] \u4e0d\u53ef\u4ee5\u4ece i \u5904\u5355\u72ec\u5f00\u59cb\u5462\uff1f\u56e0\u4e3a dp[ i ][ 1 ] \u8868\u793a\u5fc5\u987b\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff0c\u800c\u9898\u76ee\u8981\u6c42\u4e00\u4e2a\u5143\u7d20\u65f6\u4e0d\u80fd\u5220\u9664\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int maximumSum ( vector < int >& arr ) { if ( arr . empty ()) { return 0 ; } int dp0 = arr [ 0 ], dp1 = 0 , ans = dp0 ; for ( int i = 1 ; i < arr . size (); i ++ ) { dp1 = max ( dp0 , dp1 + arr [ i ]); dp0 = max ( dp0 , 0 ) + arr [ i ]; ans = max ( max ( dp0 , dp1 ), ans ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u5212\u5206\u533a\u95f4"},{"location":"algo/dp/segment/#m","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6b63\u6574\u6570M\uff0c\u8fd4\u56denums\u6570\u7ec4\u4e2dM\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u5143\u7d20\u6700\u5927\u548c \u4f8b\u5982\uff1anums = [-1, 4, -2, 3, -2, 3]\uff0cM = 2\uff0c\u6700\u5927\u548c\u4e3a8 = [ 4 ] + [3, -2, 3] dp[ i ][ j ]\u8868\u793a\uff0c\u524dj\u4e2a\u5143\u7d20\u5728i\u4e2a\u5b50\u6570\u7ec4\u4e2d\u7684\u6700\u5927\u548c\uff0c\u5176\u4e2dnums[ j ]\u843d\u5728\u7b2ci\u4e2a\u5b50\u6570\u7ec4\uff081 <= i <= M\uff0ci <= j <= n\uff09 \u72b6\u6001\u8f6c\u79fb \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \u6ce8\u610f\u5230\u5f53\u524d\u72b6\u6001dp[ i ][ j ]\u53ea\u4e0edp[ i ][j - 1]\u3001dp[i - 1][ t ]\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u4e3a\u53ef\u4ee5\u4f7f\u7528O(n)\u7684\u7a7a\u95f4\uff0cpre[ j ]\u8868\u793a\u4e0a\u4e00\u5c42\u7684\u72b6\u6001\uff0ccur[ j ]\u8868\u793a\u5f53\u524d\u72b6\u6001 \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int maxMSum ( vector < int > nums , int M ) { int n = ( int ) nums . size (), maxSum = INT_MIN ; vector < int > cur ( n + 1 , 0 ), pre ( n + 1 , 0 ); for ( int i = 1 ; i <= M ; i ++ ) { maxSum = INT_MIN ; for ( int j = i ; j <= n ; j ++ ) { cur [ j ] = max ( pre [ j - 1 ], cur [ j - 1 ]) + nums [ j - 1 ]; pre [ j - 1 ] = maxSum ; maxSum = max ( maxSum , cur [ j ]); } pre [ n ] = maxSum ; } return maxSum ; } \u5f53M = 1\u65f6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < int > getMaxSumEpisode ( vector < int > nums ) { int n = int ( nums . size ()); vector < int > ans ; if ( n == 0 ) { return ans ; } int maxSum = - ( 1ll << 31 ), curSum = 0 ; int left = 0 , right = 0 , begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; begin = i ; } if ( maxSum < curSum ) { maxSum = curSum ; left = begin ; right = i ; } } for ( int i = left ; i <= right ; i ++ ) { ans . push_back ( nums [ i ]); } return ans ; }","title":"M\u4e2a\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c"},{"location":"algo/dp/segment/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u6c42\u5176\u5b50\u6570\u7ec4\uff08\u8fde\u7eed\uff09\u548c\u7684\u7edd\u5bf9\u503c\u6700\u5927\u503c\u3002e.g. A = [-3,-5,-3,-2,-6,3,10,-10,-8,-3]\uff0c\u5b50\u6570\u7ec4\u548c\u7684\u7edd\u5bf9\u503c\u6700\u5927\u4e3a27\u3002 \u300c\u5206\u6790\u300d \u7edd\u5bf9\u503c\u6700\u5927\u8868\u793a\u4e3a\u6700\u5927\u503c\u6216\u8005\u6700\u5c0f\u503c\u5176\u4e2d\u4e4b\u4e00\u6700\u5927\u3002\u53ef\u4ee5\u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\u6c42\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c+\u6700\u5c0f\u548c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int maxAbsoluteSum ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int sum1 = 0 , sum2 = 0 , maxSum = INT_MIN , minSum = INT_MAX ; for ( int num : nums ) { if ( sum1 > 0 ) { sum1 += num ; } else { sum1 = num ; } if ( maxSum < sum1 ) { maxSum = sum1 ; } if ( sum2 < 0 ) { sum2 += num ; } else { sum2 = num ; } if ( minSum > sum2 ) { minSum = sum2 ; } } return max ( maxSum , - minSum ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u4efb\u610f\u5b50\u6570\u7ec4\u548c\u7684\u7edd\u5bf9\u503c\u7684\u6700\u5927\u503c"},{"location":"algo/dp/segment/#_2","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8bf7\u4f60\u627e\u51fa\u6570\u7ec4\u4e2d\u4e58\u79ef\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u8be5\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u6570\u5b57\uff09\uff0c\u5e76\u8fd4\u56de\u8be5\u5b50\u6570\u7ec4\u6240\u5bf9\u5e94\u7684\u4e58\u79ef\u3002\u8f93\u5165: [2,3,-2,4]\u3002\u8f93\u51fa: 6\u3002\u89e3\u91ca: \u5b50\u6570\u7ec4 [2,3] \u6709\u6700\u5927\u4e58\u79ef 6\u3002 1 2 3 4 5 6 7 8 9 10 11 int maxProduct ( vector < int >& nums ) { int n = int ( nums . size ()); int minF = nums [ 0 ], maxF = nums [ 0 ], ans = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _min = minF , _max = maxF ; minF = min ( nums [ i ], min ( _min * nums [ i ], _max * nums [ i ])); maxF = max ( nums [ i ], max ( _min * nums [ i ], _max * nums [ i ])); ans = max ( ans , maxF ); } return ans ; }","title":"\u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4"},{"location":"algo/dp/segment/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [1, 15, 7, 9, 2, 5, 10] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0c\u8868\u793a\u5c06\u6570\u7ec4\u5206\u6210\u82e5\u5e72\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\uff0c\u4f46\u662f\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7 k\uff0c\u5206\u5272\u540e\u7684\u5b50\u6570\u7ec4\u7edf\u7edf\u53d8\u6210\u5b50\u6570\u7ec4\u7684\u6700\u5927\u503c\uff0c\u6c42\u53d8\u5316\u540e\u7684\u6570\u7ec4\u548c\u3002\u4e0a\u4f8b\u5bf9\u5e94\u7684\u7b54\u6848\u662f [15, 15, 15, 9, 10, 10, 10]\uff0c\u6570\u7ec4\u548c\u662f 84\u3002 \u300c\u5206\u6790\u300d \u5bf9\u6bcf\u4e00\u4e2a\u6570\u7ec4\u5143\u7d20\u6765\u8bf4\uff0c\u5b83\u53ea\u80fd\u5904\u4e8e\u4e00\u4e2a\u533a\u95f4\u5185\u3002\u8bbe dp[ i ] \u8868\u793a\u4ece\u7b2c i \u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u5728\u9898\u76ee\u89c4\u5219\u4e0b\uff0c\u53ef\u4ee5\u5f97\u5230\u7684\u6700\u5927\u548c\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ]} = \\max_{j \\in [i, i + k)} \\{ \\text{dp[j + 1] + (j - i + 1) * } \\max(\\text{A[i : j]}) \\} \\text{dp[ i ]} = \\max_{j \\in [i, i + k)} \\{ \\text{dp[j + 1] + (j - i + 1) * } \\max(\\text{A[i : j]}) \\} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxSumAfterPartitioning ( vector < int >& arr , int k ) { int n = ( int ) arr . size (); if ( n <= k ) { return * max_element ( arr . begin (), arr . end ()) * n ; } vector < int > dp ( n + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { int _max = INT_MIN ; for ( int j = i ; j < min ( n , i + k ); j ++ ) { _max = max ( _max , arr [ j ]); dp [ i ] = max ( dp [ i ], dp [ j + 1 ] + _max * ( j - i + 1 )); } } return dp [ 0 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(kn) O(kn) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cn \u662f\u6570\u7ec4\u7684\u957f\u5ea6\u3002","title":"\u5b50\u6570\u7ec4\u957f\u5ea6\u4e0d\u8d85\u8fc7 k \u7684\u6700\u5927\u548c"},{"location":"algo/dp/segment/#m_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \u548c\u4e00\u4e2a\u6574\u6570 m \uff0c\u4f60\u9700\u8981\u5c06\u8fd9\u4e2a\u6570\u7ec4\u5206\u6210 m \u4e2a\u975e\u7a7a\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u3002\u8bd5\u95ee\u8fd9 m \u4e2a\u5b50\u6570\u7ec4\u5404\u81ea\u548c\u7684\u6700\u5927\u503c\u6700\u5c0f\u3002 \u300c\u5206\u6790\u300d \u201c\u5c06\u6570\u7ec4\u5212\u5206\u6210 m \u4e2a\u5b50\u6570\u7ec4\u201d\u662f\u3010\u52a8\u6001\u89c4\u5212\u3011\u7684\u5e38\u89c1\u95ee\u6cd5\u3002\u8bbe dp[ i ][ j ] \u5c06\u6570\u7ec4 [i: end] \u7684\u6240\u6709\u5143\u7d20\u5212\u5206\u6210 j \u6bb5\u65f6\uff0c\u6240\u6709 j \u6bb5\u548c\u7684\u6700\u5c0f\u503c\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\text{dp[ i ][ j ]} = \\min_{k \\in (i, \\text{end}]} \\{ \\text{dp[ k ][j - 1]}, \\sum_{t = i}^{k - 1} \\text{A[ t ]} \\} \\text{dp[ i ][ j ]} = \\min_{k \\in (i, \\text{end}]} \\{ \\text{dp[ k ][j - 1]}, \\sum_{t = i}^{k - 1} \\text{A[ t ]} \\} \u8fd9\u91cc\uff0c\u6211\u4eec\u8ba4\u4e3a\u7b2c i \u4e2a\u5143\u7d20\u662f\u5c5e\u4e8e\u7b2c j \u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u4ece [i + 1, end] \u904d\u5386\u5207\u5206\u70b9 k\uff0c\u4f7f\u5f97 [i, k] \u5c5e\u4e8e j \u533a\u95f4\uff0c[k + 1, end] \u5c5e\u4e8e\u524d j - 1 \u4e2a\u533a\u95f4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int splitArray ( vector < int >& nums , int m ) { int n = ( int ) nums . size (); vector < vector < int >> dp ( n + 1 , vector < int > ( m + 1 , INT_MAX )); vector < int > sum ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { sum [ i + 1 ] = sum [ i ] + nums [ i ]; } dp [ n ][ 0 ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= min ( m , n - i ); j ++ ) { for ( int k = n ; k > i ; k -- ) { dp [ i ][ j ] = min ( dp [ i ][ j ], max ( dp [ k ][ j - 1 ], sum [ k ] - sum [ i ])); } } } return dp [ 0 ][ m ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}m) O(n^{2}m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \u201c\u4f7f...\u7684\u6700\u5927\u503c\u6700\u5c0f\u201d\u662f\u3010\u4e8c\u5206\u6cd5\u3011\u7684\u5e38\u89c1\u95ee\u6cd5\u3002\u5982\u679c\u6211\u4eec\u9009\u53d6\u4e00\u4e2a\u6570 val \u6700\u4e3a\u5212\u5206\u503c\uff0c\u540c\u4e00\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u4e0d\u8d85\u8fc7 val\uff0c\u5982\u679c val \u8f83\u5c0f\uff0c\u6240\u5f97\u7684\u5b50\u6570\u7ec4\u4e2a\u6570\u4f1a\u8d85\u8fc7 m\uff1b\u53cd\u4e4b\uff0c\u5b50\u6570\u7ec4\u4e2a\u6570\u4e0d\u8db3 m\u3002\u7531\u6b64\u6211\u4eec\u5f97\u5230\u4e00\u4e2a\u5355\u8c03\u5e8f\u5217\uff0c\u53ef\u4ee5\u4f7f\u7528\u3010\u4e8c\u5206\u6cd5\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int splitArray ( vector < int >& nums , int m ) { int r = 0 , l = 0 ; for ( int num : nums ) { r += num ; l = max ( l , num ); } while ( l < r ) { int val = ( l + r ) >> 1 ; int segs = 1 , tot = 0 ; for ( int num : nums ) { if ( tot + num > val ) { tot = num ; segs ++ ; } else { tot += num ; } } if ( segs > m ) { l = val + 1 ; } else { r = val ; } } return l ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log (sum - max)) O(n \\log (sum - max)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0csum \u8868\u793a\u6570\u7ec4\u7684\u548c\uff0cmax \u8868\u793a\u6570\u7ec4\u7684\u6700\u5927\u503c","title":"\u5206\u5272\u6210 m \u4e2a\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c\u6700\u5c0f\u503c"},{"location":"algo/dp/segment/#_3","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u67d0\u4e2a\u975e\u7a7a\u5b50\u6570\u7ec4\uff08\u8fde\u7eed\u5143\u7d20\uff09\u5728\u6267\u884c\u4e00\u6b21\u53ef\u9009\u7684\u5220\u9664\u64cd\u4f5c\u540e\uff0c\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u5143\u7d20\u603b\u548c\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u53ef\u4ee5\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u51fa\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5e76\u53ef\u4ee5\u51b3\u5b9a\u8981\u4e0d\u8981\u4ece\u4e2d\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff08\u53ea\u80fd\u5220\u4e00\u6b21\u54e6\uff09\uff0c\uff08\u5220\u9664\u540e\uff09\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5e94\u5f53\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8be5\u5b50\u6570\u7ec4\uff08\u5269\u4e0b\uff09\u7684\u5143\u7d20\u603b\u548c\u662f\u6240\u6709\u5b50\u6570\u7ec4\u4e4b\u4e2d\u6700\u5927\u7684\u3002\u6ce8\u610f\uff0c\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u5b50\u6570\u7ec4 \u4e0d\u80fd\u4e3a\u7a7a\u3002e.g. A = [1,-2,0,3]\uff0c\u6700\u5927\u5b50\u6570\u7ec4\u548c\u662f 4\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ k ] \u662f\u6570\u7ec4\u5728\u7b2c i \u5904\u7ed3\u5c3e\u65f6\uff0c\u6070\u597d\u5220\u6389\u4e86 k \u4e2a\u5143\u7d20\u7684\u6700\u5927\u5b50\u6570\u7ec4\u4e4b\u548c\uff0c\u8fd9\u91cc k \u53ea\u80fd\u53d6 0 \u548c 1\u3002\u72b6\u6001 dp[ i ][ 1 ] \u7684\u4e0a\u6e38\u72b6\u6001\u662f dp[i - 1][ 0 ] \u548c dp[i - 1][ 1 ] + A[ i ]\uff0c\u8868\u793a i - 1 \u65f6\u5220\u4e86\u4e00\u4e2a\u540e\uff0ci \u5904\u7684\u5143\u7d20\u9700\u8981\u52a0\u4e0a\uff1b\u53cd\u4e4b\u5219\u4e0d\u52a0\u3002\u72b6\u6001 dp[ i ][ 0 ] \u7684\u4e0a\u6e38\u72b6\u6001\u662f dp[i - 1][ 0 ] + A[ i ] \u548c A[ i ]\u3002\u72b6\u6001\u8f6c\u79fb\u5982\u4e0b\uff1a \\begin{aligned} & dp[i][0] = \\max(dp[i-1][0], 0) + A[i] \\\\ & dp[i][1] = \\max(dp[i-1][0], dp[i-1][1] + A[i]) \\end{aligned} \\begin{aligned} & dp[i][0] = \\max(dp[i-1][0], 0) + A[i] \\\\ & dp[i][1] = \\max(dp[i-1][0], dp[i-1][1] + A[i]) \\end{aligned} \u8fd9\u91cc\u53ef\u80fd\u6709\u7591\u95ee\uff0c\u4e3a\u4ec0\u4e48 dp[ i ][ 1 ] \u4e0d\u53ef\u4ee5\u4ece i \u5904\u5355\u72ec\u5f00\u59cb\u5462\uff1f\u56e0\u4e3a dp[ i ][ 1 ] \u8868\u793a\u5fc5\u987b\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff0c\u800c\u9898\u76ee\u8981\u6c42\u4e00\u4e2a\u5143\u7d20\u65f6\u4e0d\u80fd\u5220\u9664\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int maximumSum ( vector < int >& arr ) { if ( arr . empty ()) { return 0 ; } int dp0 = arr [ 0 ], dp1 = 0 , ans = dp0 ; for ( int i = 1 ; i < arr . size (); i ++ ) { dp1 = max ( dp0 , dp1 + arr [ i ]); dp0 = max ( dp0 , 0 ) + arr [ i ]; ans = max ( max ( dp0 , dp1 ), ans ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u5220\u9664\u4e00\u6b21\u5f97\u5230\u5b50\u6570\u7ec4\u6700\u5927\u548c"},{"location":"algo/dp/sequence/","text":"\u57fa\u7840 \u00b6 \u5e8f\u5217\u578b\u52a8\u6001\u89c4\u5212\u8868\u793a\u72b6\u6001\u6210\u4e00\u4e2a\u5e8f\u5217\uff0c\u53ef\u4ee5\u662f\u65e0\u73af\u56fe\u3001\u4e5f\u53ef\u4ee5\u662f\u6709\u73af\u56fe\u3002 \u9898\u76ee \u00b6 \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u89c4\u5f8b p\uff0c\u8bf7\u4f60\u6765\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 '.' \u548c ' ' \u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d\u3002'.' \u5339\u914d\u4efb\u610f\u5355\u4e2a\u5b57\u7b26\uff0c' ' \u5339\u914d\u96f6\u4e2a\u6216\u591a\u4e2a\u524d\u9762\u7684\u90a3\u4e00\u4e2a\u5143\u7d20\u3002\u4f8b\u5982\uff0cs = \"ab\"\uff0cp = \".*\"\uff0c\u8fd4\u56de true \u300c\u5206\u6790\u300d \u300c\u533a\u95f4\u578bdp\u300ddp[i][j] \u8868\u793a s[i:] \u548c p[j:] \u5339\u914d\u3002 1\uff09\u68c0\u67e5 s[i] \u548c p[j] \u662f\u5426\u5339\u914d\uff0cp[j] \u53ef\u4ee5\u662f '.' 2\uff09\u5982\u679c p[j+1] \u662f '*'\uff0cdp[i][j] \u53ef\u4ee5\u7531 dp[i][j+2] \u8f6c\u79fb\uff0c\u4e5f\u53ef\u4ee5\u7531 dp[i+1][j] \u8f6c\u79fb\uff1b\u53cd\u4e4b\uff0cdp[i][j] \u53ea\u4f1a\u7531 dp[i+1][j] \u8f6c\u79fb\u3002\u8003\u8651 dp[i+1][j] \u65f6\uff0c\u4e0d\u80fd\u5ffd\u7565 s[i] \u548c p[j] \u662f\u5426\u5339\u914d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '.' ); if ( j < np - 1 && p [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } int res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3002 \u6700\u957f\u56de\u6587\u5b50\u4e32 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u627e\u5230 s \u4e2d\u6700\u957f\u7684\u56de\u6587\u5b50\u4e32\u3002\u4f8b\u5982\uff0cs = \"babad\"\uff0c\u8fd4\u56de \u201cbab\u201d \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u8bbe dp[i][j] \u8868\u793a\u5b50\u4e32 s[i:j] \u662f\u5426\u662f\u56de\u6587\u4e32\u3002\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a dp[i][j] = \\begin{cases} dp[i+1][j-1], & s[i] == s[j] \\\\ \\text{False}, &\\text{else} \\end{cases} dp[i][j] = \\begin{cases} dp[i+1][j-1], & s[i] == s[j] \\\\ \\text{False}, &\\text{else} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 string longestPalindrome ( string s ) { int n = int ( s . length ()), pos = 0 , len = 1 ; if ( n < 2 ) { return s ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; pos = i ; len = 2 ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { pos = i ; len = k + 1 ; dp [ i ][ j ] = true ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return s . substr ( pos , len ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u8fd9\u91cc n \u8868\u793a s \u7684\u957f\u5ea6\u3002 \u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528\u4e2d\u5fc3\u6269\u6563\u7684\u65b9\u6cd5\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u7684\u5b57\u7b26\u53ef\u4ee5\u5411\u4e24\u4fa7\u6269\u6563\uff0c\u76f4\u5230\u78b0\u5230\u4e0d\u80fd\u6784\u6210\u56de\u6587\u5b50\u4e32\u505c\u6b62\u3002\u9700\u8981\u5206\u5b50\u4e32\u4e3a\u5947\u6570\u548c\u5076\u6570\u4e24\u79cd\u60c5\u51b5\u3002 \u4e0d\u540c\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u4e2a\u6570 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 n \uff0c\u6c42\u6070\u7531 n \u4e2a\u8282\u70b9\u7ec4\u6210\u4e14\u8282\u70b9\u503c\u4ece 1 \u5230 n \u4e92\u4e0d\u76f8\u540c\u7684 \u4e8c\u53c9\u641c\u7d22\u6811 \u6709\u591a\u5c11\u79cd\uff1f\u8fd4\u56de\u6ee1\u8db3\u9898\u610f\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u79cd\u6570\u3002\u4f8b\u5982\uff0cn = 3\uff0c\u8fd4\u56de 5\u3002 \u300c\u5206\u6790\u300d Catalan number \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} 1 2 3 4 5 6 7 int numTrees ( int n ) { long C = 1 ; for ( int i = 0 ; i < n ; i ++ ) { C = C * 2 * ( 2 * i + 1 ) / ( i + 2 ) ; } return int ( C ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums = [3, 4, 2]\uff0c\u4f60\u53ef\u4ee5\u5bf9\u5b83\u8fdb\u884c\u4e00\u4e9b\u64cd\u4f5c\u3002\u6bcf\u6b21\u64cd\u4f5c\u4e2d\uff0c\u9009\u62e9\u4efb\u610f\u4e00\u4e2a nums[i] \uff0c\u5220\u9664\u5b83\u5e76\u83b7\u5f97 nums[i] \u7684\u70b9\u6570\u3002\u4e4b\u540e\uff0c\u4f60\u5fc5\u987b\u5220\u9664\u6bcf\u4e2a\u7b49\u4e8e nums[i] - 1 \u6216 nums[i] + 1 \u7684\u5143\u7d20\u3002\u5f00\u59cb\u4f60\u62e5\u6709 0 \u4e2a\u70b9\u6570\u3002\u8fd4\u56de\u4f60\u80fd\u901a\u8fc7\u8fd9\u4e9b\u64cd\u4f5c\u83b7\u5f97\u7684\u6700\u5927\u70b9\u6570\u3002\u7ed9\u51fa\u7684\u4f8b\u5b50\u7684\u7ed3\u679c\u662f 6\uff08\u5220\u9664 4 \u83b7\u5f97 4 \u4e2a\u70b9\u6570\uff0c\u56e0\u6b64 3 \u4e5f\u88ab\u5220\u9664\uff0c\u4e4b\u540e\uff0c\u5220\u9664 2 \u83b7\u5f97 2 \u4e2a\u70b9\u6570\u3002\u603b\u5171\u83b7\u5f97 6 \u4e2a\u70b9\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int deleteAndEarn ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } map < int , int >:: iterator iter = ++ cnt . begin (); int lastN = cnt . begin () -> first , lastC = cnt . begin () -> second ; int a = 0 , b = lastN * lastC ; for (; iter != cnt . end (); iter ++ ) { int na = max ( a , b ), nb = iter -> first * iter -> second ; if ( lastN + 1 == iter -> first ) { nb += a ; } else { nb += max ( a , b ); } a = na ; b = nb ; lastN = iter -> first ; } return max ( a , b ); } \u51fa\u52e4\u65b9\u6848\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n\uff0c\u8868\u793a\u5929\u6570\u3002\u4e00\u4e2a\u5b66\u751f\u6bcf\u5929\u7684\u51fa\u52e4\u72b6\u6001\u662f\uff1a\u7f3a\u52e4\uff08A\uff09\u3001\u8fdf\u5230\uff08L\uff09\u3001\u51fa\u52e4\uff08P\uff09\uff0c\u5982\u679c\u5728 n \u5929\u4e2d\uff0c\u4ed6\u80fd\u83b7\u5f97\u51fa\u52e4\u5956\u52b1\u7684\u6761\u4ef6\u662f\uff1a\uff081\uff09\u4e0d\u8d85\u8fc7 1 \u6b21\u7f3a\u52e4\uff0c\uff082\uff09\u8fde\u7eed\u8fdf\u5230\u5929\u6570\u4e0d\u8d85\u8fc7 2 \u5929\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u51fa\u52e4\u65b9\u5f0f\u6709\u591a\u5c11\u79cd\uff1f \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ][ k ] \u8868\u793a\u524d i \u5929\u6709 j \u6b21\u7f3a\u52e4\uff08A\uff09\u4e14\u4ee5\u8fde\u7eed k \u4e2a\u8fdf\u5230\uff08L\uff09\u4e3a\u7ed3\u5c3e\u7684\u51fa\u52e4\u65b9\u6848\u6570\u76ee\u3002\u56e0\u4e3a\u6700\u591a\u7f3a\u52e4\u4e00\u6b21\uff0c\u6240\u4ee5 j \\in \\{0, 1\\} j \\in \\{0, 1\\} \uff1b\u6700\u591a\u8fde\u7eed\u4e24\u6b21\u8fdf\u5230\uff0c k \\in \\{0, 1, 2\\} k \\in \\{0, 1, 2\\} \u3002\u521d\u59cb\u72b6\u6001 dp[ 0 ][ 0 ][ 0 ] = 1\u3002 \u5f53\u7b2c i \u5929\u662f P \u65f6\uff0c\u7ed3\u5c3e\u7684\u8fde\u7eed L \u4e2a\u6570\u6e05\u96f6 \\text{dp[ i ][ j ][ 0 ]} = \\sum_{k \\in \\{0, 1, 2\\}} \\text{dp[ i ][ j ][ 0 ] + dp[i - 1][ j ][ k ]} \\text{dp[ i ][ j ][ 0 ]} = \\sum_{k \\in \\{0, 1, 2\\}} \\text{dp[ i ][ j ][ 0 ] + dp[i - 1][ j ][ k ]} \u5f53\u7b2c i \u5929\u662f A \u65f6\uff0c\u7ed3\u5c3e\u7684\u8fde\u7eed L \u4e2a\u6570\u6e05\u96f6\uff0c\u4e14\u4e0a\u4e00\u4e2a\u7684\u72b6\u6001\u4e00\u5b9a\u662f 0 \u4e2a A \\text{dp[ i ][ 1 ][ 0 ]} = \\text{dp[ i ][ 1 ][ 0 ] + dp[i - 1][ 0 ][ k ]} \\text{dp[ i ][ 1 ][ 0 ]} = \\text{dp[ i ][ 1 ][ 0 ] + dp[i - 1][ 0 ][ k ]} \u5f53\u7b2c i \u5929\u662f L \u65f6\uff0c\u7ed3\u5c3e\u7684\u8fde\u7eed L \u4e2a\u6570\u52a0\u4e00 \\text{dp[ i ][ j ][ k ]} = \\sum_{k \\in \\{1, 2\\}} \\text{dp[ i ][ j ][ k ] + dp[i - 1][ j ][k - 1]} \\text{dp[ i ][ j ][ k ]} = \\sum_{k \\in \\{1, 2\\}} \\text{dp[ i ][ j ][ k ] + dp[i - 1][ j ][k - 1]} \u603b\u5171 6 \u4e2a\u72b6\u6001\uff0c\u6574\u7406\u5982\u4e0b \\begin{aligned} & \\text{dp00 = dp00 + dp01 + dp02} \\\\ & \\text{dp01 = dp00} \\\\ & \\text{dp02 = dp01} \\\\ & \\text{dp10 = dp00 + dp01 + dp02 + dp10 + dp11 + dp12} \\\\ & \\text{dp11 = dp10} \\\\ & \\text{dp12 = dp11} \\end{aligned} \\begin{aligned} & \\text{dp00 = dp00 + dp01 + dp02} \\\\ & \\text{dp01 = dp00} \\\\ & \\text{dp02 = dp01} \\\\ & \\text{dp10 = dp00 + dp01 + dp02 + dp10 + dp11 + dp12} \\\\ & \\text{dp11 = dp10} \\\\ & \\text{dp12 = dp11} \\end{aligned} \u72b6\u6001\u8f6c\u79fb\u77e9\u9635 M = \\begin{bmatrix} 1 & 1 & 0 & 1 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\end{bmatrix} \\quad \\text{dp} = \\begin{bmatrix} \\text{dp00} \\\\ \\text{dp01} \\\\ \\text{dp02} \\\\ \\text{dp10} \\\\ \\text{dp11} \\\\ \\text{dp12} \\end{bmatrix} M = \\begin{bmatrix} 1 & 1 & 0 & 1 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\end{bmatrix} \\quad \\text{dp} = \\begin{bmatrix} \\text{dp00} \\\\ \\text{dp01} \\\\ \\text{dp02} \\\\ \\text{dp10} \\\\ \\text{dp11} \\\\ \\text{dp12} \\end{bmatrix} \\text{dpNew} = \\text{M dpOld} = M^{n} \\text{ dpOld} \\text{dpNew} = \\text{M dpOld} = M^{n} \\text{ dpOld} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int checkRecord ( int n ) { vector < vector < vector < int >>> dp ( n + 1 , vector < vector < int >> ( 2 , vector < int > ( 3 , 0 ))); dp [ 0 ][ 0 ][ 0 ] = 1 ; const int mod = 1000000007 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 1 ; j ++ ) { for ( int k = 0 ; k <= 2 ; k ++ ) { dp [ i ][ j ][ 0 ] = ( dp [ i ][ j ][ 0 ] + dp [ i - 1 ][ j ][ k ]) % mod ; } } for ( int k = 0 ; k <= 2 ; k ++ ) { dp [ i ][ 1 ][ 0 ] = ( dp [ i ][ 1 ][ 0 ] + dp [ i - 1 ][ 0 ][ k ]) % mod ; } for ( int j = 0 ; j <= 1 ; j ++ ) { for ( int k = 1 ; k <= 2 ; k ++ ) { dp [ i ][ j ][ k ] = ( dp [ i ][ j ][ k ] + dp [ i - 1 ][ j ][ k - 1 ]) % mod ; } } } int ans = 0 ; for ( int j = 0 ; j <= 1 ; j ++ ) { for ( int k = 0 ; k <= 2 ; k ++ ) { ans = ( ans + dp [ n ][ j ][ k ]) % mod ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n)\uff0c O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u4f7f\u7528\u5feb\u901f\u5e42\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 const int mod = 1000000007 ; vector < vector < int >> multiply ( vector < vector < int >> a , vector < vector < int >> b ) { vector < vector < int >> ans ( 6 , vector < int > ( 6 , 0 )); for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 6 ; j ++ ) { for ( int k = 0 ; k < 6 ; k ++ ) { ans [ i ][ j ] = ( ans [ i ][ j ] + ( long ) a [ i ][ k ] * b [ k ][ j ]) % mod ; } } } return ans ; } vector < vector < int >> nMultiply ( vector < vector < int >> M , int n ) { vector < vector < int >> ans { { 1 , 0 , 0 , 0 , 0 , 0 }, { 0 , 1 , 0 , 0 , 0 , 0 }, { 0 , 0 , 1 , 0 , 0 , 0 }, { 0 , 0 , 0 , 1 , 0 , 0 }, { 0 , 0 , 0 , 0 , 1 , 0 }, { 0 , 0 , 0 , 0 , 0 , 1 } }; while ( n ) { if ( n & 1 ) { ans = multiply ( ans , M ); } M = multiply ( M , M ); n >>= 1 ; } return ans ; } int checkRecord ( int n ) { int ans = 0 ; vector < vector < int >> M { { 1 , 1 , 0 , 1 , 0 , 0 }, { 1 , 0 , 1 , 1 , 0 , 0 }, { 1 , 0 , 0 , 1 , 0 , 0 }, { 0 , 0 , 0 , 1 , 1 , 0 }, { 0 , 0 , 0 , 1 , 0 , 1 }, { 0 , 0 , 0 , 1 , 0 , 0 } }; M = nMultiply ( M , n ); for ( int j = 0 ; j < 6 ; j ++ ) { ans = ( ans + M [ 0 ][ j ]) % mod ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n)\uff0c O(\\log n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4f18\u7f8e\u5e8f\u5217 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n\uff0c\u5982\u679c\u5c06 1 - n \u5f62\u6210\u4e00\u4e2a\u6392\u5217 seq\uff0c\u4e14\u5728 i \u4f4d\u7f6e\u4e0a\u6ee1\u8db3 i % seq[ i ] == 0 \u6216 seq[ i ] % i == 0\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u4e00\u4e2a\u3010\u4f18\u7f8e\u5e8f\u5217\u3011\u3002\u8bd5\u95ee\u5bf9\u4e8e n \u800c\u8a00\uff0c\u603b\u5171\u6709\u591a\u5c11\u4e2a\u3010\u4f18\u7f8e\u5e8f\u5217\u3011\u3002 \u300c\u5206\u6790\u300d \u3010\u56de\u6eaf\u3011\u80fd\u4e0d\u80fd\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684\u5e8f\u5217\uff0c\u4e3b\u8981\u770b\u67d0\u4e00\u4e2a\u4f4d\u7f6e i \u548c\u8fd9\u4e2a\u4f4d\u7f6e\u5bf9\u5e94\u7684\u6570\u503c\u662f\u5426\u6574\u9664\u3002\u6211\u4eec\u53ef\u4ee5\u9010\u4e2a\u4f4d\u7f6e\u586b\u5145 1 - n \u7684\u5143\u7d20\uff0c\u5982\u679c\u80fd\u5f97\u5230\u4e00\u4e2a\u5b8c\u6574\u7684\u5e8f\u5217\uff0c\u5219\u603b\u7ed3\u679c\u52a0\u4e00\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector < vector < int >> next ; int dfs ( bool * vis , int idx , int n ) { if ( idx == n + 1 ) { return 1 ; } int ans = 0 ; for ( int ele : next [ idx ]) { if ( vis [ ele ]) { continue ; } vis [ ele ] = true ; ans += dfs ( vis , idx + 1 , n ); vis [ ele ] = false ; } return ans ; } int countArrangement ( int n ) { bool * vis = new bool [ n + 1 ] {}; next . resize ( n + 1 , vector < int > {}); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i % j == 0 || j % i == 0 ) { next [ i ]. emplace_back ( j ); } } } int ans = dfs ( vis , 1 , n ); delete [] vis ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n!) O(n!) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3010\u72b6\u6001\u538b\u7f29 + \u52a8\u6001\u89c4\u5212\u3011\u5f62\u6210\u4e00\u4e2a\u5e8f\u5217\uff0c\u5fc5\u7136\u6709\u67d0\u4e9b\u5143\u7d20\u5148\u88ab\u586b\u5145\uff0c\u5269\u4e0b\u7684\u5143\u7d20\u540e\u88ab\u586b\u5145\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a 32-bit \u7684\u6574\u6570\u8868\u793a\u8fd9\u6837\u7684\u5e8f\u5217\uff0c\u8fd9\u5c31\u53eb\u3010\u72b6\u6001\u538b\u7f29\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int countArrangement ( int n ) { vector < int > dp ( 1 << n , 0 ); dp [ 0 ] = 1 ; for ( int mask = 1 ; mask < ( 1 << n ); mask ++ ) { int numOf1 = __builtin_popcount ( mask ); for ( int j = 0 ; j < n ; j ++ ) { if (( mask & ( 1 << j )) && ( numOf1 % ( j + 1 ) == 0 || ( j + 1 ) % numOf1 == 0 )) { dp [ mask ] += dp [ mask ^ ( 1 << j )]; } } } return dp [( 1 << n ) - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n 2^{n}) O(n 2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n}) \u81f3\u591a k \u6b21\u4e2d\u8f6c\u7684\u6700\u4f4e\u4ef7\u683c \u00b6 \u7ed9\u4e00\u5b9a\u4e00\u4e2a\u822a\u73ed\u5217\u8868 flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]\uff0c\u8868\u793a\u4ece i \u5230 j \u7684\u5355\u5411\u822a\u73ed\u7684\u4ef7\u683c\uff0c\u8bd5\u95ee\u81f3\u591a k \u6b21\u4e2d\u8f6c\uff0c\u4ece src \u5230 dst \u7684\u6700\u4f4e\u4ef7\u683c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ t ][ i ] \u4e3a\u4ece src \u7ecf\u8fc7 t \u6b21\u4e2d\u8f6c\u5230 i \u7684\u6700\u4f4e\u4ef7\u683c\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ t ][ i ]} = \\min_{(j, i) \\in E} \\text{dp[t - 1][ j ] + cost[ j ][ i ]} \\text{dp[ t ][ i ]} = \\min_{(j, i) \\in E} \\text{dp[t - 1][ j ] + cost[ j ][ i ]} \u521d\u59cb\u72b6\u6001 \\text{dp[ 0 ][ i ]} = \\begin{cases} 0, &\\quad i = \\text{dst} \\\\ \\text{INF}, &\\quad i \\neq \\text{dst} \\end{cases} \\text{dp[ 0 ][ i ]} = \\begin{cases} 0, &\\quad i = \\text{dst} \\\\ \\text{INF}, &\\quad i \\neq \\text{dst} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int findCheapestPrice ( int n , vector < vector < int >>& flights , int src , int dst , int k ) { int MAX = 10000 * n + 1 ; vector < vector < int >> dp ( k + 2 , vector < int > ( n , MAX )); dp [ 0 ][ src ] = 0 ; for ( int t = 1 ; t <= k + 1 ; t ++ ) { for ( auto flight : flights ) { dp [ t ][ flight [ 1 ]] = min ( dp [ t ][ flight [ 1 ]], dp [ t - 1 ][ flight [ 0 ]] + flight [ 2 ]); } } int ans = MAX ; for ( int t = 0 ; t <= k + 1 ; t ++ ) { ans = min ( ans , dp [ t ][ dst ]); } return ans == MAX ? - 1 : ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(km) O(km) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(kn) O(kn) \uff0c\u5176\u4e2d m \u662f\u822a\u73ed\u5217\u8868\u7684\u957f\u5ea6\uff0cn \u662f\u8282\u70b9\u7684\u4e2a\u6570 \u6590\u6ce2\u90a3\u5951\u6570\u5217\u7b2c n \u9879 \u00b6 \\text{fib}(n) = \\begin{cases} 0, & \\quad n = 0 \\\\ 1, & \\quad n = 1 \\\\ \\text{fib}(n - 1) + \\text{fib}(n), & \\quad n \\geq 2 \\end{cases} \\text{fib}(n) = \\begin{cases} 0, & \\quad n = 0 \\\\ 1, & \\quad n = 1 \\\\ \\text{fib}(n - 1) + \\text{fib}(n), & \\quad n \\geq 2 \\end{cases} \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212 + \u5feb\u901f\u5e42\u3011\u6839\u636e\u9012\u63a8\u516c\u793a\u6784\u9020\u72b6\u6001\u8f6c\u79fb\u77e9\u9635 \\begin{aligned} \\begin{bmatrix} f_{n} \\\\ f_{n - 1} \\end{bmatrix} &= \\begin{bmatrix} f_{n - 1} + f_{n - 2} \\\\ f_{n - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} f_{n - 1} \\\\ f_{n - 2} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{2} \\begin{bmatrix} f_{n - 2} \\\\ f_{n - 3} \\end{bmatrix} \\\\ &= \\quad \\quad \\quad \\vdots \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{n - 1} \\begin{bmatrix} f_{1} \\\\ f_{0} \\end{bmatrix} \\end{aligned} \\begin{aligned} \\begin{bmatrix} f_{n} \\\\ f_{n - 1} \\end{bmatrix} &= \\begin{bmatrix} f_{n - 1} + f_{n - 2} \\\\ f_{n - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} f_{n - 1} \\\\ f_{n - 2} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{2} \\begin{bmatrix} f_{n - 2} \\\\ f_{n - 3} \\end{bmatrix} \\\\ &= \\quad \\quad \\quad \\vdots \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{n - 1} \\begin{bmatrix} f_{1} \\\\ f_{0} \\end{bmatrix} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : int mod = 1000000007 ; int fib ( int n ) { if ( n < 2 ) { return n ; } vector < vector < long >> M { { 1 , 1 }, { 1 , 0 } }; M = nMultiply ( M , n - 1 ); return M [ 0 ][ 0 ]; } vector < vector < long >> nMultiply ( vector < vector < long >> a , int n ) { vector < vector < long >> ans { { 1 , 0 }, { 0 , 1 } }; while ( n ) { if ( n % 2 != 0 ) { ans = multiply ( ans , a ); } n >>= 1 ; a = multiply ( a , a ); } return ans ; } vector < vector < long >> multiply ( vector < vector < long >> a , vector < vector < long >> b ) { vector < vector < long >> ans { { 0 , 0 }, { 0 , 0 } }; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { ans [ i ][ j ] = (( a [ i ][ 0 ] * b [ 0 ][ j ]) % mod + ( a [ i ][ 1 ] * b [ 1 ][ j ]) % mod ) % mod ; } } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u8bbf\u95ee\u5b8c\u6240\u6709\u623f\u95f4\u7684\u7b2c\u4e00\u5929 \u00b6 \u4f60\u9700\u8981\u8bbf\u95ee n \u4e2a\u623f\u95f4\uff0c\u623f\u95f4\u4ece 0 \u5230 n - 1 \u7f16\u53f7\u3002\u540c\u65f6\uff0c\u6bcf\u4e00\u5929\u90fd\u6709\u4e00\u4e2a\u65e5\u671f\u7f16\u53f7\uff0c\u4ece 0 \u5f00\u59cb\uff0c\u4f9d\u5929\u6570\u9012\u589e\u3002\u4f60\u6bcf\u5929\u90fd\u4f1a\u8bbf\u95ee\u4e00\u4e2a\u623f\u95f4\u3002 \u6700\u5f00\u59cb\u7684\u7b2c 0 \u5929\uff0c\u4f60\u8bbf\u95ee 0 \u53f7\u623f\u95f4\u3002\u7ed9\u4f60\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u4e14 \u4e0b\u6807\u4ece 0 \u5f00\u59cb \u7684\u6570\u7ec4 nextVisit \u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u5929\u4e2d\uff0c\u4f60\u8bbf\u95ee\u623f\u95f4\u7684 \u6b21\u5e8f \u5c06\u6839\u636e\u4e0b\u9762\u7684 \u89c4\u5219 \u51b3\u5b9a\uff1a \u5047\u8bbe\u67d0\u4e00\u5929\uff0c\u4f60\u8bbf\u95ee i \u53f7\u623f\u95f4\u3002 * \u5982\u679c\u7b97\u4e0a\u672c\u6b21\u8bbf\u95ee\uff0c\u8bbf\u95ee i \u53f7\u623f\u95f4\u7684\u6b21\u6570\u4e3a \u5947\u6570 \uff0c\u90a3\u4e48 \u7b2c\u4e8c\u5929 \u9700\u8981\u8bbf\u95ee nextVisit[i] \u6240\u6307\u5b9a\u7684\u623f\u95f4\uff0c\u5176\u4e2d 0 <= nextVisit[i] <= i \u3002 * \u5982\u679c\u7b97\u4e0a\u672c\u6b21\u8bbf\u95ee\uff0c\u8bbf\u95ee i \u53f7\u623f\u95f4\u7684\u6b21\u6570\u4e3a \u5076\u6570 \uff0c\u90a3\u4e48 \u7b2c\u4e8c\u5929 \u9700\u8981\u8bbf\u95ee (i + 1) mod n \u53f7\u623f\u95f4\u3002 \u8bf7\u8fd4\u56de\u4f60\u8bbf\u95ee\u5b8c\u6240\u6709\u623f\u95f4\u7684\u7b2c\u4e00\u5929\u7684\u65e5\u671f\u7f16\u53f7\u3002\u9898\u76ee\u6570\u636e\u4fdd\u8bc1\u603b\u662f\u5b58\u5728\u8fd9\u6837\u7684\u4e00\u5929\u3002\u7531\u4e8e\u7b54\u6848\u53ef\u80fd\u5f88\u5927\uff0c\u8fd4\u56de\u5bf9 109 + 7 \u53d6\u4f59\u540e\u7684\u7ed3\u679c\u3002 \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ i ] \u4e3a\u7b2c\u4e00\u6b21\u8bbf\u95ee\u7b2c i \u4e2a\u623f\u95f4\u7684\u6240\u9700\u8981\u7684\u5929\u6570\u3002\u6839\u636e\u9898\u610f\uff0c\u5982\u679c\u8981\u7b2c\u4e00\u6b21\u8bbf\u95ee\u7b2c i \u4e2a\u623f\u95f4\uff0c\u90a3\u4e48\u524d\u9762\u7684 i - 1 \u4e2a\u623f\u95f4\u8bbf\u95ee\u6b21\u6570\u5fc5\u987b\u662f\u5076\u6570\uff0c\u5e76\u4e14\u4e00\u5b9a\u662f\u7531\u7b2c i - 1 \u4e2a\u623f\u95f4\u3010\u52a0\u4e00\u5929\u3011\u800c\u6765\u7684\u3002\u5982\u679c nextVisit[i - 1] == i- 1\uff0c\u90a3\u4e48\u4e0b\u4e00\u5929\u8bbf\u95ee\u7684\u4f9d\u636e\u662f i - 1 \u623f\u95f4\uff0c\u518d\u52a0\u4e00\u5929\u624d\u80fd\u5230 i \u623f\u95f4\u3002\u5982\u679c nextVisit[i - 1] != i- 1\uff0c\u6211\u4eec\u9700\u8981\u4ece nextVisit[i - 1] \u8bbf\u95ee\u5230 i - 1\u6b64\u65f6\u9700\u8981 dp[i - 1] - dp[nextVisit[i - 1]]\uff08\u524d\u7f00\u548c\uff09 \\text{dp[ i ]} = \\begin{cases} \\text{dp[i - 1]} + 2, &\\quad \\text{nextVist[i - 1] == i - 1} \\\\ \\text{dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1, &\\quad \\text{otherwise} \\end{cases} \\text{dp[ i ]} = \\begin{cases} \\text{dp[i - 1]} + 2, &\\quad \\text{nextVist[i - 1] == i - 1} \\\\ \\text{dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1, &\\quad \\text{otherwise} \\end{cases} \u6574\u7406\u5f97\u5230\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\text{dp[ i ] = dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1 \\text{dp[ i ] = dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1 1 2 3 4 5 6 7 8 9 10 11 int firstDayBeenInAllRooms ( vector < int >& nextVisit ) { int mod = 1000000007 , n = ( int ) nextVisit . size (); vector < int > dp ( n , 0 ); for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] - dp [ nextVisit [ i - 1 ]] + 2 ) % mod ; if ( dp [ i ] < 0 ) { dp [ i ] += mod ; } } return dp [ n - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cn \u4e3a nextVisit \u7684\u957f\u5ea6 \u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57 \u00b6 0,1,\u00b7\u00b7\u00b7,n-1\u8fd9n\u4e2a\u6570\u5b57\u6392\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\uff0c\u6bcf\u6b21\u4ece\u8fd9\u4e2a\u5706\u5708\u91cc\u5220\u9664\u7b2cm\u4e2a\u6570\u5b57\uff08\u5220\u9664\u540e\u4ece\u4e0b\u4e00\u4e2a\u6570\u5b57\u5f00\u59cb\u8ba1\u6570\uff09\u3002\u6c42\u51fa\u8fd9\u4e2a\u5706\u5708\u91cc\u5269\u4e0b\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\uff0c0\u30011\u30012\u30013\u30014\u8fd95\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\u6bcf\u6b21\u5220\u9664\u7b2c3\u4e2a\u6570\u5b57\uff0c\u5219\u5220\u9664\u7684\u524d4\u4e2a\u6570\u5b57\u4f9d\u6b21\u662f2\u30010\u30014\u30011\uff0c\u56e0\u6b64\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57\u662f3\u3002 \u3010\u5206\u6790\u3011 \u3010\u52a8\u6001\u89c4\u5212\u3011\u5047\u8bbe\u957f\u5ea6\u4e3a n - 1 \u7684\u5706\u5708\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57\u662f x\uff0c\u90a3\u4e48\u957f\u5ea6\u4e3a n \u7684\u5706\u5708\u5269\u4e0b\u7684\u5143\u7d20\u662f\u4ece x \u5f00\u59cb\u7684\u7b2c m \u4e2a\u5143\u7d20\uff0c\u56e0\u4e3a\u6211\u4eec\u53ea\u9700\u8981\u4ece n - 1 \u7684\u72b6\u6001\u591a\u8d70\u4e00\u6b65\u5373\u53ef\u5230\u8fbe n\u3002 \\text{dp[ n ] = (m + dp[n - 1]) mod n} \\text{dp[ n ] = (m + dp[n - 1]) mod n} 1 2 3 4 5 6 7 int lastRemaining ( int n , int m ) { int a = 0 ; for ( int i = 1 ; i < n ; i ++ ) { a = ( a + m ) % ( i + 1 ); } return a ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) n \u4e2a\u9ab0\u5b50\u7684\u70b9\u6570\u6982\u7387 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n \u8868\u793a\u9ab0\u5b50\u7684\u4e2a\u6570\uff0c\u6c42\u8fd9 n \u4e2a\u9ab0\u5b50\u51fa\u73b0\u7684\u70b9\u548c\u6982\u7387\uff0c\u7ed3\u679c\u6309\u7167\u70b9\u548c\uff08\u975e\u6982\u7387\uff09\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u5982 n = 2\uff0c\u70b9\u548c\u4e3a [6, 7, 8, 9, 10, 11, 12]\uff0c\u5bf9\u5e94\u7684\u6982\u7387\u662f [0.02778, 0.05556, 0.08333, 0.11111, 0.13889, 0.16667, 0.13889, 0.11111, 0.08333, 0.05556, 0.02778]\u3002 \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ i ][ j ] \u8868\u793a i \u4e2a\u9ab0\u5b50\u7ec4\u6210\u70b9\u548c\u4e3a j \u7684\u6982\u7387 \\text{dp[ i ][ j ]} = \\sum_{k = 6}^{6} \\frac{\\text{dp[i - 1][j - k]}}{6} \\text{dp[ i ][ j ]} = \\sum_{k = 6}^{6} \\frac{\\text{dp[i - 1][j - k]}}{6} \u56e0\u4e3a\u7b2c i \u4e2a\u9ab0\u5b50\u7684\u7ed3\u679c\u53ea\u8ddf\u7b2c i - 1 \u4e2a\u9ab0\u5b50\u7684\u7ed3\u679c\u76f8\u5173\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4e00\u7ef4\u6570\u7ec4\u8868\u793a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < double > dicesProbability ( int n ) { vector < double > ans ( 6 , 1.0 / 6 ); for ( int i = 2 ; i <= n ; i ++ ) { vector < double > tmp ( 6 * i - i + 1 , 0.0 ); for ( int j = 0 ; j < ans . size (); j ++ ) { for ( int k = 0 ; k < 6 ; k ++ ) { tmp [ j + k ] += ans [ j ] * 1.0 / 6 ; } } ans = tmp ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u83b7\u5f97\u6700\u591a\u7b54\u9898\u5206\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u5217\u8868 questions = [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]] \u8868\u793a\u4e00\u7cfb\u5217\u7684\u9898\u76ee\uff0cquestions[ i ] = [score, skipNum]\uff0c\u5373\u5982\u679c\u4f5c\u7b54\u7b2c i \u9898\uff0c\u5c06\u83b7\u5f97\u5bf9\u5e94\u7684\u5206\u6570 score\uff0c\u4f46\u662f\u63a5\u4e0b\u6765\u9700\u8981\u8df3\u8fc7 skipNum \u4e2a\u9898\u76ee\uff1b\u5f53\u7136\uff0c\u7b2c i \u9053\u9898\u76ee\u4e5f\u53ef\u4ee5\u9009\u62e9\u4e0d\u4f5c\u7b54\uff0c\u8bd5\u95ee\uff0c\u6700\u591a\u53ef\u4ee5\u83b7\u5f97\u7684\u5206\u6570\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ i ] \u4e3a\u5904\u4e8e\u7b2c i \u9898\u65f6\uff0c\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u5206\u6570\uff0c \u4ece\u540e\u5411\u524d \u904d\u5386 \\text{dp[ i ]} = \\begin{cases} \\text{max ( dp[i + 1], dp[i + questions[ i ][ 1 ]] + questions[ i ][ 0 ]}, & \\quad \\text{i + questions[ i ][ 1 ] + 1} \\geq n \\\\ \\text{max ( dp[i + 1], questions[ i ][ 0 ])}, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ]} = \\begin{cases} \\text{max ( dp[i + 1], dp[i + questions[ i ][ 1 ]] + questions[ i ][ 0 ]}, & \\quad \\text{i + questions[ i ][ 1 ] + 1} \\geq n \\\\ \\text{max ( dp[i + 1], questions[ i ][ 0 ])}, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long long mostPoints ( vector < vector < int >>& questions ) { typedef long long ll ; int n = ( int ) questions . size (); vector < ll > dp ( n , 0 ); dp [ n - 1 ] = questions [ n - 1 ][ 0 ]; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = dp [ i + 1 ]; if ( i + questions [ i ][ 1 ] >= n ) { dp [ i ] = max ( dp [ i ], ( ll ) questions [ i ][ 0 ]); } else { dp [ i ] = max ( dp [ i ], questions [ i ][ 0 ] + dp [ i + questions [ i ][ 1 ]]); } } return dp [ 0 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u526a\u7ef3\u5b50 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4f60\u4e00\u6839\u957f\u5ea6\u4e3an\u7684\u7ef3\u5b50\uff0c\u8bf7\u628a\u7ef3\u5b50\u526a\u6210\u6574\u6570\u957f\u7684m\u6bb5\uff08m\u3001n\u90fd\u662f\u6574\u6570\uff0cn>1\u5e76\u4e14m>1\uff09\uff0c\u6bcf\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u8bb0\u4e3ak[0],k[1],...,k[m]\u3002\u8bf7\u95eek[0]xk[1]x...xk[m]\u53ef\u80fd\u7684\u6700\u5927\u4e58\u79ef\u662f\u591a\u5c11\uff1f\u4f8b\u5982\uff0c\u5f53\u7ef3\u5b50\u7684\u957f\u5ea6\u662f8\u65f6\uff0c\u6211\u4eec\u628a\u5b83\u526a\u6210\u957f\u5ea6\u5206\u522b\u4e3a2\u30013\u30013\u7684\u4e09\u6bb5\uff0c\u6b64\u65f6\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u662f18\u3002 \u793a\u4f8b1\uff1a\u8f93\u51658\u8f93\u51fa18 \u300c\u5206\u6790\u300d \u8bbe f[ i ] \u4e3a\u957f\u5ea6 i \u7684\u7ef3\u5b50\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u3002\u90a3\u4e48\uff0c\u9010\u4e2a\u5355\u4f4d\u5207\u5206\u6210\u4e24\u6bb5\uff0c\u627e\u5230\u6700\u5927\u7684\u5207\u5272\u65b9\u6848\u3002 f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public \uff1a int cutRope ( int number ) { int n = number ; if ( n < 2 ) { return 0 ; } if ( n == 2 ) { return 1 ; } if ( n == 3 ) { return 2 ; } int * f = new int [ n + 1 ]{}; f [ 1 ] = 1 ; f [ 2 ] = 2 ; f [ 3 ] = 3 ; int prod = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { int max_prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { prod = f [ j ] * f [ i - j ]; if ( max_prod < prod ) { max_prod = prod ; } } f [ i ] = max_prod ; } int res = f [ n ]; delete [] f ; return res ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u7ed9 N x 3 \u7f51\u683c\u56fe\u6d82\u8272\u7684\u65b9\u6848\u6570 \u00b6 \u4f60\u6709\u4e00\u4e2a n x 3 \u7684\u7f51\u683c\u56fe grid \uff0c\u4f60\u9700\u8981\u7528 \u7ea2\uff0c\u9ec4\uff0c\u7eff \u4e09\u79cd\u989c\u8272\u4e4b\u4e00\u7ed9\u6bcf\u4e00\u4e2a\u683c\u5b50\u4e0a\u8272\uff0c\u4e14\u786e\u4fdd\u76f8\u90bb\u683c\u5b50\u989c\u8272\u4e0d\u540c\uff08\u4e5f\u5c31\u662f\u6709\u76f8\u540c\u6c34\u5e73\u8fb9\u6216\u8005\u5782\u76f4\u8fb9\u7684\u683c\u5b50\u989c\u8272\u4e0d\u540c\uff09\u3002\u7ed9\u4f60\u7f51\u683c\u56fe\u7684\u884c\u6570 n \u3002\u8bf7\u4f60\u8fd4\u56de\u7ed9 grid \u6d82\u8272\u7684\u65b9\u6848\u6570\u3002\u7531\u4e8e\u7b54\u6848\u53ef\u80fd\u4f1a\u975e\u5e38\u5927\uff0c\u8bf7\u4f60\u8fd4\u56de\u7b54\u6848\u5bf9 10^9 + 7 \u53d6\u4f59\u7684\u7ed3\u679c\u3002 \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578bdp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. */ class Solution { public : int numOfWays ( int n ) { int aba = 6 , abc = 6 ; /* aba = aba * 3 + abc * 2 abc = aba * 2 + abc * 2; */ const int MOD = 1000000007 ; for ( int i = 1 ; i < n ; i ++ ) { int new_aba = ( aba * 3ll + abc * 2ll ) % MOD ; int new_abc = ( aba * 2ll + abc * 2ll ) % MOD ; aba = new_aba ; abc = new_abc ; } return ( aba + abc ) % MOD ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u6700\u957f\u6709\u6548\u62ec\u53f7 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u53ea\u5305\u542b '(' \u548c ')' \u7684\u5b57\u7b26\u4e32\uff0c\u627e\u51fa\u6700\u957f\u6709\u6548\uff08\u683c\u5f0f\u6b63\u786e\u4e14\u8fde\u7eed\uff09\u62ec\u53f7\u5b50\u4e32\u7684\u957f\u5ea6\u3002\u4f8b\u5982\uff0cs = \")()())\"\uff0c\u8fd4\u56de 4\uff0c\u6700\u957f\u6709\u6548\u62ec\u53f7\u5b50\u4e32\u662f \"()()\"\u3002 \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578bDP\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int longestValidParentheses ( string s ) { int maxLen = 0 , n = int ( s . length ()), leftCount = 0 ; if ( n < 2 ) { return maxLen ; } int * dp = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { if ( leftCount == 0 && s [ i ] == ')' ) { continue ; } if ( s [ i ] == '(' ) { leftCount ++ ; } else { leftCount -- ; dp [ i ] = dp [ i - 1 ] + 1 ; if ( i - dp [ i ] * 2 >= 0 ) { dp [ i ] += dp [ i - dp [ i ] * 2 ]; } } maxLen = maxLen > dp [ i ] ? maxLen : dp [ i ]; } delete [] dp ; return maxLen * 2 ; } // \u5e38\u6570\u7a7a\u95f4 int longestValidParentheses ( string s ) { int ans = 0 , L = 0 , R = 0 ; for ( char c : s ) { if ( c == '(' ) { L ++ ; } else { R ++ ; } if ( L == R ) { ans = max ( ans , 2 * R ); } else if ( L < R ) { L = R = 0 ; } } L = R = 0 ; for ( int i = ( int ) s . length () - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '(' ) { L ++ ; } else { R ++ ; } if ( L == R ) { ans = max ( ans , 2 * R ); } else if ( L > R ) { L = R = 0 ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u4e0d\u540c\u7684\u5b50\u5e8f\u5217 \u00b6 \u7ed9\u4f60\u4e24\u4e2a\u5b57\u7b26\u4e32 s \u548c t \uff0c\u7edf\u8ba1\u5e76\u8fd4\u56de\u5728 s \u7684 \u5b50\u5e8f\u5217 \u4e2d t \u51fa\u73b0\u7684\u4e2a\u6570\uff0c\u7ed3\u679c\u9700\u8981\u5bf9 100000007 \u53d6\u6a21\u3002\u4f8b\u5982\uff0cs = \"babgbag\", t = \"bag\"\uff0c\u8fd4\u56de 5\uff0c\u56e0\u4e3a s \u6709 5 \u4e2a\u5b50\u5e8f\u5217\u6ee1\u8db3\u8981\u6c42\uff0c\u5373 [babgbag, babgbag, babgbag, babgbag, babgbag] \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578b\u300d\u8bbe dp[i][j] \u8868\u793a s[:i] \u6ee1\u8db3 t[:j] \u7684\u5b50\u5e8f\u5217\u6570\u76ee\u3002\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a dp[i][j] = \\begin{cases} dp[i - 1][j - 1] + dp[i - 1][j], &s[i] == t[j] \\\\ dp[i - 1][j], &\\text{else} \\end{cases} dp[i][j] = \\begin{cases} dp[i - 1][j - 1] + dp[i - 1][j], &s[i] == t[j] \\\\ dp[i - 1][j], &\\text{else} \\end{cases} \u56e0\u4e3a s \u7684\u5b50\u5e8f\u5217\u5fc5\u987b\u5305\u542b t\uff0c\u6240\u4ee5\u72b6\u6001\u8f6c\u79fb\u6765\u81ea s \u7684\u524d\u4e00\u4f4d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int numDistinct ( string s , string t ) { const int MOD = 1000000007 ; vector < vector < int >> dp ( s . size () + 1 , vector < int > ( t . size () + 1 )); for ( int i = 0 ; i <= s . size (); i ++ ) { for ( int j = 0 ; j <= t . size (); j ++ ) { if ( j == 0 ) { dp [ i ][ j ] = 1 ; } else if ( i == 0 ) { dp [ i ][ j ] = 0 ; } else { dp [ i ][ j ] = dp [ i - 1 ][ j ] % MOD ; if ( s [ i - 1 ] == t [ j - 1 ]) { dp [ i ][ j ] = ( dp [ i ][ j ] % MOD + dp [ i - 1 ][ j - 1 ] % MOD ) % MOD ; } } } } return dp [ s . size ()][ t . size ()]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u8fd9\u91cc\uff0cn \u662f s \u7684\u957f\u5ea6\uff0cm \u662f t \u7684\u957f\u5ea6\u3002 \u6270\u4e71\u5b57\u7b26\u4e32 \u00b6 \u4f7f\u7528\u4e0b\u9762\u63cf\u8ff0\u7684\u7b97\u6cd5\u53ef\u4ee5\u6270\u4e71\u5b57\u7b26\u4e32 s \u5f97\u5230\u5b57\u7b26\u4e32 t \uff1a \u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e3a 1 \uff0c\u7b97\u6cd5\u505c\u6b62 \u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6 > 1 \uff0c\u6267\u884c\u4e0b\u8ff0\u6b65\u9aa4\uff1a \u5728\u4e00\u4e2a\u968f\u673a\u4e0b\u6807\u5904\u5c06\u5b57\u7b26\u4e32\u5206\u5272\u6210\u4e24\u4e2a\u975e\u7a7a\u7684\u5b50\u5b57\u7b26\u4e32\u3002\u5373\uff0c\u5982\u679c\u5df2\u77e5\u5b57\u7b26\u4e32 s \uff0c\u5219\u53ef\u4ee5\u5c06\u5176\u5206\u6210\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32 x \u548c y \uff0c\u4e14\u6ee1\u8db3 s = x + y \u3002\u968f\u673a \u51b3\u5b9a\u662f\u8981\u300c\u4ea4\u6362\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32\u300d\u8fd8\u662f\u8981\u300c\u4fdd\u6301\u8fd9\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32\u7684\u987a\u5e8f\u4e0d\u53d8\u300d\u3002\u5373\uff0c\u5728\u6267\u884c\u8fd9\u4e00\u6b65\u9aa4\u4e4b\u540e\uff0cs \u53ef\u80fd\u662f s = x + y \u6216\u8005 s = y + x \u3002\u5728 x \u548c y \u8fd9\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32\u4e0a\u7ee7\u7eed\u4ece\u6b65\u9aa4 1 \u5f00\u59cb\u9012\u5f52\u6267\u884c\u6b64\u7b97\u6cd5\u3002\u7ed9\u4f60\u4e24\u4e2a \u957f\u5ea6\u76f8\u7b49 \u7684\u5b57\u7b26\u4e32 s1 \u548c s2\uff0c\u5224\u65ad s2 \u662f\u5426\u662f s1 \u7684\u6270\u4e71\u5b57\u7b26\u4e32\u3002\u5982\u679c\u662f\uff0c\u8fd4\u56de true \uff1b\u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578b\u300d\u8bbe dp[i][j][k] \u8868\u793a s[i:i+k] \u548c t[j:j+k] \u662f\u6270\u4e71\u5b57\u7b26\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 bool isScramble ( string s1 , string s2 ) { int n = int ( s1 . length ()); if ( n != int ( s2 . length ())) { return false ; } if ( n == 0 ) { return true ; } bool *** dp = new bool ** [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool * [ n ]; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ] = new bool [ n + 1 ]{}; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ][ 1 ] = s1 [ i ] == s2 [ j ]; } } for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { for ( int j = 0 ; j < n - len + 1 ; j ++ ) { for ( int k = 1 ; k < len ; k ++ ) { dp [ i ][ j ][ len ] = ( ( dp [ i ][ j ][ k ] && dp [ i + k ][ j + k ][ len - k ]) || ( dp [ i + k ][ j ][ len - k ] && dp [ i ][ j + len - k ][ k ]) ); if ( dp [ i ][ j ][ len ]) { break ; } } } } } bool ans = dp [ 0 ][ 0 ][ n ]; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { delete [] dp [ i ][ j ]; } delete [] dp [ i ]; } delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{4}) O(n^{4}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{3}) O(n^{3}) \u3002","title":"\u5e8f\u5217\u578b"},{"location":"algo/dp/sequence/#_1","text":"\u5e8f\u5217\u578b\u52a8\u6001\u89c4\u5212\u8868\u793a\u72b6\u6001\u6210\u4e00\u4e2a\u5e8f\u5217\uff0c\u53ef\u4ee5\u662f\u65e0\u73af\u56fe\u3001\u4e5f\u53ef\u4ee5\u662f\u6709\u73af\u56fe\u3002","title":"\u57fa\u7840"},{"location":"algo/dp/sequence/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/dp/sequence/#_3","text":"\u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u89c4\u5f8b p\uff0c\u8bf7\u4f60\u6765\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 '.' \u548c ' ' \u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d\u3002'.' \u5339\u914d\u4efb\u610f\u5355\u4e2a\u5b57\u7b26\uff0c' ' \u5339\u914d\u96f6\u4e2a\u6216\u591a\u4e2a\u524d\u9762\u7684\u90a3\u4e00\u4e2a\u5143\u7d20\u3002\u4f8b\u5982\uff0cs = \"ab\"\uff0cp = \".*\"\uff0c\u8fd4\u56de true \u300c\u5206\u6790\u300d \u300c\u533a\u95f4\u578bdp\u300ddp[i][j] \u8868\u793a s[i:] \u548c p[j:] \u5339\u914d\u3002 1\uff09\u68c0\u67e5 s[i] \u548c p[j] \u662f\u5426\u5339\u914d\uff0cp[j] \u53ef\u4ee5\u662f '.' 2\uff09\u5982\u679c p[j+1] \u662f '*'\uff0cdp[i][j] \u53ef\u4ee5\u7531 dp[i][j+2] \u8f6c\u79fb\uff0c\u4e5f\u53ef\u4ee5\u7531 dp[i+1][j] \u8f6c\u79fb\uff1b\u53cd\u4e4b\uff0cdp[i][j] \u53ea\u4f1a\u7531 dp[i+1][j] \u8f6c\u79fb\u3002\u8003\u8651 dp[i+1][j] \u65f6\uff0c\u4e0d\u80fd\u5ffd\u7565 s[i] \u548c p[j] \u662f\u5426\u5339\u914d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '.' ); if ( j < np - 1 && p [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } int res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3002","title":"\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d"},{"location":"algo/dp/sequence/#_4","text":"\u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u627e\u5230 s \u4e2d\u6700\u957f\u7684\u56de\u6587\u5b50\u4e32\u3002\u4f8b\u5982\uff0cs = \"babad\"\uff0c\u8fd4\u56de \u201cbab\u201d \u300c\u5206\u6790\u300d \u300c\u52a8\u6001\u89c4\u5212\u300d\u8bbe dp[i][j] \u8868\u793a\u5b50\u4e32 s[i:j] \u662f\u5426\u662f\u56de\u6587\u4e32\u3002\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a dp[i][j] = \\begin{cases} dp[i+1][j-1], & s[i] == s[j] \\\\ \\text{False}, &\\text{else} \\end{cases} dp[i][j] = \\begin{cases} dp[i+1][j-1], & s[i] == s[j] \\\\ \\text{False}, &\\text{else} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 string longestPalindrome ( string s ) { int n = int ( s . length ()), pos = 0 , len = 1 ; if ( n < 2 ) { return s ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; pos = i ; len = 2 ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { pos = i ; len = k + 1 ; dp [ i ][ j ] = true ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return s . substr ( pos , len ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u8fd9\u91cc n \u8868\u793a s \u7684\u957f\u5ea6\u3002 \u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528\u4e2d\u5fc3\u6269\u6563\u7684\u65b9\u6cd5\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u7684\u5b57\u7b26\u53ef\u4ee5\u5411\u4e24\u4fa7\u6269\u6563\uff0c\u76f4\u5230\u78b0\u5230\u4e0d\u80fd\u6784\u6210\u56de\u6587\u5b50\u4e32\u505c\u6b62\u3002\u9700\u8981\u5206\u5b50\u4e32\u4e3a\u5947\u6570\u548c\u5076\u6570\u4e24\u79cd\u60c5\u51b5\u3002","title":"\u6700\u957f\u56de\u6587\u5b50\u4e32"},{"location":"algo/dp/sequence/#_5","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570 n \uff0c\u6c42\u6070\u7531 n \u4e2a\u8282\u70b9\u7ec4\u6210\u4e14\u8282\u70b9\u503c\u4ece 1 \u5230 n \u4e92\u4e0d\u76f8\u540c\u7684 \u4e8c\u53c9\u641c\u7d22\u6811 \u6709\u591a\u5c11\u79cd\uff1f\u8fd4\u56de\u6ee1\u8db3\u9898\u610f\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u79cd\u6570\u3002\u4f8b\u5982\uff0cn = 3\uff0c\u8fd4\u56de 5\u3002 \u300c\u5206\u6790\u300d Catalan number \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} 1 2 3 4 5 6 7 int numTrees ( int n ) { long C = 1 ; for ( int i = 0 ; i < n ; i ++ ) { C = C * 2 * ( 2 * i + 1 ) / ( i + 2 ) ; } return int ( C ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u4e0d\u540c\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u4e2a\u6570"},{"location":"algo/dp/sequence/#_6","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums = [3, 4, 2]\uff0c\u4f60\u53ef\u4ee5\u5bf9\u5b83\u8fdb\u884c\u4e00\u4e9b\u64cd\u4f5c\u3002\u6bcf\u6b21\u64cd\u4f5c\u4e2d\uff0c\u9009\u62e9\u4efb\u610f\u4e00\u4e2a nums[i] \uff0c\u5220\u9664\u5b83\u5e76\u83b7\u5f97 nums[i] \u7684\u70b9\u6570\u3002\u4e4b\u540e\uff0c\u4f60\u5fc5\u987b\u5220\u9664\u6bcf\u4e2a\u7b49\u4e8e nums[i] - 1 \u6216 nums[i] + 1 \u7684\u5143\u7d20\u3002\u5f00\u59cb\u4f60\u62e5\u6709 0 \u4e2a\u70b9\u6570\u3002\u8fd4\u56de\u4f60\u80fd\u901a\u8fc7\u8fd9\u4e9b\u64cd\u4f5c\u83b7\u5f97\u7684\u6700\u5927\u70b9\u6570\u3002\u7ed9\u51fa\u7684\u4f8b\u5b50\u7684\u7ed3\u679c\u662f 6\uff08\u5220\u9664 4 \u83b7\u5f97 4 \u4e2a\u70b9\u6570\uff0c\u56e0\u6b64 3 \u4e5f\u88ab\u5220\u9664\uff0c\u4e4b\u540e\uff0c\u5220\u9664 2 \u83b7\u5f97 2 \u4e2a\u70b9\u6570\u3002\u603b\u5171\u83b7\u5f97 6 \u4e2a\u70b9\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int deleteAndEarn ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } map < int , int >:: iterator iter = ++ cnt . begin (); int lastN = cnt . begin () -> first , lastC = cnt . begin () -> second ; int a = 0 , b = lastN * lastC ; for (; iter != cnt . end (); iter ++ ) { int na = max ( a , b ), nb = iter -> first * iter -> second ; if ( lastN + 1 == iter -> first ) { nb += a ; } else { nb += max ( a , b ); } a = na ; b = nb ; lastN = iter -> first ; } return max ( a , b ); }","title":"\u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570"},{"location":"algo/dp/sequence/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n\uff0c\u8868\u793a\u5929\u6570\u3002\u4e00\u4e2a\u5b66\u751f\u6bcf\u5929\u7684\u51fa\u52e4\u72b6\u6001\u662f\uff1a\u7f3a\u52e4\uff08A\uff09\u3001\u8fdf\u5230\uff08L\uff09\u3001\u51fa\u52e4\uff08P\uff09\uff0c\u5982\u679c\u5728 n \u5929\u4e2d\uff0c\u4ed6\u80fd\u83b7\u5f97\u51fa\u52e4\u5956\u52b1\u7684\u6761\u4ef6\u662f\uff1a\uff081\uff09\u4e0d\u8d85\u8fc7 1 \u6b21\u7f3a\u52e4\uff0c\uff082\uff09\u8fde\u7eed\u8fdf\u5230\u5929\u6570\u4e0d\u8d85\u8fc7 2 \u5929\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u51fa\u52e4\u65b9\u5f0f\u6709\u591a\u5c11\u79cd\uff1f \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ][ k ] \u8868\u793a\u524d i \u5929\u6709 j \u6b21\u7f3a\u52e4\uff08A\uff09\u4e14\u4ee5\u8fde\u7eed k \u4e2a\u8fdf\u5230\uff08L\uff09\u4e3a\u7ed3\u5c3e\u7684\u51fa\u52e4\u65b9\u6848\u6570\u76ee\u3002\u56e0\u4e3a\u6700\u591a\u7f3a\u52e4\u4e00\u6b21\uff0c\u6240\u4ee5 j \\in \\{0, 1\\} j \\in \\{0, 1\\} \uff1b\u6700\u591a\u8fde\u7eed\u4e24\u6b21\u8fdf\u5230\uff0c k \\in \\{0, 1, 2\\} k \\in \\{0, 1, 2\\} \u3002\u521d\u59cb\u72b6\u6001 dp[ 0 ][ 0 ][ 0 ] = 1\u3002 \u5f53\u7b2c i \u5929\u662f P \u65f6\uff0c\u7ed3\u5c3e\u7684\u8fde\u7eed L \u4e2a\u6570\u6e05\u96f6 \\text{dp[ i ][ j ][ 0 ]} = \\sum_{k \\in \\{0, 1, 2\\}} \\text{dp[ i ][ j ][ 0 ] + dp[i - 1][ j ][ k ]} \\text{dp[ i ][ j ][ 0 ]} = \\sum_{k \\in \\{0, 1, 2\\}} \\text{dp[ i ][ j ][ 0 ] + dp[i - 1][ j ][ k ]} \u5f53\u7b2c i \u5929\u662f A \u65f6\uff0c\u7ed3\u5c3e\u7684\u8fde\u7eed L \u4e2a\u6570\u6e05\u96f6\uff0c\u4e14\u4e0a\u4e00\u4e2a\u7684\u72b6\u6001\u4e00\u5b9a\u662f 0 \u4e2a A \\text{dp[ i ][ 1 ][ 0 ]} = \\text{dp[ i ][ 1 ][ 0 ] + dp[i - 1][ 0 ][ k ]} \\text{dp[ i ][ 1 ][ 0 ]} = \\text{dp[ i ][ 1 ][ 0 ] + dp[i - 1][ 0 ][ k ]} \u5f53\u7b2c i \u5929\u662f L \u65f6\uff0c\u7ed3\u5c3e\u7684\u8fde\u7eed L \u4e2a\u6570\u52a0\u4e00 \\text{dp[ i ][ j ][ k ]} = \\sum_{k \\in \\{1, 2\\}} \\text{dp[ i ][ j ][ k ] + dp[i - 1][ j ][k - 1]} \\text{dp[ i ][ j ][ k ]} = \\sum_{k \\in \\{1, 2\\}} \\text{dp[ i ][ j ][ k ] + dp[i - 1][ j ][k - 1]} \u603b\u5171 6 \u4e2a\u72b6\u6001\uff0c\u6574\u7406\u5982\u4e0b \\begin{aligned} & \\text{dp00 = dp00 + dp01 + dp02} \\\\ & \\text{dp01 = dp00} \\\\ & \\text{dp02 = dp01} \\\\ & \\text{dp10 = dp00 + dp01 + dp02 + dp10 + dp11 + dp12} \\\\ & \\text{dp11 = dp10} \\\\ & \\text{dp12 = dp11} \\end{aligned} \\begin{aligned} & \\text{dp00 = dp00 + dp01 + dp02} \\\\ & \\text{dp01 = dp00} \\\\ & \\text{dp02 = dp01} \\\\ & \\text{dp10 = dp00 + dp01 + dp02 + dp10 + dp11 + dp12} \\\\ & \\text{dp11 = dp10} \\\\ & \\text{dp12 = dp11} \\end{aligned} \u72b6\u6001\u8f6c\u79fb\u77e9\u9635 M = \\begin{bmatrix} 1 & 1 & 0 & 1 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\end{bmatrix} \\quad \\text{dp} = \\begin{bmatrix} \\text{dp00} \\\\ \\text{dp01} \\\\ \\text{dp02} \\\\ \\text{dp10} \\\\ \\text{dp11} \\\\ \\text{dp12} \\end{bmatrix} M = \\begin{bmatrix} 1 & 1 & 0 & 1 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\end{bmatrix} \\quad \\text{dp} = \\begin{bmatrix} \\text{dp00} \\\\ \\text{dp01} \\\\ \\text{dp02} \\\\ \\text{dp10} \\\\ \\text{dp11} \\\\ \\text{dp12} \\end{bmatrix} \\text{dpNew} = \\text{M dpOld} = M^{n} \\text{ dpOld} \\text{dpNew} = \\text{M dpOld} = M^{n} \\text{ dpOld} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int checkRecord ( int n ) { vector < vector < vector < int >>> dp ( n + 1 , vector < vector < int >> ( 2 , vector < int > ( 3 , 0 ))); dp [ 0 ][ 0 ][ 0 ] = 1 ; const int mod = 1000000007 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 1 ; j ++ ) { for ( int k = 0 ; k <= 2 ; k ++ ) { dp [ i ][ j ][ 0 ] = ( dp [ i ][ j ][ 0 ] + dp [ i - 1 ][ j ][ k ]) % mod ; } } for ( int k = 0 ; k <= 2 ; k ++ ) { dp [ i ][ 1 ][ 0 ] = ( dp [ i ][ 1 ][ 0 ] + dp [ i - 1 ][ 0 ][ k ]) % mod ; } for ( int j = 0 ; j <= 1 ; j ++ ) { for ( int k = 1 ; k <= 2 ; k ++ ) { dp [ i ][ j ][ k ] = ( dp [ i ][ j ][ k ] + dp [ i - 1 ][ j ][ k - 1 ]) % mod ; } } } int ans = 0 ; for ( int j = 0 ; j <= 1 ; j ++ ) { for ( int k = 0 ; k <= 2 ; k ++ ) { ans = ( ans + dp [ n ][ j ][ k ]) % mod ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n)\uff0c O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u4f7f\u7528\u5feb\u901f\u5e42\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 const int mod = 1000000007 ; vector < vector < int >> multiply ( vector < vector < int >> a , vector < vector < int >> b ) { vector < vector < int >> ans ( 6 , vector < int > ( 6 , 0 )); for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 6 ; j ++ ) { for ( int k = 0 ; k < 6 ; k ++ ) { ans [ i ][ j ] = ( ans [ i ][ j ] + ( long ) a [ i ][ k ] * b [ k ][ j ]) % mod ; } } } return ans ; } vector < vector < int >> nMultiply ( vector < vector < int >> M , int n ) { vector < vector < int >> ans { { 1 , 0 , 0 , 0 , 0 , 0 }, { 0 , 1 , 0 , 0 , 0 , 0 }, { 0 , 0 , 1 , 0 , 0 , 0 }, { 0 , 0 , 0 , 1 , 0 , 0 }, { 0 , 0 , 0 , 0 , 1 , 0 }, { 0 , 0 , 0 , 0 , 0 , 1 } }; while ( n ) { if ( n & 1 ) { ans = multiply ( ans , M ); } M = multiply ( M , M ); n >>= 1 ; } return ans ; } int checkRecord ( int n ) { int ans = 0 ; vector < vector < int >> M { { 1 , 1 , 0 , 1 , 0 , 0 }, { 1 , 0 , 1 , 1 , 0 , 0 }, { 1 , 0 , 0 , 1 , 0 , 0 }, { 0 , 0 , 0 , 1 , 1 , 0 }, { 0 , 0 , 0 , 1 , 0 , 1 }, { 0 , 0 , 0 , 1 , 0 , 0 } }; M = nMultiply ( M , n ); for ( int j = 0 ; j < 6 ; j ++ ) { ans = ( ans + M [ 0 ][ j ]) % mod ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n)\uff0c O(\\log n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u51fa\u52e4\u65b9\u6848\u6570"},{"location":"algo/dp/sequence/#_8","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n\uff0c\u5982\u679c\u5c06 1 - n \u5f62\u6210\u4e00\u4e2a\u6392\u5217 seq\uff0c\u4e14\u5728 i \u4f4d\u7f6e\u4e0a\u6ee1\u8db3 i % seq[ i ] == 0 \u6216 seq[ i ] % i == 0\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u4e00\u4e2a\u3010\u4f18\u7f8e\u5e8f\u5217\u3011\u3002\u8bd5\u95ee\u5bf9\u4e8e n \u800c\u8a00\uff0c\u603b\u5171\u6709\u591a\u5c11\u4e2a\u3010\u4f18\u7f8e\u5e8f\u5217\u3011\u3002 \u300c\u5206\u6790\u300d \u3010\u56de\u6eaf\u3011\u80fd\u4e0d\u80fd\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684\u5e8f\u5217\uff0c\u4e3b\u8981\u770b\u67d0\u4e00\u4e2a\u4f4d\u7f6e i \u548c\u8fd9\u4e2a\u4f4d\u7f6e\u5bf9\u5e94\u7684\u6570\u503c\u662f\u5426\u6574\u9664\u3002\u6211\u4eec\u53ef\u4ee5\u9010\u4e2a\u4f4d\u7f6e\u586b\u5145 1 - n \u7684\u5143\u7d20\uff0c\u5982\u679c\u80fd\u5f97\u5230\u4e00\u4e2a\u5b8c\u6574\u7684\u5e8f\u5217\uff0c\u5219\u603b\u7ed3\u679c\u52a0\u4e00\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector < vector < int >> next ; int dfs ( bool * vis , int idx , int n ) { if ( idx == n + 1 ) { return 1 ; } int ans = 0 ; for ( int ele : next [ idx ]) { if ( vis [ ele ]) { continue ; } vis [ ele ] = true ; ans += dfs ( vis , idx + 1 , n ); vis [ ele ] = false ; } return ans ; } int countArrangement ( int n ) { bool * vis = new bool [ n + 1 ] {}; next . resize ( n + 1 , vector < int > {}); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i % j == 0 || j % i == 0 ) { next [ i ]. emplace_back ( j ); } } } int ans = dfs ( vis , 1 , n ); delete [] vis ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n!) O(n!) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \u3010\u72b6\u6001\u538b\u7f29 + \u52a8\u6001\u89c4\u5212\u3011\u5f62\u6210\u4e00\u4e2a\u5e8f\u5217\uff0c\u5fc5\u7136\u6709\u67d0\u4e9b\u5143\u7d20\u5148\u88ab\u586b\u5145\uff0c\u5269\u4e0b\u7684\u5143\u7d20\u540e\u88ab\u586b\u5145\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a 32-bit \u7684\u6574\u6570\u8868\u793a\u8fd9\u6837\u7684\u5e8f\u5217\uff0c\u8fd9\u5c31\u53eb\u3010\u72b6\u6001\u538b\u7f29\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int countArrangement ( int n ) { vector < int > dp ( 1 << n , 0 ); dp [ 0 ] = 1 ; for ( int mask = 1 ; mask < ( 1 << n ); mask ++ ) { int numOf1 = __builtin_popcount ( mask ); for ( int j = 0 ; j < n ; j ++ ) { if (( mask & ( 1 << j )) && ( numOf1 % ( j + 1 ) == 0 || ( j + 1 ) % numOf1 == 0 )) { dp [ mask ] += dp [ mask ^ ( 1 << j )]; } } } return dp [( 1 << n ) - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n 2^{n}) O(n 2^{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(2^{n}) O(2^{n})","title":"\u4f18\u7f8e\u5e8f\u5217"},{"location":"algo/dp/sequence/#k","text":"\u7ed9\u4e00\u5b9a\u4e00\u4e2a\u822a\u73ed\u5217\u8868 flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]\uff0c\u8868\u793a\u4ece i \u5230 j \u7684\u5355\u5411\u822a\u73ed\u7684\u4ef7\u683c\uff0c\u8bd5\u95ee\u81f3\u591a k \u6b21\u4e2d\u8f6c\uff0c\u4ece src \u5230 dst \u7684\u6700\u4f4e\u4ef7\u683c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ t ][ i ] \u4e3a\u4ece src \u7ecf\u8fc7 t \u6b21\u4e2d\u8f6c\u5230 i \u7684\u6700\u4f4e\u4ef7\u683c\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ t ][ i ]} = \\min_{(j, i) \\in E} \\text{dp[t - 1][ j ] + cost[ j ][ i ]} \\text{dp[ t ][ i ]} = \\min_{(j, i) \\in E} \\text{dp[t - 1][ j ] + cost[ j ][ i ]} \u521d\u59cb\u72b6\u6001 \\text{dp[ 0 ][ i ]} = \\begin{cases} 0, &\\quad i = \\text{dst} \\\\ \\text{INF}, &\\quad i \\neq \\text{dst} \\end{cases} \\text{dp[ 0 ][ i ]} = \\begin{cases} 0, &\\quad i = \\text{dst} \\\\ \\text{INF}, &\\quad i \\neq \\text{dst} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int findCheapestPrice ( int n , vector < vector < int >>& flights , int src , int dst , int k ) { int MAX = 10000 * n + 1 ; vector < vector < int >> dp ( k + 2 , vector < int > ( n , MAX )); dp [ 0 ][ src ] = 0 ; for ( int t = 1 ; t <= k + 1 ; t ++ ) { for ( auto flight : flights ) { dp [ t ][ flight [ 1 ]] = min ( dp [ t ][ flight [ 1 ]], dp [ t - 1 ][ flight [ 0 ]] + flight [ 2 ]); } } int ans = MAX ; for ( int t = 0 ; t <= k + 1 ; t ++ ) { ans = min ( ans , dp [ t ][ dst ]); } return ans == MAX ? - 1 : ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(km) O(km) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(kn) O(kn) \uff0c\u5176\u4e2d m \u662f\u822a\u73ed\u5217\u8868\u7684\u957f\u5ea6\uff0cn \u662f\u8282\u70b9\u7684\u4e2a\u6570","title":"\u81f3\u591a k \u6b21\u4e2d\u8f6c\u7684\u6700\u4f4e\u4ef7\u683c"},{"location":"algo/dp/sequence/#n","text":"\\text{fib}(n) = \\begin{cases} 0, & \\quad n = 0 \\\\ 1, & \\quad n = 1 \\\\ \\text{fib}(n - 1) + \\text{fib}(n), & \\quad n \\geq 2 \\end{cases} \\text{fib}(n) = \\begin{cases} 0, & \\quad n = 0 \\\\ 1, & \\quad n = 1 \\\\ \\text{fib}(n - 1) + \\text{fib}(n), & \\quad n \\geq 2 \\end{cases} \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212 + \u5feb\u901f\u5e42\u3011\u6839\u636e\u9012\u63a8\u516c\u793a\u6784\u9020\u72b6\u6001\u8f6c\u79fb\u77e9\u9635 \\begin{aligned} \\begin{bmatrix} f_{n} \\\\ f_{n - 1} \\end{bmatrix} &= \\begin{bmatrix} f_{n - 1} + f_{n - 2} \\\\ f_{n - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} f_{n - 1} \\\\ f_{n - 2} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{2} \\begin{bmatrix} f_{n - 2} \\\\ f_{n - 3} \\end{bmatrix} \\\\ &= \\quad \\quad \\quad \\vdots \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{n - 1} \\begin{bmatrix} f_{1} \\\\ f_{0} \\end{bmatrix} \\end{aligned} \\begin{aligned} \\begin{bmatrix} f_{n} \\\\ f_{n - 1} \\end{bmatrix} &= \\begin{bmatrix} f_{n - 1} + f_{n - 2} \\\\ f_{n - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} f_{n - 1} \\\\ f_{n - 2} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{2} \\begin{bmatrix} f_{n - 2} \\\\ f_{n - 3} \\end{bmatrix} \\\\ &= \\quad \\quad \\quad \\vdots \\\\ &= \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{n - 1} \\begin{bmatrix} f_{1} \\\\ f_{0} \\end{bmatrix} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : int mod = 1000000007 ; int fib ( int n ) { if ( n < 2 ) { return n ; } vector < vector < long >> M { { 1 , 1 }, { 1 , 0 } }; M = nMultiply ( M , n - 1 ); return M [ 0 ][ 0 ]; } vector < vector < long >> nMultiply ( vector < vector < long >> a , int n ) { vector < vector < long >> ans { { 1 , 0 }, { 0 , 1 } }; while ( n ) { if ( n % 2 != 0 ) { ans = multiply ( ans , a ); } n >>= 1 ; a = multiply ( a , a ); } return ans ; } vector < vector < long >> multiply ( vector < vector < long >> a , vector < vector < long >> b ) { vector < vector < long >> ans { { 0 , 0 }, { 0 , 0 } }; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { ans [ i ][ j ] = (( a [ i ][ 0 ] * b [ 0 ][ j ]) % mod + ( a [ i ][ 1 ] * b [ 1 ][ j ]) % mod ) % mod ; } } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7b2c n \u9879"},{"location":"algo/dp/sequence/#_9","text":"\u4f60\u9700\u8981\u8bbf\u95ee n \u4e2a\u623f\u95f4\uff0c\u623f\u95f4\u4ece 0 \u5230 n - 1 \u7f16\u53f7\u3002\u540c\u65f6\uff0c\u6bcf\u4e00\u5929\u90fd\u6709\u4e00\u4e2a\u65e5\u671f\u7f16\u53f7\uff0c\u4ece 0 \u5f00\u59cb\uff0c\u4f9d\u5929\u6570\u9012\u589e\u3002\u4f60\u6bcf\u5929\u90fd\u4f1a\u8bbf\u95ee\u4e00\u4e2a\u623f\u95f4\u3002 \u6700\u5f00\u59cb\u7684\u7b2c 0 \u5929\uff0c\u4f60\u8bbf\u95ee 0 \u53f7\u623f\u95f4\u3002\u7ed9\u4f60\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u4e14 \u4e0b\u6807\u4ece 0 \u5f00\u59cb \u7684\u6570\u7ec4 nextVisit \u3002\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u5929\u4e2d\uff0c\u4f60\u8bbf\u95ee\u623f\u95f4\u7684 \u6b21\u5e8f \u5c06\u6839\u636e\u4e0b\u9762\u7684 \u89c4\u5219 \u51b3\u5b9a\uff1a \u5047\u8bbe\u67d0\u4e00\u5929\uff0c\u4f60\u8bbf\u95ee i \u53f7\u623f\u95f4\u3002 * \u5982\u679c\u7b97\u4e0a\u672c\u6b21\u8bbf\u95ee\uff0c\u8bbf\u95ee i \u53f7\u623f\u95f4\u7684\u6b21\u6570\u4e3a \u5947\u6570 \uff0c\u90a3\u4e48 \u7b2c\u4e8c\u5929 \u9700\u8981\u8bbf\u95ee nextVisit[i] \u6240\u6307\u5b9a\u7684\u623f\u95f4\uff0c\u5176\u4e2d 0 <= nextVisit[i] <= i \u3002 * \u5982\u679c\u7b97\u4e0a\u672c\u6b21\u8bbf\u95ee\uff0c\u8bbf\u95ee i \u53f7\u623f\u95f4\u7684\u6b21\u6570\u4e3a \u5076\u6570 \uff0c\u90a3\u4e48 \u7b2c\u4e8c\u5929 \u9700\u8981\u8bbf\u95ee (i + 1) mod n \u53f7\u623f\u95f4\u3002 \u8bf7\u8fd4\u56de\u4f60\u8bbf\u95ee\u5b8c\u6240\u6709\u623f\u95f4\u7684\u7b2c\u4e00\u5929\u7684\u65e5\u671f\u7f16\u53f7\u3002\u9898\u76ee\u6570\u636e\u4fdd\u8bc1\u603b\u662f\u5b58\u5728\u8fd9\u6837\u7684\u4e00\u5929\u3002\u7531\u4e8e\u7b54\u6848\u53ef\u80fd\u5f88\u5927\uff0c\u8fd4\u56de\u5bf9 109 + 7 \u53d6\u4f59\u540e\u7684\u7ed3\u679c\u3002 \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ i ] \u4e3a\u7b2c\u4e00\u6b21\u8bbf\u95ee\u7b2c i \u4e2a\u623f\u95f4\u7684\u6240\u9700\u8981\u7684\u5929\u6570\u3002\u6839\u636e\u9898\u610f\uff0c\u5982\u679c\u8981\u7b2c\u4e00\u6b21\u8bbf\u95ee\u7b2c i \u4e2a\u623f\u95f4\uff0c\u90a3\u4e48\u524d\u9762\u7684 i - 1 \u4e2a\u623f\u95f4\u8bbf\u95ee\u6b21\u6570\u5fc5\u987b\u662f\u5076\u6570\uff0c\u5e76\u4e14\u4e00\u5b9a\u662f\u7531\u7b2c i - 1 \u4e2a\u623f\u95f4\u3010\u52a0\u4e00\u5929\u3011\u800c\u6765\u7684\u3002\u5982\u679c nextVisit[i - 1] == i- 1\uff0c\u90a3\u4e48\u4e0b\u4e00\u5929\u8bbf\u95ee\u7684\u4f9d\u636e\u662f i - 1 \u623f\u95f4\uff0c\u518d\u52a0\u4e00\u5929\u624d\u80fd\u5230 i \u623f\u95f4\u3002\u5982\u679c nextVisit[i - 1] != i- 1\uff0c\u6211\u4eec\u9700\u8981\u4ece nextVisit[i - 1] \u8bbf\u95ee\u5230 i - 1\u6b64\u65f6\u9700\u8981 dp[i - 1] - dp[nextVisit[i - 1]]\uff08\u524d\u7f00\u548c\uff09 \\text{dp[ i ]} = \\begin{cases} \\text{dp[i - 1]} + 2, &\\quad \\text{nextVist[i - 1] == i - 1} \\\\ \\text{dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1, &\\quad \\text{otherwise} \\end{cases} \\text{dp[ i ]} = \\begin{cases} \\text{dp[i - 1]} + 2, &\\quad \\text{nextVist[i - 1] == i - 1} \\\\ \\text{dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1, &\\quad \\text{otherwise} \\end{cases} \u6574\u7406\u5f97\u5230\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\text{dp[ i ] = dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1 \\text{dp[ i ] = dp[i - 1]} + 1 + \\text{dp[i - 1] - dp[nextVisit[i - 1]]} + 1 1 2 3 4 5 6 7 8 9 10 11 int firstDayBeenInAllRooms ( vector < int >& nextVisit ) { int mod = 1000000007 , n = ( int ) nextVisit . size (); vector < int > dp ( n , 0 ); for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] - dp [ nextVisit [ i - 1 ]] + 2 ) % mod ; if ( dp [ i ] < 0 ) { dp [ i ] += mod ; } } return dp [ n - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0cn \u4e3a nextVisit \u7684\u957f\u5ea6","title":"\u8bbf\u95ee\u5b8c\u6240\u6709\u623f\u95f4\u7684\u7b2c\u4e00\u5929"},{"location":"algo/dp/sequence/#_10","text":"0,1,\u00b7\u00b7\u00b7,n-1\u8fd9n\u4e2a\u6570\u5b57\u6392\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\uff0c\u6bcf\u6b21\u4ece\u8fd9\u4e2a\u5706\u5708\u91cc\u5220\u9664\u7b2cm\u4e2a\u6570\u5b57\uff08\u5220\u9664\u540e\u4ece\u4e0b\u4e00\u4e2a\u6570\u5b57\u5f00\u59cb\u8ba1\u6570\uff09\u3002\u6c42\u51fa\u8fd9\u4e2a\u5706\u5708\u91cc\u5269\u4e0b\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\uff0c0\u30011\u30012\u30013\u30014\u8fd95\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\u6bcf\u6b21\u5220\u9664\u7b2c3\u4e2a\u6570\u5b57\uff0c\u5219\u5220\u9664\u7684\u524d4\u4e2a\u6570\u5b57\u4f9d\u6b21\u662f2\u30010\u30014\u30011\uff0c\u56e0\u6b64\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57\u662f3\u3002 \u3010\u5206\u6790\u3011 \u3010\u52a8\u6001\u89c4\u5212\u3011\u5047\u8bbe\u957f\u5ea6\u4e3a n - 1 \u7684\u5706\u5708\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57\u662f x\uff0c\u90a3\u4e48\u957f\u5ea6\u4e3a n \u7684\u5706\u5708\u5269\u4e0b\u7684\u5143\u7d20\u662f\u4ece x \u5f00\u59cb\u7684\u7b2c m \u4e2a\u5143\u7d20\uff0c\u56e0\u4e3a\u6211\u4eec\u53ea\u9700\u8981\u4ece n - 1 \u7684\u72b6\u6001\u591a\u8d70\u4e00\u6b65\u5373\u53ef\u5230\u8fbe n\u3002 \\text{dp[ n ] = (m + dp[n - 1]) mod n} \\text{dp[ n ] = (m + dp[n - 1]) mod n} 1 2 3 4 5 6 7 int lastRemaining ( int n , int m ) { int a = 0 ; for ( int i = 1 ; i < n ; i ++ ) { a = ( a + m ) % ( i + 1 ); } return a ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57"},{"location":"algo/dp/sequence/#n_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n \u8868\u793a\u9ab0\u5b50\u7684\u4e2a\u6570\uff0c\u6c42\u8fd9 n \u4e2a\u9ab0\u5b50\u51fa\u73b0\u7684\u70b9\u548c\u6982\u7387\uff0c\u7ed3\u679c\u6309\u7167\u70b9\u548c\uff08\u975e\u6982\u7387\uff09\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u5982 n = 2\uff0c\u70b9\u548c\u4e3a [6, 7, 8, 9, 10, 11, 12]\uff0c\u5bf9\u5e94\u7684\u6982\u7387\u662f [0.02778, 0.05556, 0.08333, 0.11111, 0.13889, 0.16667, 0.13889, 0.11111, 0.08333, 0.05556, 0.02778]\u3002 \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ i ][ j ] \u8868\u793a i \u4e2a\u9ab0\u5b50\u7ec4\u6210\u70b9\u548c\u4e3a j \u7684\u6982\u7387 \\text{dp[ i ][ j ]} = \\sum_{k = 6}^{6} \\frac{\\text{dp[i - 1][j - k]}}{6} \\text{dp[ i ][ j ]} = \\sum_{k = 6}^{6} \\frac{\\text{dp[i - 1][j - k]}}{6} \u56e0\u4e3a\u7b2c i \u4e2a\u9ab0\u5b50\u7684\u7ed3\u679c\u53ea\u8ddf\u7b2c i - 1 \u4e2a\u9ab0\u5b50\u7684\u7ed3\u679c\u76f8\u5173\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4e00\u7ef4\u6570\u7ec4\u8868\u793a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < double > dicesProbability ( int n ) { vector < double > ans ( 6 , 1.0 / 6 ); for ( int i = 2 ; i <= n ; i ++ ) { vector < double > tmp ( 6 * i - i + 1 , 0.0 ); for ( int j = 0 ; j < ans . size (); j ++ ) { for ( int k = 0 ; k < 6 ; k ++ ) { tmp [ j + k ] += ans [ j ] * 1.0 / 6 ; } } ans = tmp ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"n \u4e2a\u9ab0\u5b50\u7684\u70b9\u6570\u6982\u7387"},{"location":"algo/dp/sequence/#_11","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u7ef4\u5217\u8868 questions = [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]] \u8868\u793a\u4e00\u7cfb\u5217\u7684\u9898\u76ee\uff0cquestions[ i ] = [score, skipNum]\uff0c\u5373\u5982\u679c\u4f5c\u7b54\u7b2c i \u9898\uff0c\u5c06\u83b7\u5f97\u5bf9\u5e94\u7684\u5206\u6570 score\uff0c\u4f46\u662f\u63a5\u4e0b\u6765\u9700\u8981\u8df3\u8fc7 skipNum \u4e2a\u9898\u76ee\uff1b\u5f53\u7136\uff0c\u7b2c i \u9053\u9898\u76ee\u4e5f\u53ef\u4ee5\u9009\u62e9\u4e0d\u4f5c\u7b54\uff0c\u8bd5\u95ee\uff0c\u6700\u591a\u53ef\u4ee5\u83b7\u5f97\u7684\u5206\u6570\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u52a8\u6001\u89c4\u5212\u3011\u8bbe dp[ i ] \u4e3a\u5904\u4e8e\u7b2c i \u9898\u65f6\uff0c\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u5206\u6570\uff0c \u4ece\u540e\u5411\u524d \u904d\u5386 \\text{dp[ i ]} = \\begin{cases} \\text{max ( dp[i + 1], dp[i + questions[ i ][ 1 ]] + questions[ i ][ 0 ]}, & \\quad \\text{i + questions[ i ][ 1 ] + 1} \\geq n \\\\ \\text{max ( dp[i + 1], questions[ i ][ 0 ])}, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ]} = \\begin{cases} \\text{max ( dp[i + 1], dp[i + questions[ i ][ 1 ]] + questions[ i ][ 0 ]}, & \\quad \\text{i + questions[ i ][ 1 ] + 1} \\geq n \\\\ \\text{max ( dp[i + 1], questions[ i ][ 0 ])}, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long long mostPoints ( vector < vector < int >>& questions ) { typedef long long ll ; int n = ( int ) questions . size (); vector < ll > dp ( n , 0 ); dp [ n - 1 ] = questions [ n - 1 ][ 0 ]; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = dp [ i + 1 ]; if ( i + questions [ i ][ 1 ] >= n ) { dp [ i ] = max ( dp [ i ], ( ll ) questions [ i ][ 0 ]); } else { dp [ i ] = max ( dp [ i ], questions [ i ][ 0 ] + dp [ i + questions [ i ][ 1 ]]); } } return dp [ 0 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u83b7\u5f97\u6700\u591a\u7b54\u9898\u5206\u6570"},{"location":"algo/dp/sequence/#_12","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4f60\u4e00\u6839\u957f\u5ea6\u4e3an\u7684\u7ef3\u5b50\uff0c\u8bf7\u628a\u7ef3\u5b50\u526a\u6210\u6574\u6570\u957f\u7684m\u6bb5\uff08m\u3001n\u90fd\u662f\u6574\u6570\uff0cn>1\u5e76\u4e14m>1\uff09\uff0c\u6bcf\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u8bb0\u4e3ak[0],k[1],...,k[m]\u3002\u8bf7\u95eek[0]xk[1]x...xk[m]\u53ef\u80fd\u7684\u6700\u5927\u4e58\u79ef\u662f\u591a\u5c11\uff1f\u4f8b\u5982\uff0c\u5f53\u7ef3\u5b50\u7684\u957f\u5ea6\u662f8\u65f6\uff0c\u6211\u4eec\u628a\u5b83\u526a\u6210\u957f\u5ea6\u5206\u522b\u4e3a2\u30013\u30013\u7684\u4e09\u6bb5\uff0c\u6b64\u65f6\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u662f18\u3002 \u793a\u4f8b1\uff1a\u8f93\u51658\u8f93\u51fa18 \u300c\u5206\u6790\u300d \u8bbe f[ i ] \u4e3a\u957f\u5ea6 i \u7684\u7ef3\u5b50\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u3002\u90a3\u4e48\uff0c\u9010\u4e2a\u5355\u4f4d\u5207\u5206\u6210\u4e24\u6bb5\uff0c\u627e\u5230\u6700\u5927\u7684\u5207\u5272\u65b9\u6848\u3002 f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public \uff1a int cutRope ( int number ) { int n = number ; if ( n < 2 ) { return 0 ; } if ( n == 2 ) { return 1 ; } if ( n == 3 ) { return 2 ; } int * f = new int [ n + 1 ]{}; f [ 1 ] = 1 ; f [ 2 ] = 2 ; f [ 3 ] = 3 ; int prod = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { int max_prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { prod = f [ j ] * f [ i - j ]; if ( max_prod < prod ) { max_prod = prod ; } } f [ i ] = max_prod ; } int res = f [ n ]; delete [] f ; return res ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u526a\u7ef3\u5b50"},{"location":"algo/dp/sequence/#n-x-3","text":"\u4f60\u6709\u4e00\u4e2a n x 3 \u7684\u7f51\u683c\u56fe grid \uff0c\u4f60\u9700\u8981\u7528 \u7ea2\uff0c\u9ec4\uff0c\u7eff \u4e09\u79cd\u989c\u8272\u4e4b\u4e00\u7ed9\u6bcf\u4e00\u4e2a\u683c\u5b50\u4e0a\u8272\uff0c\u4e14\u786e\u4fdd\u76f8\u90bb\u683c\u5b50\u989c\u8272\u4e0d\u540c\uff08\u4e5f\u5c31\u662f\u6709\u76f8\u540c\u6c34\u5e73\u8fb9\u6216\u8005\u5782\u76f4\u8fb9\u7684\u683c\u5b50\u989c\u8272\u4e0d\u540c\uff09\u3002\u7ed9\u4f60\u7f51\u683c\u56fe\u7684\u884c\u6570 n \u3002\u8bf7\u4f60\u8fd4\u56de\u7ed9 grid \u6d82\u8272\u7684\u65b9\u6848\u6570\u3002\u7531\u4e8e\u7b54\u6848\u53ef\u80fd\u4f1a\u975e\u5e38\u5927\uff0c\u8bf7\u4f60\u8fd4\u56de\u7b54\u6848\u5bf9 10^9 + 7 \u53d6\u4f59\u7684\u7ed3\u679c\u3002 \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578bdp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. */ class Solution { public : int numOfWays ( int n ) { int aba = 6 , abc = 6 ; /* aba = aba * 3 + abc * 2 abc = aba * 2 + abc * 2; */ const int MOD = 1000000007 ; for ( int i = 1 ; i < n ; i ++ ) { int new_aba = ( aba * 3ll + abc * 2ll ) % MOD ; int new_abc = ( aba * 2ll + abc * 2ll ) % MOD ; aba = new_aba ; abc = new_abc ; } return ( aba + abc ) % MOD ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u7ed9 N x 3 \u7f51\u683c\u56fe\u6d82\u8272\u7684\u65b9\u6848\u6570"},{"location":"algo/dp/sequence/#_13","text":"\u7ed9\u4f60\u4e00\u4e2a\u53ea\u5305\u542b '(' \u548c ')' \u7684\u5b57\u7b26\u4e32\uff0c\u627e\u51fa\u6700\u957f\u6709\u6548\uff08\u683c\u5f0f\u6b63\u786e\u4e14\u8fde\u7eed\uff09\u62ec\u53f7\u5b50\u4e32\u7684\u957f\u5ea6\u3002\u4f8b\u5982\uff0cs = \")()())\"\uff0c\u8fd4\u56de 4\uff0c\u6700\u957f\u6709\u6548\u62ec\u53f7\u5b50\u4e32\u662f \"()()\"\u3002 \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578bDP\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int longestValidParentheses ( string s ) { int maxLen = 0 , n = int ( s . length ()), leftCount = 0 ; if ( n < 2 ) { return maxLen ; } int * dp = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { if ( leftCount == 0 && s [ i ] == ')' ) { continue ; } if ( s [ i ] == '(' ) { leftCount ++ ; } else { leftCount -- ; dp [ i ] = dp [ i - 1 ] + 1 ; if ( i - dp [ i ] * 2 >= 0 ) { dp [ i ] += dp [ i - dp [ i ] * 2 ]; } } maxLen = maxLen > dp [ i ] ? maxLen : dp [ i ]; } delete [] dp ; return maxLen * 2 ; } // \u5e38\u6570\u7a7a\u95f4 int longestValidParentheses ( string s ) { int ans = 0 , L = 0 , R = 0 ; for ( char c : s ) { if ( c == '(' ) { L ++ ; } else { R ++ ; } if ( L == R ) { ans = max ( ans , 2 * R ); } else if ( L < R ) { L = R = 0 ; } } L = R = 0 ; for ( int i = ( int ) s . length () - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '(' ) { L ++ ; } else { R ++ ; } if ( L == R ) { ans = max ( ans , 2 * R ); } else if ( L > R ) { L = R = 0 ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6700\u957f\u6709\u6548\u62ec\u53f7"},{"location":"algo/dp/sequence/#_14","text":"\u7ed9\u4f60\u4e24\u4e2a\u5b57\u7b26\u4e32 s \u548c t \uff0c\u7edf\u8ba1\u5e76\u8fd4\u56de\u5728 s \u7684 \u5b50\u5e8f\u5217 \u4e2d t \u51fa\u73b0\u7684\u4e2a\u6570\uff0c\u7ed3\u679c\u9700\u8981\u5bf9 100000007 \u53d6\u6a21\u3002\u4f8b\u5982\uff0cs = \"babgbag\", t = \"bag\"\uff0c\u8fd4\u56de 5\uff0c\u56e0\u4e3a s \u6709 5 \u4e2a\u5b50\u5e8f\u5217\u6ee1\u8db3\u8981\u6c42\uff0c\u5373 [babgbag, babgbag, babgbag, babgbag, babgbag] \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578b\u300d\u8bbe dp[i][j] \u8868\u793a s[:i] \u6ee1\u8db3 t[:j] \u7684\u5b50\u5e8f\u5217\u6570\u76ee\u3002\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a dp[i][j] = \\begin{cases} dp[i - 1][j - 1] + dp[i - 1][j], &s[i] == t[j] \\\\ dp[i - 1][j], &\\text{else} \\end{cases} dp[i][j] = \\begin{cases} dp[i - 1][j - 1] + dp[i - 1][j], &s[i] == t[j] \\\\ dp[i - 1][j], &\\text{else} \\end{cases} \u56e0\u4e3a s \u7684\u5b50\u5e8f\u5217\u5fc5\u987b\u5305\u542b t\uff0c\u6240\u4ee5\u72b6\u6001\u8f6c\u79fb\u6765\u81ea s \u7684\u524d\u4e00\u4f4d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int numDistinct ( string s , string t ) { const int MOD = 1000000007 ; vector < vector < int >> dp ( s . size () + 1 , vector < int > ( t . size () + 1 )); for ( int i = 0 ; i <= s . size (); i ++ ) { for ( int j = 0 ; j <= t . size (); j ++ ) { if ( j == 0 ) { dp [ i ][ j ] = 1 ; } else if ( i == 0 ) { dp [ i ][ j ] = 0 ; } else { dp [ i ][ j ] = dp [ i - 1 ][ j ] % MOD ; if ( s [ i - 1 ] == t [ j - 1 ]) { dp [ i ][ j ] = ( dp [ i ][ j ] % MOD + dp [ i - 1 ][ j - 1 ] % MOD ) % MOD ; } } } } return dp [ s . size ()][ t . size ()]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u8fd9\u91cc\uff0cn \u662f s \u7684\u957f\u5ea6\uff0cm \u662f t \u7684\u957f\u5ea6\u3002","title":"\u4e0d\u540c\u7684\u5b50\u5e8f\u5217"},{"location":"algo/dp/sequence/#_15","text":"\u4f7f\u7528\u4e0b\u9762\u63cf\u8ff0\u7684\u7b97\u6cd5\u53ef\u4ee5\u6270\u4e71\u5b57\u7b26\u4e32 s \u5f97\u5230\u5b57\u7b26\u4e32 t \uff1a \u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e3a 1 \uff0c\u7b97\u6cd5\u505c\u6b62 \u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6 > 1 \uff0c\u6267\u884c\u4e0b\u8ff0\u6b65\u9aa4\uff1a \u5728\u4e00\u4e2a\u968f\u673a\u4e0b\u6807\u5904\u5c06\u5b57\u7b26\u4e32\u5206\u5272\u6210\u4e24\u4e2a\u975e\u7a7a\u7684\u5b50\u5b57\u7b26\u4e32\u3002\u5373\uff0c\u5982\u679c\u5df2\u77e5\u5b57\u7b26\u4e32 s \uff0c\u5219\u53ef\u4ee5\u5c06\u5176\u5206\u6210\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32 x \u548c y \uff0c\u4e14\u6ee1\u8db3 s = x + y \u3002\u968f\u673a \u51b3\u5b9a\u662f\u8981\u300c\u4ea4\u6362\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32\u300d\u8fd8\u662f\u8981\u300c\u4fdd\u6301\u8fd9\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32\u7684\u987a\u5e8f\u4e0d\u53d8\u300d\u3002\u5373\uff0c\u5728\u6267\u884c\u8fd9\u4e00\u6b65\u9aa4\u4e4b\u540e\uff0cs \u53ef\u80fd\u662f s = x + y \u6216\u8005 s = y + x \u3002\u5728 x \u548c y \u8fd9\u4e24\u4e2a\u5b50\u5b57\u7b26\u4e32\u4e0a\u7ee7\u7eed\u4ece\u6b65\u9aa4 1 \u5f00\u59cb\u9012\u5f52\u6267\u884c\u6b64\u7b97\u6cd5\u3002\u7ed9\u4f60\u4e24\u4e2a \u957f\u5ea6\u76f8\u7b49 \u7684\u5b57\u7b26\u4e32 s1 \u548c s2\uff0c\u5224\u65ad s2 \u662f\u5426\u662f s1 \u7684\u6270\u4e71\u5b57\u7b26\u4e32\u3002\u5982\u679c\u662f\uff0c\u8fd4\u56de true \uff1b\u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u300c\u5206\u6790\u300d \u300c\u5e8f\u5217\u578b\u300d\u8bbe dp[i][j][k] \u8868\u793a s[i:i+k] \u548c t[j:j+k] \u662f\u6270\u4e71\u5b57\u7b26\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 bool isScramble ( string s1 , string s2 ) { int n = int ( s1 . length ()); if ( n != int ( s2 . length ())) { return false ; } if ( n == 0 ) { return true ; } bool *** dp = new bool ** [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool * [ n ]; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ] = new bool [ n + 1 ]{}; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ][ 1 ] = s1 [ i ] == s2 [ j ]; } } for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { for ( int j = 0 ; j < n - len + 1 ; j ++ ) { for ( int k = 1 ; k < len ; k ++ ) { dp [ i ][ j ][ len ] = ( ( dp [ i ][ j ][ k ] && dp [ i + k ][ j + k ][ len - k ]) || ( dp [ i + k ][ j ][ len - k ] && dp [ i ][ j + len - k ][ k ]) ); if ( dp [ i ][ j ][ len ]) { break ; } } } } } bool ans = dp [ 0 ][ 0 ][ n ]; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { delete [] dp [ i ][ j ]; } delete [] dp [ i ]; } delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{4}) O(n^{4}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n^{3}) O(n^{3}) \u3002","title":"\u6270\u4e71\u5b57\u7b26\u4e32"},{"location":"algo/dp/stocks/","text":"\u4e00\u6b21\u4ea4\u6613 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4prices\uff0c\u5b83\u7684\u7b2ci\u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002\u4f60\u53ea\u80fd\u9009\u62e9 \u67d0\u4e00\u5929 \u4e70\u5165\u8fd9\u53ea\u80a1\u7968\uff0c\u5e76\u9009\u62e9\u5728 \u672a\u6765\u7684\u67d0\u4e00\u4e2a\u4e0d\u540c\u7684\u65e5\u5b50 \u5356\u51fa\u8be5\u80a1\u7968\u3002\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u8fd4\u56de\u4f60\u53ef\u4ee5\u4ece\u8fd9\u7b14\u4ea4\u6613\u4e2d\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u5982\u679c\u4f60\u4e0d\u80fd\u83b7\u53d6\u4efb\u4f55\u5229\u6da6\uff0c\u8fd4\u56de 0 \u3002 \u8f93\u5165\uff1a[7, 1, 5, 3, 6, 4] \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a\u5728\u7b2c 2 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 6\uff09\u7684\u65f6\u5019\u5356\u51fa\uff0c\u6700\u5927\u5229\u6da6 = 6-1 = 5 \u3002\u6ce8\u610f\u5229\u6da6\u4e0d\u80fd\u662f 7-1 = 6, \u56e0\u4e3a\u5356\u51fa\u4ef7\u683c\u9700\u8981\u5927\u4e8e\u4e70\u5165\u4ef7\u683c\uff1b\u540c\u65f6\uff0c\u4f60\u4e0d\u80fd\u5728\u4e70\u5165\u524d\u5356\u51fa\u80a1\u7968\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6700\u5927\u5229\u6da6 = \u5356\u51fa\u65f6\u7684\u4ef7\u683c - \u4e70\u5165\u65f6\u7684\u4ef7\u683c\uff0c\u90a3\u4e48\u9488\u5bf9\u6bcf\u4e00\u5929i\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u8fd9\u4e00\u5929\u7684\u6700\u5927\u5229\u6da6 \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \u5f88\u5bb9\u6613\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u65b9\u6cd5\u3002\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2ai\uff0c\u6211\u4eec\u91cd\u590d\u6c42\u89e3i\u4e4b\u524d\u7684\u6700\u5c0f\u80a1\u7968\u4ef7\u683c\uff0c\u8fd9\u4e00\u6b65\u662f\u5197\u4f59\u7684\uff0c\u56e0\u4e3a\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86[0, i)\u7684\u6700\u5c0f\u503cx\uff0c\u90a3\u4e48[0, i]\u7684\u6700\u5c0f\u503c a\u2018 = min(a, stocks[ i ])\uff0c\u4ece\u800c\u907f\u514d\u4e86\u91cd\u590d\u904d\u5386\u3002\u4e8e\u662f\u6211\u4eec\u6709\u4e00\u4e2a\u9ad8\u6548\u7684\u7b97\u6cd5 1 2 3 4 5 6 int minPrice = INT_MAX , maxProfit = INT_MIN ; for ( int stock : stocks ) { minPrice = min ( minPrice , stock ); maxProfit = max ( maxProfit , stock - minPrice ); } return maxProfit ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u591a\u6b21\u4ea4\u6613 \u00b6 \u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\u7684\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u3001\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u672a\u5356\u51fa\u80a1\u7968\u65f6\u4e0d\u5141\u8bb8\u4e70\u5165\uff0c\u4e70\u5165\u548c\u5356\u51fa\u4e0d\u5728\u540c\u4e00\u5929\u3002\u6c42\u6700\u5927\u6536\u76ca\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u67d0\u4e00\u5929 i \uff0c\u6211\u4eec\u4f1a\u6709\u4e24\u79cd\u72b6\u6001\uff1a\u6301\u6709\u80a1\u7968\u548c\u4e0d\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ 0 ] \u8868\u793a i \u5929\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u53d7\u76ca\uff0cdp[ i ][ 1 ] \u8868\u793a i \u5929\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u6536\u76ca\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \u6211\u4eec\u6ce8\u610f\u5230\uff0c\u7b2c i \u5929\u7684\u4e24\u79cd\u72b6\u6001\u53ea\u4e0e\u7b2c i-1 \u5929\u7684\u4e24\u79cd\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5bf9\u65f6\u95f4\u590d\u6742\u5ea6\u8fdb\u884c\u4f18\u5316\u3002\u6700\u540e\u4e00\u5929\uff0c\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u4e00\u5b9a\u9ad8\u4e8e\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u3002 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); int dp0 = 0 , dp1 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 , dp1 + prices [ i ]); int tmp1 = max ( dp0 - prices [ i ], dp1 ); dp0 = tmp0 ; dp1 = tmp1 ; } return dp0 ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u81f3\u591ak\u6b21\u4ea4\u6613 \u00b6 \u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u6700\u591ak\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u56e0\u4e3a\u9898\u76ee\u8981\u6c42\u6301\u6709\u80a1\u7968\u65f6\u4e0d\u80fd\u518d\u4e70\u5165\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f\u4e00\u5929 i \uff0c\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\uff1a\u8fd9\u4e00\u5929\u6709\u80a1\u7968\u548c\u8fd9\u4e00\u5929\u6ca1\u6709\u80a1\u7968\u3002\u518d\u6839\u636e\u4ea4\u6613\u7684\u6b21\u6570\uff0c\u8bbe dp[ i ][ j ][ 0 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u671f\u95f4\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u672a\u6301\u6709\u80a1\u7968\uff0cdp[ i ][ j ][ 1 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u6301\u6709\u80a1\u7968\u3002\u6211\u4eec\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \u5bf9\u4e8e dp[ i ][ j ][ 0 ] \u8fd9\u4e00\u5929\u672a\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u4e00\u5929\u4e5f\u672a\u6301\u6709\u80a1\u7968\uff0c\u6216\u8005(2) i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\u800c\u5728 i \u8fd9\u4e00\u5929\u5356\u51fa\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u6301\u6709\u7684\u80a1\u7968\u4e00\u5b9a\u662f\u7b2c j \u6b21\u4ea4\u6613\u4ea7\u751f\u7684\u3002\u540c\u6837\u5730\uff0c\u5bf9\u4e8e dp[ i ][ j ][ 1 ] \u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u5929\u672a\u6301\u6709\u800c i \u8fd9\u4e00\u5929\u4e70\u5165\u80a1\u7968\u5e76\u4e14 i-1 \u5c5e\u4e8e\u7b2c j-1 \u6b21\u4ea4\u6613\u6216\u8005\uff081\uff09i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u76f4\u63a5\u8fc7\u6e21\u800c\u6765\u3002i = 0 \u8868\u793a\u7684\u662f\u7b2c\u4e00\u5929\u7684\u80a1\u4ef7\uff0c\u5bf9\u4e8e\u7b2c j = 1, 2, ..., k \u6b21\u4ea4\u6613\uff0c\u5982\u679c\u5728 i = 0 \u5904\u53d1\u751f\u5356\u51fa\uff0cdp[ 0 ][ j ][ 1 ] = -prices[ 0 ]\u3002\u6700\u7ec8\u7684\u5229\u6da6\u548c\u53d1\u751f\u5728\u6700\u540e\u4e00\u5929\u4e0d\u6301\u6709\u80a1\u7968\u4e2d\u7684\u67d0\u4e00\u4e2a j \u503c\uff0c\u5373 \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \u6211\u4eec\u8fd8\u53ef\u4ee5\u53d1\u73b0\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4e0e\u7b2c i-1\u5929\u7684\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u4e3a\u5728\u7a7a\u95f4\u4e0a\u53ef\u4ee5\u4f18\u5316\u3002\u8bbe dp0[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u672a\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6\uff0cdp1[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6 \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 int maxProfit ( int k , vector < int >& prices ) { int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } vector < int > dp0 ( k + 1 , 0 ), dp1 ( k + 1 , - prices [ 0 ]); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp0 [ j ] = max ( dp0 [ j ], dp1 [ j ] + prices [ i ]); dp1 [ j ] = max ( dp0 [ j - 1 ] - prices [ i ], dp1 [ j ]); } } return * max_element ( dp0 . begin (), dp0 . end ()); } \u65f6\u95f4\u590d\u6742\u5ea6 O(nk) O(nk) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(k) O(k) \u5e26\u6709\u51b7\u51bb\u671f\u7684\u4ea4\u6613 \u00b6 \u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u4f46\u662f\u6bcf\u4e00\u6b21\u4ea4\u6613\u5b8c\u6210\u540e\u7684\u4e0b\u4e00\u5929\u4e3a\u51b7\u51bb\u671f\uff0c\u4e0d\u80fd\u8d2d\u4e70\u80a1\u7968\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u7b2c i \u5929\u7ed3\u675f\uff0c\u6211\u4eec\u4f1a\u51fa\u73b0\u4e09\u79cd\u72b6\u6001\uff1a\uff081\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4e14\u4e0d\u4f1a\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff082\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4f46\u662f\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff083\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u4f1a\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001 dp[ i ][ 0 ] \u8868\u793a\u72b6\u6001\uff081\uff09\uff0c\u524d\u4e00\u5929 i-1 \u7684\u72b6\u6001\u53ef\u80fd\u662f\uff081\uff09\u548c\uff082\uff09\uff1bdp[ i ][ 1 ] \u8868\u793a\u72b6\u6001\uff082\uff09\uff0c\u524d\u4e00\u5929\u7684\u72b6\u6001\u4e00\u5b9a\u662f\uff083\uff09\uff0c\u5e76\u4e14\u5728\u7b2c i \u5929\u5356\u51fa\u80a1\u7968\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u6837\u624d\u4f1a\u8fdb\u5165\u51b7\u51bb\u671f\uff1bdp[ i ][ 2 ] \u8868\u793a\u72b6\u6001\uff083\uff09\uff0c\u524d\u4e00\u5929\u7684\u53ef\u80fd\u72b6\u6001\u662f\uff081\uff09\u548c\uff083\uff09\uff0c\u56e0\u4e3a\u7b2c i \u5929\u7ed3\u675f\u662f\u8981\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u4e0d\u53ef\u80fd\u662f\u51b7\u51bb\u671f\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \u6211\u4eec\u89c2\u5bdf\u5230\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4f1a\u4e0e\u524d\u4e00\u5929\u7684\u72b6\u6001\u6709\u5173\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4fdd\u7559\u524d\u4e00\u5929\u7684\u72b6\u6001\u5373\u53ef\u3002 \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } int dp0 = 0 , dp1 = 0 , dp2 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { dp2 = max ( dp0 - prices [ i ], dp2 ); dp0 = max ( dp0 , dp1 ); dp1 = dp2 + prices [ i ]; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u5e8f\u5217stocks = [100, 80, 60, 70, 60, 75, 85], \u6c42\u5176\u6bcf\u4e00\u5929\u7684\u80a1\u7968\u8de8\u5ea6\uff08\u4ecei\u5929\u5f00\u59cb\u5411\u524d\u8ba1\u6570\uff0c\u80a1\u7968\u4ef7\u683c\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u4ef7\u683c\uff09\uff0c\u8f93\u51fa\u7ed3\u679c[1, 1, 1, 2, 1, 4, 6] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u7684\u7b97\u6cd5\uff0c\u4f46\u662f\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u67d0\u4e00\u5929\u7684\u80a1\u7968 stocks[ i ]\uff0c\u5fc5\u7136\u4f1a\u9010\u4e2a\u4e0ei\u4e4b\u524d\u7684\u5143\u7d20\u6bd4\u8f83\uff0c\u7ec8\u4e8e\u78b0\u5230\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u6216\u8005\u6ca1\u6709\uff0c\u8fd9\u65f6\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u5bf9\u4e8e\u4e0b\u4e00\u4e2a\u80a1\u4ef7 stocks[i + 1] \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \u5355\u8c03\u6808\u9002\u5408\u89e3\u51b3\u6b64\u7c7b\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 stack < int > stk , cnt ; vector < int > ans ; for ( int s : stocks ) { int num = 1 ; while ( ! stk . empty () && stk . top () <= s ) { num += cnt . top (); cnt . pop (); stk . pop (); } ans . emplace_back ( num ); cnt . push ( num ); stk . push ( s ); } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u80a1\u7968\u4e70\u5356"},{"location":"algo/dp/stocks/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4prices\uff0c\u5b83\u7684\u7b2ci\u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002\u4f60\u53ea\u80fd\u9009\u62e9 \u67d0\u4e00\u5929 \u4e70\u5165\u8fd9\u53ea\u80a1\u7968\uff0c\u5e76\u9009\u62e9\u5728 \u672a\u6765\u7684\u67d0\u4e00\u4e2a\u4e0d\u540c\u7684\u65e5\u5b50 \u5356\u51fa\u8be5\u80a1\u7968\u3002\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u8fd4\u56de\u4f60\u53ef\u4ee5\u4ece\u8fd9\u7b14\u4ea4\u6613\u4e2d\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u5982\u679c\u4f60\u4e0d\u80fd\u83b7\u53d6\u4efb\u4f55\u5229\u6da6\uff0c\u8fd4\u56de 0 \u3002 \u8f93\u5165\uff1a[7, 1, 5, 3, 6, 4] \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a\u5728\u7b2c 2 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 6\uff09\u7684\u65f6\u5019\u5356\u51fa\uff0c\u6700\u5927\u5229\u6da6 = 6-1 = 5 \u3002\u6ce8\u610f\u5229\u6da6\u4e0d\u80fd\u662f 7-1 = 6, \u56e0\u4e3a\u5356\u51fa\u4ef7\u683c\u9700\u8981\u5927\u4e8e\u4e70\u5165\u4ef7\u683c\uff1b\u540c\u65f6\uff0c\u4f60\u4e0d\u80fd\u5728\u4e70\u5165\u524d\u5356\u51fa\u80a1\u7968\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6700\u5927\u5229\u6da6 = \u5356\u51fa\u65f6\u7684\u4ef7\u683c - \u4e70\u5165\u65f6\u7684\u4ef7\u683c\uff0c\u90a3\u4e48\u9488\u5bf9\u6bcf\u4e00\u5929i\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u8fd9\u4e00\u5929\u7684\u6700\u5927\u5229\u6da6 \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \u5f88\u5bb9\u6613\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u65b9\u6cd5\u3002\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2ai\uff0c\u6211\u4eec\u91cd\u590d\u6c42\u89e3i\u4e4b\u524d\u7684\u6700\u5c0f\u80a1\u7968\u4ef7\u683c\uff0c\u8fd9\u4e00\u6b65\u662f\u5197\u4f59\u7684\uff0c\u56e0\u4e3a\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86[0, i)\u7684\u6700\u5c0f\u503cx\uff0c\u90a3\u4e48[0, i]\u7684\u6700\u5c0f\u503c a\u2018 = min(a, stocks[ i ])\uff0c\u4ece\u800c\u907f\u514d\u4e86\u91cd\u590d\u904d\u5386\u3002\u4e8e\u662f\u6211\u4eec\u6709\u4e00\u4e2a\u9ad8\u6548\u7684\u7b97\u6cd5 1 2 3 4 5 6 int minPrice = INT_MAX , maxProfit = INT_MIN ; for ( int stock : stocks ) { minPrice = min ( minPrice , stock ); maxProfit = max ( maxProfit , stock - minPrice ); } return maxProfit ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u4e00\u6b21\u4ea4\u6613"},{"location":"algo/dp/stocks/#_2","text":"\u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\u7684\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u3001\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u672a\u5356\u51fa\u80a1\u7968\u65f6\u4e0d\u5141\u8bb8\u4e70\u5165\uff0c\u4e70\u5165\u548c\u5356\u51fa\u4e0d\u5728\u540c\u4e00\u5929\u3002\u6c42\u6700\u5927\u6536\u76ca\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u67d0\u4e00\u5929 i \uff0c\u6211\u4eec\u4f1a\u6709\u4e24\u79cd\u72b6\u6001\uff1a\u6301\u6709\u80a1\u7968\u548c\u4e0d\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ 0 ] \u8868\u793a i \u5929\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u53d7\u76ca\uff0cdp[ i ][ 1 ] \u8868\u793a i \u5929\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u6536\u76ca\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \u6211\u4eec\u6ce8\u610f\u5230\uff0c\u7b2c i \u5929\u7684\u4e24\u79cd\u72b6\u6001\u53ea\u4e0e\u7b2c i-1 \u5929\u7684\u4e24\u79cd\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5bf9\u65f6\u95f4\u590d\u6742\u5ea6\u8fdb\u884c\u4f18\u5316\u3002\u6700\u540e\u4e00\u5929\uff0c\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u4e00\u5b9a\u9ad8\u4e8e\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u3002 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); int dp0 = 0 , dp1 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 , dp1 + prices [ i ]); int tmp1 = max ( dp0 - prices [ i ], dp1 ); dp0 = tmp0 ; dp1 = tmp1 ; } return dp0 ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u591a\u6b21\u4ea4\u6613"},{"location":"algo/dp/stocks/#k","text":"\u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u6700\u591ak\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u56e0\u4e3a\u9898\u76ee\u8981\u6c42\u6301\u6709\u80a1\u7968\u65f6\u4e0d\u80fd\u518d\u4e70\u5165\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f\u4e00\u5929 i \uff0c\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\uff1a\u8fd9\u4e00\u5929\u6709\u80a1\u7968\u548c\u8fd9\u4e00\u5929\u6ca1\u6709\u80a1\u7968\u3002\u518d\u6839\u636e\u4ea4\u6613\u7684\u6b21\u6570\uff0c\u8bbe dp[ i ][ j ][ 0 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u671f\u95f4\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u672a\u6301\u6709\u80a1\u7968\uff0cdp[ i ][ j ][ 1 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u6301\u6709\u80a1\u7968\u3002\u6211\u4eec\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \u5bf9\u4e8e dp[ i ][ j ][ 0 ] \u8fd9\u4e00\u5929\u672a\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u4e00\u5929\u4e5f\u672a\u6301\u6709\u80a1\u7968\uff0c\u6216\u8005(2) i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\u800c\u5728 i \u8fd9\u4e00\u5929\u5356\u51fa\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u6301\u6709\u7684\u80a1\u7968\u4e00\u5b9a\u662f\u7b2c j \u6b21\u4ea4\u6613\u4ea7\u751f\u7684\u3002\u540c\u6837\u5730\uff0c\u5bf9\u4e8e dp[ i ][ j ][ 1 ] \u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u5929\u672a\u6301\u6709\u800c i \u8fd9\u4e00\u5929\u4e70\u5165\u80a1\u7968\u5e76\u4e14 i-1 \u5c5e\u4e8e\u7b2c j-1 \u6b21\u4ea4\u6613\u6216\u8005\uff081\uff09i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u76f4\u63a5\u8fc7\u6e21\u800c\u6765\u3002i = 0 \u8868\u793a\u7684\u662f\u7b2c\u4e00\u5929\u7684\u80a1\u4ef7\uff0c\u5bf9\u4e8e\u7b2c j = 1, 2, ..., k \u6b21\u4ea4\u6613\uff0c\u5982\u679c\u5728 i = 0 \u5904\u53d1\u751f\u5356\u51fa\uff0cdp[ 0 ][ j ][ 1 ] = -prices[ 0 ]\u3002\u6700\u7ec8\u7684\u5229\u6da6\u548c\u53d1\u751f\u5728\u6700\u540e\u4e00\u5929\u4e0d\u6301\u6709\u80a1\u7968\u4e2d\u7684\u67d0\u4e00\u4e2a j \u503c\uff0c\u5373 \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \u6211\u4eec\u8fd8\u53ef\u4ee5\u53d1\u73b0\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4e0e\u7b2c i-1\u5929\u7684\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u4e3a\u5728\u7a7a\u95f4\u4e0a\u53ef\u4ee5\u4f18\u5316\u3002\u8bbe dp0[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u672a\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6\uff0cdp1[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6 \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 int maxProfit ( int k , vector < int >& prices ) { int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } vector < int > dp0 ( k + 1 , 0 ), dp1 ( k + 1 , - prices [ 0 ]); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp0 [ j ] = max ( dp0 [ j ], dp1 [ j ] + prices [ i ]); dp1 [ j ] = max ( dp0 [ j - 1 ] - prices [ i ], dp1 [ j ]); } } return * max_element ( dp0 . begin (), dp0 . end ()); } \u65f6\u95f4\u590d\u6742\u5ea6 O(nk) O(nk) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(k) O(k)","title":"\u81f3\u591ak\u6b21\u4ea4\u6613"},{"location":"algo/dp/stocks/#_3","text":"\u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u4f46\u662f\u6bcf\u4e00\u6b21\u4ea4\u6613\u5b8c\u6210\u540e\u7684\u4e0b\u4e00\u5929\u4e3a\u51b7\u51bb\u671f\uff0c\u4e0d\u80fd\u8d2d\u4e70\u80a1\u7968\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u7b2c i \u5929\u7ed3\u675f\uff0c\u6211\u4eec\u4f1a\u51fa\u73b0\u4e09\u79cd\u72b6\u6001\uff1a\uff081\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4e14\u4e0d\u4f1a\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff082\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4f46\u662f\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff083\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u4f1a\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001 dp[ i ][ 0 ] \u8868\u793a\u72b6\u6001\uff081\uff09\uff0c\u524d\u4e00\u5929 i-1 \u7684\u72b6\u6001\u53ef\u80fd\u662f\uff081\uff09\u548c\uff082\uff09\uff1bdp[ i ][ 1 ] \u8868\u793a\u72b6\u6001\uff082\uff09\uff0c\u524d\u4e00\u5929\u7684\u72b6\u6001\u4e00\u5b9a\u662f\uff083\uff09\uff0c\u5e76\u4e14\u5728\u7b2c i \u5929\u5356\u51fa\u80a1\u7968\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u6837\u624d\u4f1a\u8fdb\u5165\u51b7\u51bb\u671f\uff1bdp[ i ][ 2 ] \u8868\u793a\u72b6\u6001\uff083\uff09\uff0c\u524d\u4e00\u5929\u7684\u53ef\u80fd\u72b6\u6001\u662f\uff081\uff09\u548c\uff083\uff09\uff0c\u56e0\u4e3a\u7b2c i \u5929\u7ed3\u675f\u662f\u8981\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u4e0d\u53ef\u80fd\u662f\u51b7\u51bb\u671f\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \u6211\u4eec\u89c2\u5bdf\u5230\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4f1a\u4e0e\u524d\u4e00\u5929\u7684\u72b6\u6001\u6709\u5173\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4fdd\u7559\u524d\u4e00\u5929\u7684\u72b6\u6001\u5373\u53ef\u3002 \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } int dp0 = 0 , dp1 = 0 , dp2 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { dp2 = max ( dp0 - prices [ i ], dp2 ); dp0 = max ( dp0 , dp1 ); dp1 = dp2 + prices [ i ]; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u5e26\u6709\u51b7\u51bb\u671f\u7684\u4ea4\u6613"},{"location":"algo/dp/stocks/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u5e8f\u5217stocks = [100, 80, 60, 70, 60, 75, 85], \u6c42\u5176\u6bcf\u4e00\u5929\u7684\u80a1\u7968\u8de8\u5ea6\uff08\u4ecei\u5929\u5f00\u59cb\u5411\u524d\u8ba1\u6570\uff0c\u80a1\u7968\u4ef7\u683c\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u4ef7\u683c\uff09\uff0c\u8f93\u51fa\u7ed3\u679c[1, 1, 1, 2, 1, 4, 6] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u7684\u7b97\u6cd5\uff0c\u4f46\u662f\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u67d0\u4e00\u5929\u7684\u80a1\u7968 stocks[ i ]\uff0c\u5fc5\u7136\u4f1a\u9010\u4e2a\u4e0ei\u4e4b\u524d\u7684\u5143\u7d20\u6bd4\u8f83\uff0c\u7ec8\u4e8e\u78b0\u5230\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u6216\u8005\u6ca1\u6709\uff0c\u8fd9\u65f6\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u5bf9\u4e8e\u4e0b\u4e00\u4e2a\u80a1\u4ef7 stocks[i + 1] \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \u5355\u8c03\u6808\u9002\u5408\u89e3\u51b3\u6b64\u7c7b\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 stack < int > stk , cnt ; vector < int > ans ; for ( int s : stocks ) { int num = 1 ; while ( ! stk . empty () && stk . top () <= s ) { num += cnt . top (); cnt . pop (); stk . pop (); } ans . emplace_back ( num ); cnt . push ( num ); stk . push ( s ); } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6"},{"location":"algo/dp/tree/","text":"\u76d1\u63a7\u4e8c\u53c9\u6811 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u6211\u4eec\u5728\u6811\u7684\u8282\u70b9\u4e0a\u5b89\u88c5\u6444\u50cf\u5934\u3002\u8282\u70b9\u4e0a\u7684\u6bcf\u4e2a\u6444\u5f71\u5934\u90fd\u53ef\u4ee5\u76d1\u89c6\u5176\u7236\u5bf9\u8c61\u3001\u81ea\u8eab\u53ca\u5176\u76f4\u63a5\u5b50\u5bf9\u8c61\u3002\u8ba1\u7b97\u76d1\u63a7\u6811\u7684\u6240\u6709\u8282\u70b9\u6240\u9700\u7684\u6700\u5c0f\u6444\u50cf\u5934\u6570\u91cf\u3002\u4f8b\u5982\uff0c \\begin{matrix} & & & & & 0 \\\\ & & & & & \\downarrow \\\\ & & & & & {\\color{Red} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 0 & & & & & & 0 \\\\ \\end{matrix} \\begin{matrix} & & & & & 0 \\\\ & & & & & \\downarrow \\\\ & & & & & {\\color{Red} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 0 & & & & & & 0 \\\\ \\end{matrix} \u53ea\u8981\u5728\u7ea2\u8272\u8282\u70b9\u5904\u653e\u7f6e\u4e00\u4e2a\u76d1\u63a7\u5373\u53ef\u3002 \u300c\u5206\u6790\u300d \u8003\u8651\u7b80\u5355\u7684\u7ed3\u6784\uff1a\u4e00\u4e2a\u6839\u7ed3\u70b9\uff08v\uff09\u548c\u5de6\uff08l\uff09\u53f3\uff08r\uff09\u5b50\u8282\u70b9\uff0c\u5728\u6240\u6709\u8282\u70b9\u88ab\u8986\u76d6\u7684\u6761\u4ef6\u4e0b\uff0c\u6709\u4e09\u79cd\u72b6\u6001 a\uff09v \u5904\u653e\u7f6e\u4e00\u4e2a\u76d1\u63a7\u65f6\uff0c\u6240\u9700\u8981\u7684\u6700\u5c11\u6570\u76ee\u3002v\u3001l\u3001r \u88ab\u8986\u76d6\u3002\u5de6\u53f3\u5b50\u8282\u70b9\u7684\u5b50\u6811\u4e5f\u9700\u8981\u88ab\u8986\u76d6 b\uff09v \u88ab\u8986\u76d6\u4f46\u662f\u4e0d\u9700\u8981\u76d1\u63a7\u65f6\u7684\u6700\u5c11\u6570\u76ee\u3002\u6b64\u65f6 l \u548c r \u6709\u4e00\u5904\u653e\u76d1\u63a7 c\uff09l \u548c r \u88ab\u8986\u76d6\u7684\u6700\u5c0f\u6570\u76ee\uff0c\u6b64\u65f6 v \u4e0d\u4e00\u5b9a\u88ab\u8986\u76d6 \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\begin{aligned} & v_{a} = l_{c} + r_{c} + 1 \\\\ & v_{b} = \\min {(v_{a}, l_{a} + r_{b}, l_{b} + r_{a})} \\\\ & v_{c} = \\min {(v_{a}, l_{b} + r_{b})} \\end{aligned} \\begin{aligned} & v_{a} = l_{c} + r_{c} + 1 \\\\ & v_{b} = \\min {(v_{a}, l_{a} + r_{b}, l_{b} + r_{a})} \\\\ & v_{c} = \\min {(v_{a}, l_{b} + r_{b})} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct states { int a , b , c ; states ( int x , int y , int z ) : a ( x ), b ( y ), c ( z ) {} }; class Solution { public : int minCameraCover ( TreeNode * root ) { states s = dfs ( root ); return s . b ; } states dfs ( TreeNode * root ) { states s ( INT_MAX / 2 , 0 , 0 ); if ( root == nullptr ) { return s ; } states l = dfs ( root -> left ); states r = dfs ( root -> right ); s . a = l . c + r . c + 1 ; s . b = min ( s . a , min ( l . a + r . b , l . b + r . a )); s . c = min ( l . b + r . b , s . a ); return s ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(log(n)) O(log(n)) \u3002","title":"\u6811\u4e0a\u578b"},{"location":"algo/dp/tree/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u6211\u4eec\u5728\u6811\u7684\u8282\u70b9\u4e0a\u5b89\u88c5\u6444\u50cf\u5934\u3002\u8282\u70b9\u4e0a\u7684\u6bcf\u4e2a\u6444\u5f71\u5934\u90fd\u53ef\u4ee5\u76d1\u89c6\u5176\u7236\u5bf9\u8c61\u3001\u81ea\u8eab\u53ca\u5176\u76f4\u63a5\u5b50\u5bf9\u8c61\u3002\u8ba1\u7b97\u76d1\u63a7\u6811\u7684\u6240\u6709\u8282\u70b9\u6240\u9700\u7684\u6700\u5c0f\u6444\u50cf\u5934\u6570\u91cf\u3002\u4f8b\u5982\uff0c \\begin{matrix} & & & & & 0 \\\\ & & & & & \\downarrow \\\\ & & & & & {\\color{Red} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 0 & & & & & & 0 \\\\ \\end{matrix} \\begin{matrix} & & & & & 0 \\\\ & & & & & \\downarrow \\\\ & & & & & {\\color{Red} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 0 & & & & & & 0 \\\\ \\end{matrix} \u53ea\u8981\u5728\u7ea2\u8272\u8282\u70b9\u5904\u653e\u7f6e\u4e00\u4e2a\u76d1\u63a7\u5373\u53ef\u3002 \u300c\u5206\u6790\u300d \u8003\u8651\u7b80\u5355\u7684\u7ed3\u6784\uff1a\u4e00\u4e2a\u6839\u7ed3\u70b9\uff08v\uff09\u548c\u5de6\uff08l\uff09\u53f3\uff08r\uff09\u5b50\u8282\u70b9\uff0c\u5728\u6240\u6709\u8282\u70b9\u88ab\u8986\u76d6\u7684\u6761\u4ef6\u4e0b\uff0c\u6709\u4e09\u79cd\u72b6\u6001 a\uff09v \u5904\u653e\u7f6e\u4e00\u4e2a\u76d1\u63a7\u65f6\uff0c\u6240\u9700\u8981\u7684\u6700\u5c11\u6570\u76ee\u3002v\u3001l\u3001r \u88ab\u8986\u76d6\u3002\u5de6\u53f3\u5b50\u8282\u70b9\u7684\u5b50\u6811\u4e5f\u9700\u8981\u88ab\u8986\u76d6 b\uff09v \u88ab\u8986\u76d6\u4f46\u662f\u4e0d\u9700\u8981\u76d1\u63a7\u65f6\u7684\u6700\u5c11\u6570\u76ee\u3002\u6b64\u65f6 l \u548c r \u6709\u4e00\u5904\u653e\u76d1\u63a7 c\uff09l \u548c r \u88ab\u8986\u76d6\u7684\u6700\u5c0f\u6570\u76ee\uff0c\u6b64\u65f6 v \u4e0d\u4e00\u5b9a\u88ab\u8986\u76d6 \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\begin{aligned} & v_{a} = l_{c} + r_{c} + 1 \\\\ & v_{b} = \\min {(v_{a}, l_{a} + r_{b}, l_{b} + r_{a})} \\\\ & v_{c} = \\min {(v_{a}, l_{b} + r_{b})} \\end{aligned} \\begin{aligned} & v_{a} = l_{c} + r_{c} + 1 \\\\ & v_{b} = \\min {(v_{a}, l_{a} + r_{b}, l_{b} + r_{a})} \\\\ & v_{c} = \\min {(v_{a}, l_{b} + r_{b})} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct states { int a , b , c ; states ( int x , int y , int z ) : a ( x ), b ( y ), c ( z ) {} }; class Solution { public : int minCameraCover ( TreeNode * root ) { states s = dfs ( root ); return s . b ; } states dfs ( TreeNode * root ) { states s ( INT_MAX / 2 , 0 , 0 ); if ( root == nullptr ) { return s ; } states l = dfs ( root -> left ); states r = dfs ( root -> right ); s . a = l . c + r . c + 1 ; s . b = min ( s . a , min ( l . a + r . b , l . b + r . a )); s . c = min ( l . b + r . b , s . a ); return s ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(log(n)) O(log(n)) \u3002","title":"\u76d1\u63a7\u4e8c\u53c9\u6811"},{"location":"algo/sort/basis/","text":"\u57fa\u7840 \u00b6 \u6392\u5e8f\u7b97\u6cd5\u65e8\u5728\u627e\u5230\u9ad8\u6548\u7684\u65b9\u6cd5\u8ba9\u65e0\u5e8f\u7684\u6570\u7ec4\u53d8\u6210\u6709\u5e8f \u7a33\u5b9a\u6392\u5e8f \u00b6 \u5bf9\u4e8e\u76f8\u540c\u5143\u7d20\uff0c\u6392\u5e8f\u524d\u540e\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\u3002 \u9898\u76ee \u00b6 \u4e0b\u4e00\u4e2a\u6392\u5217 \u00b6 \u6574\u6570\u6570\u7ec4\u7684\u4e0b\u4e00\u4e2a\u6392\u5217\u662f\u6307\u5176\u6574\u6570\u7684\u4e0b\u4e00\u4e2a\u5b57\u5178\u5e8f\u66f4\u5927\u7684\u6392\u5217\u3002\u5982\u679c\u4e0d\u5b58\u5728\u4e0b\u4e00\u4e2a\u66f4\u5927\u7684\u6392\u5217\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6570\u7ec4\u5fc5\u987b\u91cd\u6392\u4e3a\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u6392\u5217\uff08\u5373\uff0c\u5176\u5143\u7d20\u6309\u5347\u5e8f\u6392\u5217\uff09\u3002\u4f8b\u5982\uff0carr = [1,2,3] \u7684\u4e0b\u4e00\u4e2a\u6392\u5217\u662f [1,3,2] \u3002 \u300c\u5206\u6790\u300d \u300c\u6392\u5e8f\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = int ( nums . size ()), idx = - 1 ; if ( n < 2 ) { return ; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( nums [ i - 1 ] < nums [ i ]) { idx = i - 1 ; break ; } } if ( idx == - 1 ) { sort ( nums . begin (), nums . end ()); return ; } for ( int i = n - 1 ; i > idx ; i -- ) { if ( nums [ i ] > nums [ idx ]) { swap ( nums [ i ], nums [ idx ]); sort ( nums . begin () + idx + 1 , nums . end ()); return ; } } } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u5355\u8c03\u9012\u589e\u7684\u6570\u5b57 \u00b6 \u5f53\u4e14\u4ec5\u5f53\u6bcf\u4e2a\u76f8\u90bb\u4f4d\u6570\u4e0a\u7684\u6570\u5b57 x \u548c y \u6ee1\u8db3 x <= y \u65f6\uff0c\u6211\u4eec\u79f0\u8fd9\u4e2a\u6574\u6570\u662f\u5355\u8c03\u9012\u589e\u7684\u3002\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 n \uff0c\u8fd4\u56de \u5c0f\u4e8e\u6216\u7b49\u4e8e n \u7684\u6700\u5927\u6570\u5b57\uff0c\u4e14\u6570\u5b57\u5448 \u5355\u8c03\u9012\u589e \u3002 \u300c\u5206\u6790\u300d \u5982\u679c N \u6574\u4f53\u9006\u5e8f\uff0c\u5219\u8fd4\u56de n\uff1b\u5426\u5219\uff0c\u6700\u540e\u4e00\u4e2a\u6b63\u5e8f\u7684\u4f4d\u7f6e\u540e\u7f6e\u6210 9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: N = 10 Output: 9 Input: N = 1234 Output: 1234 Input: N = 332 Output: 299 */ int monotoneIncreasingDigits ( int N ) { int ans = 0 ; string str = to_string ( N ); int len = int ( str . length ()), idx = - 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] < str [ i - 1 ]) { idx = i ; break ; } } if ( idx == - 1 ) { return N ; } int pos = idx - 1 ; while ( pos >= 1 && str [ pos ] == str [ pos - 1 ]) { pos -- ; } str [ pos ] -- ; // current position decrease by 1 for ( int i = pos + 1 ; i < len ; i ++ ) { str [ i ] = '9' ; } for ( int i = len - 1 , pow = 1 ; i >= 0 ; i -- , pow *= 10 ) { ans += ( str [ i ] - '0' ) * pow ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u6700\u5927\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u7ec4\u975e\u8d1f\u6574\u6570 nums\uff0c\u91cd\u65b0\u6392\u5217\u6bcf\u4e2a\u6570\u7684\u987a\u5e8f\uff08\u6bcf\u4e2a\u6570\u4e0d\u53ef\u62c6\u5206\uff09\u4f7f\u4e4b\u7ec4\u6210\u4e00\u4e2a\u6700\u5927\u7684\u6574\u6570\u3002\u6ce8\u610f\uff1a\u8f93\u51fa\u7ed3\u679c\u53ef\u80fd\u975e\u5e38\u5927\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u800c\u4e0d\u662f\u6574\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [3,30,34,5,9] Output: \"9534330\" */ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans = \"\" ; if ( nums . empty ()) { return ans ; } sort ( nums . begin (), nums . end (), []( const int & x , const int & y ) { long i = 10 , j = 10 ; while ( i <= x ) { i *= 10 ; } while ( j <= y ) { j *= 10 ; } return j * x + y > i * y + x ; }); if ( nums [ 0 ] == 0 ) { return \"0\" ; } for ( const int & ele : nums ) { ans += to_string ( ele ); } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n\\log n) O(n\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u8fd9\u91cc n \u662f nums \u7684\u957f\u5ea6\u3002","title":"\u57fa\u7840"},{"location":"algo/sort/basis/#_1","text":"\u6392\u5e8f\u7b97\u6cd5\u65e8\u5728\u627e\u5230\u9ad8\u6548\u7684\u65b9\u6cd5\u8ba9\u65e0\u5e8f\u7684\u6570\u7ec4\u53d8\u6210\u6709\u5e8f","title":"\u57fa\u7840"},{"location":"algo/sort/basis/#_2","text":"\u5bf9\u4e8e\u76f8\u540c\u5143\u7d20\uff0c\u6392\u5e8f\u524d\u540e\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\u3002","title":"\u7a33\u5b9a\u6392\u5e8f"},{"location":"algo/sort/basis/#_3","text":"","title":"\u9898\u76ee"},{"location":"algo/sort/basis/#_4","text":"\u6574\u6570\u6570\u7ec4\u7684\u4e0b\u4e00\u4e2a\u6392\u5217\u662f\u6307\u5176\u6574\u6570\u7684\u4e0b\u4e00\u4e2a\u5b57\u5178\u5e8f\u66f4\u5927\u7684\u6392\u5217\u3002\u5982\u679c\u4e0d\u5b58\u5728\u4e0b\u4e00\u4e2a\u66f4\u5927\u7684\u6392\u5217\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6570\u7ec4\u5fc5\u987b\u91cd\u6392\u4e3a\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u6392\u5217\uff08\u5373\uff0c\u5176\u5143\u7d20\u6309\u5347\u5e8f\u6392\u5217\uff09\u3002\u4f8b\u5982\uff0carr = [1,2,3] \u7684\u4e0b\u4e00\u4e2a\u6392\u5217\u662f [1,3,2] \u3002 \u300c\u5206\u6790\u300d \u300c\u6392\u5e8f\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = int ( nums . size ()), idx = - 1 ; if ( n < 2 ) { return ; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( nums [ i - 1 ] < nums [ i ]) { idx = i - 1 ; break ; } } if ( idx == - 1 ) { sort ( nums . begin (), nums . end ()); return ; } for ( int i = n - 1 ; i > idx ; i -- ) { if ( nums [ i ] > nums [ idx ]) { swap ( nums [ i ], nums [ idx ]); sort ( nums . begin () + idx + 1 , nums . end ()); return ; } } } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u4e0b\u4e00\u4e2a\u6392\u5217"},{"location":"algo/sort/basis/#_5","text":"\u5f53\u4e14\u4ec5\u5f53\u6bcf\u4e2a\u76f8\u90bb\u4f4d\u6570\u4e0a\u7684\u6570\u5b57 x \u548c y \u6ee1\u8db3 x <= y \u65f6\uff0c\u6211\u4eec\u79f0\u8fd9\u4e2a\u6574\u6570\u662f\u5355\u8c03\u9012\u589e\u7684\u3002\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 n \uff0c\u8fd4\u56de \u5c0f\u4e8e\u6216\u7b49\u4e8e n \u7684\u6700\u5927\u6570\u5b57\uff0c\u4e14\u6570\u5b57\u5448 \u5355\u8c03\u9012\u589e \u3002 \u300c\u5206\u6790\u300d \u5982\u679c N \u6574\u4f53\u9006\u5e8f\uff0c\u5219\u8fd4\u56de n\uff1b\u5426\u5219\uff0c\u6700\u540e\u4e00\u4e2a\u6b63\u5e8f\u7684\u4f4d\u7f6e\u540e\u7f6e\u6210 9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: N = 10 Output: 9 Input: N = 1234 Output: 1234 Input: N = 332 Output: 299 */ int monotoneIncreasingDigits ( int N ) { int ans = 0 ; string str = to_string ( N ); int len = int ( str . length ()), idx = - 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] < str [ i - 1 ]) { idx = i ; break ; } } if ( idx == - 1 ) { return N ; } int pos = idx - 1 ; while ( pos >= 1 && str [ pos ] == str [ pos - 1 ]) { pos -- ; } str [ pos ] -- ; // current position decrease by 1 for ( int i = pos + 1 ; i < len ; i ++ ) { str [ i ] = '9' ; } for ( int i = len - 1 , pow = 1 ; i >= 0 ; i -- , pow *= 10 ) { ans += ( str [ i ] - '0' ) * pow ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5355\u8c03\u9012\u589e\u7684\u6570\u5b57"},{"location":"algo/sort/basis/#_6","text":"\u7ed9\u5b9a\u4e00\u7ec4\u975e\u8d1f\u6574\u6570 nums\uff0c\u91cd\u65b0\u6392\u5217\u6bcf\u4e2a\u6570\u7684\u987a\u5e8f\uff08\u6bcf\u4e2a\u6570\u4e0d\u53ef\u62c6\u5206\uff09\u4f7f\u4e4b\u7ec4\u6210\u4e00\u4e2a\u6700\u5927\u7684\u6574\u6570\u3002\u6ce8\u610f\uff1a\u8f93\u51fa\u7ed3\u679c\u53ef\u80fd\u975e\u5e38\u5927\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u800c\u4e0d\u662f\u6574\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [3,30,34,5,9] Output: \"9534330\" */ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans = \"\" ; if ( nums . empty ()) { return ans ; } sort ( nums . begin (), nums . end (), []( const int & x , const int & y ) { long i = 10 , j = 10 ; while ( i <= x ) { i *= 10 ; } while ( j <= y ) { j *= 10 ; } return j * x + y > i * y + x ; }); if ( nums [ 0 ] == 0 ) { return \"0\" ; } for ( const int & ele : nums ) { ans += to_string ( ele ); } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n\\log n) O(n\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u8fd9\u91cc n \u662f nums \u7684\u957f\u5ea6\u3002","title":"\u6700\u5927\u6570"},{"location":"algo/sort/merge/","text":"\u539f\u7406 \u00b6 \u5f52\u5e76\u6392\u5e8f\u91c7\u7528\u5206\u6cbb\u7684\u601d\u60f3\uff0c\u5c06\u5f85\u6392\u5e8f\u7684\u6570\u636e\u5206\u5757\uff0c\u5e76\u5728\u5757\u5185\u6392\u597d\u5e8f\uff0c\u5757\u4e4b\u95f4\u91cd\u65b0\u7ec4\u7ec7\u79f0\u6709\u5e8f\u6570\u636e\u3002 \u9898\u76ee \u00b6 \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4,\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570P\u3002\u5e76\u5c06P\u5bf91000000007\u53d6\u6a21\u7684\u7ed3\u679c\u8f93\u51fa\u3002 \u5373\u8f93\u51faP%1000000007\uff0c\u4f8b\u5982\u8f93\u5165 [1,2,3,4,5,6,7,0]\uff0c\u8f93\u51fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a int InversePairs ( vector < int > data ) { int n = int ( data . size ()); if ( n < 2 ) { return 0 ; } long count = 0 ; mergeSort ( data , 0 , n - 1 , count ); return ( count % 1000000007 ); } void mergeSort ( vector < int > & arr , int b , int e , long & count ) { if ( b >= e ) { return ; } int m = ( b + e ) / 2 ; mergeSort ( arr , b , m , count ); mergeSort ( arr , m + 1 , e , count ); merge ( arr , b , m , e , count ); } void merge ( vector < int > & arr , int b , int m , int e , long & count ) { int * temp = new int [ e - b + 1 ]{}; int i = b , j = m + 1 , right = 0 , pos = 0 ; while ( i <= m && j <= e ) { if ( arr [ i ] < arr [ j ]) { temp [ pos ++ ] = arr [ i ++ ]; count += right ; } else { temp [ pos ++ ] = arr [ j ++ ]; right ++ ; } } count += ( m - i + 1 ) * right ; while ( i <= m ) { temp [ pos ++ ] = arr [ i ++ ]; } while ( j <= e ) { temp [ pos ++ ] = arr [ j ++ ]; } for ( int i = b ; i <= e ; i ++ ) { arr [ i ] = temp [ i - b ]; } delete [] temp ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u5f52\u5e76\u6392\u5e8f"},{"location":"algo/sort/merge/#_1","text":"\u5f52\u5e76\u6392\u5e8f\u91c7\u7528\u5206\u6cbb\u7684\u601d\u60f3\uff0c\u5c06\u5f85\u6392\u5e8f\u7684\u6570\u636e\u5206\u5757\uff0c\u5e76\u5728\u5757\u5185\u6392\u597d\u5e8f\uff0c\u5757\u4e4b\u95f4\u91cd\u65b0\u7ec4\u7ec7\u79f0\u6709\u5e8f\u6570\u636e\u3002","title":"\u539f\u7406"},{"location":"algo/sort/merge/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/sort/merge/#_3","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4,\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570P\u3002\u5e76\u5c06P\u5bf91000000007\u53d6\u6a21\u7684\u7ed3\u679c\u8f93\u51fa\u3002 \u5373\u8f93\u51faP%1000000007\uff0c\u4f8b\u5982\u8f93\u5165 [1,2,3,4,5,6,7,0]\uff0c\u8f93\u51fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a int InversePairs ( vector < int > data ) { int n = int ( data . size ()); if ( n < 2 ) { return 0 ; } long count = 0 ; mergeSort ( data , 0 , n - 1 , count ); return ( count % 1000000007 ); } void mergeSort ( vector < int > & arr , int b , int e , long & count ) { if ( b >= e ) { return ; } int m = ( b + e ) / 2 ; mergeSort ( arr , b , m , count ); mergeSort ( arr , m + 1 , e , count ); merge ( arr , b , m , e , count ); } void merge ( vector < int > & arr , int b , int m , int e , long & count ) { int * temp = new int [ e - b + 1 ]{}; int i = b , j = m + 1 , right = 0 , pos = 0 ; while ( i <= m && j <= e ) { if ( arr [ i ] < arr [ j ]) { temp [ pos ++ ] = arr [ i ++ ]; count += right ; } else { temp [ pos ++ ] = arr [ j ++ ]; right ++ ; } } count += ( m - i + 1 ) * right ; while ( i <= m ) { temp [ pos ++ ] = arr [ i ++ ]; } while ( j <= e ) { temp [ pos ++ ] = arr [ j ++ ]; } for ( int i = b ; i <= e ; i ++ ) { arr [ i ] = temp [ i - b ]; } delete [] temp ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9"},{"location":"algo/sort/quick/","text":"\u539f\u7406 \u00b6 \u5feb\u901f\u6392\u5e8f\u627e\u5230\u4e00\u4e2a\u4e2d\u8f74\uff08pivot\uff09\u4f7f\u5f97\u53f3\u4fa7\u7684\u6570\u503c\u4e0d\u5c0f\u4e8e\u4e2d\u8f74\u503c\u4e14\u5de6\u4fa7\u7684\u6570\u503c\u4e0d\u5927\u4e8e\u4e2d\u8f74\u503c\u3002 \u9898\u76ee \u00b6 \u6570\u7ec4\u4e2d\u7684\u7b2cK\u4e2a\u6700\u5927\u5143\u7d20 \u00b6 \u7ed9\u5b9a\u6574\u6570\u6570\u7ec4 nums \u548c\u6574\u6570 k\uff0c\u8bf7\u8fd4\u56de\u6570\u7ec4\u4e2d\u7b2c k \u4e2a\u6700\u5927\u7684\u5143\u7d20\u3002\u8bf7\u6ce8\u610f\uff0c\u4f60\u9700\u8981\u627e\u7684\u662f\u6570\u7ec4\u6392\u5e8f\u540e\u7684\u7b2c k \u4e2a\u6700\u5927\u7684\u5143\u7d20\uff0c\u800c\u4e0d\u662f\u7b2c k \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u3002\u4f60\u5fc5\u987b\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u7684\u7b97\u6cd5\u89e3\u51b3\u6b64\u95ee\u9898\u3002\u4f8b\u5982\uff0c[3,2,1,5,6,4], k = 2\uff0c\u8fd4\u56de 5\u3002 \u300c\u5206\u6790\u300d \u300c\u6539\u8fdb\u7248\u5feb\u901f\u6392\u5e8f\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int findKthLargest ( vector < int >& nums , int k ) { int n = int ( nums . size ()); k = n - k ; int b = 0 , e = n - 1 ; while ( true ) { int i = b , j = e ; while ( i < j ) { while ( i < j && nums [ i ] <= nums [ j ]) { j -- ; } swap ( nums [ i ], nums [ j ]); while ( i < j && nums [ i ] <= nums [ j ]) { i ++ ; } swap ( nums [ i ], nums [ j ]); } if ( i == k ) { return nums [ i ]; } else if ( i > k ) { e = i - 1 ; } else { b = i + 1 ; } } return 0 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"algo/sort/quick/#_1","text":"\u5feb\u901f\u6392\u5e8f\u627e\u5230\u4e00\u4e2a\u4e2d\u8f74\uff08pivot\uff09\u4f7f\u5f97\u53f3\u4fa7\u7684\u6570\u503c\u4e0d\u5c0f\u4e8e\u4e2d\u8f74\u503c\u4e14\u5de6\u4fa7\u7684\u6570\u503c\u4e0d\u5927\u4e8e\u4e2d\u8f74\u503c\u3002","title":"\u539f\u7406"},{"location":"algo/sort/quick/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/sort/quick/#k","text":"\u7ed9\u5b9a\u6574\u6570\u6570\u7ec4 nums \u548c\u6574\u6570 k\uff0c\u8bf7\u8fd4\u56de\u6570\u7ec4\u4e2d\u7b2c k \u4e2a\u6700\u5927\u7684\u5143\u7d20\u3002\u8bf7\u6ce8\u610f\uff0c\u4f60\u9700\u8981\u627e\u7684\u662f\u6570\u7ec4\u6392\u5e8f\u540e\u7684\u7b2c k \u4e2a\u6700\u5927\u7684\u5143\u7d20\uff0c\u800c\u4e0d\u662f\u7b2c k \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u3002\u4f60\u5fc5\u987b\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u7684\u7b97\u6cd5\u89e3\u51b3\u6b64\u95ee\u9898\u3002\u4f8b\u5982\uff0c[3,2,1,5,6,4], k = 2\uff0c\u8fd4\u56de 5\u3002 \u300c\u5206\u6790\u300d \u300c\u6539\u8fdb\u7248\u5feb\u901f\u6392\u5e8f\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int findKthLargest ( vector < int >& nums , int k ) { int n = int ( nums . size ()); k = n - k ; int b = 0 , e = n - 1 ; while ( true ) { int i = b , j = e ; while ( i < j ) { while ( i < j && nums [ i ] <= nums [ j ]) { j -- ; } swap ( nums [ i ], nums [ j ]); while ( i < j && nums [ i ] <= nums [ j ]) { i ++ ; } swap ( nums [ i ], nums [ j ]); } if ( i == k ) { return nums [ i ]; } else if ( i > k ) { e = i - 1 ; } else { b = i + 1 ; } } return 0 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u6570\u7ec4\u4e2d\u7684\u7b2cK\u4e2a\u6700\u5927\u5143\u7d20"},{"location":"data-structure/binary-indexed-tree/","text":"\u7b80\u4ecb \u00b6 \u6811\u72b6\u6570\u7ec4\u662f\u4e00\u79cd\u5bf9\u5b58\u50a8\u6570\u5b57\u7684\u5217\u8868\u8fdb\u884c\u9ad8\u6548\u5730\u66f4\u65b0\u53ca\u6c42\u524d\u7f00\u548c\u7684\u6570\u636e\u7ed3\u6784\u3002\u4e3b\u8981\u7684\u64cd\u4f5c\u4e3a\uff1a \u66f4\u65b0\uff08update\uff09 \u6c42\u548c\uff08sum\uff09 \u6811\u72b6\u6570\u7ec4\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u4fdd\u5b58\u6570\u636e\uff0c\u4f46\u67d0\u4e9b\u7ed3\u70b9\u662f\u524d\u65b9\u82e5\u5e72\u7ed3\u70b9\u7684\u603b\u548c \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \u4f8b\u5982\uff0c \u7ed3\u70b9 1\u30013\u30015\u30017 \u53ea\u7ba1\u7406\u4e00\u4e2a\u6570\u503c\uff0c\u7ed3\u70b9 2 \u7ba1\u7406 1\u30012\uff08\u5171\u4e24\u4e2a\uff09\uff0c\u7ed3\u70b9 4 \u7ba1\u7406 1\u30012\u30013\u30014\uff08\u5171\u56db\u4e2a\uff09\u3002\u6b64\u5904\u7684\u6570\u5b57\u5747\u8868\u793a\u6570\u7ec4\u7684\u79e9\uff08\u4ece 1 \u5f00\u59cb\uff09\u3002 \u539f\u7406 \u00b6 lowBit \u00b6 \u82e5\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0c\u6211\u4eec\u6c42\u8fd9\u4e2a\u79e9\u4e0b\u4e00\u5c42\u79e9\uff0c\u5373\u5f53\u524d\u7ed3\u70b9\u53ef\u7ba1\u7406\u7684\u7ed3\u70b9\u6570\u76ee\u3002 1 2 3 int lowBit ( int x ) { return x & ( - x ); } \u6b64\u5904 x \u8868\u793a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0cx & (-x) \u8868\u793a\u6c42 x \u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u7b2c\u4e00\u4e2a 1 \u53ca\u5176\u53f3\u8fb9\u7684\u6240\u6709 0 \u6784\u6210\u7684\u503c\u3002 \u4f8b\u5982\uff0c \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5947\u6570\u7684 lowBit \u4e00\u5b9a\u4e3a 1\uff0c\u5076\u6570\u7684 lowBit \u4e00\u5b9a\u662f\u5076\u6570 \u66f4\u65b0 \u00b6 \u5982\u679c\u6211\u4eec\u60f3\u5bf9\u67d0\u4e00\u4e2a\u6570\u503c\u66f4\u65b0\uff0c\u5982\u7d2f\u52a0\u4e00\u4e2a\u6570\u503c\uff0c\u9700\u8981\u5c06\u5f53\u524d\u7ed3\u70b9\u53ca\u5176\u6240\u6709\u7684\u4e0a\u7ea7\u66f4\u65b0\u3002 1 2 3 4 5 6 7 vector < int > C ; void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } } \u67e5\u8be2 \u00b6 \u82e5\u7ed9\u5b9a\u4e00\u4e2a\u79e9\uff0c\u5e94\u5f53\u8fd4\u56de\u622a\u6b62\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u524d\u7f00\u548c\u3002 1 2 3 4 5 6 7 8 int query ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; } \u521d\u59cb\u5316\u5efa\u6811 \u00b6 \u5982\u679c\u7ed9\u5b9a\u4e86\u4e00\u4e2a\u6570\u7ec4\uff0c\u6211\u4eec\u5e0c\u671b\u6709\u53e6\u4e00\u4e2a\u6570\u7ec4\u5728 O(n) O(n) \u7684\u65f6\u95f4\u4e0b\u5efa\u7acb\u6811\u72b6\u6570\u7ec4\u3002 1 2 3 4 5 for ( int i = 1 ; i <= n ; i ++ ) { C [ i ] += A [ i ]; int j = i + lowBit ( i ); if ( j <= n ) { C [ j ] += C [ i ]; } } \u9898\u76ee \u00b6 \u7edf\u8ba1\u53f3\u4fa7\u5c0f\u4e8e\u5f53\u524d\u5143\u7d20\u7684\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u5982 nums = [5, 2, 6, 1, 1]\uff0c\u8fd4\u56de\u4e00\u4e2a\u7b49\u957f\u7684\u6570\u7ec4\uff0ccnt = [3, 2, 2, 0, 0]\u3002cnt[ i ] \u8868\u793a\u5728 (i : ] \u8303\u56f4\u5185\u6bd4 nums[ i ] \u5c0f\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u7b97\u6cd5\u662f O(n^{2}) O(n^{2}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u4e24\u5c42\u5faa\u73af\uff0c\u4f46\u662f\u5bb9\u6613\u8d85\u65f6\u3002\u9898\u610f\u8981\u6c42\u662f\u6c42\u5f53\u524d\u5143\u7d20\u5bf9\u5e94\u7684\u7edf\u8ba1\u503c\uff0c\u5f88\u81ea\u7136\u5730\u6211\u4eec\u4f1a\u60f3\u5230\u6876\u6392\uff1a\u7531\u540e\u5411\u524d\u5c06\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u653e\u5230\u6876\u4e2d\uff0c\u8fd9\u91cc\u7684\u6876\u6307\u7684\u662f\u6392\u5217\u540e\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u8fd9\u6837\u505a\u4f9d\u7136\u4e0d\u80fd\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u9898\u76ee\u8981\u6c42\u662f\u7edf\u8ba1\u4e2a\u6570\uff0c\u672c\u8d28\u4e0a\u662f\u6c42\u548c\uff0c\u533a\u522b\u5728\u4e8e\u6bcf\u6b21\u66f4\u65b0\u64cd\u4f5c\u65f6\uff0c\u53ea\u4f1a +1 \u3002\u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6811\u72b6\u6570\u7ec4\u6c42\u89e3\u3002 (1) \u7528 map \u7edf\u8ba1\u6570\u7ec4\u5404\u4e2a\u5143\u7d20\u51fa\u73b0\u7684\u4e2a\u6570 (2) \u6839\u636e\u7edf\u8ba1\u540e\u7684\u7ed3\u679c\u786e\u5b9a\u6811\u72b6\u6570\u7ec4\u7684\u957f\u5ea6 len \uff0c\u5982\u679c\u6709\u91cd\u590d\u5143\u7d20\u51fa\u73b0\uff0c\u8fd9\u4e2a\u5143\u7d20\u5360\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u5982\u679c\u65e0\u91cd\u590d\u5143\u7d20\uff0c\u8fd9\u4e2a\u5143\u7d20\u53ea\u5360\u4e00\u4e2a\u4f4d\u7f6e\u3002\u8fd9\u91cc\u7ed9\u91cd\u590d\u7684\u5143\u7d20\u8bbe\u7f6e\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u4e3a\u4e86\u907f\u514d\u5728\u540e\u7eed\u6c42\u548c\u64cd\u4f5c\u4e2d\u9519\u8bef\u5730\u5c06\u76f8\u7b49\u5143\u7d20\u8ba1\u7b97\u5728\u5185 (3) \u4ece\u540e\u5411\u524d\u904d\u5386\u6570\u7ec4\uff0c\u627e\u5230\u5143\u7d20\u5728\u6811\u72b6\u6570\u7ec4\u7684\u4f4d\u7f6e\uff0c\u5148\u6c42\u548c\uff0c\u518d\u66f4\u65b0\u3002\u5982\u679c\u662f\u91cd\u590d\u5143\u7d20\uff0c\u5b83\u6709\u4e24\u4e2a\u4f4d\u7f6e\uff0c i \u548c i-1\u4e24\u4e2a\u4e3a\u4f4d\u7f6e\uff0c\u6211\u4eec\u7528 i \u6c42\u548c\uff0c\u7528 i-1 \u66f4\u65b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > C ; int lowBit ( int x ) { return x & ( - x ); } void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } } int getSum ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; } vector < int > countSmaller ( vector < int >& nums ) { int n = ( int ) nums . size (), len = 0 ; vector < int > ans ( n , 0 ); if ( n < 2 ) { return ans ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } for ( auto iter = cnt . begin (); iter != cnt . end (); iter ++ ) { len ++ ; if ( iter -> second > 1 ) { len ++ ; } iter -> second = len ; } C . resize ( len + 1 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { ans [ i ] = getSum ( cnt [ nums [ i ]] - 1 ); update ( cnt [ nums [ i ]]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6811\u72b6\u6570\u7ec4"},{"location":"data-structure/binary-indexed-tree/#_1","text":"\u6811\u72b6\u6570\u7ec4\u662f\u4e00\u79cd\u5bf9\u5b58\u50a8\u6570\u5b57\u7684\u5217\u8868\u8fdb\u884c\u9ad8\u6548\u5730\u66f4\u65b0\u53ca\u6c42\u524d\u7f00\u548c\u7684\u6570\u636e\u7ed3\u6784\u3002\u4e3b\u8981\u7684\u64cd\u4f5c\u4e3a\uff1a \u66f4\u65b0\uff08update\uff09 \u6c42\u548c\uff08sum\uff09 \u6811\u72b6\u6570\u7ec4\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u4fdd\u5b58\u6570\u636e\uff0c\u4f46\u67d0\u4e9b\u7ed3\u70b9\u662f\u524d\u65b9\u82e5\u5e72\u7ed3\u70b9\u7684\u603b\u548c \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \u4f8b\u5982\uff0c \u7ed3\u70b9 1\u30013\u30015\u30017 \u53ea\u7ba1\u7406\u4e00\u4e2a\u6570\u503c\uff0c\u7ed3\u70b9 2 \u7ba1\u7406 1\u30012\uff08\u5171\u4e24\u4e2a\uff09\uff0c\u7ed3\u70b9 4 \u7ba1\u7406 1\u30012\u30013\u30014\uff08\u5171\u56db\u4e2a\uff09\u3002\u6b64\u5904\u7684\u6570\u5b57\u5747\u8868\u793a\u6570\u7ec4\u7684\u79e9\uff08\u4ece 1 \u5f00\u59cb\uff09\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/binary-indexed-tree/#_2","text":"","title":"\u539f\u7406"},{"location":"data-structure/binary-indexed-tree/#lowbit","text":"\u82e5\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0c\u6211\u4eec\u6c42\u8fd9\u4e2a\u79e9\u4e0b\u4e00\u5c42\u79e9\uff0c\u5373\u5f53\u524d\u7ed3\u70b9\u53ef\u7ba1\u7406\u7684\u7ed3\u70b9\u6570\u76ee\u3002 1 2 3 int lowBit ( int x ) { return x & ( - x ); } \u6b64\u5904 x \u8868\u793a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0cx & (-x) \u8868\u793a\u6c42 x \u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u7b2c\u4e00\u4e2a 1 \u53ca\u5176\u53f3\u8fb9\u7684\u6240\u6709 0 \u6784\u6210\u7684\u503c\u3002 \u4f8b\u5982\uff0c \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5947\u6570\u7684 lowBit \u4e00\u5b9a\u4e3a 1\uff0c\u5076\u6570\u7684 lowBit \u4e00\u5b9a\u662f\u5076\u6570","title":"lowBit"},{"location":"data-structure/binary-indexed-tree/#_3","text":"\u5982\u679c\u6211\u4eec\u60f3\u5bf9\u67d0\u4e00\u4e2a\u6570\u503c\u66f4\u65b0\uff0c\u5982\u7d2f\u52a0\u4e00\u4e2a\u6570\u503c\uff0c\u9700\u8981\u5c06\u5f53\u524d\u7ed3\u70b9\u53ca\u5176\u6240\u6709\u7684\u4e0a\u7ea7\u66f4\u65b0\u3002 1 2 3 4 5 6 7 vector < int > C ; void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } }","title":"\u66f4\u65b0"},{"location":"data-structure/binary-indexed-tree/#_4","text":"\u82e5\u7ed9\u5b9a\u4e00\u4e2a\u79e9\uff0c\u5e94\u5f53\u8fd4\u56de\u622a\u6b62\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u524d\u7f00\u548c\u3002 1 2 3 4 5 6 7 8 int query ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; }","title":"\u67e5\u8be2"},{"location":"data-structure/binary-indexed-tree/#_5","text":"\u5982\u679c\u7ed9\u5b9a\u4e86\u4e00\u4e2a\u6570\u7ec4\uff0c\u6211\u4eec\u5e0c\u671b\u6709\u53e6\u4e00\u4e2a\u6570\u7ec4\u5728 O(n) O(n) \u7684\u65f6\u95f4\u4e0b\u5efa\u7acb\u6811\u72b6\u6570\u7ec4\u3002 1 2 3 4 5 for ( int i = 1 ; i <= n ; i ++ ) { C [ i ] += A [ i ]; int j = i + lowBit ( i ); if ( j <= n ) { C [ j ] += C [ i ]; } }","title":"\u521d\u59cb\u5316\u5efa\u6811"},{"location":"data-structure/binary-indexed-tree/#_6","text":"","title":"\u9898\u76ee"},{"location":"data-structure/binary-indexed-tree/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u5982 nums = [5, 2, 6, 1, 1]\uff0c\u8fd4\u56de\u4e00\u4e2a\u7b49\u957f\u7684\u6570\u7ec4\uff0ccnt = [3, 2, 2, 0, 0]\u3002cnt[ i ] \u8868\u793a\u5728 (i : ] \u8303\u56f4\u5185\u6bd4 nums[ i ] \u5c0f\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u7b97\u6cd5\u662f O(n^{2}) O(n^{2}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u4e24\u5c42\u5faa\u73af\uff0c\u4f46\u662f\u5bb9\u6613\u8d85\u65f6\u3002\u9898\u610f\u8981\u6c42\u662f\u6c42\u5f53\u524d\u5143\u7d20\u5bf9\u5e94\u7684\u7edf\u8ba1\u503c\uff0c\u5f88\u81ea\u7136\u5730\u6211\u4eec\u4f1a\u60f3\u5230\u6876\u6392\uff1a\u7531\u540e\u5411\u524d\u5c06\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u653e\u5230\u6876\u4e2d\uff0c\u8fd9\u91cc\u7684\u6876\u6307\u7684\u662f\u6392\u5217\u540e\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u8fd9\u6837\u505a\u4f9d\u7136\u4e0d\u80fd\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u9898\u76ee\u8981\u6c42\u662f\u7edf\u8ba1\u4e2a\u6570\uff0c\u672c\u8d28\u4e0a\u662f\u6c42\u548c\uff0c\u533a\u522b\u5728\u4e8e\u6bcf\u6b21\u66f4\u65b0\u64cd\u4f5c\u65f6\uff0c\u53ea\u4f1a +1 \u3002\u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6811\u72b6\u6570\u7ec4\u6c42\u89e3\u3002 (1) \u7528 map \u7edf\u8ba1\u6570\u7ec4\u5404\u4e2a\u5143\u7d20\u51fa\u73b0\u7684\u4e2a\u6570 (2) \u6839\u636e\u7edf\u8ba1\u540e\u7684\u7ed3\u679c\u786e\u5b9a\u6811\u72b6\u6570\u7ec4\u7684\u957f\u5ea6 len \uff0c\u5982\u679c\u6709\u91cd\u590d\u5143\u7d20\u51fa\u73b0\uff0c\u8fd9\u4e2a\u5143\u7d20\u5360\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u5982\u679c\u65e0\u91cd\u590d\u5143\u7d20\uff0c\u8fd9\u4e2a\u5143\u7d20\u53ea\u5360\u4e00\u4e2a\u4f4d\u7f6e\u3002\u8fd9\u91cc\u7ed9\u91cd\u590d\u7684\u5143\u7d20\u8bbe\u7f6e\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u4e3a\u4e86\u907f\u514d\u5728\u540e\u7eed\u6c42\u548c\u64cd\u4f5c\u4e2d\u9519\u8bef\u5730\u5c06\u76f8\u7b49\u5143\u7d20\u8ba1\u7b97\u5728\u5185 (3) \u4ece\u540e\u5411\u524d\u904d\u5386\u6570\u7ec4\uff0c\u627e\u5230\u5143\u7d20\u5728\u6811\u72b6\u6570\u7ec4\u7684\u4f4d\u7f6e\uff0c\u5148\u6c42\u548c\uff0c\u518d\u66f4\u65b0\u3002\u5982\u679c\u662f\u91cd\u590d\u5143\u7d20\uff0c\u5b83\u6709\u4e24\u4e2a\u4f4d\u7f6e\uff0c i \u548c i-1\u4e24\u4e2a\u4e3a\u4f4d\u7f6e\uff0c\u6211\u4eec\u7528 i \u6c42\u548c\uff0c\u7528 i-1 \u66f4\u65b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > C ; int lowBit ( int x ) { return x & ( - x ); } void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } } int getSum ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; } vector < int > countSmaller ( vector < int >& nums ) { int n = ( int ) nums . size (), len = 0 ; vector < int > ans ( n , 0 ); if ( n < 2 ) { return ans ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } for ( auto iter = cnt . begin (); iter != cnt . end (); iter ++ ) { len ++ ; if ( iter -> second > 1 ) { len ++ ; } iter -> second = len ; } C . resize ( len + 1 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { ans [ i ] = getSum ( cnt [ nums [ i ]] - 1 ); update ( cnt [ nums [ i ]]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u7edf\u8ba1\u53f3\u4fa7\u5c0f\u4e8e\u5f53\u524d\u5143\u7d20\u7684\u4e2a\u6570"},{"location":"data-structure/hash/","text":"\u7b80\u4ecb \u00b6 \u54c8\u5e0c\u8868\u662f\u4e00\u79cd\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \u7684\u6570\u636e\u7ed3\u6784 \u9898\u76ee \u00b6 \u6570\u7ec4\u4e2d\u91cd\u590d\u7684\u6570\u636e \u00b6 \u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\uff0c\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u503c\u4f4d\u4e8e [1, n]\uff0c\u4ed6\u4eec\u51fa\u73b0\u7684\u6b21\u6570\u4e3a 1 \u6b21\u6216 2 \u6b21\uff0c\u8bf7\u627e\u51fa\u6240\u6709\u7684\u51fa\u73b0 2 \u6b21\u7684\u5143\u7d20\u3002\u7ebf\u6027\u65f6\u95f4\u548c\u5e38\u6570\u7a7a\u95f4\u3002 \u300c\u5206\u6790\u300d \u3010\u539f\u5730\u54c8\u5e0c\u3011\u6bcf\u4e00\u4e2a\u503c\u90fd\u4f4d\u4e8e [1, n]\uff0c\u90a3\u4e48\u8fd9\u4e9b\u503c\u5c31\u53ef\u4ee5\u6210\u4e3a\u5143\u7d20\u4e0b\u6807\uff0c\u76f8\u540c\u7684\u503c\u5bf9\u5e94\u76f8\u540c\u7684\u4e0b\u6807\u3002\u6211\u4eec\u7b2c\u4e00\u6b21\u8bbf\u95ee\u7684\u6570\u636e\u5143\u7d20\u6539\u5199\u6210\u76f8\u53cd\u6570\uff0c\u5982\u679c\u9047\u5230\u76f8\u540c\u7684\u4e0b\u6807\uff0c\u6b64\u65f6\u5bf9\u5e94\u7684\u503c\u5c31\u662f\u8d1f\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { if ( nums [ abs ( num ) - 1 ] < 0 ) { ans . emplace_back ( abs ( num )); } else { nums [ abs ( num ) - 1 ] *= - 1 ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u5168 O(1) \u7ed3\u6784 \u00b6 \u8bbe\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u53ef\u4ee5\u5728\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u4e0b\u5b9e\u73b0\u5982\u4e0b\u529f\u80fd\uff1a 1\uff09\u5bf9\u5b57\u7b26\u4e32 key \u8ba1\u6570\u52a0\u4e00 2\uff09\u5bf9\u5b57\u7b26\u4e32 key \u8ba1\u6570\u51cf\u4e00\uff0c\u5982\u679c\u51cf\u4e3a 0\uff0c\u5220\u9664\u8fd9\u4e2a\u5b57\u7b26\u4e32 3\uff09\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u6700\u5927\u7684\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\u4e32 4\uff09\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u6700\u5c0f\u7684\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\u4e32 \u300c\u5206\u6790\u300d \u3010\u54c8\u5e0c\u8868 + \u53cc\u5411\u94fe\u8868\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 struct BiListNode { int val ; BiListNode * prev , * next ; BiListNode ( int x ) : val ( x ), prev ( nullptr ), next ( nullptr ) {} }; class AllOne { unordered_map < string , int > str2int ; unordered_map < int , BiListNode *> int2node ; unordered_map < int , unordered_set < string >> int2str ; BiListNode * head , * tail ; public : AllOne () { head = new BiListNode ( 0 ); tail = new BiListNode ( INT_MAX ); head -> next = tail ; tail -> prev = head ; } void deleteNode ( BiListNode * prev , BiListNode * cur ) { prev -> next = cur -> next ; cur -> next -> prev = prev ; delete cur ; } void addNode ( BiListNode * prev , BiListNode * cur ) { cur -> next = prev -> next ; cur -> prev = prev ; prev -> next -> prev = cur ; prev -> next = cur ; } void inc ( string key ) { if ( str2int . count ( key )) { int cnt = str2int [ key ]; str2int [ key ] ++ ; int2str [ cnt + 1 ]. emplace ( key ); if ( ! int2node . count ( cnt + 1 )) { BiListNode * node = new BiListNode ( cnt + 1 ); addNode ( int2node [ cnt ], node ); int2node [ cnt + 1 ] = node ; } int2str [ cnt ]. erase ( key ); if ( int2str [ cnt ]. empty ()) { int2str . erase ( cnt ); deleteNode ( int2node [ cnt ] -> prev , int2node [ cnt ]); int2node . erase ( cnt ); } } else { str2int [ key ] = 1 ; int2str [ 1 ]. emplace ( key ); if ( ! int2node . count ( 1 )) { BiListNode * node = new BiListNode ( 1 ); addNode ( head , node ); int2node [ 1 ] = node ; } } } void dec ( string key ) { int cnt = str2int [ key ]; if ( cnt == 1 ) { str2int . erase ( key ); } else { str2int [ key ] -- ; int2str [ cnt - 1 ]. emplace ( key ); if ( ! int2node . count ( cnt - 1 )) { BiListNode * node = new BiListNode ( cnt - 1 ); addNode ( int2node [ cnt ] -> prev , node ); int2node [ cnt - 1 ] = node ; } } int2str [ cnt ]. erase ( key ); if ( int2str [ cnt ]. empty ()) { int2str . erase ( cnt ); deleteNode ( int2node [ cnt ] -> prev , int2node [ cnt ]); int2node . erase ( cnt ); } } string getMaxKey () { if ( int2node . empty ()) { return \"\" ; } int val = tail -> prev -> val ; return * int2str [ val ]. begin (); } string getMinKey () { if ( int2node . empty ()) { return \"\" ; } int val = head -> next -> val ; return * int2str [ val ]. begin (); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u91cd\u590d\u7684\u5b57\u7b26 \u00b6 \u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u627e\u51fa\u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5f53\u4ece\u5b57\u7b26\u6d41\u4e2d\u53ea\u8bfb\u51fa\u524d\u4e24\u4e2a\u5b57\u7b26\"go\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"g\"\u3002\u5f53\u4ece\u8be5\u5b57\u7b26\u6d41\u4e2d\u8bfb\u51fa\u524d\u516d\u4e2a\u5b57\u7b26\u201cgoogle\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"l\"\u3002\u5982\u679c\u5f53\u524d\u5b57\u7b26\u6d41\u6ca1\u6709\u5b58\u5728\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u8fd4\u56de#\u5b57\u7b26\u3002 \u300c\u5206\u6790\u300d \u7528\u4e00\u4e2a\u957f\u4e3a 256 \u7684\u6570\u7ec4\u8868\u793a ACSII \u5b57\u7b26\uff0c\u5982\u679c\u91cd\u590d\u7684\u5b57\u7b26\u51fa\u73b0\uff0c\u628a\u5bf9\u5e94\u7684\u4f4d\u7f6e\u7f6e\u6210 -1\uff0c\u6700\u540e\u8fd4\u56de\u6700\u5c0f\u7684\u7d22\u5f15\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { int * ascii ; int N ; int flow ; public \uff1a Solution () { N = 256 ; ascii = new int [ N ]{}; flow = 1 ; } ~ Solution () { delete [] ascii ; } //Insert one char from stringstream void Insert ( char ch ) { int idx = int ( ch ); if ( ascii [ idx ] == 0 ) { ascii [ idx ] = flow ; } else { ascii [ idx ] = - 1 ; } flow ++ ; } //return the first appearence once char in current stringstream char FirstAppearingOnce () { int pos = flow , ch = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] < 1 ) { continue ; } if ( pos > ascii [ i ]) { pos = ascii [ i ]; ch = i ; } } if ( pos == flow ) { return '#' ; } return char ( ch ); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u7f3a\u5931\u7684\u7b2c\u4e00\u4e2a\u6b63\u6570 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u672a\u6392\u5e8f\u7684\u6574\u6570\u6570\u7ec4 nums \uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u6ca1\u6709\u51fa\u73b0\u7684\u6700\u5c0f\u7684\u6b63\u6574\u6570\u3002\u8bf7\u4f60\u5b9e\u73b0\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u5e76\u4e14\u53ea\u4f7f\u7528\u5e38\u6570\u7ea7\u522b\u989d\u5916\u7a7a\u95f4\u7684\u89e3\u51b3\u65b9\u6848\u3002\u4f8b\u5982\uff0c[3,4,-1,1] \u8fd4\u56de 2\u3002 \u300c\u5206\u6790\u300d \u300c\u539f\u5730\u54c8\u5e0c\u300d \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & -1 \\\\ & & \\Downarrow & \\\\ -3 & 4 & -5 & -1 \\end{matrix} \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & -1 \\\\ & & \\Downarrow & \\\\ -3 & 4 & -5 & -1 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int firstMissingPositive ( vector < int >& nums ) { int n = int ( nums . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] <= 0 ) { nums [ i ] = n + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { int num = abs ( nums [ i ]); if ( num <= n ) { nums [ num - 1 ] = - abs ( nums [ num - 1 ]); } } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] > 0 ) { return i + 1 ; } } return n + 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u5b58\u5728\u91cd\u590d\u5143\u7d20 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \u548c\u4e24\u4e2a\u6574\u6570 k \u548c t \u3002\u627e\u51fa\u6ee1\u8db3\u4e0b\u8ff0\u6761\u4ef6\u7684\u4e0b\u6807\u5bf9 (i, j)\uff1a i != j, abs(i - j) <= k abs(nums[i] - nums[j]) <= t \u5982\u679c\u5b58\u5728\uff0c\u8fd4\u56de true \uff1b\u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u300c\u5206\u6790\u300d \u300c\u54c8\u5e0c\u8868\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false */ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; set < int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { iter = hash . lower_bound ( max ( nums [ i ], INT_MIN + t ) - t ); if ( iter != hash . end () && * iter <= min ( nums [ i ], INT_MAX - t ) + t ) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u6700\u5c0f\u8986\u76d6\u5b50\u4e32 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u3001\u4e00\u4e2a\u5b57\u7b26\u4e32 t \u3002\u8fd4\u56de s \u4e2d\u6db5\u76d6 t \u6240\u6709\u5b57\u7b26\u7684\u6700\u5c0f\u5b50\u4e32\u3002\u5982\u679c s \u4e2d\u4e0d\u5b58\u5728\u6db5\u76d6 t \u6240\u6709\u5b57\u7b26\u7684\u5b50\u4e32\uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32 \"\" \u3002 \u300c\u5206\u6790\u300d \u300c\u6ed1\u52a8\u7a97\u53e3 + \u54c8\u5e0c\u8868\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" */ class Solution { public : string minWindow ( string s , string t ) { unordered_map < char , int > tDict , sDict ; for ( const auto & c : t ) { tDict [ c ] ++ ; } int ns = int ( s . length ()); int l = 0 , r = - 1 , ansL = - 1 , minLen = INT_MAX ; while ( r < ns ) { if ( tDict . find ( s [ ++ r ]) != tDict . end ()) { sDict [ s [ r ]] ++ ; } while ( isCover ( tDict , sDict ) && l <= r ) { if ( r - l + 1 < minLen ) { minLen = r - l + 1 ; ansL = l ; } if ( tDict . find ( s [ l ]) != tDict . end ()) { sDict [ s [ l ]] -- ; } l ++ ; } } return - 1 == ansL ? string () : s . substr ( ansL , minLen ); } bool isCover ( unordered_map < char , int > & tDict , unordered_map < char , int > & sDict ) { for ( const auto & item : tDict ) { if ( sDict [ item . first ] < item . second ) { return false ; } } return true ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u6700\u957f\u8fde\u7eed\u5e8f\u5217 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u672a\u6392\u5e8f\u7684\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u51fa\u6570\u5b57\u8fde\u7eed\u7684\u6700\u957f\u5e8f\u5217\uff08\u4e0d\u8981\u6c42\u5e8f\u5217\u5143\u7d20\u5728\u539f\u6570\u7ec4\u4e2d\u8fde\u7eed\uff09\u7684\u957f\u5ea6\u3002\u8bf7\u4f60\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u7684\u7b97\u6cd5\u89e3\u51b3\u6b64\u95ee\u9898\u3002\u4f8b\u5982\uff0cnums = [100,4,200,1,3,2]\uff0c\u8fd4\u56de 4\uff0c\u6700\u957f\u8fde\u7eed\u5e8f\u5217\u662f [1, 2, 3, 4]\u3002 \u300c\u5206\u6790\u300d \u300c\u54c8\u5e0c\u8868\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int longestConsecutive ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int ans = 1 ; unordered_set < int > hash ; for ( const auto & ele : nums ) { hash . insert ( ele ); } for ( const int & ele : nums ) { if ( hash . find ( ele - 1 ) != hash . end ()) { int curNum = ele ; int len = 1 ; while ( hash . find ( curNum ) != hash . end ()) { curNum ++ ; len ++ ; } ans = max ( ans , len ); } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u54c8\u5e0c\u8868"},{"location":"data-structure/hash/#_1","text":"\u54c8\u5e0c\u8868\u662f\u4e00\u79cd\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \u7684\u6570\u636e\u7ed3\u6784","title":"\u7b80\u4ecb"},{"location":"data-structure/hash/#_2","text":"","title":"\u9898\u76ee"},{"location":"data-structure/hash/#_3","text":"\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\uff0c\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u503c\u4f4d\u4e8e [1, n]\uff0c\u4ed6\u4eec\u51fa\u73b0\u7684\u6b21\u6570\u4e3a 1 \u6b21\u6216 2 \u6b21\uff0c\u8bf7\u627e\u51fa\u6240\u6709\u7684\u51fa\u73b0 2 \u6b21\u7684\u5143\u7d20\u3002\u7ebf\u6027\u65f6\u95f4\u548c\u5e38\u6570\u7a7a\u95f4\u3002 \u300c\u5206\u6790\u300d \u3010\u539f\u5730\u54c8\u5e0c\u3011\u6bcf\u4e00\u4e2a\u503c\u90fd\u4f4d\u4e8e [1, n]\uff0c\u90a3\u4e48\u8fd9\u4e9b\u503c\u5c31\u53ef\u4ee5\u6210\u4e3a\u5143\u7d20\u4e0b\u6807\uff0c\u76f8\u540c\u7684\u503c\u5bf9\u5e94\u76f8\u540c\u7684\u4e0b\u6807\u3002\u6211\u4eec\u7b2c\u4e00\u6b21\u8bbf\u95ee\u7684\u6570\u636e\u5143\u7d20\u6539\u5199\u6210\u76f8\u53cd\u6570\uff0c\u5982\u679c\u9047\u5230\u76f8\u540c\u7684\u4e0b\u6807\uff0c\u6b64\u65f6\u5bf9\u5e94\u7684\u503c\u5c31\u662f\u8d1f\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { if ( nums [ abs ( num ) - 1 ] < 0 ) { ans . emplace_back ( abs ( num )); } else { nums [ abs ( num ) - 1 ] *= - 1 ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6570\u7ec4\u4e2d\u91cd\u590d\u7684\u6570\u636e"},{"location":"data-structure/hash/#o1","text":"\u8bbe\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u53ef\u4ee5\u5728\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u4e0b\u5b9e\u73b0\u5982\u4e0b\u529f\u80fd\uff1a 1\uff09\u5bf9\u5b57\u7b26\u4e32 key \u8ba1\u6570\u52a0\u4e00 2\uff09\u5bf9\u5b57\u7b26\u4e32 key \u8ba1\u6570\u51cf\u4e00\uff0c\u5982\u679c\u51cf\u4e3a 0\uff0c\u5220\u9664\u8fd9\u4e2a\u5b57\u7b26\u4e32 3\uff09\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u6700\u5927\u7684\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\u4e32 4\uff09\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u6700\u5c0f\u7684\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\u4e32 \u300c\u5206\u6790\u300d \u3010\u54c8\u5e0c\u8868 + \u53cc\u5411\u94fe\u8868\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 struct BiListNode { int val ; BiListNode * prev , * next ; BiListNode ( int x ) : val ( x ), prev ( nullptr ), next ( nullptr ) {} }; class AllOne { unordered_map < string , int > str2int ; unordered_map < int , BiListNode *> int2node ; unordered_map < int , unordered_set < string >> int2str ; BiListNode * head , * tail ; public : AllOne () { head = new BiListNode ( 0 ); tail = new BiListNode ( INT_MAX ); head -> next = tail ; tail -> prev = head ; } void deleteNode ( BiListNode * prev , BiListNode * cur ) { prev -> next = cur -> next ; cur -> next -> prev = prev ; delete cur ; } void addNode ( BiListNode * prev , BiListNode * cur ) { cur -> next = prev -> next ; cur -> prev = prev ; prev -> next -> prev = cur ; prev -> next = cur ; } void inc ( string key ) { if ( str2int . count ( key )) { int cnt = str2int [ key ]; str2int [ key ] ++ ; int2str [ cnt + 1 ]. emplace ( key ); if ( ! int2node . count ( cnt + 1 )) { BiListNode * node = new BiListNode ( cnt + 1 ); addNode ( int2node [ cnt ], node ); int2node [ cnt + 1 ] = node ; } int2str [ cnt ]. erase ( key ); if ( int2str [ cnt ]. empty ()) { int2str . erase ( cnt ); deleteNode ( int2node [ cnt ] -> prev , int2node [ cnt ]); int2node . erase ( cnt ); } } else { str2int [ key ] = 1 ; int2str [ 1 ]. emplace ( key ); if ( ! int2node . count ( 1 )) { BiListNode * node = new BiListNode ( 1 ); addNode ( head , node ); int2node [ 1 ] = node ; } } } void dec ( string key ) { int cnt = str2int [ key ]; if ( cnt == 1 ) { str2int . erase ( key ); } else { str2int [ key ] -- ; int2str [ cnt - 1 ]. emplace ( key ); if ( ! int2node . count ( cnt - 1 )) { BiListNode * node = new BiListNode ( cnt - 1 ); addNode ( int2node [ cnt ] -> prev , node ); int2node [ cnt - 1 ] = node ; } } int2str [ cnt ]. erase ( key ); if ( int2str [ cnt ]. empty ()) { int2str . erase ( cnt ); deleteNode ( int2node [ cnt ] -> prev , int2node [ cnt ]); int2node . erase ( cnt ); } } string getMaxKey () { if ( int2node . empty ()) { return \"\" ; } int val = tail -> prev -> val ; return * int2str [ val ]. begin (); } string getMinKey () { if ( int2node . empty ()) { return \"\" ; } int val = head -> next -> val ; return * int2str [ val ]. begin (); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u5168 O(1) \u7ed3\u6784"},{"location":"data-structure/hash/#_4","text":"\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u627e\u51fa\u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5f53\u4ece\u5b57\u7b26\u6d41\u4e2d\u53ea\u8bfb\u51fa\u524d\u4e24\u4e2a\u5b57\u7b26\"go\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"g\"\u3002\u5f53\u4ece\u8be5\u5b57\u7b26\u6d41\u4e2d\u8bfb\u51fa\u524d\u516d\u4e2a\u5b57\u7b26\u201cgoogle\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"l\"\u3002\u5982\u679c\u5f53\u524d\u5b57\u7b26\u6d41\u6ca1\u6709\u5b58\u5728\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u8fd4\u56de#\u5b57\u7b26\u3002 \u300c\u5206\u6790\u300d \u7528\u4e00\u4e2a\u957f\u4e3a 256 \u7684\u6570\u7ec4\u8868\u793a ACSII \u5b57\u7b26\uff0c\u5982\u679c\u91cd\u590d\u7684\u5b57\u7b26\u51fa\u73b0\uff0c\u628a\u5bf9\u5e94\u7684\u4f4d\u7f6e\u7f6e\u6210 -1\uff0c\u6700\u540e\u8fd4\u56de\u6700\u5c0f\u7684\u7d22\u5f15\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { int * ascii ; int N ; int flow ; public \uff1a Solution () { N = 256 ; ascii = new int [ N ]{}; flow = 1 ; } ~ Solution () { delete [] ascii ; } //Insert one char from stringstream void Insert ( char ch ) { int idx = int ( ch ); if ( ascii [ idx ] == 0 ) { ascii [ idx ] = flow ; } else { ascii [ idx ] = - 1 ; } flow ++ ; } //return the first appearence once char in current stringstream char FirstAppearingOnce () { int pos = flow , ch = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] < 1 ) { continue ; } if ( pos > ascii [ i ]) { pos = ascii [ i ]; ch = i ; } } if ( pos == flow ) { return '#' ; } return char ( ch ); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u91cd\u590d\u7684\u5b57\u7b26"},{"location":"data-structure/hash/#_5","text":"\u7ed9\u4f60\u4e00\u4e2a\u672a\u6392\u5e8f\u7684\u6574\u6570\u6570\u7ec4 nums \uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u6ca1\u6709\u51fa\u73b0\u7684\u6700\u5c0f\u7684\u6b63\u6574\u6570\u3002\u8bf7\u4f60\u5b9e\u73b0\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u5e76\u4e14\u53ea\u4f7f\u7528\u5e38\u6570\u7ea7\u522b\u989d\u5916\u7a7a\u95f4\u7684\u89e3\u51b3\u65b9\u6848\u3002\u4f8b\u5982\uff0c[3,4,-1,1] \u8fd4\u56de 2\u3002 \u300c\u5206\u6790\u300d \u300c\u539f\u5730\u54c8\u5e0c\u300d \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & -1 \\\\ & & \\Downarrow & \\\\ -3 & 4 & -5 & -1 \\end{matrix} \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & -1 \\\\ & & \\Downarrow & \\\\ -3 & 4 & -5 & -1 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int firstMissingPositive ( vector < int >& nums ) { int n = int ( nums . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] <= 0 ) { nums [ i ] = n + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { int num = abs ( nums [ i ]); if ( num <= n ) { nums [ num - 1 ] = - abs ( nums [ num - 1 ]); } } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] > 0 ) { return i + 1 ; } } return n + 1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u7f3a\u5931\u7684\u7b2c\u4e00\u4e2a\u6b63\u6570"},{"location":"data-structure/hash/#_6","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \u548c\u4e24\u4e2a\u6574\u6570 k \u548c t \u3002\u627e\u51fa\u6ee1\u8db3\u4e0b\u8ff0\u6761\u4ef6\u7684\u4e0b\u6807\u5bf9 (i, j)\uff1a i != j, abs(i - j) <= k abs(nums[i] - nums[j]) <= t \u5982\u679c\u5b58\u5728\uff0c\u8fd4\u56de true \uff1b\u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u300c\u5206\u6790\u300d \u300c\u54c8\u5e0c\u8868\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false */ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; set < int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { iter = hash . lower_bound ( max ( nums [ i ], INT_MIN + t ) - t ); if ( iter != hash . end () && * iter <= min ( nums [ i ], INT_MAX - t ) + t ) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u5b58\u5728\u91cd\u590d\u5143\u7d20"},{"location":"data-structure/hash/#_7","text":"\u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u3001\u4e00\u4e2a\u5b57\u7b26\u4e32 t \u3002\u8fd4\u56de s \u4e2d\u6db5\u76d6 t \u6240\u6709\u5b57\u7b26\u7684\u6700\u5c0f\u5b50\u4e32\u3002\u5982\u679c s \u4e2d\u4e0d\u5b58\u5728\u6db5\u76d6 t \u6240\u6709\u5b57\u7b26\u7684\u5b50\u4e32\uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32 \"\" \u3002 \u300c\u5206\u6790\u300d \u300c\u6ed1\u52a8\u7a97\u53e3 + \u54c8\u5e0c\u8868\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" */ class Solution { public : string minWindow ( string s , string t ) { unordered_map < char , int > tDict , sDict ; for ( const auto & c : t ) { tDict [ c ] ++ ; } int ns = int ( s . length ()); int l = 0 , r = - 1 , ansL = - 1 , minLen = INT_MAX ; while ( r < ns ) { if ( tDict . find ( s [ ++ r ]) != tDict . end ()) { sDict [ s [ r ]] ++ ; } while ( isCover ( tDict , sDict ) && l <= r ) { if ( r - l + 1 < minLen ) { minLen = r - l + 1 ; ansL = l ; } if ( tDict . find ( s [ l ]) != tDict . end ()) { sDict [ s [ l ]] -- ; } l ++ ; } } return - 1 == ansL ? string () : s . substr ( ansL , minLen ); } bool isCover ( unordered_map < char , int > & tDict , unordered_map < char , int > & sDict ) { for ( const auto & item : tDict ) { if ( sDict [ item . first ] < item . second ) { return false ; } } return true ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6700\u5c0f\u8986\u76d6\u5b50\u4e32"},{"location":"data-structure/hash/#_8","text":"\u7ed9\u5b9a\u4e00\u4e2a\u672a\u6392\u5e8f\u7684\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u51fa\u6570\u5b57\u8fde\u7eed\u7684\u6700\u957f\u5e8f\u5217\uff08\u4e0d\u8981\u6c42\u5e8f\u5217\u5143\u7d20\u5728\u539f\u6570\u7ec4\u4e2d\u8fde\u7eed\uff09\u7684\u957f\u5ea6\u3002\u8bf7\u4f60\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u7684\u7b97\u6cd5\u89e3\u51b3\u6b64\u95ee\u9898\u3002\u4f8b\u5982\uff0cnums = [100,4,200,1,3,2]\uff0c\u8fd4\u56de 4\uff0c\u6700\u957f\u8fde\u7eed\u5e8f\u5217\u662f [1, 2, 3, 4]\u3002 \u300c\u5206\u6790\u300d \u300c\u54c8\u5e0c\u8868\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int longestConsecutive ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int ans = 1 ; unordered_set < int > hash ; for ( const auto & ele : nums ) { hash . insert ( ele ); } for ( const int & ele : nums ) { if ( hash . find ( ele - 1 ) != hash . end ()) { int curNum = ele ; int len = 1 ; while ( hash . find ( curNum ) != hash . end ()) { curNum ++ ; len ++ ; } ans = max ( ans , len ); } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6700\u957f\u8fde\u7eed\u5e8f\u5217"},{"location":"data-structure/list/","text":"\u7b80\u4ecb \u00b6 \u94fe\u8868\u662f\u4e00\u79cd\u5bfb\u4f4d\u8bbf\u95ee\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4ee5\u6307\u9488\u7684\u65b9\u5f0f\uff0c\u5c06\u4e24\u5757\u6570\u636e\u8fde\u63a5\u8d77\u6765\u3002\u5b58\u50a8\u7a7a\u95f4\u4e0a\u901a\u5e38\u662f\u4e0d\u8fde\u7eed\u7684\uff0c\u589e\u5220\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \u3002\u901a\u5e38\u800c\u8a00\uff0c\u94fe\u8868\u6709\u5982\u4e0b\u51e0\u79cd \u5355\u94fe\u8868 \u53cc\u94fe\u8868 \u5faa\u73af\u94fe\u8868 \u94fe\u8868\u7ed3\u70b9\u8bbe\u8ba1 \u00b6 \u7ed3\u70b9\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a \u6570\u636e\u57df \u6307\u9488\u57df \u5bf9\u5355\u94fe\u8868\u800c\u8a00\uff0c\u5176\u7ed3\u70b9\u7684\u5b9a\u4e49\u65b9\u5f0f\u5982\u4e0b 1 2 3 4 5 6 7 struct ListNode { int val ; ListNode * next ; ListNode () : val ( 0 ), next ( nullptr ) {} ListNode ( int x ) : val ( x ), next ( nullptr ) {} ListNode ( int x , ListNode * next ) : val ( x ), next ( next ) {} }; \u9898\u76ee \u00b6 \u53cd\u8f6c\u94fe\u8868 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* from 1 -> 2 -> 3 -> 4 -> 5 to 5 -> 4 -> 3 -> 2 -> 1 */ // \u8fed\u4ee3 ListNode * reverseList ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next , * p3 = head -> next -> next ; while ( p3 != nullptr ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; p3 = p3 -> next ; } p2 -> next = p1 ; head -> next = nullptr ; return p2 ; } // \u9012\u5f52 ListNode * reverseList ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * ans = reverse ( head , head -> next ); head -> next = nullptr ; return ans ; } ListNode * reverse ( ListNode * p1 , ListNode * p2 ) { if ( p2 -> next != nullptr ) { ListNode * p3 = p2 -> next ; p2 -> next = p1 ; return reverse ( p2 , p3 ); } p2 -> next = p1 ; return p2 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u9012\u5f52\u7248\u672c\u7684\u7a7a\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) \uff0c\u8fed\u4ee3\u7248\u672c\u7684\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u300c\u90e8\u5206\u533a\u95f4\u53cd\u8f6c\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] 1 -> 2 -> 3 -> 4 -> 5 | v 1 -> 4 -> 3 -> 2 -> 5 */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int left , int right ) { if ( left >= right || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = head , * p0 = pre ; int i = 1 ; while ( i < left ) { p1 = p1 -> next ; p0 = p0 -> next ; i ++ ; if ( p1 == nullptr ) { delete pre ; return head ; } } ListNode * tail = p1 , * p2 = p1 -> next ; if ( p2 == nullptr ) { delete pre ; return head ; } ListNode * p3 = p2 -> next ; while ( i < right ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } p3 = p3 -> next ; i ++ ; } p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u627e\u51fa\u4e24\u4e2a\u94fe\u8868\u7684\u76f8\u4ea4\u7ed3\u70b9 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868A\u3001B\uff0c\u627e\u51fa\u4e24\u8005\u76f8\u4ea4\u7684\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u4ea4\uff0c\u8fd4\u56de\u4e3a\u7a7a\u6307\u9488\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u65b9\u6cd5\u662f\u5c06\u8fd9\u4e24\u4e2a\u94fe\u8868\u7528\u6808\u4fdd\u5b58\u8d77\u6765\uff0c\u6bd4\u5bf9\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u540c\uff0c\u5219\u5fc5\u5b9a\u4e0d\u76f8\u4ea4\uff0c\u5982\u679c\u76f8\u540c\uff0c\u53cd\u5411\u904d\u5386\u6808\u5373\u53ef\u627e\u5230\u7b2c\u4e00\u4e2a\u76f8\u4ea4\u7684\u7ed3\u70b9\u3002\u4f46\u662f\u5e38\u6570\u7a7a\u95f4\u7684\u7b97\u6cd5\u662f\u5b58\u5728\u7684\u3002\u95ee\u9898\u7684\u96be\u70b9\u5728\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u4e0d\u4e00\u81f4\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u548c\u662f\u4e00\u5b9a\u7684\uff0c\u5373\u6211\u4eec\u5148\u904d\u5386\u94fe\u8868 pHead1 \u518d\u904d\u5386\u94fe\u8868 pHead2 \u4e0e\u5148\u904d\u5386 pHead2 \u518d\u904d\u5386 pHead1 \u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684\u3002\u90a3\u4e48\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u662f\u5728\u67d0\u4e2a\u7ed3\u70b9\u76f8\u4ea4\u7684\uff0c\u6309\u7167\u4e0a\u8ff0\u7684\u904d\u5386\u65b9\u6cd5\uff0c\u4e24\u4e2a\u6307\u9488\u4e00\u5b9a\u5728\u76f8\u4ea4\u7684\u7ed3\u70b9\u76f8\u4f1a\u3002 \u9996\u5148\uff0c\u521d\u59cb\u72b6\u6001\u4e0b\uff0c\u4e24\u4e2a\u6307\u9488\u5206\u522b\u5904\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u5934\u7ed3\u70b9 \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} p_{1} p_{1} \u548c p_{2} p_{2} \u540c\u65f6\u5411\u540e\u79fb\u52a8\u76f4\u5230\u67d0\u4e00\u4e2a\u7387\u5148\u5230\u8fbe\u672b\u7ed3\u70b9\u3002\u672c\u4f8b\u4e2d\uff0c p_{2} p_{2} \u5148\u5230\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece pHead1 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u540c\u6837\u5730\uff0c p_{1} p_{1} \u4e5f\u4f1a\u5230\u8fbe\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece phead2 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u5c31\u4f1a\u53d1\u73b0\uff0c p_{1} p_{1} \u548c p_{2} p_{2} \u5904\u5728\u76f8\u540c\u4f4d\u7f6e\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u53ef\u4ee5\u540c\u65f6\u8fbe\u5230\u5404\u81ea\u7684\u5c3e\u7ed3\u70b9\u3002 \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \u6700\u7ec8\u53ef\u4ee5\u627e\u5230\u76f8\u4ea4\u4f4d\u7f6e\u5904\u7684\u7ed3\u70b9 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( headA == nullptr || headB == nullptr ) { return nullptr ; } ListNode * p1 = headA , * p2 = headB ; for ( int i = 0 ; i < 3 ; i ++ ) { while ( p1 != nullptr && p2 != nullptr ) { if ( p1 == p2 ) { return p1 ; } p1 = p1 -> next ; p2 = p2 -> next ; } if ( p1 == nullptr ) { p1 = headB ; } if ( p2 == nullptr ) { p2 = headA ; } } return nullptr ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u94fe\u8868\u7684\u4e2d\u5fc3\u8282\u70b9 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u7684\u4e2d\u5fc3\u8282\u70b9\uff0c\u5982\u679c\u94fe\u8868\u7684\u7ed3\u70b9\u4e2a\u6570\u662f\u5076\u6570\uff0c\u5219\u8fd4\u56de\u9760\u540e\u4f4d\u7f6e\u7684\u7ed3\u70b9\u3002 \u300c\u5206\u6790\u300d \u4f7f\u7528\u3010\u5feb\u6162\u6307\u9488\u3011\u65b9\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 ListNode * middleNode ( ListNode * head ) { ListNode * p1 = head , * p2 = head ; while ( p2 != nullptr ) { p2 = p2 -> next ; if ( p2 == nullptr ) { return p1 ; } p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u4e24\u4e24\u4ea4\u6362\u94fe\u8868\u4e2d\u7684\u8282\u70b9 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u94fe\u8868\uff0c\u4e24\u4e24\u4ea4\u6362\u5176\u4e2d\u76f8\u90bb\u7684\u8282\u70b9\uff0c\u5e76\u8fd4\u56de\u4ea4\u6362\u540e\u94fe\u8868\u7684\u5934\u8282\u70b9\u3002\u4f60\u5fc5\u987b\u5728\u4e0d\u4fee\u6539\u8282\u70b9\u5185\u90e8\u7684\u503c\u7684\u60c5\u51b5\u4e0b\u5b8c\u6210\u672c\u9898\uff08\u5373\uff0c\u53ea\u80fd\u8fdb\u884c\u8282\u70b9\u4ea4\u6362\uff09\u3002\u4f8b\u5982\uff0c1->2->3->4 \u53d8\u6210 2->1->4->3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ListNode * swapPairs ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); ListNode * par = head , * son = head -> next , * gra = pre ; pre -> next = head ; while ( son != nullptr ) { par -> next = son -> next ; son -> next = par ; gra -> next = son ; gra = par ; par = par -> next ; if ( par == nullptr ) { break ; } son = par -> next ; } head = pre -> next ; delete pre ; return head ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 K \u4e2a\u4e00\u7ec4\u7ffb\u8f6c\u94fe\u8868 \u00b6 \u7ed9\u4f60\u94fe\u8868\u7684\u5934\u8282\u70b9 head \uff0c\u6bcf k \u4e2a\u8282\u70b9\u4e00\u7ec4\u8fdb\u884c\u7ffb\u8f6c\uff0c\u8bf7\u4f60\u8fd4\u56de\u4fee\u6539\u540e\u7684\u94fe\u8868\u3002k \u662f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u5b83\u7684\u503c\u5c0f\u4e8e\u6216\u7b49\u4e8e\u94fe\u8868\u7684\u957f\u5ea6\u3002\u5982\u679c\u8282\u70b9\u603b\u6570\u4e0d\u662f k \u7684\u6574\u6570\u500d\uff0c\u90a3\u4e48\u8bf7\u5c06\u6700\u540e\u5269\u4f59\u7684\u8282\u70b9\u4fdd\u6301\u539f\u6709\u987a\u5e8f\u3002\u4f60\u4e0d\u80fd\u53ea\u662f\u5355\u7eaf\u7684\u6539\u53d8\u8282\u70b9\u5185\u90e8\u7684\u503c\uff0c\u800c\u662f\u9700\u8981\u5b9e\u9645\u8fdb\u884c\u8282\u70b9\u4ea4\u6362\u3002\u4f8b\u5982\uff0c1->2->3->4->5\uff0ck = 2 \u65f6\uff0c\u8fd4\u56de 2->1->4->3->5\uff1bk = 3 \u65f6\uff0c\u8fd4\u56de 3->2->1->4->5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k < 2 ) { return head ; } ListNode * front = head ; for ( int i = 0 ; i < k ; i ++ ) { if ( front == nullptr ) { return head ; } front = front -> next ; } bool isEnd = false ; ListNode * pre = new ListNode ( 0 ); ListNode * gra = pre , * par = head , * son = head -> next ; while ( true ) { ListNode * temp = front , * p1 = gra , * p2 = par , * p3 = son ; while ( p2 != temp ) { if ( front == nullptr ) { isEnd = true ; } else { front = front -> next ; } p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { break ; } p3 = p3 -> next ; } par -> next = p2 ; gra -> next = p1 ; gra = par ; par = p2 ; son = p3 ; if ( isEnd || p3 == nullptr ) { break ; } } head = pre -> next ; delete pre ; return head ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 LRU \u7f13\u5b58\u673a\u5236 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 /* \u8fd0\u7528\u4f60\u6240\u638c\u63e1\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8bbe\u8ba1\u548c\u5b9e\u73b0\u4e00\u4e2aLRU(\u6700\u8fd1\u6700\u5c11\u4f7f\u7528)\u7f13\u5b58\u673a\u5236 \u3002 \u5b9e\u73b0 LRUCache \u7c7b\uff1a LRUCache(int capacity) \u4ee5\u6b63\u6574\u6570\u4f5c\u4e3a\u5bb9\u91cf capacity \u521d\u59cb\u5316 LRU \u7f13\u5b58 int get(int key) \u5982\u679c\u5173\u952e\u5b57 key \u5b58\u5728\u4e8e\u7f13\u5b58\u4e2d\uff0c\u5219\u8fd4\u56de\u5173\u952e\u5b57\u7684\u503c\uff0c\u5426\u5219\u8fd4\u56de -1 \u3002 void put(int key, int value) \u5982\u679c\u5173\u952e\u5b57\u5df2\u7ecf\u5b58\u5728\uff0c\u5219\u53d8\u66f4\u5176\u6570\u636e\u503c\uff1b\u5982\u679c\u5173\u952e \u5b57\u4e0d\u5b58\u5728\uff0c\u5219\u63d2\u5165\u8be5\u7ec4\u300c\u5173\u952e\u5b57-\u503c\u300d\u3002\u5f53\u7f13\u5b58\u5bb9\u91cf\u8fbe\u5230\u4e0a\u9650\u65f6\uff0c\u5b83\u5e94\u8be5\u5728\u5199\u5165\u65b0\u6570\u636e\u4e4b\u524d \u5220\u9664\u6700\u4e45\u672a\u4f7f\u7528\u7684\u6570\u636e\u503c\uff0c\u4ece\u800c\u4e3a\u65b0\u7684\u6570\u636e\u503c\u7559\u51fa\u7a7a\u95f4\u3002 \u8f93\u5165 [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] \u8f93\u51fa [null, null, null, 1, null, -1, null, -1, 3, 4] \u89e3\u91ca LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // \u7f13\u5b58\u662f {1=1} lRUCache.put(2, 2); // \u7f13\u5b58\u662f {1=1, 2=2} lRUCache.get(1); // \u8fd4\u56de 1 lRUCache.put(3, 3); // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5173\u952e\u5b57 2 \u4f5c\u5e9f\uff0c\u7f13\u5b58\u662f {1=1, 3=3} lRUCache.get(2); // \u8fd4\u56de -1 (\u672a\u627e\u5230) lRUCache.put(4, 4); // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5173\u952e\u5b57 1 \u4f5c\u5e9f\uff0c\u7f13\u5b58\u662f {4=4, 3=3} lRUCache.get(1); // \u8fd4\u56de -1 (\u672a\u627e\u5230) lRUCache.get(3); // \u8fd4\u56de 3 lRUCache.get(4); // \u8fd4\u56de 4 */ struct BiNode { int key , val ; BiNode * prec , * next ; BiNode ( int k , int v ) : key ( k ), val ( v ), prec ( nullptr ), next ( nullptr ) {} }; class LRUCache { BiNode * head ; BiNode * tail ; int cap ; unordered_map < int , BiNode *> hash ; public : LRUCache ( int capacity ) { cap = capacity ; head = new BiNode ( 0 , 0 ); tail = new BiNode ( 0 , 0 ); head -> next = tail ; tail -> prec = head ; } ~ LRUCache () { BiNode * curNode = head -> next ; while ( curNode != nullptr ) { delete curNode -> prec ; curNode = curNode -> next ; } delete tail ; } int get ( int key ) { if ( hash . find ( key ) != hash . end ()) { BiNode * node = hash [ key ]; int value = node -> val ; isolateNode ( node ); setFirstNode ( node ); return value ; } else { return - 1 ; } } void put ( int key , int value ) { BiNode * node ; if ( hash . find ( key ) == hash . end ()) { node = new BiNode ( key , value ); cap -- ; } else { node = hash [ key ]; node -> val = value ; isolateNode ( node ); } setFirstNode ( node ); hash [ key ] = node ; if ( cap < 0 ) { hash . erase ( tail -> prec -> key ); deleteNode ( tail -> prec ); cap ++ ; } } void setFirstNode ( BiNode * node ) { head -> next -> prec = node ; node -> next = head -> next ; node -> prec = head ; head -> next = node ; } void isolateNode ( BiNode * node ) { node -> prec -> next = node -> next ; node -> next -> prec = node -> prec ; } void deleteNode ( BiNode * node ) { isolateNode ( node ); delete node ; } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ \u65f6\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u73af\u5f62\u94fe\u8868 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\u7684\u5934\u8282\u70b9 head \uff0c\u8fd4\u56de\u94fe\u8868\u5f00\u59cb\u5165\u73af\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002 \u5982\u679c\u94fe\u8868\u65e0\u73af\uff0c\u5219\u8fd4\u56de null\u3002 \u300c\u5206\u6790\u300d \u300c\u5feb\u6162\u6307\u9488\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) { return head ; } ListNode * p1 = head , * p2 = head ; while ( true ) { if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; p1 = p1 -> next ; if ( p1 == p2 ) { break ; } } p1 = head ; while ( p1 != p2 ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u590d\u6742\u94fe\u8868\u7684\u590d\u5236 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u590d\u6742\u94fe\u8868\uff08\u6bcf\u4e2a\u8282\u70b9\u4e2d\u6709\u8282\u70b9\u503c\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u7279\u6b8a\u6307\u9488random\u6307\u5411\u4e00\u4e2a\u968f\u673a\u8282\u70b9\uff09\uff0c\u8bf7\u5bf9\u6b64\u94fe\u8868\u8fdb\u884c\u6df1\u62f7\u8d1d\uff0c\u5e76\u8fd4\u56de\u62f7\u8d1d\u540e\u7684\u5934\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\uff0c\u8f93\u51fa\u7ed3\u679c\u4e2d\u8bf7\u4e0d\u8981\u8fd4\u56de\u53c2\u6570\u4e2d\u7684\u8282\u70b9\u5f15\u7528\uff0c\u5426\u5219\u5224\u9898\u7a0b\u5e8f\u4f1a\u76f4\u63a5\u8fd4\u56de\u7a7a\uff09 Solution\uff1aWe copy each node to append itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) \uff1a label(x), next(NULL), random(NULL) { } }; */ class Solution { public \uff1a RandomListNode * Clone ( RandomListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } RandomListNode * p1 = pHead ; while ( p1 != NULL ) { RandomListNode * temp = new RandomListNode ( p1 -> label ); temp -> next = p1 -> next ; p1 -> next = temp ; p1 = p1 -> next -> next ; } p1 = pHead ; while ( p1 != NULL ) { if ( p1 -> random != NULL ) { p1 -> next -> random = p1 -> random -> next ; } p1 = p1 -> next -> next ; } RandomListNode * head = pHead -> next , * p2 = pHead -> next ; p1 = pHead ; while ( p1 != NULL ) { p1 -> next = p2 -> next ; if ( p2 -> next != NULL ) { p2 -> next = p2 -> next -> next ; } p1 = p1 -> next ; p2 = p2 -> next ; } return head ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002 \u5220\u9664\u94fe\u8868\u4e2d\u7684\u91cd\u590d\u5143\u7d20 \u00b6 \u300c\u4fdd\u7559\u91cd\u590d\u7684\u5143\u7d20\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: 1 -> 1 -> 2 Output: 1 -> 2 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next ; while ( true ) { while ( p2 != nullptr && p1 -> val == p2 -> val ) { p2 = p2 -> next ; } p1 -> next = p2 ; p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } return head ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u300c\u4e0d\u4fdd\u7559\u91cd\u590d\u7684\u5143\u7d20\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5 Output: 1 -> 2 -> 5 */ ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = pre , * p2 = head ; while ( p2 != nullptr ) { bool isDup = false ; while ( p2 -> next != nullptr && p2 -> next -> val == p2 -> val ) { p2 = p2 -> next ; isDup = true ; } p2 = p2 -> next ; if ( isDup ) { p1 -> next = p2 ; } else { p1 = p1 -> next ; } } head = pre -> next ; delete pre ; return head ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u94fe\u8868"},{"location":"data-structure/list/#_1","text":"\u94fe\u8868\u662f\u4e00\u79cd\u5bfb\u4f4d\u8bbf\u95ee\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4ee5\u6307\u9488\u7684\u65b9\u5f0f\uff0c\u5c06\u4e24\u5757\u6570\u636e\u8fde\u63a5\u8d77\u6765\u3002\u5b58\u50a8\u7a7a\u95f4\u4e0a\u901a\u5e38\u662f\u4e0d\u8fde\u7eed\u7684\uff0c\u589e\u5220\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \u3002\u901a\u5e38\u800c\u8a00\uff0c\u94fe\u8868\u6709\u5982\u4e0b\u51e0\u79cd \u5355\u94fe\u8868 \u53cc\u94fe\u8868 \u5faa\u73af\u94fe\u8868","title":"\u7b80\u4ecb"},{"location":"data-structure/list/#_2","text":"\u7ed3\u70b9\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a \u6570\u636e\u57df \u6307\u9488\u57df \u5bf9\u5355\u94fe\u8868\u800c\u8a00\uff0c\u5176\u7ed3\u70b9\u7684\u5b9a\u4e49\u65b9\u5f0f\u5982\u4e0b 1 2 3 4 5 6 7 struct ListNode { int val ; ListNode * next ; ListNode () : val ( 0 ), next ( nullptr ) {} ListNode ( int x ) : val ( x ), next ( nullptr ) {} ListNode ( int x , ListNode * next ) : val ( x ), next ( next ) {} };","title":"\u94fe\u8868\u7ed3\u70b9\u8bbe\u8ba1"},{"location":"data-structure/list/#_3","text":"","title":"\u9898\u76ee"},{"location":"data-structure/list/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* from 1 -> 2 -> 3 -> 4 -> 5 to 5 -> 4 -> 3 -> 2 -> 1 */ // \u8fed\u4ee3 ListNode * reverseList ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next , * p3 = head -> next -> next ; while ( p3 != nullptr ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; p3 = p3 -> next ; } p2 -> next = p1 ; head -> next = nullptr ; return p2 ; } // \u9012\u5f52 ListNode * reverseList ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * ans = reverse ( head , head -> next ); head -> next = nullptr ; return ans ; } ListNode * reverse ( ListNode * p1 , ListNode * p2 ) { if ( p2 -> next != nullptr ) { ListNode * p3 = p2 -> next ; p2 -> next = p1 ; return reverse ( p2 , p3 ); } p2 -> next = p1 ; return p2 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u9012\u5f52\u7248\u672c\u7684\u7a7a\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) \uff0c\u8fed\u4ee3\u7248\u672c\u7684\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u300c\u90e8\u5206\u533a\u95f4\u53cd\u8f6c\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] 1 -> 2 -> 3 -> 4 -> 5 | v 1 -> 4 -> 3 -> 2 -> 5 */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int left , int right ) { if ( left >= right || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = head , * p0 = pre ; int i = 1 ; while ( i < left ) { p1 = p1 -> next ; p0 = p0 -> next ; i ++ ; if ( p1 == nullptr ) { delete pre ; return head ; } } ListNode * tail = p1 , * p2 = p1 -> next ; if ( p2 == nullptr ) { delete pre ; return head ; } ListNode * p3 = p2 -> next ; while ( i < right ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } p3 = p3 -> next ; i ++ ; } p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u53cd\u8f6c\u94fe\u8868"},{"location":"data-structure/list/#_5","text":"\u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868A\u3001B\uff0c\u627e\u51fa\u4e24\u8005\u76f8\u4ea4\u7684\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u4ea4\uff0c\u8fd4\u56de\u4e3a\u7a7a\u6307\u9488\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u65b9\u6cd5\u662f\u5c06\u8fd9\u4e24\u4e2a\u94fe\u8868\u7528\u6808\u4fdd\u5b58\u8d77\u6765\uff0c\u6bd4\u5bf9\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u540c\uff0c\u5219\u5fc5\u5b9a\u4e0d\u76f8\u4ea4\uff0c\u5982\u679c\u76f8\u540c\uff0c\u53cd\u5411\u904d\u5386\u6808\u5373\u53ef\u627e\u5230\u7b2c\u4e00\u4e2a\u76f8\u4ea4\u7684\u7ed3\u70b9\u3002\u4f46\u662f\u5e38\u6570\u7a7a\u95f4\u7684\u7b97\u6cd5\u662f\u5b58\u5728\u7684\u3002\u95ee\u9898\u7684\u96be\u70b9\u5728\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u4e0d\u4e00\u81f4\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u548c\u662f\u4e00\u5b9a\u7684\uff0c\u5373\u6211\u4eec\u5148\u904d\u5386\u94fe\u8868 pHead1 \u518d\u904d\u5386\u94fe\u8868 pHead2 \u4e0e\u5148\u904d\u5386 pHead2 \u518d\u904d\u5386 pHead1 \u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684\u3002\u90a3\u4e48\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u662f\u5728\u67d0\u4e2a\u7ed3\u70b9\u76f8\u4ea4\u7684\uff0c\u6309\u7167\u4e0a\u8ff0\u7684\u904d\u5386\u65b9\u6cd5\uff0c\u4e24\u4e2a\u6307\u9488\u4e00\u5b9a\u5728\u76f8\u4ea4\u7684\u7ed3\u70b9\u76f8\u4f1a\u3002 \u9996\u5148\uff0c\u521d\u59cb\u72b6\u6001\u4e0b\uff0c\u4e24\u4e2a\u6307\u9488\u5206\u522b\u5904\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u5934\u7ed3\u70b9 \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} p_{1} p_{1} \u548c p_{2} p_{2} \u540c\u65f6\u5411\u540e\u79fb\u52a8\u76f4\u5230\u67d0\u4e00\u4e2a\u7387\u5148\u5230\u8fbe\u672b\u7ed3\u70b9\u3002\u672c\u4f8b\u4e2d\uff0c p_{2} p_{2} \u5148\u5230\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece pHead1 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u540c\u6837\u5730\uff0c p_{1} p_{1} \u4e5f\u4f1a\u5230\u8fbe\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece phead2 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u5c31\u4f1a\u53d1\u73b0\uff0c p_{1} p_{1} \u548c p_{2} p_{2} \u5904\u5728\u76f8\u540c\u4f4d\u7f6e\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u53ef\u4ee5\u540c\u65f6\u8fbe\u5230\u5404\u81ea\u7684\u5c3e\u7ed3\u70b9\u3002 \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \u6700\u7ec8\u53ef\u4ee5\u627e\u5230\u76f8\u4ea4\u4f4d\u7f6e\u5904\u7684\u7ed3\u70b9 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( headA == nullptr || headB == nullptr ) { return nullptr ; } ListNode * p1 = headA , * p2 = headB ; for ( int i = 0 ; i < 3 ; i ++ ) { while ( p1 != nullptr && p2 != nullptr ) { if ( p1 == p2 ) { return p1 ; } p1 = p1 -> next ; p2 = p2 -> next ; } if ( p1 == nullptr ) { p1 = headB ; } if ( p2 == nullptr ) { p2 = headA ; } } return nullptr ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u627e\u51fa\u4e24\u4e2a\u94fe\u8868\u7684\u76f8\u4ea4\u7ed3\u70b9"},{"location":"data-structure/list/#_6","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u7684\u4e2d\u5fc3\u8282\u70b9\uff0c\u5982\u679c\u94fe\u8868\u7684\u7ed3\u70b9\u4e2a\u6570\u662f\u5076\u6570\uff0c\u5219\u8fd4\u56de\u9760\u540e\u4f4d\u7f6e\u7684\u7ed3\u70b9\u3002 \u300c\u5206\u6790\u300d \u4f7f\u7528\u3010\u5feb\u6162\u6307\u9488\u3011\u65b9\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 ListNode * middleNode ( ListNode * head ) { ListNode * p1 = head , * p2 = head ; while ( p2 != nullptr ) { p2 = p2 -> next ; if ( p2 == nullptr ) { return p1 ; } p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u94fe\u8868\u7684\u4e2d\u5fc3\u8282\u70b9"},{"location":"data-structure/list/#_7","text":"\u7ed9\u4f60\u4e00\u4e2a\u94fe\u8868\uff0c\u4e24\u4e24\u4ea4\u6362\u5176\u4e2d\u76f8\u90bb\u7684\u8282\u70b9\uff0c\u5e76\u8fd4\u56de\u4ea4\u6362\u540e\u94fe\u8868\u7684\u5934\u8282\u70b9\u3002\u4f60\u5fc5\u987b\u5728\u4e0d\u4fee\u6539\u8282\u70b9\u5185\u90e8\u7684\u503c\u7684\u60c5\u51b5\u4e0b\u5b8c\u6210\u672c\u9898\uff08\u5373\uff0c\u53ea\u80fd\u8fdb\u884c\u8282\u70b9\u4ea4\u6362\uff09\u3002\u4f8b\u5982\uff0c1->2->3->4 \u53d8\u6210 2->1->4->3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ListNode * swapPairs ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); ListNode * par = head , * son = head -> next , * gra = pre ; pre -> next = head ; while ( son != nullptr ) { par -> next = son -> next ; son -> next = par ; gra -> next = son ; gra = par ; par = par -> next ; if ( par == nullptr ) { break ; } son = par -> next ; } head = pre -> next ; delete pre ; return head ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u4e24\u4e24\u4ea4\u6362\u94fe\u8868\u4e2d\u7684\u8282\u70b9"},{"location":"data-structure/list/#k","text":"\u7ed9\u4f60\u94fe\u8868\u7684\u5934\u8282\u70b9 head \uff0c\u6bcf k \u4e2a\u8282\u70b9\u4e00\u7ec4\u8fdb\u884c\u7ffb\u8f6c\uff0c\u8bf7\u4f60\u8fd4\u56de\u4fee\u6539\u540e\u7684\u94fe\u8868\u3002k \u662f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u5b83\u7684\u503c\u5c0f\u4e8e\u6216\u7b49\u4e8e\u94fe\u8868\u7684\u957f\u5ea6\u3002\u5982\u679c\u8282\u70b9\u603b\u6570\u4e0d\u662f k \u7684\u6574\u6570\u500d\uff0c\u90a3\u4e48\u8bf7\u5c06\u6700\u540e\u5269\u4f59\u7684\u8282\u70b9\u4fdd\u6301\u539f\u6709\u987a\u5e8f\u3002\u4f60\u4e0d\u80fd\u53ea\u662f\u5355\u7eaf\u7684\u6539\u53d8\u8282\u70b9\u5185\u90e8\u7684\u503c\uff0c\u800c\u662f\u9700\u8981\u5b9e\u9645\u8fdb\u884c\u8282\u70b9\u4ea4\u6362\u3002\u4f8b\u5982\uff0c1->2->3->4->5\uff0ck = 2 \u65f6\uff0c\u8fd4\u56de 2->1->4->3->5\uff1bk = 3 \u65f6\uff0c\u8fd4\u56de 3->2->1->4->5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k < 2 ) { return head ; } ListNode * front = head ; for ( int i = 0 ; i < k ; i ++ ) { if ( front == nullptr ) { return head ; } front = front -> next ; } bool isEnd = false ; ListNode * pre = new ListNode ( 0 ); ListNode * gra = pre , * par = head , * son = head -> next ; while ( true ) { ListNode * temp = front , * p1 = gra , * p2 = par , * p3 = son ; while ( p2 != temp ) { if ( front == nullptr ) { isEnd = true ; } else { front = front -> next ; } p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { break ; } p3 = p3 -> next ; } par -> next = p2 ; gra -> next = p1 ; gra = par ; par = p2 ; son = p3 ; if ( isEnd || p3 == nullptr ) { break ; } } head = pre -> next ; delete pre ; return head ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"K \u4e2a\u4e00\u7ec4\u7ffb\u8f6c\u94fe\u8868"},{"location":"data-structure/list/#lru","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 /* \u8fd0\u7528\u4f60\u6240\u638c\u63e1\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8bbe\u8ba1\u548c\u5b9e\u73b0\u4e00\u4e2aLRU(\u6700\u8fd1\u6700\u5c11\u4f7f\u7528)\u7f13\u5b58\u673a\u5236 \u3002 \u5b9e\u73b0 LRUCache \u7c7b\uff1a LRUCache(int capacity) \u4ee5\u6b63\u6574\u6570\u4f5c\u4e3a\u5bb9\u91cf capacity \u521d\u59cb\u5316 LRU \u7f13\u5b58 int get(int key) \u5982\u679c\u5173\u952e\u5b57 key \u5b58\u5728\u4e8e\u7f13\u5b58\u4e2d\uff0c\u5219\u8fd4\u56de\u5173\u952e\u5b57\u7684\u503c\uff0c\u5426\u5219\u8fd4\u56de -1 \u3002 void put(int key, int value) \u5982\u679c\u5173\u952e\u5b57\u5df2\u7ecf\u5b58\u5728\uff0c\u5219\u53d8\u66f4\u5176\u6570\u636e\u503c\uff1b\u5982\u679c\u5173\u952e \u5b57\u4e0d\u5b58\u5728\uff0c\u5219\u63d2\u5165\u8be5\u7ec4\u300c\u5173\u952e\u5b57-\u503c\u300d\u3002\u5f53\u7f13\u5b58\u5bb9\u91cf\u8fbe\u5230\u4e0a\u9650\u65f6\uff0c\u5b83\u5e94\u8be5\u5728\u5199\u5165\u65b0\u6570\u636e\u4e4b\u524d \u5220\u9664\u6700\u4e45\u672a\u4f7f\u7528\u7684\u6570\u636e\u503c\uff0c\u4ece\u800c\u4e3a\u65b0\u7684\u6570\u636e\u503c\u7559\u51fa\u7a7a\u95f4\u3002 \u8f93\u5165 [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] \u8f93\u51fa [null, null, null, 1, null, -1, null, -1, 3, 4] \u89e3\u91ca LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // \u7f13\u5b58\u662f {1=1} lRUCache.put(2, 2); // \u7f13\u5b58\u662f {1=1, 2=2} lRUCache.get(1); // \u8fd4\u56de 1 lRUCache.put(3, 3); // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5173\u952e\u5b57 2 \u4f5c\u5e9f\uff0c\u7f13\u5b58\u662f {1=1, 3=3} lRUCache.get(2); // \u8fd4\u56de -1 (\u672a\u627e\u5230) lRUCache.put(4, 4); // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5173\u952e\u5b57 1 \u4f5c\u5e9f\uff0c\u7f13\u5b58\u662f {4=4, 3=3} lRUCache.get(1); // \u8fd4\u56de -1 (\u672a\u627e\u5230) lRUCache.get(3); // \u8fd4\u56de 3 lRUCache.get(4); // \u8fd4\u56de 4 */ struct BiNode { int key , val ; BiNode * prec , * next ; BiNode ( int k , int v ) : key ( k ), val ( v ), prec ( nullptr ), next ( nullptr ) {} }; class LRUCache { BiNode * head ; BiNode * tail ; int cap ; unordered_map < int , BiNode *> hash ; public : LRUCache ( int capacity ) { cap = capacity ; head = new BiNode ( 0 , 0 ); tail = new BiNode ( 0 , 0 ); head -> next = tail ; tail -> prec = head ; } ~ LRUCache () { BiNode * curNode = head -> next ; while ( curNode != nullptr ) { delete curNode -> prec ; curNode = curNode -> next ; } delete tail ; } int get ( int key ) { if ( hash . find ( key ) != hash . end ()) { BiNode * node = hash [ key ]; int value = node -> val ; isolateNode ( node ); setFirstNode ( node ); return value ; } else { return - 1 ; } } void put ( int key , int value ) { BiNode * node ; if ( hash . find ( key ) == hash . end ()) { node = new BiNode ( key , value ); cap -- ; } else { node = hash [ key ]; node -> val = value ; isolateNode ( node ); } setFirstNode ( node ); hash [ key ] = node ; if ( cap < 0 ) { hash . erase ( tail -> prec -> key ); deleteNode ( tail -> prec ); cap ++ ; } } void setFirstNode ( BiNode * node ) { head -> next -> prec = node ; node -> next = head -> next ; node -> prec = head ; head -> next = node ; } void isolateNode ( BiNode * node ) { node -> prec -> next = node -> next ; node -> next -> prec = node -> prec ; } void deleteNode ( BiNode * node ) { isolateNode ( node ); delete node ; } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ \u65f6\u95f4\u590d\u6742\u5ea6 O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"LRU \u7f13\u5b58\u673a\u5236"},{"location":"data-structure/list/#_8","text":"\u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\u7684\u5934\u8282\u70b9 head \uff0c\u8fd4\u56de\u94fe\u8868\u5f00\u59cb\u5165\u73af\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002 \u5982\u679c\u94fe\u8868\u65e0\u73af\uff0c\u5219\u8fd4\u56de null\u3002 \u300c\u5206\u6790\u300d \u300c\u5feb\u6162\u6307\u9488\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) { return head ; } ListNode * p1 = head , * p2 = head ; while ( true ) { if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; p1 = p1 -> next ; if ( p1 == p2 ) { break ; } } p1 = head ; while ( p1 != p2 ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u73af\u5f62\u94fe\u8868"},{"location":"data-structure/list/#_9","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u590d\u6742\u94fe\u8868\uff08\u6bcf\u4e2a\u8282\u70b9\u4e2d\u6709\u8282\u70b9\u503c\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u7279\u6b8a\u6307\u9488random\u6307\u5411\u4e00\u4e2a\u968f\u673a\u8282\u70b9\uff09\uff0c\u8bf7\u5bf9\u6b64\u94fe\u8868\u8fdb\u884c\u6df1\u62f7\u8d1d\uff0c\u5e76\u8fd4\u56de\u62f7\u8d1d\u540e\u7684\u5934\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\uff0c\u8f93\u51fa\u7ed3\u679c\u4e2d\u8bf7\u4e0d\u8981\u8fd4\u56de\u53c2\u6570\u4e2d\u7684\u8282\u70b9\u5f15\u7528\uff0c\u5426\u5219\u5224\u9898\u7a0b\u5e8f\u4f1a\u76f4\u63a5\u8fd4\u56de\u7a7a\uff09 Solution\uff1aWe copy each node to append itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) \uff1a label(x), next(NULL), random(NULL) { } }; */ class Solution { public \uff1a RandomListNode * Clone ( RandomListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } RandomListNode * p1 = pHead ; while ( p1 != NULL ) { RandomListNode * temp = new RandomListNode ( p1 -> label ); temp -> next = p1 -> next ; p1 -> next = temp ; p1 = p1 -> next -> next ; } p1 = pHead ; while ( p1 != NULL ) { if ( p1 -> random != NULL ) { p1 -> next -> random = p1 -> random -> next ; } p1 = p1 -> next -> next ; } RandomListNode * head = pHead -> next , * p2 = pHead -> next ; p1 = pHead ; while ( p1 != NULL ) { p1 -> next = p2 -> next ; if ( p2 -> next != NULL ) { p2 -> next = p2 -> next -> next ; } p1 = p1 -> next ; p2 = p2 -> next ; } return head ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"\u590d\u6742\u94fe\u8868\u7684\u590d\u5236"},{"location":"data-structure/list/#_10","text":"\u300c\u4fdd\u7559\u91cd\u590d\u7684\u5143\u7d20\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: 1 -> 1 -> 2 Output: 1 -> 2 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next ; while ( true ) { while ( p2 != nullptr && p1 -> val == p2 -> val ) { p2 = p2 -> next ; } p1 -> next = p2 ; p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } return head ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002 \u300c\u4e0d\u4fdd\u7559\u91cd\u590d\u7684\u5143\u7d20\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5 Output: 1 -> 2 -> 5 */ ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = pre , * p2 = head ; while ( p2 != nullptr ) { bool isDup = false ; while ( p2 -> next != nullptr && p2 -> next -> val == p2 -> val ) { p2 = p2 -> next ; isDup = true ; } p2 = p2 -> next ; if ( isDup ) { p1 -> next = p2 ; } else { p1 = p1 -> next ; } } head = pre -> next ; delete pre ; return head ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5220\u9664\u94fe\u8868\u4e2d\u7684\u91cd\u590d\u5143\u7d20"},{"location":"data-structure/monotone-queue/","text":"\u7b80\u4ecb \u00b6 \u5355\u8c03\u961f\u5217\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u961f\u5217\uff0c\u7279\u70b9\u662f\u961f\u5217\u5185\u7684\u5143\u7d20\u76f8\u5bf9\u6709\u5e8f\u3002 \u548c\u81f3\u5c11\u4e3a K \u7684\u6700\u77ed\u5b50\u6570\u7ec4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [2, -1, 2] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0c\u6c42\u5b50\u6570\u7ec4\u7684\u548c\u5927\u4e8e\u7b49\u4e8e k \u7684\u6700\u5c0f\u957f\u5ea6\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u524d\u7f00\u548c + \u5355\u8c03\u961f\u5217\u3011\u5047\u8bbe\u5b50\u6570\u7ec4\u7684\u5934\u7d22\u5f15\u4e3a i\uff0c\u5c3e\u7d22\u5f15\u662f j\uff0c\u90a3\u4e48\u5bf9\u4e8e\u56fa\u5b9a\u7684 j\uff0c\u6211\u4eec\u5e0c\u671b\u5728\u6ee1\u8db3 presum[ j ] - presum[ i ] >= k \u65f6\u7684\u6700\u5927 i\uff0c\u4e8e\u662f\uff0c\u6211\u4eec\u53d1\u73b0\uff0ci \u548c j \u662f\u6709\u5e8f\u7684\uff0c\u5e76\u4e14 presum[ i ] \u548c presum[ j ] \u4e5f\u662f\u6709\u5e8f\u7684\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5e0c\u671b\u501f\u52a9\u4e00\u79cd\u6570\u636e\u7ed3\u6784\u5b58\u50a8 i\u3002\u9700\u8981\u6ee1\u8db3\uff1a1\uff09\u7ed9\u5b9a\u4e00\u4e2a j\uff0c\u5f53\u786e\u5b9a i \u6ee1\u8db3\u8fde\u7eed\u548c\u7684\u8981\u6c42\u65f6\uff0c\u5c06 i \u79fb\u9664\uff0c\u6b64\u65f6\u5bf9\u4e8e\u5927\u4e8e j \u7684\u7d22\u5f15 k\uff0c\u6ee1\u8db3 presum[ k ] - presum[ i ] >= k \u65f6\uff0ck - i < j - i \u4e00\u5b9a\u6210\u7acb\uff1b2\uff09\u5c06 j \u52a0\u5165\u5230\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u4e2d\uff0c\u9700\u8981\u4fdd\u8bc1\u6709\u5e8f\u3002\u8fd9\u6837\u7684\u7ed3\u6784\u662f\u5355\u8c03\u961f\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int shortestSubarray ( vector < int >& nums , int k ) { int n = ( int ) nums . size (), ans = n + 1 ; vector < long > presum ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { presum [ i + 1 ] = presum [ i ] + nums [ i ]; } deque < int > dq ; for ( int i = 0 ; i < presum . size (); i ++ ) { while ( ! dq . empty () && presum [ i ] - presum [ dq . front ()] >= k ) { ans = min ( ans , i - dq . front ()); dq . pop_front (); } while ( ! dq . empty () && presum [ i ] < presum [ dq . back ()]) { dq . pop_back (); } dq . push_back ( i ); } return ans == n + 1 ? - 1 : ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u5355\u8c03\u961f\u5217"},{"location":"data-structure/monotone-queue/#_1","text":"\u5355\u8c03\u961f\u5217\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u961f\u5217\uff0c\u7279\u70b9\u662f\u961f\u5217\u5185\u7684\u5143\u7d20\u76f8\u5bf9\u6709\u5e8f\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/monotone-queue/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [2, -1, 2] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0c\u6c42\u5b50\u6570\u7ec4\u7684\u548c\u5927\u4e8e\u7b49\u4e8e k \u7684\u6700\u5c0f\u957f\u5ea6\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u3010\u524d\u7f00\u548c + \u5355\u8c03\u961f\u5217\u3011\u5047\u8bbe\u5b50\u6570\u7ec4\u7684\u5934\u7d22\u5f15\u4e3a i\uff0c\u5c3e\u7d22\u5f15\u662f j\uff0c\u90a3\u4e48\u5bf9\u4e8e\u56fa\u5b9a\u7684 j\uff0c\u6211\u4eec\u5e0c\u671b\u5728\u6ee1\u8db3 presum[ j ] - presum[ i ] >= k \u65f6\u7684\u6700\u5927 i\uff0c\u4e8e\u662f\uff0c\u6211\u4eec\u53d1\u73b0\uff0ci \u548c j \u662f\u6709\u5e8f\u7684\uff0c\u5e76\u4e14 presum[ i ] \u548c presum[ j ] \u4e5f\u662f\u6709\u5e8f\u7684\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5e0c\u671b\u501f\u52a9\u4e00\u79cd\u6570\u636e\u7ed3\u6784\u5b58\u50a8 i\u3002\u9700\u8981\u6ee1\u8db3\uff1a1\uff09\u7ed9\u5b9a\u4e00\u4e2a j\uff0c\u5f53\u786e\u5b9a i \u6ee1\u8db3\u8fde\u7eed\u548c\u7684\u8981\u6c42\u65f6\uff0c\u5c06 i \u79fb\u9664\uff0c\u6b64\u65f6\u5bf9\u4e8e\u5927\u4e8e j \u7684\u7d22\u5f15 k\uff0c\u6ee1\u8db3 presum[ k ] - presum[ i ] >= k \u65f6\uff0ck - i < j - i \u4e00\u5b9a\u6210\u7acb\uff1b2\uff09\u5c06 j \u52a0\u5165\u5230\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u4e2d\uff0c\u9700\u8981\u4fdd\u8bc1\u6709\u5e8f\u3002\u8fd9\u6837\u7684\u7ed3\u6784\u662f\u5355\u8c03\u961f\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int shortestSubarray ( vector < int >& nums , int k ) { int n = ( int ) nums . size (), ans = n + 1 ; vector < long > presum ( n + 1 , 0 ); for ( int i = 0 ; i < n ; i ++ ) { presum [ i + 1 ] = presum [ i ] + nums [ i ]; } deque < int > dq ; for ( int i = 0 ; i < presum . size (); i ++ ) { while ( ! dq . empty () && presum [ i ] - presum [ dq . front ()] >= k ) { ans = min ( ans , i - dq . front ()); dq . pop_front (); } while ( ! dq . empty () && presum [ i ] < presum [ dq . back ()]) { dq . pop_back (); } dq . push_back ( i ); } return ans == n + 1 ? - 1 : ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u548c\u81f3\u5c11\u4e3a K \u7684\u6700\u77ed\u5b50\u6570\u7ec4"},{"location":"data-structure/monotone-stack/","text":"\u7b80\u4ecb \u00b6 \u5355\u8c03\u6808\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6570\u636e\u7ed3\u6784\uff0c\u6808\u5185\u5143\u7d20\u503c\uff08\u4e25\u683c\uff09\u5355\u8c03\u53d8\u5316\u3002 \u5355\u8c03\u6808\u9002\u7528\u4e8e\u6c42\u89e3\u300cNext Greater Number\u300d\u8fd9\u4e00\u7c7b\u95ee\u9898 \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217 e.g. {1,3,4,2}\uff0c\u6c42\u6bcf\u4e00\u4e2a\u6570\u5b57\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u6bd4\u81ea\u5df1\u5927\u7684\u6570\u5b57\uff0c\u5982\u679c\u6ca1\u6709\u8fd4\u56de-1\uff0c\u6a21\u677f\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 vector < int > nextGreaterNumber ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ), stk ; for ( int i = 0 ; i < nums . size (); i ++ ) { while ( ! stk . empty () && nums [ stk . back ()] < nums [ i ]) { ans [ stk . back ()] = nums [ i ]; stk . pop_back (); } stk . emplace_back ( i ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u8fdb\u4e00\u6b65\uff0c\u5982\u679c\u662f\u5faa\u73af\u6570\u7ec4\uff08\u67d0\u4e00\u4f4d\u7f6e\u7684\u5143\u7d20\u4ece\u53f3\u4fa7\u5f00\u59cb\u67e5\u627e\u4e3a\u6570\u7ec4\u5c3e\u540e\uff0c\u7ee7\u7eed\u4ece\u6570\u7ec4\u5934\u67e5\u627e\uff09\u65f6\uff0c\u53ea\u9700\u8981\u8fd9\u4e2a\u6570\u7ec4\u540e\u9762\u62fc\u63a5\u81ea\u5df1\u5373\u53ef\uff0c\u6a21\u677f\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 vector < int > nextGreaterNumber ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ), stk ; for ( int i = 0 ; i < nums . size () * 2 ; i ++ ) { int j = i % nums . size (); while ( ! stk . empty () && nums [ stk . back ()] < nums [ j ]) { ans [ stk . back ()] = nums [ j ]; stk . pop_back (); } stk . emplace_back ( j ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u9898\u76ee \u00b6 \u6700\u957f\u6b63\u503c\u533a\u95f4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217e.g.[1,3,-2,-4,1]\uff0c\u8bf7\u627e\u51fa\u6700\u5927\u7684\u4e00\u4e2a\u5b50\u533a\u95f4\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u533a\u95f4\u5143\u7d20\u7684\u548c\u4e3a\u6b63\u6570 \u300c\u5206\u6790\u300d \u5bb9\u6613\u60f3\u5230\u300c\u4e8c\u5206+\u6ed1\u52a8\u7a97\u53e3\u300d\u7684\u65b9\u6cd5\uff0c\u8fd9\u91cc\u300c\u4e8c\u5206\u300d\u5bfc\u81f4\u9519\u8bef\u7684\u539f\u56e0\u662f\uff1a\u6b63\u503c\u533a\u95f4\u7684\u957f\u5ea6\u4e0d\u662f\u5355\u8c03\u7684\uff0c\u5373\u65e0\u6cd5\u6839\u636e\u4e00\u4e2a\u4e2d\u95f4\u503c\uff0c\u786e\u5b9a\u4e0b\u4e00\u6b65\u8fdb\u5165\u5230\u5de6\u533a\u95f4\u8fd8\u662f\u53f3\u533a\u95f4\u3002 \u672c\u9898\u7684\u65b9\u6cd5\u662f\u300c\u524d\u7f00\u548c+\u5355\u8c03\u6808\u300d\uff0c\u300c\u524d\u7f00\u548c\u300d\u6c42\u89e3\u533a\u95f4\u548c(i, j)\uff0c\u6211\u4eec\u5e0c\u671b\u8fd9\u4e2a\u533a\u95f4|j - i|\u53ef\u4ee5\u6700\u5927\u3002\u5982\u679c\u56fa\u5b9a\u533a\u95f4\u7684\u5de6\u7aef\u70b9i\uff0c\u8981\u4f7f|j - i|\u5c3d\u53ef\u80fd\u7684\u5927\uff0c\u5c31\u8981\u6c42j\u5bf9\u5e94\u7684\u6570\u5b57\u6bd4i\u5bf9\u5e94\u7684\u6570\u5b57\u5927\uff0c\u4e5f\u5c31\u662f\u8bf4\u627e\u5230\u6700\u540e\u4e00\u4e2aj \\text{presum}[j_{\\text{max}}] - \\text{presum}[i] \\geq 0 \\text{presum}[j_{\\text{max}}] - \\text{presum}[i] \\geq 0 \u53ef\u4ee5\u5229\u7528\u300c\u5355\u8c03\u6808\u300d\u5b9e\u73b0\uff0c\u53ea\u8981\u5bf9\u300cNext Greater Number\u300d\u7565\u52a0\u6539\u52a8\u5373\u53ef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int longest_postive_value_interval ( vector < int >& nums ) { vector < int > presum ( nums . size () + 1 ), stk { 0 }; for ( int i = 0 ; i < nums . size (); i ++ ) { presum [ i + 1 ] = presum [ i ]; if ( nums [ i ] > 8 ) { presum [ i + 1 ] += 1 ; } else { presum [ i + 1 ] += - 1 ; } if ( presum [ stk . back ()] > presum [ i + 1 ]) { stk . emplace_back ( i + 1 ); } } int ans = 0 ; for ( int i = ( int ) presum . size () - 1 ; i > 0 ; i -- ) { while ( ! stk . empty () && presum [ stk . back ()] < presum [ i ]) { ans = max ( ans , i - stk . back ()); stk . pop_back (); } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u4e0b\u4e0b\u4e2a\u66f4\u5927\u7684\u5143\u7d20 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217[2,4,0,9,6]\uff0c\u8bf7\u627e\u51fa\u6bcf\u4e2a\u5143\u7d20\u53f3\u4fa7\u7b2c\u4e8c\u4e2a\u5927\u4e8e\u81ea\u8eab\u7684\u5143\u7d20 \u300c\u5206\u6790\u300d \u4e00\u4e2a\u300c\u5355\u8c03\u6808\u300d\u53ef\u4ee5\u51b3\u89e3\u300cNext Greater Number\u300d\uff0c\u4e24\u4e2a\u5355\u8c03\u6808\u53ef\u4ee5\u89e3\u51b3\u300cNext Next Greater Number\u300d\u3002\u6211\u4eec\u6709\u4e24\u4e2a\u300c\u5355\u8c03\u6808\u300ds1\u3001s2\u7b5b\u9009\u51fa\u6765\u66f4\u5c0f\u7684\u6808\u5b9a\u5143\u7d20\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < int > nextNextGreaterNumber ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ), s1 , s2 ; for ( int i = 0 ; i < nums . size (); i ++ ) { while ( ! s2 . empty () && nums [ s2 . back ()] < nums [ i ]) { ans [ s2 . back ()] = nums [ i ]; s2 . pop_back (); } int j = ( int ) s1 . size () - 1 ; while ( j >= 0 && nums [ s1 [ j ]] < nums [ i ]) { j -- ; } s2 . insert ( s2 . end (), s1 . begin () + ( j + 1 ), s1 . end ()); s1 . resize ( j + 1 ); s1 . emplace_back ( i ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u53bb\u91cd\u590d\u5b57\u6bcd \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u5c06 s \u4e2d\u7684\u6240\u6709\u91cd\u590d\u5b57\u6bcd\u53bb\u6389\uff0c\u8fd4\u56de\u4e00\u4e2a\u4e0d\u6539\u53d8\u539f\u5b57\u7b26\u4e32\u5185\u5b57\u6bcd\u76f8\u5bf9\u4f4d\u7f6e\u4e14\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u65e0\u91cd\u590d\u5b57\u7b26\u4e32\u3002\u5982 s = cbacdcbc -> s' = acdb \u300c\u5206\u6790\u300d \u8003\u8651\u4e00\u4e2a\u7b80\u5355\u7684\u60c5\u51b5\uff1a\u53bb\u9664\u4e00\u4e2a\u5b57\u7b26 ch\uff0c\u4f7f\u5f97 s' \u7684\u5b57\u5178\u5e8f\u5217\u6700\u5c0f\u3002\u65b9\u6cd5\u662f\u627e\u5230\u6700\u5c0f\u7684 i \u6ee1\u8db3 i = \\arg \\min_{i \\in [0, n - 1)} \\text{s[ i ]} \\geq \\text{s[i + 1]} i = \\arg \\min_{i \\in [0, n - 1)} \\text{s[ i ]} \\geq \\text{s[i + 1]} \u53ea\u9700\u8981\u91cd\u590d\u4e0a\u8ff0\u7684\u65b9\u6cd5\u5373\u53ef\uff0c\u4f46\u8fd9\u6837\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n^{2}) O(n^{2}) \u3002\u6211\u4eec\u53d1\u73b0\uff0c\u6709\u4e9b\u5b57\u7b26\u53ef\u4ee5\u4e00\u6b21\u6027\u627e\u5230\uff0c\u8fd9\u5c31\u7528\u5230\u4e86\u3010\u5355\u8c03\u6808\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 string removeDuplicateLetters ( string s ) { string ans = \"\" ; vector < int > cnt ( 26 , 0 ); bool * in = new bool [ 26 ]{}; for ( char ch : s ) { cnt [ ch - 'a' ] ++ ; } int n = ( int ) s . length (); for ( int i = 0 ; i < n ; i ++ ) { if ( ! in [ s [ i ] - 'a' ]) { while ( ! ans . empty () && ans . back () >= s [ i ] && cnt [ ans . back () - 'a' ]) { in [ ans . back () - 'a' ] = false ; ans . pop_back (); } ans . push_back ( s [ i ]); in [ s [ i ] - 'a' ] = true ; } cnt [ s [ i ] - 'a' ] -- ; } delete [] in ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\Sigma) O(\\Sigma) \uff0c\u8fd9\u91cc\u7684 \\Sigma \\Sigma \u6307\u7684\u662f\u5b57\u7b26\u7684\u96c6\u5408\uff0c\u672c\u9898\u662f 26\u3002 \u5224\u65ad\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u5148\u5e8f\u904d\u5386 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u904d\u5386\u5e8f\u5217\uff0c\u5224\u65ad\u662f\u5426\u662f\u5148\u5e8f\u904d\u5386\u5e8f\u5217 \u300c\u5206\u6790\u300d \u3010\u5355\u8c03\u6808\u3011\u5148\u5e8f\u904d\u5386\u6ee1\u8db3 \u6839\u8282\u70b9 - \u5de6\u5b50\u6811 - \u53f3\u5b50\u6811 \u8fd9\u6837\u7684\u7ed3\u6784\uff0c\u5e76\u4e14\u4ee5\u9012\u5f52\u7684\u65b9\u5f0f\u5448\u73b0\uff0c\u5373\u5de6\u53f3\u5b50\u6811\u4e5f\u4f1a\u6709\u7c7b\u4f3c\u7684\u7ed3\u6784\u3002\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u904d\u5386\uff0c\u6211\u4eec\u53d1\u73b0\uff0c\u4ee5\u7b2c\u4e00\u4e2a\u5927\u4e8e\u6839\u8282\u70b9\u7684\u5143\u7d20\u4e3a\u5206\u754c\u7ebf\uff0c\u5de6\u4fa7\u7684\u5747\u5c0f\u4e8e\u6839\u8282\u70b9\uff0c\u53f3\u4fa7\u7684\u5747\u5927\u4e8e\u6839\u8282\u70b9\u3002\u4e8e\u662f\uff0c\u6211\u4eec\u628a\u5c0f\u4e8e\u6839\u8282\u70b9\u7684\u5143\u7d20\u90fd\u52a0\u5165\u5230\u6808\u4e2d\uff0c\u76f4\u5230\u9047\u5230\u5927\u4e8e\u6808\u9876\u7684\u5143\u7d20\uff0c\u4e00\u6b21\u628a\u6808\u5185\u7684\u5143\u7d20\u5f39\u51fa\u3002\u6b64\u5916\uff0c\u6211\u4eec\u9700\u8981\u4fdd\u5b58\u6839\u8282\u70b9\u7684\u5927\u5c0f\uff0c\u7528\u4e8e\u6bd4\u8f83\u53f3\u5b50\u6811\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 bool verifyPreorder ( vector < int >& preorder ) { vector < int > stk ; int MIN = INT_MIN ; for ( auto val : preorder ) { if ( val < MIN ) { return false ; } while ( ! stk . empty () && stk . back () < val ) { MIN = stk . back (); stk . pop_back (); } stk . emplace_back ( val ); } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u79fb\u9664 k \u4e2a\u5b57\u7b26\u540e\u7684\u6700\u5c0f\u503c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b\u6570\u5b57\u7684\u5b57\u7b26\u4e32 num = \u201c10200\u201d \u548c\u4e00\u4e2a\u6574\u6570 k = 1\uff0c\u5220\u9664 k \u4e2a\u5b57\u7b26\uff0c\u4f7f\u5f97\u5269\u4e0b\u7684\u6570\u5b57\u503c\u6700\u5c0f\uff0c\u7ed3\u679c\u4e0d\u5305\u542b\u524d\u7f6e 0. \u300c\u5206\u6790\u300d \u3010\u5355\u8c03\u6808\u3011\u8003\u8651\u5220\u9664\u4e00\u4e2a\u5b57\u7b26\u7684\u60c5\u51b5\uff0c\u4ee5 \u201c14235\u201d \u4e3a\u4f8b\uff0c\u53ea\u6709\u5220\u9664 \u201c4\u201d \u65f6\uff0c\u5f97\u5230\u7684\u503c\u6700\u5c0f\uff0c\u6211\u4eec\u53d1\u73b0\u5220\u9664\u7684\u5b57\u7b26\u8981\u6bd4\u5b83\u7684\u540e\u4e00\u4e2a\u5b57\u7b26\u5927\uff0c\u5e76\u4e14\u88ab\u5220\u9664\u7684\u5b57\u7b26\u4f4d\u7f6e\u5c3d\u53ef\u80fd\u9760\u524d\u3002\u5982\u679c\u6bcf\u6b21\u626b\u63cf\u5220\u9664\u4e00\u4e2a\uff0c\u603b\u5171\u9700\u8981 O(kn) O(kn) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u6211\u4eec\u4f7f\u7528\u3010\u5355\u8c03\u6808\u3011\u6765\u4f18\u5316\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 string removeKdigits ( string num , int k ) { string ans = \"\" ; for ( char ch : num ) { while ( k && ! ans . empty () && ans . back () > ch ) { ans . pop_back (); k -- ; } if ( ans . empty () && ch == '0' ) { continue ; } ans . push_back ( ch ); } while ( k -- && ! ans . empty ()) { ans . pop_back (); } return ans . empty () ? \"0\" : ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u67f1\u72b6\u56fe\u4e2d\u6700\u5927\u7684\u77e9\u5f62 \u00b6 \u7ed9\u5b9a n \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u7528\u6765\u8868\u793a\u67f1\u72b6\u56fe\u4e2d\u5404\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\u3002\u6bcf\u4e2a\u67f1\u5b50\u5f7c\u6b64\u76f8\u90bb\uff0c\u4e14\u5bbd\u5ea6\u4e3a 1 \u3002\u6c42\u5728\u8be5\u67f1\u72b6\u56fe\u4e2d\uff0c\u80fd\u591f\u52fe\u52d2\u51fa\u6765\u7684\u77e9\u5f62\u7684\u6700\u5927\u9762\u79ef\u3002 \u300c\u5206\u6790\u300d \u300c\u5355\u8c03\u6808\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. */ int largestRectangleArea ( vector < int >& heights ) { int ans = 0 , n = int ( heights . size ()); if ( n == 0 ) { return ans ; } heights . emplace_back ( 0 ); stack < int > stk ; for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } int area = H * W ; if ( ans < area ) { ans = area ; } } stk . push ( i ); } heights . pop_back (); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u6700\u5927\u77e9\u5f62 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4ec5\u5305\u542b 0 \u548c 1 \u3001\u5927\u5c0f\u4e3a rows x cols \u7684\u4e8c\u7ef4\u4e8c\u8fdb\u5236\u77e9\u9635\uff0c\u627e\u51fa\u53ea\u5305\u542b 1 \u7684\u6700\u5927\u77e9\u5f62\uff0c\u5e76\u8fd4\u56de\u5176\u9762\u79ef\u3002 \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 1 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 1 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \u6700\u5927\u9762\u79ef\u662f 6 \u300c\u5206\u6790\u300d \u300c\u5355\u8c03\u6808\u300d\u5c06\u77e9\u9635\u538b\u7f29\u6210\u4e00\u884c\uff0c\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u503c\u8868\u793a\u5f53\u524d\u5217\u8fde\u7eed\u7684 1 \u7684\u4e2a\u6570\u3002\u540e\u7eed\u5bf9\u8fd9\u4e00\u5217\u6c42\u6700\u5927\u9762\u79ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { int ans = 0 ; int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( matrix [ 0 ]. size ()); vector < int > heights ( nCol , 0 ); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { heights [ j ] = ( heights [ j ] + 1 ) * ( matrix [ i ][ j ] - '0' ); } ans = max ( ans , getRecArea ( heights )); } return ans ; } int getRecArea ( vector < int > heights ) { int ans = 0 , n = int ( heights . size ()); stack < int > stk ; heights . emplace_back ( 0 ); for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } ans = max ( ans , W * H ); } stk . push ( i ); } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u5355\u8c03\u6808"},{"location":"data-structure/monotone-stack/#_1","text":"\u5355\u8c03\u6808\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6570\u636e\u7ed3\u6784\uff0c\u6808\u5185\u5143\u7d20\u503c\uff08\u4e25\u683c\uff09\u5355\u8c03\u53d8\u5316\u3002 \u5355\u8c03\u6808\u9002\u7528\u4e8e\u6c42\u89e3\u300cNext Greater Number\u300d\u8fd9\u4e00\u7c7b\u95ee\u9898 \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217 e.g. {1,3,4,2}\uff0c\u6c42\u6bcf\u4e00\u4e2a\u6570\u5b57\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u6bd4\u81ea\u5df1\u5927\u7684\u6570\u5b57\uff0c\u5982\u679c\u6ca1\u6709\u8fd4\u56de-1\uff0c\u6a21\u677f\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 vector < int > nextGreaterNumber ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ), stk ; for ( int i = 0 ; i < nums . size (); i ++ ) { while ( ! stk . empty () && nums [ stk . back ()] < nums [ i ]) { ans [ stk . back ()] = nums [ i ]; stk . pop_back (); } stk . emplace_back ( i ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u8fdb\u4e00\u6b65\uff0c\u5982\u679c\u662f\u5faa\u73af\u6570\u7ec4\uff08\u67d0\u4e00\u4f4d\u7f6e\u7684\u5143\u7d20\u4ece\u53f3\u4fa7\u5f00\u59cb\u67e5\u627e\u4e3a\u6570\u7ec4\u5c3e\u540e\uff0c\u7ee7\u7eed\u4ece\u6570\u7ec4\u5934\u67e5\u627e\uff09\u65f6\uff0c\u53ea\u9700\u8981\u8fd9\u4e2a\u6570\u7ec4\u540e\u9762\u62fc\u63a5\u81ea\u5df1\u5373\u53ef\uff0c\u6a21\u677f\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 vector < int > nextGreaterNumber ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ), stk ; for ( int i = 0 ; i < nums . size () * 2 ; i ++ ) { int j = i % nums . size (); while ( ! stk . empty () && nums [ stk . back ()] < nums [ j ]) { ans [ stk . back ()] = nums [ j ]; stk . pop_back (); } stk . emplace_back ( j ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u7b80\u4ecb"},{"location":"data-structure/monotone-stack/#_2","text":"","title":"\u9898\u76ee"},{"location":"data-structure/monotone-stack/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217e.g.[1,3,-2,-4,1]\uff0c\u8bf7\u627e\u51fa\u6700\u5927\u7684\u4e00\u4e2a\u5b50\u533a\u95f4\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u533a\u95f4\u5143\u7d20\u7684\u548c\u4e3a\u6b63\u6570 \u300c\u5206\u6790\u300d \u5bb9\u6613\u60f3\u5230\u300c\u4e8c\u5206+\u6ed1\u52a8\u7a97\u53e3\u300d\u7684\u65b9\u6cd5\uff0c\u8fd9\u91cc\u300c\u4e8c\u5206\u300d\u5bfc\u81f4\u9519\u8bef\u7684\u539f\u56e0\u662f\uff1a\u6b63\u503c\u533a\u95f4\u7684\u957f\u5ea6\u4e0d\u662f\u5355\u8c03\u7684\uff0c\u5373\u65e0\u6cd5\u6839\u636e\u4e00\u4e2a\u4e2d\u95f4\u503c\uff0c\u786e\u5b9a\u4e0b\u4e00\u6b65\u8fdb\u5165\u5230\u5de6\u533a\u95f4\u8fd8\u662f\u53f3\u533a\u95f4\u3002 \u672c\u9898\u7684\u65b9\u6cd5\u662f\u300c\u524d\u7f00\u548c+\u5355\u8c03\u6808\u300d\uff0c\u300c\u524d\u7f00\u548c\u300d\u6c42\u89e3\u533a\u95f4\u548c(i, j)\uff0c\u6211\u4eec\u5e0c\u671b\u8fd9\u4e2a\u533a\u95f4|j - i|\u53ef\u4ee5\u6700\u5927\u3002\u5982\u679c\u56fa\u5b9a\u533a\u95f4\u7684\u5de6\u7aef\u70b9i\uff0c\u8981\u4f7f|j - i|\u5c3d\u53ef\u80fd\u7684\u5927\uff0c\u5c31\u8981\u6c42j\u5bf9\u5e94\u7684\u6570\u5b57\u6bd4i\u5bf9\u5e94\u7684\u6570\u5b57\u5927\uff0c\u4e5f\u5c31\u662f\u8bf4\u627e\u5230\u6700\u540e\u4e00\u4e2aj \\text{presum}[j_{\\text{max}}] - \\text{presum}[i] \\geq 0 \\text{presum}[j_{\\text{max}}] - \\text{presum}[i] \\geq 0 \u53ef\u4ee5\u5229\u7528\u300c\u5355\u8c03\u6808\u300d\u5b9e\u73b0\uff0c\u53ea\u8981\u5bf9\u300cNext Greater Number\u300d\u7565\u52a0\u6539\u52a8\u5373\u53ef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int longest_postive_value_interval ( vector < int >& nums ) { vector < int > presum ( nums . size () + 1 ), stk { 0 }; for ( int i = 0 ; i < nums . size (); i ++ ) { presum [ i + 1 ] = presum [ i ]; if ( nums [ i ] > 8 ) { presum [ i + 1 ] += 1 ; } else { presum [ i + 1 ] += - 1 ; } if ( presum [ stk . back ()] > presum [ i + 1 ]) { stk . emplace_back ( i + 1 ); } } int ans = 0 ; for ( int i = ( int ) presum . size () - 1 ; i > 0 ; i -- ) { while ( ! stk . empty () && presum [ stk . back ()] < presum [ i ]) { ans = max ( ans , i - stk . back ()); stk . pop_back (); } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6700\u957f\u6b63\u503c\u533a\u95f4"},{"location":"data-structure/monotone-stack/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217[2,4,0,9,6]\uff0c\u8bf7\u627e\u51fa\u6bcf\u4e2a\u5143\u7d20\u53f3\u4fa7\u7b2c\u4e8c\u4e2a\u5927\u4e8e\u81ea\u8eab\u7684\u5143\u7d20 \u300c\u5206\u6790\u300d \u4e00\u4e2a\u300c\u5355\u8c03\u6808\u300d\u53ef\u4ee5\u51b3\u89e3\u300cNext Greater Number\u300d\uff0c\u4e24\u4e2a\u5355\u8c03\u6808\u53ef\u4ee5\u89e3\u51b3\u300cNext Next Greater Number\u300d\u3002\u6211\u4eec\u6709\u4e24\u4e2a\u300c\u5355\u8c03\u6808\u300ds1\u3001s2\u7b5b\u9009\u51fa\u6765\u66f4\u5c0f\u7684\u6808\u5b9a\u5143\u7d20\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < int > nextNextGreaterNumber ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ), s1 , s2 ; for ( int i = 0 ; i < nums . size (); i ++ ) { while ( ! s2 . empty () && nums [ s2 . back ()] < nums [ i ]) { ans [ s2 . back ()] = nums [ i ]; s2 . pop_back (); } int j = ( int ) s1 . size () - 1 ; while ( j >= 0 && nums [ s1 [ j ]] < nums [ i ]) { j -- ; } s2 . insert ( s2 . end (), s1 . begin () + ( j + 1 ), s1 . end ()); s1 . resize ( j + 1 ); s1 . emplace_back ( i ); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u4e0b\u4e0b\u4e2a\u66f4\u5927\u7684\u5143\u7d20"},{"location":"data-structure/monotone-stack/#_5","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u5c06 s \u4e2d\u7684\u6240\u6709\u91cd\u590d\u5b57\u6bcd\u53bb\u6389\uff0c\u8fd4\u56de\u4e00\u4e2a\u4e0d\u6539\u53d8\u539f\u5b57\u7b26\u4e32\u5185\u5b57\u6bcd\u76f8\u5bf9\u4f4d\u7f6e\u4e14\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u65e0\u91cd\u590d\u5b57\u7b26\u4e32\u3002\u5982 s = cbacdcbc -> s' = acdb \u300c\u5206\u6790\u300d \u8003\u8651\u4e00\u4e2a\u7b80\u5355\u7684\u60c5\u51b5\uff1a\u53bb\u9664\u4e00\u4e2a\u5b57\u7b26 ch\uff0c\u4f7f\u5f97 s' \u7684\u5b57\u5178\u5e8f\u5217\u6700\u5c0f\u3002\u65b9\u6cd5\u662f\u627e\u5230\u6700\u5c0f\u7684 i \u6ee1\u8db3 i = \\arg \\min_{i \\in [0, n - 1)} \\text{s[ i ]} \\geq \\text{s[i + 1]} i = \\arg \\min_{i \\in [0, n - 1)} \\text{s[ i ]} \\geq \\text{s[i + 1]} \u53ea\u9700\u8981\u91cd\u590d\u4e0a\u8ff0\u7684\u65b9\u6cd5\u5373\u53ef\uff0c\u4f46\u8fd9\u6837\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n^{2}) O(n^{2}) \u3002\u6211\u4eec\u53d1\u73b0\uff0c\u6709\u4e9b\u5b57\u7b26\u53ef\u4ee5\u4e00\u6b21\u6027\u627e\u5230\uff0c\u8fd9\u5c31\u7528\u5230\u4e86\u3010\u5355\u8c03\u6808\u3011\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 string removeDuplicateLetters ( string s ) { string ans = \"\" ; vector < int > cnt ( 26 , 0 ); bool * in = new bool [ 26 ]{}; for ( char ch : s ) { cnt [ ch - 'a' ] ++ ; } int n = ( int ) s . length (); for ( int i = 0 ; i < n ; i ++ ) { if ( ! in [ s [ i ] - 'a' ]) { while ( ! ans . empty () && ans . back () >= s [ i ] && cnt [ ans . back () - 'a' ]) { in [ ans . back () - 'a' ] = false ; ans . pop_back (); } ans . push_back ( s [ i ]); in [ s [ i ] - 'a' ] = true ; } cnt [ s [ i ] - 'a' ] -- ; } delete [] in ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\Sigma) O(\\Sigma) \uff0c\u8fd9\u91cc\u7684 \\Sigma \\Sigma \u6307\u7684\u662f\u5b57\u7b26\u7684\u96c6\u5408\uff0c\u672c\u9898\u662f 26\u3002","title":"\u53bb\u91cd\u590d\u5b57\u6bcd"},{"location":"data-structure/monotone-stack/#_6","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u904d\u5386\u5e8f\u5217\uff0c\u5224\u65ad\u662f\u5426\u662f\u5148\u5e8f\u904d\u5386\u5e8f\u5217 \u300c\u5206\u6790\u300d \u3010\u5355\u8c03\u6808\u3011\u5148\u5e8f\u904d\u5386\u6ee1\u8db3 \u6839\u8282\u70b9 - \u5de6\u5b50\u6811 - \u53f3\u5b50\u6811 \u8fd9\u6837\u7684\u7ed3\u6784\uff0c\u5e76\u4e14\u4ee5\u9012\u5f52\u7684\u65b9\u5f0f\u5448\u73b0\uff0c\u5373\u5de6\u53f3\u5b50\u6811\u4e5f\u4f1a\u6709\u7c7b\u4f3c\u7684\u7ed3\u6784\u3002\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u904d\u5386\uff0c\u6211\u4eec\u53d1\u73b0\uff0c\u4ee5\u7b2c\u4e00\u4e2a\u5927\u4e8e\u6839\u8282\u70b9\u7684\u5143\u7d20\u4e3a\u5206\u754c\u7ebf\uff0c\u5de6\u4fa7\u7684\u5747\u5c0f\u4e8e\u6839\u8282\u70b9\uff0c\u53f3\u4fa7\u7684\u5747\u5927\u4e8e\u6839\u8282\u70b9\u3002\u4e8e\u662f\uff0c\u6211\u4eec\u628a\u5c0f\u4e8e\u6839\u8282\u70b9\u7684\u5143\u7d20\u90fd\u52a0\u5165\u5230\u6808\u4e2d\uff0c\u76f4\u5230\u9047\u5230\u5927\u4e8e\u6808\u9876\u7684\u5143\u7d20\uff0c\u4e00\u6b21\u628a\u6808\u5185\u7684\u5143\u7d20\u5f39\u51fa\u3002\u6b64\u5916\uff0c\u6211\u4eec\u9700\u8981\u4fdd\u5b58\u6839\u8282\u70b9\u7684\u5927\u5c0f\uff0c\u7528\u4e8e\u6bd4\u8f83\u53f3\u5b50\u6811\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 bool verifyPreorder ( vector < int >& preorder ) { vector < int > stk ; int MIN = INT_MIN ; for ( auto val : preorder ) { if ( val < MIN ) { return false ; } while ( ! stk . empty () && stk . back () < val ) { MIN = stk . back (); stk . pop_back (); } stk . emplace_back ( val ); } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u5224\u65ad\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u5148\u5e8f\u904d\u5386"},{"location":"data-structure/monotone-stack/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b\u6570\u5b57\u7684\u5b57\u7b26\u4e32 num = \u201c10200\u201d \u548c\u4e00\u4e2a\u6574\u6570 k = 1\uff0c\u5220\u9664 k \u4e2a\u5b57\u7b26\uff0c\u4f7f\u5f97\u5269\u4e0b\u7684\u6570\u5b57\u503c\u6700\u5c0f\uff0c\u7ed3\u679c\u4e0d\u5305\u542b\u524d\u7f6e 0. \u300c\u5206\u6790\u300d \u3010\u5355\u8c03\u6808\u3011\u8003\u8651\u5220\u9664\u4e00\u4e2a\u5b57\u7b26\u7684\u60c5\u51b5\uff0c\u4ee5 \u201c14235\u201d \u4e3a\u4f8b\uff0c\u53ea\u6709\u5220\u9664 \u201c4\u201d \u65f6\uff0c\u5f97\u5230\u7684\u503c\u6700\u5c0f\uff0c\u6211\u4eec\u53d1\u73b0\u5220\u9664\u7684\u5b57\u7b26\u8981\u6bd4\u5b83\u7684\u540e\u4e00\u4e2a\u5b57\u7b26\u5927\uff0c\u5e76\u4e14\u88ab\u5220\u9664\u7684\u5b57\u7b26\u4f4d\u7f6e\u5c3d\u53ef\u80fd\u9760\u524d\u3002\u5982\u679c\u6bcf\u6b21\u626b\u63cf\u5220\u9664\u4e00\u4e2a\uff0c\u603b\u5171\u9700\u8981 O(kn) O(kn) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u6211\u4eec\u4f7f\u7528\u3010\u5355\u8c03\u6808\u3011\u6765\u4f18\u5316\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 string removeKdigits ( string num , int k ) { string ans = \"\" ; for ( char ch : num ) { while ( k && ! ans . empty () && ans . back () > ch ) { ans . pop_back (); k -- ; } if ( ans . empty () && ch == '0' ) { continue ; } ans . push_back ( ch ); } while ( k -- && ! ans . empty ()) { ans . pop_back (); } return ans . empty () ? \"0\" : ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u79fb\u9664 k \u4e2a\u5b57\u7b26\u540e\u7684\u6700\u5c0f\u503c"},{"location":"data-structure/monotone-stack/#_7","text":"\u7ed9\u5b9a n \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u7528\u6765\u8868\u793a\u67f1\u72b6\u56fe\u4e2d\u5404\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\u3002\u6bcf\u4e2a\u67f1\u5b50\u5f7c\u6b64\u76f8\u90bb\uff0c\u4e14\u5bbd\u5ea6\u4e3a 1 \u3002\u6c42\u5728\u8be5\u67f1\u72b6\u56fe\u4e2d\uff0c\u80fd\u591f\u52fe\u52d2\u51fa\u6765\u7684\u77e9\u5f62\u7684\u6700\u5927\u9762\u79ef\u3002 \u300c\u5206\u6790\u300d \u300c\u5355\u8c03\u6808\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. */ int largestRectangleArea ( vector < int >& heights ) { int ans = 0 , n = int ( heights . size ()); if ( n == 0 ) { return ans ; } heights . emplace_back ( 0 ); stack < int > stk ; for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } int area = H * W ; if ( ans < area ) { ans = area ; } } stk . push ( i ); } heights . pop_back (); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u67f1\u72b6\u56fe\u4e2d\u6700\u5927\u7684\u77e9\u5f62"},{"location":"data-structure/monotone-stack/#_8","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4ec5\u5305\u542b 0 \u548c 1 \u3001\u5927\u5c0f\u4e3a rows x cols \u7684\u4e8c\u7ef4\u4e8c\u8fdb\u5236\u77e9\u9635\uff0c\u627e\u51fa\u53ea\u5305\u542b 1 \u7684\u6700\u5927\u77e9\u5f62\uff0c\u5e76\u8fd4\u56de\u5176\u9762\u79ef\u3002 \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 1 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 1 & \\color{red}1 & \\color{red}1 & \\color{red}1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \u6700\u5927\u9762\u79ef\u662f 6 \u300c\u5206\u6790\u300d \u300c\u5355\u8c03\u6808\u300d\u5c06\u77e9\u9635\u538b\u7f29\u6210\u4e00\u884c\uff0c\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u503c\u8868\u793a\u5f53\u524d\u5217\u8fde\u7eed\u7684 1 \u7684\u4e2a\u6570\u3002\u540e\u7eed\u5bf9\u8fd9\u4e00\u5217\u6c42\u6700\u5927\u9762\u79ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { int ans = 0 ; int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( matrix [ 0 ]. size ()); vector < int > heights ( nCol , 0 ); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { heights [ j ] = ( heights [ j ] + 1 ) * ( matrix [ i ][ j ] - '0' ); } ans = max ( ans , getRecArea ( heights )); } return ans ; } int getRecArea ( vector < int > heights ) { int ans = 0 , n = int ( heights . size ()); stack < int > stk ; heights . emplace_back ( 0 ); for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } ans = max ( ans , W * H ); } stk . push ( i ); } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6700\u5927\u77e9\u5f62"},{"location":"data-structure/priority-queue/","text":"\u7b80\u4ecb \u00b6 \u4f18\u5148\u961f\u5217\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6570\u636e\u7ed3\u6784\uff0c\u901a\u5e38\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\uff0c\u6309\u7167\u5f53\u524d\u6240\u6709\u5143\u7d20\u7684\u4e00\u4e2a\u7279\u6027\uff0ce.g. \u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u7b49\u7b49\u3002 \u9898\u76ee \u00b6 \u4f1a\u8bae\u5ba4\u7684\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4f1a\u8bae\u65f6\u95f4\u5217\u8868 intervals = [[1, 13], [13, 15], [6, 9]]\uff0cintervals[ i ] \u8868\u793a\u4e00\u4e2a\u4f1a\u8bae\u7684\u5f00\u59cb\u7ed3\u675f\u65f6\u95f4\uff0c\u8bd5\u95ee\u4e3a\u4e86\u907f\u514d\u4f1a\u8bae\u51b2\u7a81\uff0c\u81f3\u5c11\u9700\u8981\u51c6\u5907\u591a\u5c11\u4e2a\u4f1a\u8bae\u5ba4\uff1f \u300c\u5206\u6790\u300d \u3010\u4f18\u5148\u961f\u5217\u3011\u5c06 intervals \u6309\u7167\u4f1a\u8bae\u5f00\u59cb\u65f6\u95f4\u6392\u5e8f\uff0c\u9010\u4e2a\u5224\u65ad\u5f53\u524d\u4f1a\u8bae\u662f\u5426\u4e0e\u4e4b\u524d\u7684\u4f1a\u8bae\u6709\u51b2\u7a81\uff0c\u5982\u679c\u90fd\u6709\u51b2\u7a81\uff0c\u90a3\u4e48\u4f1a\u8bae\u5ba4\u52a0\u4e00\u3002\u5229\u7528\u3010\u4f18\u5148\u961f\u5217\u3011\u4f18\u5316\u4e0a\u8ff0\u7b97\u6cd5\uff0c\u56e0\u4e3a\u6211\u4eec\u5224\u65ad\u4e00\u4e2a\u5f53\u524d\u4f1a\u8bae\u662f\u5426\u9700\u8981\u5355\u72ec\u5f00\u4e00\u4e2a\u4f1a\u8bae\u5ba4\uff0c\u53ea\u9700\u8981\u68c0\u67e5\uff0c\u5f53\u524d\u4f1a\u8bae\u7684\u5f00\u59cb\u65f6\u95f4 t1 \u4e0e\u4e4b\u524d\u6240\u6709\u4f1a\u8bae\u7684\u6700\u65e9\u7ed3\u675f\u65f6\u95f4 t2 \u505a\u5bf9\u6bd4\u3002\u5982\u679c t1 \u4ecd\u9ad8\u4e8e t2\uff0c\u90a3\u4e48\u5f53\u524d\u4f1a\u8bae\u4e0e\u4e4b\u524d\u7684\u90fd\u6709\u51b2\u7a81\uff1b\u53cd\u4e4b\uff0c\u6211\u4eec\u5c06\u5f53\u524d\u4f1a\u8bae\u66ff\u6362\u6700\u65e9\u7ed3\u675f\u7684\u4f1a\u8bae\u3002\u6700\u540e\u4f18\u5148\u961f\u5217\u4e2d\u5b58\u5728\u4f1a\u8bae\u4e2a\u6570\u5c31\u662f\u9700\u8981\u5f00\u8bbe\u7684\u4f1a\u8bae\u5ba4\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 int minMeetingRooms ( vector < vector < int >>& intervals ) { sort ( intervals . begin (), intervals . end ()); priority_queue < int , vector < int > , greater < int >> pq ; for ( vector < int > interval : intervals ) { if ( ! pq . empty () && pq . top () <= interval [ 0 ]) { pq . pop (); } pq . push ( interval [ 1 ]); } return ( int ) pq . size (); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u7b2c K \u4e2a\u6700\u5c0f\u7684\u7d20\u6570\u5206\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4 arr = [1, 2, 3, 5] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0carr \u4e2d\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u7ec4\u6210\u4e00\u4e2a\u5c0f\u4e8e 1 \u5206\u6570\uff0c\u6c42\u7b2c k \u5c0f\u7684\u90a3\u4e2a\u5206\u6570\u3002 \u300c\u5206\u6790\u300d \u3010\u4f18\u5148\u961f\u5217\u3011\u6bcf\u4e00\u4e2a\u4f4d\u7f6e j (0 < j < n) \u7684\u524d\u65b9\u6709 j \u4e2a\u6570\uff0c\u8fd9\u4e9b\u6570\u5b57\u4e0e j \u7ec4\u6210\u7684\u5206\u6570\u5927\u5c0f\u662f\u5355\u8c03\u9012\u589e\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u9274\u3010\u5408\u5e76\u6709\u5e8f\u94fe\u8868\u3011\u7684\u65b9\u6cd5\uff0c\u5c06\u6bcf\u4e00\u4e2a j \u89c6\u4f5c\u4e00\u4e2a\u5355\u8c03\u94fe\u8868\uff0c\u5229\u7528\u6700\u5c0f\u5806\u6c42\u5f97\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 vector < int > kthSmallestPrimeFraction ( vector < int >& arr , int k ) { int n = ( int ) arr . size (); vector < int > ans ( 2 , 0 ); if ( n == 0 ) { return {}; } typedef pair < int , int > PII ; struct cmp { bool operator ()( PII & a , PII & b ) { return a . first * b . second > a . second * b . first ; } }; priority_queue < PII , vector < PII > , cmp > pq ; unordered_map < int , int > idx ; idx [ arr [ 0 ]] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { idx [ arr [ i ]] = i ; pq . emplace ( PII ( arr [ 0 ], arr [ i ])); } while ( k -- ) { int a = pq . top (). first , b = pq . top (). second ; pq . pop (); if ( idx [ a ] < idx [ b ] - 1 ) { pq . emplace ( PII ( arr [ idx [ a ] + 1 ], b )); } ans = vector < int > { a , b }; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(k \\log n) O(k \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f arr \u7684\u957f\u5ea6 \u62c6\u5206\u6570\u7ec4\u4e3a\u8fde\u7eed\u5b50\u5e8f\u5217 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6309\u5347\u5e8f\u6392\u5e8f\u7684\u6574\u6570\u6570\u7ec4 num\uff08\u53ef\u80fd\u5305\u542b\u91cd\u590d\u6570\u5b57\uff09\uff0c\u8bf7\u4f60\u5c06\u5b83\u4eec\u5206\u5272\u6210\u4e00\u4e2a\u6216\u591a\u4e2a\u957f\u5ea6\u81f3\u5c11\u4e3a 3 \u7684\u5b50\u5e8f\u5217\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5e8f\u5217\u90fd\u7531\u8fde\u7eed\u6574\u6570\u7ec4\u6210\u3002\u5982\u679c\u53ef\u4ee5\u5b8c\u6210\u4e0a\u8ff0\u5206\u5272\uff0c\u5219\u8fd4\u56de true \uff1b\u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u300c\u5206\u6790\u300d \u3010\u54c8\u5e0c + \u4f18\u5148\u961f\u5217\u3011\u6bcf\u5f53\u9047\u5230\u4e00\u4e2a\u503c num\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u4ee5 (num - 1) \u7ed3\u5c3e\u7684\u5b50\u5e8f\u5217 [a1, a2, ...]\uff0c\u90a3\u4e48\u9700\u8981\u65b0\u5efa\u4e00\u4e2a\u4ee5 num \u5f00\u5934\u7684\u5b50\u5e8f\u5217\u3002\u56e0\u4e3a num \u53ef\u80fd\u662f\u91cd\u590d\u7684\uff0ce.g. 1 1 2 2 3 3\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u4f18\u5148\u5c06 num \u6dfb\u52a0\u5230\u6240\u6709\u5b50\u5e8f\u5217 [a1, a2, ...] \u4e2d\u6700\u77ed\u7684\u90a3\u4e2a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool isPossible ( vector < int >& nums ) { if ( nums . size () < 3 ) { return false ; } typedef priority_queue < int , vector < int > , greater < int >> pq ; unordered_map < int , pq > M ; for ( int num : nums ) { if ( M . count ( num - 1 )) { int len = M [ num - 1 ]. top (); M [ num - 1 ]. pop (); if ( M [ num - 1 ]. empty ()) { M . erase ( num - 1 ); } M [ num ]. push ( len + 1 ); } else { M [ num ]. push ( 1 ); } } for ( auto it = M . begin (); it != M . end (); it ++ ) { if ( ! it -> second . empty () && it -> second . top () < 3 ) { return false ; } } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u6709\u5e8f\u77e9\u9635\u4e2d\u7684\u7b2c k \u4e2a\u6700\u5c0f\u6570\u7ec4\u548c \u00b6 \u7ed9\u4f60\u4e00\u4e2a m * n \u7684\u77e9\u9635 mat\uff0c\u4ee5\u53ca\u4e00\u4e2a\u6574\u6570 k \uff0c\u77e9\u9635\u4e2d\u7684\u6bcf\u4e00\u884c\u90fd\u4ee5\u975e\u9012\u51cf\u7684\u987a\u5e8f\u6392\u5217\u3002\u4f60\u53ef\u4ee5\u4ece\u6bcf\u4e00\u884c\u4e2d\u9009\u51fa 1 \u4e2a\u5143\u7d20\u5f62\u6210\u4e00\u4e2a\u6570\u7ec4\u3002\u8fd4\u56de\u6240\u6709\u53ef\u80fd\u6570\u7ec4\u4e2d\u7684\u7b2c k \u4e2a \u6700\u5c0f \u6570\u7ec4\u548c\u3002\u4f8b\u5982\uff0c\u77e9\u9635\u5982\u4e0b\uff0ck = 7 \\begin{bmatrix} 1 & 10 & 10 \\\\ 1 & 4 & 5 \\\\ 2 & 3 & 6 \\end{bmatrix} \\begin{bmatrix} 1 & 10 & 10 \\\\ 1 & 4 & 5 \\\\ 2 & 3 & 6 \\end{bmatrix} \u300c\u5206\u6790\u300d \u5982\u679c\u6bcf\u4e00\u884c\u9009\u62e9\u4e00\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u4e00\u5171\u6709 m^{n} m^{n} \u79cd\u53ef\u80fd\uff0c\u5f88\u96be\u5728\u89c4\u5b9a\u65f6\u95f4\u5185\u679a\u4e3e\u5b8c\u3002\u6ce8\u610f\u5230\u9898\u76ee\u6c42\u7684\u662f\u7b2ck\u5c0f\u7684\u7ec4\u5408\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0ck = 7\uff0cmat\u7684\u524d\u4e24\u884c\u7ec4\u5408\u5c31\u67099\u4e2a\u65b9\u6848 s1, s2, ..., s9\uff0c\u53ea\u9700\u8981\u5c06\u7b2c\u4e09\u884c\u7684\u9996\u4f4d\u52a0\u5165\u5230\u8fd99\u4e2a\u548c\u4e0a\uff0c\u5c31\u80fd\u77e5\u9053\u7b2c7\u5c0f\u7684\u503c\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u884c\u904d\u5386\uff0c\u6bcf\u6b21\u9700\u8981\u5c06\u5df2\u7ecf\u7ec4\u5408\u7684topK\uff0c\u4e0e\u5f53\u524d\u884c\u7684\u5143\u7d20\u4e24\u4e24\u76f8\u52a0\uff0c\u518d\u7b5b\u9009\u51fatopK\u5c0f\u7684\u7ec4\u5408\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int kthSmallest ( vector < vector < int >>& mat , int k ) { if ( mat . empty () || mat [ 0 ]. empty ()) { return 0 ; } vector < int > nums ; for ( int j = 0 ; j < mat [ 0 ]. size () && j < k ; j ++ ) { nums . emplace_back ( mat [ 0 ][ j ]); } for ( int i = 1 ; i < mat . size (); i ++ ) { priority_queue < int , vector < int > , greater < int >> pq ; for ( int num : nums ) { for ( int j = 0 ; j < mat [ i ]. size (); j ++ ) { pq . push ( num + mat [ i ][ j ]); } } nums . clear (); for ( int j = 0 ; j < k && ! pq . empty (); j ++ ) { nums . emplace_back ( pq . top ()); pq . pop (); } } sort ( nums . begin (), nums . end ()); return nums . back (); } \u65f6\u95f4\u590d\u6742\u5ea6 O(mkn) O(mkn) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(kn) O(kn) \u3002 \u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums\uff0c\u6709\u4e00\u4e2a\u5927\u5c0f\u4e3a k \u7684\u6ed1\u52a8\u7a97\u53e3\u4ece\u6570\u7ec4\u7684\u6700\u5de6\u4fa7\u79fb\u52a8\u5230\u6570\u7ec4\u7684\u6700\u53f3\u4fa7\u3002\u4f60\u53ea\u53ef\u4ee5\u770b\u5230\u5728\u6ed1\u52a8\u7a97\u53e3\u5185\u7684 k \u4e2a\u6570\u5b57\u3002\u6ed1\u52a8\u7a97\u53e3\u6bcf\u6b21\u53ea\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u3002\u8fd4\u56de \u6ed1\u52a8\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c \u3002 \u300c\u5206\u6790\u300d \u300c\u4f18\u5148\u961f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 */ vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; multiset < int > hash ; int n = ( int ) nums . size (); for ( int i = 0 ; i < k ; i ++ ) { hash . insert ( nums [ i ]); } for ( int i = k ; i < n ; i ++ ) { ans . emplace_back ( *-- hash . end ()); hash . erase ( hash . find ( nums [ i - k ])); hash . insert ( nums [ i ]); } ans . emplace_back ( *-- hash . end ()); return ans ; } vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; int n = ( int ) nums . size (); priority_queue < pair < int , int >> pq ; for ( int i = 0 ; i < k ; i ++ ) { pq . emplace ( nums [ i ], i ); } for ( int i = k ; i <= n ; i ++ ) { while ( pq . top (). second + k < i ) { pq . pop (); } ans . emplace_back ( pq . top (). first ); if ( i < n ) { pq . emplace ( nums [ i ], i ); } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log k) O(n \\log k) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u63a5\u96e8\u6c34 \u00b6 \u7ed9\u4f60\u4e00\u4e2a m x n \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u7684\u503c\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u4e8c\u7ef4\u9ad8\u5ea6\u56fe\u6bcf\u4e2a\u5355\u5143\u7684\u9ad8\u5ea6\uff0c\u8bf7\u8ba1\u7b97\u56fe\u4e2d\u5f62\u72b6\u6700\u591a\u80fd\u63a5\u591a\u5c11\u4f53\u79ef\u7684\u96e8\u6c34\u3002 \u300c\u5206\u6790\u300d \u300c\u4f18\u5148\u961f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* \u7ed9\u51fa\u5982\u4e0b 3x6 \u7684\u9ad8\u5ea6\u56fe: [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] \u8fd4\u56de 4 \u3002 */ int trapRainWater ( vector < vector < int >>& heightMap ) { int nRow = ( int ) heightMap . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) heightMap [ 0 ]. size (); if ( nCol < 3 ) { return 0 ; } typedef pair < int , pair < int , int >> PIII ; priority_queue < PIII , vector < PIII > , greater < PIII >> heap ; bool ** vis = new bool * [ nRow ]; for ( int i = 0 ; i < nRow ; i ++ ) { vis [ i ] = new bool [ nCol ]{}; heap . push ({ heightMap [ i ][ 0 ], { i , 0 }}); heap . push ({ heightMap [ i ][ nCol - 1 ], { i , nCol - 1 }}); vis [ i ][ 0 ] = vis [ i ][ nCol - 1 ] = true ; } for ( int j = 0 ; j < nCol ; j ++ ) { heap . push ({ heightMap [ 0 ][ j ], { 0 , j }}); heap . push ({ heightMap [ nRow - 1 ][ j ], { nRow - 1 , j }}); vis [ 0 ][ j ] = vis [ nRow - 1 ][ j ] = true ; } int dx [ 4 ] = { - 1 , 0 , 1 , 0 }, dy [ 4 ] = { 0 , - 1 , 0 , 1 }; int ans = 0 ; while ( ! heap . empty ()) { auto cur = heap . top (); heap . pop (); int x = cur . second . first , y = cur . second . second ; int h = cur . first ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx >= 0 && xx < nRow && yy >= 0 && yy < nCol && ! vis [ xx ][ yy ]) { vis [ xx ][ yy ] = true ; ans += max ( h - heightMap [ xx ][ yy ], 0 ); heap . push ({ max ( h , heightMap [ xx ][ yy ]), { xx , yy }}); } } } for ( int i = 0 ; i < nRow ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \u3002","title":"\u4f18\u5148\u961f\u5217"},{"location":"data-structure/priority-queue/#_1","text":"\u4f18\u5148\u961f\u5217\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6570\u636e\u7ed3\u6784\uff0c\u901a\u5e38\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\uff0c\u6309\u7167\u5f53\u524d\u6240\u6709\u5143\u7d20\u7684\u4e00\u4e2a\u7279\u6027\uff0ce.g. \u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u7b49\u7b49\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/priority-queue/#_2","text":"","title":"\u9898\u76ee"},{"location":"data-structure/priority-queue/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4f1a\u8bae\u65f6\u95f4\u5217\u8868 intervals = [[1, 13], [13, 15], [6, 9]]\uff0cintervals[ i ] \u8868\u793a\u4e00\u4e2a\u4f1a\u8bae\u7684\u5f00\u59cb\u7ed3\u675f\u65f6\u95f4\uff0c\u8bd5\u95ee\u4e3a\u4e86\u907f\u514d\u4f1a\u8bae\u51b2\u7a81\uff0c\u81f3\u5c11\u9700\u8981\u51c6\u5907\u591a\u5c11\u4e2a\u4f1a\u8bae\u5ba4\uff1f \u300c\u5206\u6790\u300d \u3010\u4f18\u5148\u961f\u5217\u3011\u5c06 intervals \u6309\u7167\u4f1a\u8bae\u5f00\u59cb\u65f6\u95f4\u6392\u5e8f\uff0c\u9010\u4e2a\u5224\u65ad\u5f53\u524d\u4f1a\u8bae\u662f\u5426\u4e0e\u4e4b\u524d\u7684\u4f1a\u8bae\u6709\u51b2\u7a81\uff0c\u5982\u679c\u90fd\u6709\u51b2\u7a81\uff0c\u90a3\u4e48\u4f1a\u8bae\u5ba4\u52a0\u4e00\u3002\u5229\u7528\u3010\u4f18\u5148\u961f\u5217\u3011\u4f18\u5316\u4e0a\u8ff0\u7b97\u6cd5\uff0c\u56e0\u4e3a\u6211\u4eec\u5224\u65ad\u4e00\u4e2a\u5f53\u524d\u4f1a\u8bae\u662f\u5426\u9700\u8981\u5355\u72ec\u5f00\u4e00\u4e2a\u4f1a\u8bae\u5ba4\uff0c\u53ea\u9700\u8981\u68c0\u67e5\uff0c\u5f53\u524d\u4f1a\u8bae\u7684\u5f00\u59cb\u65f6\u95f4 t1 \u4e0e\u4e4b\u524d\u6240\u6709\u4f1a\u8bae\u7684\u6700\u65e9\u7ed3\u675f\u65f6\u95f4 t2 \u505a\u5bf9\u6bd4\u3002\u5982\u679c t1 \u4ecd\u9ad8\u4e8e t2\uff0c\u90a3\u4e48\u5f53\u524d\u4f1a\u8bae\u4e0e\u4e4b\u524d\u7684\u90fd\u6709\u51b2\u7a81\uff1b\u53cd\u4e4b\uff0c\u6211\u4eec\u5c06\u5f53\u524d\u4f1a\u8bae\u66ff\u6362\u6700\u65e9\u7ed3\u675f\u7684\u4f1a\u8bae\u3002\u6700\u540e\u4f18\u5148\u961f\u5217\u4e2d\u5b58\u5728\u4f1a\u8bae\u4e2a\u6570\u5c31\u662f\u9700\u8981\u5f00\u8bbe\u7684\u4f1a\u8bae\u5ba4\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 int minMeetingRooms ( vector < vector < int >>& intervals ) { sort ( intervals . begin (), intervals . end ()); priority_queue < int , vector < int > , greater < int >> pq ; for ( vector < int > interval : intervals ) { if ( ! pq . empty () && pq . top () <= interval [ 0 ]) { pq . pop (); } pq . push ( interval [ 1 ]); } return ( int ) pq . size (); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u4f1a\u8bae\u5ba4\u7684\u4e2a\u6570"},{"location":"data-structure/priority-queue/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4 arr = [1, 2, 3, 5] \u548c\u4e00\u4e2a\u6574\u6570 k = 3\uff0carr \u4e2d\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u7ec4\u6210\u4e00\u4e2a\u5c0f\u4e8e 1 \u5206\u6570\uff0c\u6c42\u7b2c k \u5c0f\u7684\u90a3\u4e2a\u5206\u6570\u3002 \u300c\u5206\u6790\u300d \u3010\u4f18\u5148\u961f\u5217\u3011\u6bcf\u4e00\u4e2a\u4f4d\u7f6e j (0 < j < n) \u7684\u524d\u65b9\u6709 j \u4e2a\u6570\uff0c\u8fd9\u4e9b\u6570\u5b57\u4e0e j \u7ec4\u6210\u7684\u5206\u6570\u5927\u5c0f\u662f\u5355\u8c03\u9012\u589e\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u9274\u3010\u5408\u5e76\u6709\u5e8f\u94fe\u8868\u3011\u7684\u65b9\u6cd5\uff0c\u5c06\u6bcf\u4e00\u4e2a j \u89c6\u4f5c\u4e00\u4e2a\u5355\u8c03\u94fe\u8868\uff0c\u5229\u7528\u6700\u5c0f\u5806\u6c42\u5f97\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 vector < int > kthSmallestPrimeFraction ( vector < int >& arr , int k ) { int n = ( int ) arr . size (); vector < int > ans ( 2 , 0 ); if ( n == 0 ) { return {}; } typedef pair < int , int > PII ; struct cmp { bool operator ()( PII & a , PII & b ) { return a . first * b . second > a . second * b . first ; } }; priority_queue < PII , vector < PII > , cmp > pq ; unordered_map < int , int > idx ; idx [ arr [ 0 ]] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { idx [ arr [ i ]] = i ; pq . emplace ( PII ( arr [ 0 ], arr [ i ])); } while ( k -- ) { int a = pq . top (). first , b = pq . top (). second ; pq . pop (); if ( idx [ a ] < idx [ b ] - 1 ) { pq . emplace ( PII ( arr [ idx [ a ] + 1 ], b )); } ans = vector < int > { a , b }; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(k \\log n) O(k \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f arr \u7684\u957f\u5ea6","title":"\u7b2c K \u4e2a\u6700\u5c0f\u7684\u7d20\u6570\u5206\u6570"},{"location":"data-structure/priority-queue/#_4","text":"\u7ed9\u4f60\u4e00\u4e2a\u6309\u5347\u5e8f\u6392\u5e8f\u7684\u6574\u6570\u6570\u7ec4 num\uff08\u53ef\u80fd\u5305\u542b\u91cd\u590d\u6570\u5b57\uff09\uff0c\u8bf7\u4f60\u5c06\u5b83\u4eec\u5206\u5272\u6210\u4e00\u4e2a\u6216\u591a\u4e2a\u957f\u5ea6\u81f3\u5c11\u4e3a 3 \u7684\u5b50\u5e8f\u5217\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b50\u5e8f\u5217\u90fd\u7531\u8fde\u7eed\u6574\u6570\u7ec4\u6210\u3002\u5982\u679c\u53ef\u4ee5\u5b8c\u6210\u4e0a\u8ff0\u5206\u5272\uff0c\u5219\u8fd4\u56de true \uff1b\u5426\u5219\uff0c\u8fd4\u56de false \u3002 \u300c\u5206\u6790\u300d \u3010\u54c8\u5e0c + \u4f18\u5148\u961f\u5217\u3011\u6bcf\u5f53\u9047\u5230\u4e00\u4e2a\u503c num\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u4ee5 (num - 1) \u7ed3\u5c3e\u7684\u5b50\u5e8f\u5217 [a1, a2, ...]\uff0c\u90a3\u4e48\u9700\u8981\u65b0\u5efa\u4e00\u4e2a\u4ee5 num \u5f00\u5934\u7684\u5b50\u5e8f\u5217\u3002\u56e0\u4e3a num \u53ef\u80fd\u662f\u91cd\u590d\u7684\uff0ce.g. 1 1 2 2 3 3\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u4f18\u5148\u5c06 num \u6dfb\u52a0\u5230\u6240\u6709\u5b50\u5e8f\u5217 [a1, a2, ...] \u4e2d\u6700\u77ed\u7684\u90a3\u4e2a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool isPossible ( vector < int >& nums ) { if ( nums . size () < 3 ) { return false ; } typedef priority_queue < int , vector < int > , greater < int >> pq ; unordered_map < int , pq > M ; for ( int num : nums ) { if ( M . count ( num - 1 )) { int len = M [ num - 1 ]. top (); M [ num - 1 ]. pop (); if ( M [ num - 1 ]. empty ()) { M . erase ( num - 1 ); } M [ num ]. push ( len + 1 ); } else { M [ num ]. push ( 1 ); } } for ( auto it = M . begin (); it != M . end (); it ++ ) { if ( ! it -> second . empty () && it -> second . top () < 3 ) { return false ; } } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u62c6\u5206\u6570\u7ec4\u4e3a\u8fde\u7eed\u5b50\u5e8f\u5217"},{"location":"data-structure/priority-queue/#k_1","text":"\u7ed9\u4f60\u4e00\u4e2a m * n \u7684\u77e9\u9635 mat\uff0c\u4ee5\u53ca\u4e00\u4e2a\u6574\u6570 k \uff0c\u77e9\u9635\u4e2d\u7684\u6bcf\u4e00\u884c\u90fd\u4ee5\u975e\u9012\u51cf\u7684\u987a\u5e8f\u6392\u5217\u3002\u4f60\u53ef\u4ee5\u4ece\u6bcf\u4e00\u884c\u4e2d\u9009\u51fa 1 \u4e2a\u5143\u7d20\u5f62\u6210\u4e00\u4e2a\u6570\u7ec4\u3002\u8fd4\u56de\u6240\u6709\u53ef\u80fd\u6570\u7ec4\u4e2d\u7684\u7b2c k \u4e2a \u6700\u5c0f \u6570\u7ec4\u548c\u3002\u4f8b\u5982\uff0c\u77e9\u9635\u5982\u4e0b\uff0ck = 7 \\begin{bmatrix} 1 & 10 & 10 \\\\ 1 & 4 & 5 \\\\ 2 & 3 & 6 \\end{bmatrix} \\begin{bmatrix} 1 & 10 & 10 \\\\ 1 & 4 & 5 \\\\ 2 & 3 & 6 \\end{bmatrix} \u300c\u5206\u6790\u300d \u5982\u679c\u6bcf\u4e00\u884c\u9009\u62e9\u4e00\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u4e00\u5171\u6709 m^{n} m^{n} \u79cd\u53ef\u80fd\uff0c\u5f88\u96be\u5728\u89c4\u5b9a\u65f6\u95f4\u5185\u679a\u4e3e\u5b8c\u3002\u6ce8\u610f\u5230\u9898\u76ee\u6c42\u7684\u662f\u7b2ck\u5c0f\u7684\u7ec4\u5408\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0ck = 7\uff0cmat\u7684\u524d\u4e24\u884c\u7ec4\u5408\u5c31\u67099\u4e2a\u65b9\u6848 s1, s2, ..., s9\uff0c\u53ea\u9700\u8981\u5c06\u7b2c\u4e09\u884c\u7684\u9996\u4f4d\u52a0\u5165\u5230\u8fd99\u4e2a\u548c\u4e0a\uff0c\u5c31\u80fd\u77e5\u9053\u7b2c7\u5c0f\u7684\u503c\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u884c\u904d\u5386\uff0c\u6bcf\u6b21\u9700\u8981\u5c06\u5df2\u7ecf\u7ec4\u5408\u7684topK\uff0c\u4e0e\u5f53\u524d\u884c\u7684\u5143\u7d20\u4e24\u4e24\u76f8\u52a0\uff0c\u518d\u7b5b\u9009\u51fatopK\u5c0f\u7684\u7ec4\u5408\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int kthSmallest ( vector < vector < int >>& mat , int k ) { if ( mat . empty () || mat [ 0 ]. empty ()) { return 0 ; } vector < int > nums ; for ( int j = 0 ; j < mat [ 0 ]. size () && j < k ; j ++ ) { nums . emplace_back ( mat [ 0 ][ j ]); } for ( int i = 1 ; i < mat . size (); i ++ ) { priority_queue < int , vector < int > , greater < int >> pq ; for ( int num : nums ) { for ( int j = 0 ; j < mat [ i ]. size (); j ++ ) { pq . push ( num + mat [ i ][ j ]); } } nums . clear (); for ( int j = 0 ; j < k && ! pq . empty (); j ++ ) { nums . emplace_back ( pq . top ()); pq . pop (); } } sort ( nums . begin (), nums . end ()); return nums . back (); } \u65f6\u95f4\u590d\u6742\u5ea6 O(mkn) O(mkn) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(kn) O(kn) \u3002","title":"\u6709\u5e8f\u77e9\u9635\u4e2d\u7684\u7b2c k \u4e2a\u6700\u5c0f\u6570\u7ec4\u548c"},{"location":"data-structure/priority-queue/#_5","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums\uff0c\u6709\u4e00\u4e2a\u5927\u5c0f\u4e3a k \u7684\u6ed1\u52a8\u7a97\u53e3\u4ece\u6570\u7ec4\u7684\u6700\u5de6\u4fa7\u79fb\u52a8\u5230\u6570\u7ec4\u7684\u6700\u53f3\u4fa7\u3002\u4f60\u53ea\u53ef\u4ee5\u770b\u5230\u5728\u6ed1\u52a8\u7a97\u53e3\u5185\u7684 k \u4e2a\u6570\u5b57\u3002\u6ed1\u52a8\u7a97\u53e3\u6bcf\u6b21\u53ea\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u3002\u8fd4\u56de \u6ed1\u52a8\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c \u3002 \u300c\u5206\u6790\u300d \u300c\u4f18\u5148\u961f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 */ vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; multiset < int > hash ; int n = ( int ) nums . size (); for ( int i = 0 ; i < k ; i ++ ) { hash . insert ( nums [ i ]); } for ( int i = k ; i < n ; i ++ ) { ans . emplace_back ( *-- hash . end ()); hash . erase ( hash . find ( nums [ i - k ])); hash . insert ( nums [ i ]); } ans . emplace_back ( *-- hash . end ()); return ans ; } vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; int n = ( int ) nums . size (); priority_queue < pair < int , int >> pq ; for ( int i = 0 ; i < k ; i ++ ) { pq . emplace ( nums [ i ], i ); } for ( int i = k ; i <= n ; i ++ ) { while ( pq . top (). second + k < i ) { pq . pop (); } ans . emplace_back ( pq . top (). first ); if ( i < n ) { pq . emplace ( nums [ i ], i ); } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log k) O(n \\log k) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c"},{"location":"data-structure/priority-queue/#_6","text":"\u7ed9\u4f60\u4e00\u4e2a m x n \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u7684\u503c\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u4e8c\u7ef4\u9ad8\u5ea6\u56fe\u6bcf\u4e2a\u5355\u5143\u7684\u9ad8\u5ea6\uff0c\u8bf7\u8ba1\u7b97\u56fe\u4e2d\u5f62\u72b6\u6700\u591a\u80fd\u63a5\u591a\u5c11\u4f53\u79ef\u7684\u96e8\u6c34\u3002 \u300c\u5206\u6790\u300d \u300c\u4f18\u5148\u961f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* \u7ed9\u51fa\u5982\u4e0b 3x6 \u7684\u9ad8\u5ea6\u56fe: [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] \u8fd4\u56de 4 \u3002 */ int trapRainWater ( vector < vector < int >>& heightMap ) { int nRow = ( int ) heightMap . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) heightMap [ 0 ]. size (); if ( nCol < 3 ) { return 0 ; } typedef pair < int , pair < int , int >> PIII ; priority_queue < PIII , vector < PIII > , greater < PIII >> heap ; bool ** vis = new bool * [ nRow ]; for ( int i = 0 ; i < nRow ; i ++ ) { vis [ i ] = new bool [ nCol ]{}; heap . push ({ heightMap [ i ][ 0 ], { i , 0 }}); heap . push ({ heightMap [ i ][ nCol - 1 ], { i , nCol - 1 }}); vis [ i ][ 0 ] = vis [ i ][ nCol - 1 ] = true ; } for ( int j = 0 ; j < nCol ; j ++ ) { heap . push ({ heightMap [ 0 ][ j ], { 0 , j }}); heap . push ({ heightMap [ nRow - 1 ][ j ], { nRow - 1 , j }}); vis [ 0 ][ j ] = vis [ nRow - 1 ][ j ] = true ; } int dx [ 4 ] = { - 1 , 0 , 1 , 0 }, dy [ 4 ] = { 0 , - 1 , 0 , 1 }; int ans = 0 ; while ( ! heap . empty ()) { auto cur = heap . top (); heap . pop (); int x = cur . second . first , y = cur . second . second ; int h = cur . first ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx >= 0 && xx < nRow && yy >= 0 && yy < nCol && ! vis [ xx ][ yy ]) { vis [ xx ][ yy ] = true ; ans += max ( h - heightMap [ xx ][ yy ], 0 ); heap . push ({ max ( h , heightMap [ xx ][ yy ]), { xx , yy }}); } } } for ( int i = 0 ; i < nRow ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(nm) O(nm) \u3002","title":"\u63a5\u96e8\u6c34"},{"location":"data-structure/segment-tree/","text":"\u7b80\u4ecb \u00b6 \u7ebf\u6bb5\u6811\u662f\u4e00\u79cd\u9ad8\u6548\u5730\u7ef4\u62a4\u533a\u95f4\u4fe1\u606f\uff08\u548c\u3001\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u7b49\uff09\u7684\u4e00\u79cd\u6811\u5f62\u7ed3\u6784\u3002\u7ebf\u6bb5\u6811\u6709\u4e24\u4e2a\u4e3b\u8981\u7684\u63a5\u53e3 \u67e5\u8be2\uff08query\uff09\uff0c\u4f8b\u5982\u6c42\u533a\u95f4\u548c \u66f4\u65b0\uff08update\uff09\uff0c\u66f4\u65b0\u67d0\u4e00\u4f4d\u7f6e\u7684\u503c\uff0c\u5bf9\u5e94\u7684\u6240\u6709\u533a\u95f4\u548c\u5c06\u88ab\u66f4\u65b0 \u4e24\u8005\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a O(\\log n) O(\\log n) \u3002 \u539f\u7406 \u00b6 \u5efa\u6811 \u00b6 \u7ebf\u6bb5\u6811\u4e0e\u6700\u5c0f\u5806\u7c7b\u4f3c\uff0c\u4ee5\u4e8c\u53c9\u6811\u6765\u5efa\u7acb\uff0c\u627f\u8f7d\u7684\u5f62\u5f0f\u662f\u4e00\u4e2a\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u7ebf\u6bb5\u6811\u7684\u6839\u7ed3\u70b9\u5bf9\u5e94\u7684\u7d22\u5f15\u662f 1\uff1b\u7ebf\u6bb5\u6811\u662f\u4e00\u9897\u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\uff0c\u6700\u540e\u4e00\u5c42\u9760\u5de6\u6392\u5217\u3002 \u53f6\u5b50\u7ed3\u70b9\u662f\u5947\u6570 \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \u53f6\u5b50\u7ed3\u70b9\u662f\u5076\u6570 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \u5b8c\u6ee1\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u4e0e\u975e\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u6709\u4e00\u4e2a\u5173\u7cfb n_{\\text{leaves}} = n_{non-leaves} + 1 n_{\\text{leaves}} = n_{non-leaves} + 1 \u56e0\u6b64\uff0c\u7ebf\u6bb5\u6811\u5c06\u539f\u6570\u7ec4\u7684\u6bcf\u4e00\u4e2a\u503c\u90fd\u653e\u5728\u53f6\u5b50\u7ed3\u70b9\u4e0a\uff0c\u81ea\u5e95\u5411\u4e0a\u5730\u5efa\u6811\u3002 1 2 3 4 5 6 7 8 9 10 void initialize ( vector < int > nums ) { int n = ( int ) nums . size (); vector < int > A ( n * 2 , 0 ); for ( int j = n , i = 0 ; i < n ; i ++ , j ++ ) { A [ j ] = nums [ i ]; } for ( int j = n - 1 ; j > 0 ; j -- ) { A [ j ] = A [ j * 2 ] + A [ j * 2 + 1 ]; } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u67e5\u8be2 \u00b6 \u7ebf\u6bb5\u6811\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u4fe1\u606f\uff0c\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b\uff0c\u6839\u7ed3\u70b9\u8868\u793a\u6574\u4e2a\u533a\u95f4\u548c\u3002\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5e0c\u671b\u76f4\u63a5\u8fd4\u56de\u4e00\u4e2a\u533a\u95f4\u7684\u548c\uff0c\u4f46\u5f80\u5f80\u7ed9\u51fa\u7684\u533a\u95f4\u8fb9\u754c\u4e0d\u662f\u6070\u597d\u5bf9\u5e94\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06\u8981\u6c42\u7684\u533a\u95f4\u5206\u5272\uff0c\u6c42\u6bcf\u4e00\u4e2a\u5b50\u533a\u95f4\u7684\u548c\uff0c\u5373\u53ef\u5f97\u5230\u6700\u7ec8\u7ed3\u679c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int sumRange ( int left , int right ) { int sum = 0 ; left += n ; right += n ; while ( left <= right ) { if ( left % 2 != 0 ) { sum += A [ left ++ ]; } if ( right % 2 == 0 ) { sum += A [ right -- ]; } left >>= 1 ; right >>= 1 ; } return sum ; } \u66f4\u65b0 \u00b6 \u5f53\u539f\u6570\u7ec4\u7684\u4e00\u4e2a\u6216\u82e5\u5e72\u4e2a\u6570\u503c\u53d1\u751f\u6539\u53d8\u65f6\uff0c\u5bf9\u5e94\u7684\u533a\u95f4\u4fe1\u606f\u4e5f\u8981\u53d1\u751f\u53d8\u5316\uff0c\u4ece\u53f6\u5b50\u7ed3\u70b9\u5f00\u59cb\u66f4\u65b0\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7684\u7ed3\u70b9\u3002\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b 1 2 3 4 5 6 7 8 void update ( int index , int val ) { index += n ; int diff = val - A [ index ]; while ( index ) { A [ index ] += diff ; index >>= 1 ; } } \u9898\u76ee \u00b6","title":"\u7ebf\u6bb5\u6811"},{"location":"data-structure/segment-tree/#_1","text":"\u7ebf\u6bb5\u6811\u662f\u4e00\u79cd\u9ad8\u6548\u5730\u7ef4\u62a4\u533a\u95f4\u4fe1\u606f\uff08\u548c\u3001\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u7b49\uff09\u7684\u4e00\u79cd\u6811\u5f62\u7ed3\u6784\u3002\u7ebf\u6bb5\u6811\u6709\u4e24\u4e2a\u4e3b\u8981\u7684\u63a5\u53e3 \u67e5\u8be2\uff08query\uff09\uff0c\u4f8b\u5982\u6c42\u533a\u95f4\u548c \u66f4\u65b0\uff08update\uff09\uff0c\u66f4\u65b0\u67d0\u4e00\u4f4d\u7f6e\u7684\u503c\uff0c\u5bf9\u5e94\u7684\u6240\u6709\u533a\u95f4\u548c\u5c06\u88ab\u66f4\u65b0 \u4e24\u8005\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a O(\\log n) O(\\log n) \u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/segment-tree/#_2","text":"","title":"\u539f\u7406"},{"location":"data-structure/segment-tree/#_3","text":"\u7ebf\u6bb5\u6811\u4e0e\u6700\u5c0f\u5806\u7c7b\u4f3c\uff0c\u4ee5\u4e8c\u53c9\u6811\u6765\u5efa\u7acb\uff0c\u627f\u8f7d\u7684\u5f62\u5f0f\u662f\u4e00\u4e2a\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u7ebf\u6bb5\u6811\u7684\u6839\u7ed3\u70b9\u5bf9\u5e94\u7684\u7d22\u5f15\u662f 1\uff1b\u7ebf\u6bb5\u6811\u662f\u4e00\u9897\u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\uff0c\u6700\u540e\u4e00\u5c42\u9760\u5de6\u6392\u5217\u3002 \u53f6\u5b50\u7ed3\u70b9\u662f\u5947\u6570 \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \u53f6\u5b50\u7ed3\u70b9\u662f\u5076\u6570 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \u5b8c\u6ee1\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u4e0e\u975e\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u6709\u4e00\u4e2a\u5173\u7cfb n_{\\text{leaves}} = n_{non-leaves} + 1 n_{\\text{leaves}} = n_{non-leaves} + 1 \u56e0\u6b64\uff0c\u7ebf\u6bb5\u6811\u5c06\u539f\u6570\u7ec4\u7684\u6bcf\u4e00\u4e2a\u503c\u90fd\u653e\u5728\u53f6\u5b50\u7ed3\u70b9\u4e0a\uff0c\u81ea\u5e95\u5411\u4e0a\u5730\u5efa\u6811\u3002 1 2 3 4 5 6 7 8 9 10 void initialize ( vector < int > nums ) { int n = ( int ) nums . size (); vector < int > A ( n * 2 , 0 ); for ( int j = n , i = 0 ; i < n ; i ++ , j ++ ) { A [ j ] = nums [ i ]; } for ( int j = n - 1 ; j > 0 ; j -- ) { A [ j ] = A [ j * 2 ] + A [ j * 2 + 1 ]; } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u5efa\u6811"},{"location":"data-structure/segment-tree/#_4","text":"\u7ebf\u6bb5\u6811\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u4fe1\u606f\uff0c\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b\uff0c\u6839\u7ed3\u70b9\u8868\u793a\u6574\u4e2a\u533a\u95f4\u548c\u3002\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5e0c\u671b\u76f4\u63a5\u8fd4\u56de\u4e00\u4e2a\u533a\u95f4\u7684\u548c\uff0c\u4f46\u5f80\u5f80\u7ed9\u51fa\u7684\u533a\u95f4\u8fb9\u754c\u4e0d\u662f\u6070\u597d\u5bf9\u5e94\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06\u8981\u6c42\u7684\u533a\u95f4\u5206\u5272\uff0c\u6c42\u6bcf\u4e00\u4e2a\u5b50\u533a\u95f4\u7684\u548c\uff0c\u5373\u53ef\u5f97\u5230\u6700\u7ec8\u7ed3\u679c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int sumRange ( int left , int right ) { int sum = 0 ; left += n ; right += n ; while ( left <= right ) { if ( left % 2 != 0 ) { sum += A [ left ++ ]; } if ( right % 2 == 0 ) { sum += A [ right -- ]; } left >>= 1 ; right >>= 1 ; } return sum ; }","title":"\u67e5\u8be2"},{"location":"data-structure/segment-tree/#_5","text":"\u5f53\u539f\u6570\u7ec4\u7684\u4e00\u4e2a\u6216\u82e5\u5e72\u4e2a\u6570\u503c\u53d1\u751f\u6539\u53d8\u65f6\uff0c\u5bf9\u5e94\u7684\u533a\u95f4\u4fe1\u606f\u4e5f\u8981\u53d1\u751f\u53d8\u5316\uff0c\u4ece\u53f6\u5b50\u7ed3\u70b9\u5f00\u59cb\u66f4\u65b0\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7684\u7ed3\u70b9\u3002\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b 1 2 3 4 5 6 7 8 void update ( int index , int val ) { index += n ; int diff = val - A [ index ]; while ( index ) { A [ index ] += diff ; index >>= 1 ; } }","title":"\u66f4\u65b0"},{"location":"data-structure/segment-tree/#_6","text":"","title":"\u9898\u76ee"},{"location":"data-structure/stack-queue/","text":"\u6808 \u00b6 \u6808\u662f\u4e00\u79cd\u5177\u6709\u3010\u5148\u8fdb\u540e\u51fa\u3011\u7279\u6027\u7684\u6570\u636e\u7ed3\u6784\uff0c\u901a\u5e38\u4e8e\u8f85\u52a9\u5b9e\u73b0\u975e\u9012\u5f52\u7b97\u6cd5\uff0c\u5982DFS\u3002 \u4e24\u4e2a\u6808\u5b9e\u73b0\u961f\u5217 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () { } /** Push element x to the back of queue. */ void push ( int x ) { s1 . push ( x ); } /** Removes the element from in front of queue and returns that element. */ int pop () { int ans = peek (); s2 . pop (); return ans ; } /** Get the front element. */ int peek () { if ( s2 . empty ()) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } } return s2 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty () && s2 . empty (); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ \u65f6\u95f4\u590d\u6742\u5ea6\uff1apush \u548c empty \u4e3a O(1) O(1) \uff0cpop \u548c peak \u7684\u5747\u644a\u4e3a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u6700\u5c0f\u6808 \u00b6 \u5b9e\u73b0\u4e00\u4e2a\u6700\u5c0f\u6808\uff0c\u65f6\u523b\u83b7\u53d6\u6808\u5185\u7684\u6700\u5c0f\u503c\u3002 \u300c\u5206\u6790\u300d \u7528\u4e24\u4e2avector\u5b9e\u73b0\u3002\u6bcf\u6b21\u300c\u5165\u6808\u300d\u65f6\uff0c\u5c06\u5f53\u524d\u6700\u5c0f\u5143\u7d20\u538b\u5165\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 */ class MinStack { vector < int > arr1 , arr2 ; public : /** initialize your data structure here. */ MinStack () { } void push ( int val ) { arr1 . emplace_back ( val ); if ( arr2 . empty () || arr2 . back () > val ) { arr2 . emplace_back ( val ); } else { arr2 . emplace_back ( arr2 . back ()); } } void pop () { arr1 . pop_back (); arr2 . pop_back (); } int top () { return arr1 . back (); } int getMin () { return arr2 . back (); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u961f\u5217 \u00b6 \u961f\u5217\u662f\u4e00\u79cd\u5177\u6709\u3010\u5148\u8fdb\u5148\u51fa\u3011\u7279\u6027\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7528\u4e8e\u5b9e\u73b0BFS\u7b97\u6cd5\u3002 \u7528\u961f\u5217\u5b9e\u73b0\u6808 \u00b6 \u53ea\u7528\u4e00\u4e2a\u961f\u5217\u5b9e\u73b0\u6808\u7684\u529f\u80fd\uff1a\u538b\u5165\u3001\u5f39\u51fa\u3001\u53d6\u6808\u9876\u5143\u7d20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyStack { queue < int > q ; public : /** Initialize your data structure here. */ MyStack () { } /** Push element x onto stack. */ void push ( int x ) { int n = ( int ) q . size (); q . push ( x ); for ( int i = 0 ; i < n ; i ++ ) { q . push ( q . front ()); q . pop (); } } /** Removes the element on top of the stack and returns that element. */ int pop () { int ans = q . front (); q . pop (); return ans ; } /** Get the top element. */ int top () { return q . front (); } /** Returns whether the stack is empty. */ bool empty () { return q . empty (); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1apush \u662f O(n) O(n) \uff0ctop \u548c pop \u90fd\u662f O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u6808 & \u961f\u5217"},{"location":"data-structure/stack-queue/#_1","text":"\u6808\u662f\u4e00\u79cd\u5177\u6709\u3010\u5148\u8fdb\u540e\u51fa\u3011\u7279\u6027\u7684\u6570\u636e\u7ed3\u6784\uff0c\u901a\u5e38\u4e8e\u8f85\u52a9\u5b9e\u73b0\u975e\u9012\u5f52\u7b97\u6cd5\uff0c\u5982DFS\u3002","title":"\u6808"},{"location":"data-structure/stack-queue/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () { } /** Push element x to the back of queue. */ void push ( int x ) { s1 . push ( x ); } /** Removes the element from in front of queue and returns that element. */ int pop () { int ans = peek (); s2 . pop (); return ans ; } /** Get the front element. */ int peek () { if ( s2 . empty ()) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } } return s2 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty () && s2 . empty (); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ \u65f6\u95f4\u590d\u6742\u5ea6\uff1apush \u548c empty \u4e3a O(1) O(1) \uff0cpop \u548c peak \u7684\u5747\u644a\u4e3a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u4e24\u4e2a\u6808\u5b9e\u73b0\u961f\u5217"},{"location":"data-structure/stack-queue/#_3","text":"\u5b9e\u73b0\u4e00\u4e2a\u6700\u5c0f\u6808\uff0c\u65f6\u523b\u83b7\u53d6\u6808\u5185\u7684\u6700\u5c0f\u503c\u3002 \u300c\u5206\u6790\u300d \u7528\u4e24\u4e2avector\u5b9e\u73b0\u3002\u6bcf\u6b21\u300c\u5165\u6808\u300d\u65f6\uff0c\u5c06\u5f53\u524d\u6700\u5c0f\u5143\u7d20\u538b\u5165\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 */ class MinStack { vector < int > arr1 , arr2 ; public : /** initialize your data structure here. */ MinStack () { } void push ( int val ) { arr1 . emplace_back ( val ); if ( arr2 . empty () || arr2 . back () > val ) { arr2 . emplace_back ( val ); } else { arr2 . emplace_back ( arr2 . back ()); } } void pop () { arr1 . pop_back (); arr2 . pop_back (); } int top () { return arr1 . back (); } int getMin () { return arr2 . back (); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u6700\u5c0f\u6808"},{"location":"data-structure/stack-queue/#_4","text":"\u961f\u5217\u662f\u4e00\u79cd\u5177\u6709\u3010\u5148\u8fdb\u5148\u51fa\u3011\u7279\u6027\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7528\u4e8e\u5b9e\u73b0BFS\u7b97\u6cd5\u3002","title":"\u961f\u5217"},{"location":"data-structure/stack-queue/#_5","text":"\u53ea\u7528\u4e00\u4e2a\u961f\u5217\u5b9e\u73b0\u6808\u7684\u529f\u80fd\uff1a\u538b\u5165\u3001\u5f39\u51fa\u3001\u53d6\u6808\u9876\u5143\u7d20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyStack { queue < int > q ; public : /** Initialize your data structure here. */ MyStack () { } /** Push element x onto stack. */ void push ( int x ) { int n = ( int ) q . size (); q . push ( x ); for ( int i = 0 ; i < n ; i ++ ) { q . push ( q . front ()); q . pop (); } } /** Removes the element on top of the stack and returns that element. */ int pop () { int ans = q . front (); q . pop (); return ans ; } /** Get the top element. */ int top () { return q . front (); } /** Returns whether the stack is empty. */ bool empty () { return q . empty (); } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1apush \u662f O(n) O(n) \uff0ctop \u548c pop \u90fd\u662f O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u7528\u961f\u5217\u5b9e\u73b0\u6808"},{"location":"data-structure/string/","text":"\u5339\u914d \u00b6 KMP \u00b6 KMP\u8bb2\u6c42\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u5339\u914d\uff0c\u5f53\u51fa\u73b0\u8bef\u5339\u914d\u7684\u5b57\u7b26\u65f6\uff0c\u5c06\u6a21\u5f0f\u4e32P\u5411\u53f3\u79fb\u52a8\u82e5\u5e72\u8ddd\u79bb\u3002KMP\u501f\u52a9P\u7684\u524d\u7f00\uff08\u5386\u53f2\u5339\u914d\u4fe1\u606f\uff09\u6784\u5efanext\u6570\u7ec4\u3002\u5c06P\u524d\u7f00\u4e2d\u4e0e\u5931\u914d\u5b57\u7b26\u524d\u6700\u5927\u91cd\u5408\u7684\u4f4d\u7f6e\u5bf9\u9f50\u3002P\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u53d1\u751f\u5931\u914d\u65f6\uff0c\u5bf9\u5e94\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u8be5\u662f-1\uff0c\u8868\u793a\u5c06\u6574\u4e2aP\u79fb\u52a8\u5230\u5931\u914d\u5b57\u7b26\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002 \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \u4e3a\u4e86\u66f4\u52a0\u9ad8\u6548\u5730\u79fb\u52a8P\uff0cnext\u6570\u7ec4\u8868\u793a\u5730\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u5f53\u5c3d\u53ef\u80fd\u5730\u5c0f \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) , \u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0cm\u662fP\u7684\u957f\u5ea6\uff0cn\u662fT\u7684\u957f\u5ea6 \u300cLeetcode 28. \u5b9e\u73b0 strStr()\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahaystack = \"hello\", needle = \"ll\" \u8f93\u51fa\uff1a2 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahaystack = \"aaaaa\", needle = \"bba\" \u8f93\u51fa\uff1a-1 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahaystack = \"\", needle = \"\" \u8f93\u51fa\uff1a0 */ int strStr ( string haystack , string needle ) { int n = ( int ) haystack . length (), m = ( int ) needle . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } vector < int > next ( m , - 1 ); int j = 0 , k = - 1 ; while ( j < m - 1 ) { if ( k < 0 || needle [ j ] == needle [ k ]) { j ++ ; k ++ ; next [ j ] = needle [ j ] != needle [ k ] ? k : next [ k ]; } else { k = next [ k ]; } } int i = 0 ; j = 0 ; while ( i < n && j < m ) { if ( j < 0 || haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } return i - j > n - m ? - 1 : i - j ; } \u300cLeetcode 214. \u6700\u77ed\u56de\u6587\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u5728\u5b57\u7b26\u4e32\u524d\u9762\u6dfb\u52a0\u5b57\u7b26\u5c06\u5176\u8f6c\u6362\u4e3a\u56de\u6587\u4e32\u3002 \u627e\u5230\u5e76\u8fd4\u56de\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f\u8f6c\u6362\u7684\u6700\u77ed\u56de\u6587\u4e32\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1as = \"aacecaaa\" \u8f93\u51fa\uff1a\"aaacecaaa\" \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1as = \"abcd\" \u8f93\u51fa\uff1a\"dcbabcd\" */ string shortestPalindrome ( string s ) { int n = ( int ) s . length (); if ( n <= 1 ) { return s ; } vector < int > next ( n , - 1 ); int i = 0 , pos = - 1 ; while ( i < n - 1 ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i ++ ; pos ++ ; next [ i ] = s [ i ] != s [ pos ] ? pos : next [ pos ]; } else { pos = next [ pos ]; } } pos = 0 ; i = n - 1 ; while ( i >= 0 && pos < n ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i -- ; pos ++ ; } else { pos = next [ pos ]; } } string ans = s . substr ( pos , n - pos ); reverse ( ans . begin (), ans . end ()); return ans + s ; } Boyer-Moore \u00b6 \u574f\u5b57\u7b26 \u00b6 \u5f53\u6a21\u5f0f\u4e32P\u4e0e\u6587\u672c\u4e32T\u5728\u67d0\u4ee5\u4f4d\u7f6epos\u53d1\u751f\u4e0d\u5339\u914d\u65f6\uff0cT[pos]\u53eb\u505a\u574f\u5b57\u7b26\u3002 1.1 \u574f\u5b57\u7b26\u54c8\u5e0c\u8868\u7684\u6784\u9020\uff0c\u4e00\u904d\u626b\u63cf\u5c06P\u4e2d\u7684\u5b57\u7b26\u4f4d\u7f6e\u4fdd\u5b58\u5728\u5b57\u5178\u4e2d\uff0ckey\u4e3a\u5b57\u7b26\u672c\u8eab\uff0cvalue\u4e3a\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u3002 1.2 \u5f53\u574f\u5b57\u7b26\u4e0d\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06\u6a21\u5f0f\u4e32\u5168\u90e8\u79fb\u52a8\u5230\u574f\u5b57\u7b26\u540e\u4e00\u4f4d \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} 1.3 \u5f53\u574f\u5b57\u7b26\u51fa\u73b0\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06P\u4e2d\u6700\u8fd1\u7684\u5b57\u7b26\u4e0eT\u4e2d\u7684\u574f\u5b57\u7b26\u5bf9\u5e94 \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \u4f46\u662f\u5982\u679c\u574f\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u5927\u4e8e\u4e0d\u5339\u914d\u7684\u4f4d\u7f6ej\u65f6\uff0c\u79fb\u52a8\u7684\u8ddd\u79bb\u662f\u8d1f\u6570 \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0cBM\u8fd8\u9700\u8981\u597d\u540e\u7f00\u89c4\u5219\u3002 \u597d\u540e\u7f00 \u00b6 \u56e0\u4e3aT\u4e0eP\u7684\u5339\u914d\u662f\u4ece\u5de6\u5230\u53f3\uff08\u79fb\u52a8\u65b9\u5411\u4e00\u76f4\u662f\u5411\u53f3\uff09\uff0c\u5f53\u51fa\u73b0\u574f\u5b57\u7b26\u65f6\uff0cP\u7684\u540e\u534a\u90e8\u5206\uff08\u5982\u679c\u6709\uff09\u4e00\u5b9a\u662f\u5339\u914d\u597d\u7684\uff0c\u8fd9\u90e8\u5206\u53eb\u505a\u597d\u540e\u7f00\u3002 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06P\u7684\u597d\u540e\u7f00\u5339\u914d\u7684\u524d\u7f00\u90e8\u5206\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u7684\u90e8\u5206\uff08\u540e\u7f00\uff09\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06\u90e8\u5206\u540e\u7f00\uff08P\u524d\u7f00\u4e2d\u7684\uff09\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u6ca1\u6709\u51fa\u73b0\uff0c\u5c06P\u6574\u4f53\u79fb\u52a8lenP\uff08P\u7684\u957f\u5ea6\uff09 \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \u597d\u540e\u7f00\u7684\u6784\u9020 \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} k\u8868\u793a\u597d\u540e\u7f00\u7684\u957f\u5ea6\uff08\u4ece1\u5f00\u59cb\uff09\uff0cpos\u8868\u793a\u597d\u540e\u7f00\u5728\u524d\u7f00\u51fa\u73b0\u7684\u4f4d\u7f6e\uff08\u82e5\u4e0d\u5b58\u5728\u4e3a-1\uff09, T/F\u8868\u793a\u957f\u5ea6\u4e3ak\u7684\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u4f8b\u5982 \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \u574f\u5b57\u7b26\u4e0e\u597d\u540e\u7f00\u7ec4\u5408 \u00b6 \u5206\u522b\u8ba1\u7b97\u4e24\u79cd\u89c4\u5219\u4e0b\u79fb\u52a8\u7684\u8ddd\u79bb\uff0c\u53d6\u8f83\u5927\u8005\u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m + \\Sigma) O(m + \\Sigma) \uff1b\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u6700\u597d\u60c5\u51b5\u4e0b O(\\frac{n}{m}) O(\\frac{n}{m}) \uff0c\u6700\u5dee\u60c5\u51b5\u4e0b O(n+m) O(n+m) \u300cBoyerMoore\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BoyerMoore { vector < int > bc ; vector < int > suffix ; bool * prefix ; string T , P ; int nT , nP ; public : const int N = 256 ; BoyerMoore ( string text , string pattern ) { T = text ; P = pattern ; nT = ( int ) T . length (); nP = ( int ) P . length (); } ~ BoyerMoore () { delete [] prefix ; } void buildBadCharacter () { bc . resize ( N , - 1 ); for ( int i = 0 ; i < nP ; i ++ ) { bc [ P [ i ]] = i ; } } void buildGoodSuffix () { suffix . resize ( nP , - 1 ); prefix = new bool [ nP ]{}; for ( int i = 0 ; i < nP - 1 ; i ++ ) { // k\u4ee3\u8868\u540e\u7f00\u7684\u957f\u5ea6 int j = i , k = 0 ; while ( j >= 0 && P [ j ] == P [ nP - 1 - k ]) { k ++ ; j -- ; suffix [ k ] = j + 1 ; } if ( j == - 1 ) { prefix [ k ] = true ; } } } int stepsToMoveWithGoodSuffix ( int idxBC ) { int k = nP - idxBC - 1 ; if ( k == 0 ) { return 0 ; } if ( suffix [ k ] != - 1 ) { return idxBC - suffix [ k ] + 1 ; } for ( int i = k - 1 ; i > 0 ; i -- ) { if ( prefix [ i ]) { return nP - i - suffix [ i ]; } } return nP ; } vector < int > match () { buildBadCharacter (); buildGoodSuffix (); vector < int > ans ; int k = nP - 1 ; while ( k < nT ) { int i = k , j = nP - 1 ; while ( j >= 0 && T [ i ] == P [ j ]) { i -- ; j -- ; } if ( j == - 1 ) { ans . emplace_back ( i + 1 ); k ++ ; continue ; } int stepsWithBC = nP - 1 - bc [ T [ i ]] - ( k - i ); int stepsWithGS = stepsToMoveWithGoodSuffix ( j ); k += max ( stepsWithBC , stepsWithGS ); } return ans ; } bool isMatch () { return ! match (). empty (); } }; /* string T = \"ababab\", P = \"abab\"; // aaabaaabbbabaa,babb: -1 // ababbbbaaabbbaaa,bbbb: 3 BoyerMoore bm(T, P); vector<int> pos = bm.match(); // [0 2] */ Rabin-Karp \u00b6 \u5229\u7528\u54c8\u5e0c\u7684\u65b9\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u6210\u4e00\u4e2a\u6570\u3002\u7531\u6b64\uff0c\u4e24\u5b57\u7b26\u4e32\u4e4b\u95f4\u7684\u6bd4\u8f83\u8f6c\u5316\u4e3a\u4e24\u6570\u5b57\u7684\u6bd4\u8f83\u3002\u5982\u679c\u51fa\u73b0\u6563\u5217\u51b2\u7a81\uff0c\u9010\u4e00\u6bd4\u8f83\u4e24\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u3002 \u300cRabin-Karp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } int key = 0 , value = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { key += P [ i ]; value += T [ i ]; } key += P [ m - 1 ]; for ( int i = m - 1 , j = - 1 ; i < n ; i ++ ) { value += T [ i ]; if ( j >= 0 ) { value -= T [ j ]; } j ++ ; if ( value == key ) { int x = j , y = 0 ; while ( x <= i && y < m && T [ x ] == P [ y ]) { x ++ ; y ++ ; } if ( y == m ) { return j ; } } } return - 1 ; } int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } for ( int i = 0 ; i <= n - m ; i ++ ) { if ( T . substr ( i , m ) == P ) { return i ; } } return - 1 ; }","title":"\u5b57\u7b26\u4e32"},{"location":"data-structure/string/#_1","text":"","title":"\u5339\u914d"},{"location":"data-structure/string/#kmp","text":"KMP\u8bb2\u6c42\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u5339\u914d\uff0c\u5f53\u51fa\u73b0\u8bef\u5339\u914d\u7684\u5b57\u7b26\u65f6\uff0c\u5c06\u6a21\u5f0f\u4e32P\u5411\u53f3\u79fb\u52a8\u82e5\u5e72\u8ddd\u79bb\u3002KMP\u501f\u52a9P\u7684\u524d\u7f00\uff08\u5386\u53f2\u5339\u914d\u4fe1\u606f\uff09\u6784\u5efanext\u6570\u7ec4\u3002\u5c06P\u524d\u7f00\u4e2d\u4e0e\u5931\u914d\u5b57\u7b26\u524d\u6700\u5927\u91cd\u5408\u7684\u4f4d\u7f6e\u5bf9\u9f50\u3002P\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u53d1\u751f\u5931\u914d\u65f6\uff0c\u5bf9\u5e94\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u8be5\u662f-1\uff0c\u8868\u793a\u5c06\u6574\u4e2aP\u79fb\u52a8\u5230\u5931\u914d\u5b57\u7b26\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002 \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \u4e3a\u4e86\u66f4\u52a0\u9ad8\u6548\u5730\u79fb\u52a8P\uff0cnext\u6570\u7ec4\u8868\u793a\u5730\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u5f53\u5c3d\u53ef\u80fd\u5730\u5c0f \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) , \u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0cm\u662fP\u7684\u957f\u5ea6\uff0cn\u662fT\u7684\u957f\u5ea6 \u300cLeetcode 28. \u5b9e\u73b0 strStr()\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahaystack = \"hello\", needle = \"ll\" \u8f93\u51fa\uff1a2 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahaystack = \"aaaaa\", needle = \"bba\" \u8f93\u51fa\uff1a-1 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahaystack = \"\", needle = \"\" \u8f93\u51fa\uff1a0 */ int strStr ( string haystack , string needle ) { int n = ( int ) haystack . length (), m = ( int ) needle . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } vector < int > next ( m , - 1 ); int j = 0 , k = - 1 ; while ( j < m - 1 ) { if ( k < 0 || needle [ j ] == needle [ k ]) { j ++ ; k ++ ; next [ j ] = needle [ j ] != needle [ k ] ? k : next [ k ]; } else { k = next [ k ]; } } int i = 0 ; j = 0 ; while ( i < n && j < m ) { if ( j < 0 || haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } return i - j > n - m ? - 1 : i - j ; } \u300cLeetcode 214. \u6700\u77ed\u56de\u6587\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u5728\u5b57\u7b26\u4e32\u524d\u9762\u6dfb\u52a0\u5b57\u7b26\u5c06\u5176\u8f6c\u6362\u4e3a\u56de\u6587\u4e32\u3002 \u627e\u5230\u5e76\u8fd4\u56de\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f\u8f6c\u6362\u7684\u6700\u77ed\u56de\u6587\u4e32\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1as = \"aacecaaa\" \u8f93\u51fa\uff1a\"aaacecaaa\" \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1as = \"abcd\" \u8f93\u51fa\uff1a\"dcbabcd\" */ string shortestPalindrome ( string s ) { int n = ( int ) s . length (); if ( n <= 1 ) { return s ; } vector < int > next ( n , - 1 ); int i = 0 , pos = - 1 ; while ( i < n - 1 ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i ++ ; pos ++ ; next [ i ] = s [ i ] != s [ pos ] ? pos : next [ pos ]; } else { pos = next [ pos ]; } } pos = 0 ; i = n - 1 ; while ( i >= 0 && pos < n ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i -- ; pos ++ ; } else { pos = next [ pos ]; } } string ans = s . substr ( pos , n - pos ); reverse ( ans . begin (), ans . end ()); return ans + s ; }","title":"KMP"},{"location":"data-structure/string/#boyer-moore","text":"","title":"Boyer-Moore"},{"location":"data-structure/string/#_2","text":"\u5f53\u6a21\u5f0f\u4e32P\u4e0e\u6587\u672c\u4e32T\u5728\u67d0\u4ee5\u4f4d\u7f6epos\u53d1\u751f\u4e0d\u5339\u914d\u65f6\uff0cT[pos]\u53eb\u505a\u574f\u5b57\u7b26\u3002 1.1 \u574f\u5b57\u7b26\u54c8\u5e0c\u8868\u7684\u6784\u9020\uff0c\u4e00\u904d\u626b\u63cf\u5c06P\u4e2d\u7684\u5b57\u7b26\u4f4d\u7f6e\u4fdd\u5b58\u5728\u5b57\u5178\u4e2d\uff0ckey\u4e3a\u5b57\u7b26\u672c\u8eab\uff0cvalue\u4e3a\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u3002 1.2 \u5f53\u574f\u5b57\u7b26\u4e0d\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06\u6a21\u5f0f\u4e32\u5168\u90e8\u79fb\u52a8\u5230\u574f\u5b57\u7b26\u540e\u4e00\u4f4d \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} 1.3 \u5f53\u574f\u5b57\u7b26\u51fa\u73b0\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06P\u4e2d\u6700\u8fd1\u7684\u5b57\u7b26\u4e0eT\u4e2d\u7684\u574f\u5b57\u7b26\u5bf9\u5e94 \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \u4f46\u662f\u5982\u679c\u574f\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u5927\u4e8e\u4e0d\u5339\u914d\u7684\u4f4d\u7f6ej\u65f6\uff0c\u79fb\u52a8\u7684\u8ddd\u79bb\u662f\u8d1f\u6570 \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0cBM\u8fd8\u9700\u8981\u597d\u540e\u7f00\u89c4\u5219\u3002","title":"\u574f\u5b57\u7b26"},{"location":"data-structure/string/#_3","text":"\u56e0\u4e3aT\u4e0eP\u7684\u5339\u914d\u662f\u4ece\u5de6\u5230\u53f3\uff08\u79fb\u52a8\u65b9\u5411\u4e00\u76f4\u662f\u5411\u53f3\uff09\uff0c\u5f53\u51fa\u73b0\u574f\u5b57\u7b26\u65f6\uff0cP\u7684\u540e\u534a\u90e8\u5206\uff08\u5982\u679c\u6709\uff09\u4e00\u5b9a\u662f\u5339\u914d\u597d\u7684\uff0c\u8fd9\u90e8\u5206\u53eb\u505a\u597d\u540e\u7f00\u3002 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06P\u7684\u597d\u540e\u7f00\u5339\u914d\u7684\u524d\u7f00\u90e8\u5206\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u7684\u90e8\u5206\uff08\u540e\u7f00\uff09\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06\u90e8\u5206\u540e\u7f00\uff08P\u524d\u7f00\u4e2d\u7684\uff09\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u6ca1\u6709\u51fa\u73b0\uff0c\u5c06P\u6574\u4f53\u79fb\u52a8lenP\uff08P\u7684\u957f\u5ea6\uff09 \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \u597d\u540e\u7f00\u7684\u6784\u9020 \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} k\u8868\u793a\u597d\u540e\u7f00\u7684\u957f\u5ea6\uff08\u4ece1\u5f00\u59cb\uff09\uff0cpos\u8868\u793a\u597d\u540e\u7f00\u5728\u524d\u7f00\u51fa\u73b0\u7684\u4f4d\u7f6e\uff08\u82e5\u4e0d\u5b58\u5728\u4e3a-1\uff09, T/F\u8868\u793a\u957f\u5ea6\u4e3ak\u7684\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u4f8b\u5982 \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned}","title":"\u597d\u540e\u7f00"},{"location":"data-structure/string/#_4","text":"\u5206\u522b\u8ba1\u7b97\u4e24\u79cd\u89c4\u5219\u4e0b\u79fb\u52a8\u7684\u8ddd\u79bb\uff0c\u53d6\u8f83\u5927\u8005\u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m + \\Sigma) O(m + \\Sigma) \uff1b\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u6700\u597d\u60c5\u51b5\u4e0b O(\\frac{n}{m}) O(\\frac{n}{m}) \uff0c\u6700\u5dee\u60c5\u51b5\u4e0b O(n+m) O(n+m) \u300cBoyerMoore\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BoyerMoore { vector < int > bc ; vector < int > suffix ; bool * prefix ; string T , P ; int nT , nP ; public : const int N = 256 ; BoyerMoore ( string text , string pattern ) { T = text ; P = pattern ; nT = ( int ) T . length (); nP = ( int ) P . length (); } ~ BoyerMoore () { delete [] prefix ; } void buildBadCharacter () { bc . resize ( N , - 1 ); for ( int i = 0 ; i < nP ; i ++ ) { bc [ P [ i ]] = i ; } } void buildGoodSuffix () { suffix . resize ( nP , - 1 ); prefix = new bool [ nP ]{}; for ( int i = 0 ; i < nP - 1 ; i ++ ) { // k\u4ee3\u8868\u540e\u7f00\u7684\u957f\u5ea6 int j = i , k = 0 ; while ( j >= 0 && P [ j ] == P [ nP - 1 - k ]) { k ++ ; j -- ; suffix [ k ] = j + 1 ; } if ( j == - 1 ) { prefix [ k ] = true ; } } } int stepsToMoveWithGoodSuffix ( int idxBC ) { int k = nP - idxBC - 1 ; if ( k == 0 ) { return 0 ; } if ( suffix [ k ] != - 1 ) { return idxBC - suffix [ k ] + 1 ; } for ( int i = k - 1 ; i > 0 ; i -- ) { if ( prefix [ i ]) { return nP - i - suffix [ i ]; } } return nP ; } vector < int > match () { buildBadCharacter (); buildGoodSuffix (); vector < int > ans ; int k = nP - 1 ; while ( k < nT ) { int i = k , j = nP - 1 ; while ( j >= 0 && T [ i ] == P [ j ]) { i -- ; j -- ; } if ( j == - 1 ) { ans . emplace_back ( i + 1 ); k ++ ; continue ; } int stepsWithBC = nP - 1 - bc [ T [ i ]] - ( k - i ); int stepsWithGS = stepsToMoveWithGoodSuffix ( j ); k += max ( stepsWithBC , stepsWithGS ); } return ans ; } bool isMatch () { return ! match (). empty (); } }; /* string T = \"ababab\", P = \"abab\"; // aaabaaabbbabaa,babb: -1 // ababbbbaaabbbaaa,bbbb: 3 BoyerMoore bm(T, P); vector<int> pos = bm.match(); // [0 2] */","title":"\u574f\u5b57\u7b26\u4e0e\u597d\u540e\u7f00\u7ec4\u5408"},{"location":"data-structure/string/#rabin-karp","text":"\u5229\u7528\u54c8\u5e0c\u7684\u65b9\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u6210\u4e00\u4e2a\u6570\u3002\u7531\u6b64\uff0c\u4e24\u5b57\u7b26\u4e32\u4e4b\u95f4\u7684\u6bd4\u8f83\u8f6c\u5316\u4e3a\u4e24\u6570\u5b57\u7684\u6bd4\u8f83\u3002\u5982\u679c\u51fa\u73b0\u6563\u5217\u51b2\u7a81\uff0c\u9010\u4e00\u6bd4\u8f83\u4e24\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u3002 \u300cRabin-Karp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } int key = 0 , value = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { key += P [ i ]; value += T [ i ]; } key += P [ m - 1 ]; for ( int i = m - 1 , j = - 1 ; i < n ; i ++ ) { value += T [ i ]; if ( j >= 0 ) { value -= T [ j ]; } j ++ ; if ( value == key ) { int x = j , y = 0 ; while ( x <= i && y < m && T [ x ] == P [ y ]) { x ++ ; y ++ ; } if ( y == m ) { return j ; } } } return - 1 ; } int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } for ( int i = 0 ; i <= n - m ; i ++ ) { if ( T . substr ( i , m ) == P ) { return i ; } } return - 1 ; }","title":"Rabin-Karp"},{"location":"data-structure/unionset/","text":"\u7b80\u4ecb \u00b6 \u5e76\u67e5\u96c6\u662f\u4e00\u79cd\u6811\u5f62\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u8981\u5904\u7406\u4e0d\u4ea4\u96c6\u7684\u67e5\u8be2\u548c\u5408\u5e76\u95ee\u9898\uff0c\u5b83\u6709\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff1a \u67e5\u627e\uff08Find\uff09\uff1a\u786e\u5b9a\u5f53\u524d\u7ed3\u70b9\u5c5e\u4e8e\u54ea\u4e00\u4e2a\u96c6\u5408 \u5408\u5e76\uff08Union\uff09\uff1a\u5c06\u4e24\u4e2a\u4e0d\u540c\u7684\u96c6\u5408\u5408\u5e76\u5728\u4e00\u8d77 \u6211\u4eec\u901a\u5e38\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4 fa[ x ] \uff0c\u4e0b\u6807 x \u4ee3\u8868\u67d0\u4e00\u4e2a\u7ed3\u70b9\uff0cfa[ x ] \u8868\u793a\u8fd9\u4e2a\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u3002 \u539f\u7406 \u00b6 \u521d\u59cb\u5316 \u00b6 \u8d77\u59cb\u72b6\u6001\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u662f\u81ea\u6210\u4e00\u4e2a\u96c6\u5408 1 2 3 for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } \u67e5\u627e \u00b6 \u6211\u4eec\u5e0c\u671b\u5728\u8fd9\u4e00\u6b65\u53ef\u4ee5\u5feb\u901f\u5730\u627e\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u6839\u7ed3\u70b9 1 2 3 int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } \u8fd9\u91cc\u7528\u5230\u4e86 \u8def\u5f84\u538b\u7f29 \u7684\u65b9\u6cd5\u3002\u5728\u5bfb\u627e\u6839\u7ed3\u70b9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c06\u6240\u6709\u7684\u5b50\u8282\u70b9\u8fde\u63a5\u5230\u6839\u7ed3\u70b9\u3002 \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix} \u5408\u5e76 \u00b6 \u7531\u4e8e\u67d0\u4e9b\u7ea6\u675f\uff0c\u4e24\u4e2a\u539f\u672c\u4e0d\u76f8\u4ea4\u7684\u96c6\u5408\u53d1\u751f\u4e86\u8054\u7cfb\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u9700\u8981\u5c06\u5176\u4e2d\u7684\u4e00\u4e2a\u96c6\u5408\u5408\u5e76\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u3002 \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} 1 2 3 void Union ( int x , int y ) { fa [ find ( x )] = find ( y ); } \u8fd9\u91cc\u6211\u4eec\u5904\u7406\u5730\u6bd4\u8f83\u7b80\u5355\uff0c\u5c06\u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u5f53\u4f5c\u53e6\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u7684\u5b69\u5b50\u3002\u5982\u679c\u6211\u4eec\u8003\u8651\u5c06\u6df1\u5ea6\u5c0f\u7684\u6811\u5408\u5e76\u5230\u6df1\u5ea6\u8f83\u5927\u7684\u6811\u4e0b\uff0c\u67e5\u8be2\u6548\u7387\u4f1a\u63d0\u9ad8\u3002\u8fd9\u79cd\u65b9\u6cd5\u6211\u4eec\u79f0\u4e4b\u4e3a \u6309\u79e9\u5408\u5e76 \u3002 1 2 3 4 5 6 7 8 9 10 11 void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } \u5f53\u7136\uff0c\u9664\u4e86\u6309\u7167\u6df1\u5ea6\u5408\u5e76\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u6309\u7167\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u5408\u5e76\u3002\u56e0\u4e3a\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u548c\u6df1\u5ea6\u4e0d\u603b\u4f1a\u51fa\u73b0\u7684\u540c\u4e00\u4fa7\uff08\u5373\u4e00\u4e2a\u96c6\u5408\u7684\u7ed3\u70b9\u6570\u76ee\u591a\u4e14\u6df1\u5ea6\u5927\uff09\uff0c\u6211\u4eec\u901a\u5e38\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u4f5c\u4e3a\u5408\u5e76\u7684\u4f9d\u636e\u3002 \u9898\u76ee \u00b6 \u670b\u53cb\u5708\u95ee\u9898 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a n \\times n n \\times n \u7684\u77e9\u9635 friends\uff0cfriends[ i ][ j ] = 1 \u8868\u793a i \u548c j \u4e3a\u670b\u53cb\uff0c\u53cd\u4e4b\uff0c\u8868\u793a\u975e\u670b\u53cb\uff0c\u6839\u636e\u8fd9\u4e2a\u77e9\u9635\u627e\u51fa\u5f53\u524d\u8fd9 n \u4e2a\u4eba\u4e2d\u6709\u51e0\u4e2a\u670b\u53cb\u5708\u3002\u4f8b\u5982\uff0cA \u4e0e B \u662f\u670b\u53cb\uff0cB \u4e0e C \u662f\u670b\u53cb\uff0c\u90a3\u4e48A\u3001B\u3001C \u662f\u4e00\u4e2a\u670b\u53cb\u5708\u7684\uff0c\u5373\u4fbf\u662fA \u4e0e C \u4e0d\u662f\u670b\u53cb\u3002 \u300c\u5206\u6790\u300d \u8fd9\u662f\u5178\u578b\u7684\u5e76\u67e5\u96c6\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u5c06\u6bcf\u4e00\u4e2a\u4eba\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u670b\u53cb\u5708\uff0c\u5982\u679c\u4e24\u4eba\u662f\u670b\u53cb\u5c31\u5c06\u8fd9\u4e24\u4eba\u6240\u5728\u7684\u96c6\u5408\u5408\u5e76\uff0c\u6700\u7ec8\u53ea\u9700\u8981\u7edf\u8ba1 fa[ i ] == i \u7684\u4e2a\u6570\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > fa , dep ; int find ( int x ) { if ( x != fa [ x ]) { fa [ x ] = find ( fa [ x ]); dep [ x ] = 1 ; } dep [ fa [ x ]] = 2 ; return fa [ x ]; } void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } int findCircleNum ( vector < vector < int >>& isConnected ) { int n = ( int ) isConnected . size (); if ( n < 2 ) { return n ; } fa . resize ( n , 0 ); dep . resize ( n , 1 ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isConnected [ i ][ j ]) { unify ( i , j ); } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i == fa [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2} \\log n) O(n^{2} \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u6309\u7167\u516c\u56e0\u6570\u5206\u7fa4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [20, 50, 9, 63]\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u6709\u5927\u4e8e 1 \u7684\u516c\u56e0\u6570\uff0c\u8fd9\u4e24\u4e2a\u6570\u5c5e\u4e8e\u540c\u4e00\u4e2a\u7fa4\uff0c\u7fa4\u6210\u5458\u6570\u76ee\u6700\u591a\u662f\u591a\u5c11\uff1f\u7ed9\u51fa\u7684\u4f8b\u5b50\u662f 2\u3002 \u300c\u5206\u6790\u300d \u3010\u56e0\u5b50\u5206\u89e3 + \u5e76\u67e5\u96c6\u3011\u3002\u5c06\u6bcf\u4e00\u4e2a\u6570\u4e0e\u5176\u8d28\u56e0\u5b50\u5212\u5206\u5230\u540c\u4e00\u4e2a\u7fa4\uff0cnums \u4e2d\u7684\u6570\u53ef\u4ee5\u901a\u8fc7\u5171\u540c\u7684\u8d28\u56e0\u5b50\u8fde\u63a5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 vector < int > fa ; int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } int largestComponentSize ( vector < int >& nums ) { int n = * max_element ( nums . begin (), nums . end ()); fa . resize ( n + 1 ); for ( int i = 0 ; i <= n ; i ++ ) { fa [ i ] = i ; } for ( int num : nums ) { for ( int prime = 2 ; prime <= ( int ) sqrt ( num ); prime ++ ) { if ( num % prime == 0 ) { unify ( num , prime ); unify ( num , num / prime ); } } } vector < int > cnt ( n + 1 , 0 ); for ( int num : nums ) { cnt [ find ( num )] ++ ; } return * max_element ( cnt . begin (), cnt . end ()); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\sqrt{n}) O(n \\sqrt{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f nums \u5217\u8868\u4e2d\u7684\u6700\u5927\u503c\u3002 \u6309\u516c\u56e0\u5b50\u6392\u5e8f\u6570\u7ec4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [7, 21, 3]\uff0c\u5982\u679c\u4e24\u4e2a\u5143\u7d20\u7684\u5171\u56e0\u5b50\u5927\u4e8e 1\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u4ea4\u6362\uff0c\u8bd5\u95ee\uff0c\u80fd\u5426\u6700\u7ec8\u5f97\u5230\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\uff1f \u300c\u5206\u6790\u300d \u3010\u5e76\u67e5\u96c6\u3011\u5982\u679c a \u548c b \u53ef\u4ea4\u6362\uff0cb \u548c c \u53ef\u4ea4\u6362\uff0c\u90a3\u4e48 a \u548c c \u53ef\u4ea4\u6362\u3002\u56e0\u6b64\uff0c\u540c\u4e00\u4e2a\u96c6\u5408\u7684\u5143\u7d20\u4efb\u610f\u4ea4\u6362\uff0c\u5373\u53ef\u5f97\u5230\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\u3002\u6211\u4eec\u501f\u52a9\u4e00\u4e2a\u6570\u4e0e\u5b83\u7684\u6240\u6709\u56e0\u5b50\uff0c\u6784\u9020\u5e76\u67e5\u96c6\uff0c\u8fd9\u6837\u907f\u514d O(n^{2}) O(n^{2}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u6700\u7ec8\uff0c\u6211\u4eec\u7528\u6392\u5e8f\u597d\u7684\u6570\u7ec4\u4e0e\u4e3a\u6392\u5e8f\u7684\u6570\u7ec4\u9010\u4e00\u6bd4\u8f83\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u5b57\u4e0d\u5c5e\u4e8e\u540c\u4e00\u4e2a\u96c6\u5408\uff0c\u90a3\u4e48 nums \u662f\u4e0d\u80fd\u6709\u5e8f\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 vector < int > fa ; int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } bool gcdSort ( vector < int >& nums ) { int n = * max_element ( nums . begin (), nums . end ()) + 1 ; fa . resize ( n ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int num : nums ) { for ( int prime = 2 ; prime <= ( int ) sqrt ( num ); prime ++ ) { if ( num % prime == 0 ) { unify ( num , prime ); unify ( num , num / prime ); } } } vector < int > sortedNums = nums ; sort ( sortedNums . begin (), sortedNums . end ()); for ( int i = 0 ; i < ( int ) nums . size (); i ++ ) { if ( nums [ i ] == sortedNums [ i ]) { continue ; } if ( find ( nums [ i ]) != find ( sortedNums [ i ])) { return false ; } } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(m \\sqrt{m}) O(m \\sqrt{m}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) \uff0c\u5176\u4e2d m \u662f nums \u4e2d\u7684\u6700\u5927\u503c \u60c5\u4fa3\u7275\u624b \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 row = [5, 4, 2, 6, 3, 1, 0, 7]\uff0c\u8868\u793a N \u5bf9\u60c5\u4fa3\uff0c(2 * i, 2 * i + 1) \u662f\u60c5\u4fa3\uff0c\u6709\u4e9b\u60c5\u4fa3\u6ca1\u6709\u76f8\u90bb\u5750\u5728\u4e00\u8d77\uff0c\u6211\u4eec\u53ef\u4ee5\u4efb\u610f\u8c03\u6362\u4e24\u4e2a\u4eba\u7684\u5ea7\u4f4d\uff0c\u6765\u4f7f\u5f97\u60c5\u4fa3\u5750\u5230\u4e00\u8d77\u3002\u8bd5\u95ee\uff0c\u6700\u5c11\u8c03\u6362\u591a\u5c11\u6b21\u5ea7\u4f4d\uff1f \u300c\u5206\u6790\u300d \u3010\u5e76\u67e5\u96c6\u30112i \u548c 2i + 1\uff0c\u662f\u4e00\u5bf9\u60c5\u4fa3\uff0c\u5c5e\u4e8e\u4e00\u4e2a\u96c6\u5408\u3002\u5982\u679c\u6709\u4eba\u5750\u9519\u4e86\u4f4d\u7f6e\uff0c\u5982\u4e09\u5bf9\u60c5\u4fa3 a1 b1 c2 b2 a2 c1\uff0c\u6211\u4eec\u9700\u8c03\u6574\u4e24\u6b21\u624d\u80fd\u56de\u5f52\u6b63\u5e38\u3002\u6211\u4eec\u7edf\u8ba1\u6240\u6709\u7684\u5750\u9519\u4f4d\u7f6e\u7684\u60c5\u4fa3\u96c6\u5408\uff0c\u7136\u540e\u60c5\u4fa3\u6570\u51cf\u53bb\u8fde\u901a\u5206\u91cf\u6570\u76ee\u5373\u4e3a\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 vector < int > fa ; int find ( int x ) { return x == fa [ x ] ? x : fa [ x ] = find ( fa [ x ]); } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } int minSwapsCouples ( vector < int >& row ) { int n = ( int ) row . size () / 2 , cnt = 0 ; fa . resize ( n ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { unify ( row [ 2 * i ] / 2 , row [ 2 * i + 1 ] / 2 ); } for ( int i = 0 ; i < n ; i ++ ) { cnt += ( i == find ( i )); } return n - cnt ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u4e8c\u5206\u56fe \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u56fe graph = [[1, 2], [0, 3], [0], [1]]\uff0c\u7b2c i \u884c\u5c31\u662f\u8282\u70b9 i \u76f8\u8fde\u63a5\u7684\u8282\u70b9\u53f7\u7801 \uff08i \u4ece 0 \u5f00\u59cb\uff09\uff0c\u5224\u65ad\u80fd\u5426\u5c06\u6240\u6709\u8282\u70b9\u5206\u6210\u4e24\u4e2a\u96c6\u5408\uff0c\u540c\u4e00\u4e2a\u96c6\u5408\u7684\u8282\u70b9\u6ca1\u6709\u76f8\u90bb\u7684\u8fb9\u3002 \u300c\u5206\u6790\u300d \u3010\u5e76\u67e5\u96c6\u3011\u5982\u679c\u8282\u70b9 i \u7684\u76f8\u90bb\u8282\u70b9\u4e3a neighbors\uff0c\u90a3\u4e48 i \u4e0e neighbor \u4e2d\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u4e0d\u5c5e\u4e8e\u540c\u4e00\u4e2a\u96c6\u5408\uff0c\u7531\u6b64\u63a8\u51fa\uff0cneighbor \u4e2d\u7684\u6240\u6709\u8282\u70b9\u5728\u540c\u4e00\u4e2a\u96c6\u5408 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 vector < int > fa ; int find ( int x ) { return x == fa [ x ] ? x : fa [ x ] = find ( fa [ x ]); } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } bool isBipartite ( vector < vector < int >>& graph ) { size_t n = graph . size (); fa . resize ( n ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j : graph [ i ]) { if ( find ( i ) == find ( j )) { return false ; } unify ( graph [ i ][ 0 ], j ); } } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2} \\log n) O(n^{2} \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u5e76\u67e5\u96c6"},{"location":"data-structure/unionset/#_1","text":"\u5e76\u67e5\u96c6\u662f\u4e00\u79cd\u6811\u5f62\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u8981\u5904\u7406\u4e0d\u4ea4\u96c6\u7684\u67e5\u8be2\u548c\u5408\u5e76\u95ee\u9898\uff0c\u5b83\u6709\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff1a \u67e5\u627e\uff08Find\uff09\uff1a\u786e\u5b9a\u5f53\u524d\u7ed3\u70b9\u5c5e\u4e8e\u54ea\u4e00\u4e2a\u96c6\u5408 \u5408\u5e76\uff08Union\uff09\uff1a\u5c06\u4e24\u4e2a\u4e0d\u540c\u7684\u96c6\u5408\u5408\u5e76\u5728\u4e00\u8d77 \u6211\u4eec\u901a\u5e38\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4 fa[ x ] \uff0c\u4e0b\u6807 x \u4ee3\u8868\u67d0\u4e00\u4e2a\u7ed3\u70b9\uff0cfa[ x ] \u8868\u793a\u8fd9\u4e2a\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/unionset/#_2","text":"","title":"\u539f\u7406"},{"location":"data-structure/unionset/#_3","text":"\u8d77\u59cb\u72b6\u6001\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u662f\u81ea\u6210\u4e00\u4e2a\u96c6\u5408 1 2 3 for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; }","title":"\u521d\u59cb\u5316"},{"location":"data-structure/unionset/#_4","text":"\u6211\u4eec\u5e0c\u671b\u5728\u8fd9\u4e00\u6b65\u53ef\u4ee5\u5feb\u901f\u5730\u627e\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u6839\u7ed3\u70b9 1 2 3 int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } \u8fd9\u91cc\u7528\u5230\u4e86 \u8def\u5f84\u538b\u7f29 \u7684\u65b9\u6cd5\u3002\u5728\u5bfb\u627e\u6839\u7ed3\u70b9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c06\u6240\u6709\u7684\u5b50\u8282\u70b9\u8fde\u63a5\u5230\u6839\u7ed3\u70b9\u3002 \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix}","title":"\u67e5\u627e"},{"location":"data-structure/unionset/#_5","text":"\u7531\u4e8e\u67d0\u4e9b\u7ea6\u675f\uff0c\u4e24\u4e2a\u539f\u672c\u4e0d\u76f8\u4ea4\u7684\u96c6\u5408\u53d1\u751f\u4e86\u8054\u7cfb\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u9700\u8981\u5c06\u5176\u4e2d\u7684\u4e00\u4e2a\u96c6\u5408\u5408\u5e76\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u3002 \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} 1 2 3 void Union ( int x , int y ) { fa [ find ( x )] = find ( y ); } \u8fd9\u91cc\u6211\u4eec\u5904\u7406\u5730\u6bd4\u8f83\u7b80\u5355\uff0c\u5c06\u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u5f53\u4f5c\u53e6\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u7684\u5b69\u5b50\u3002\u5982\u679c\u6211\u4eec\u8003\u8651\u5c06\u6df1\u5ea6\u5c0f\u7684\u6811\u5408\u5e76\u5230\u6df1\u5ea6\u8f83\u5927\u7684\u6811\u4e0b\uff0c\u67e5\u8be2\u6548\u7387\u4f1a\u63d0\u9ad8\u3002\u8fd9\u79cd\u65b9\u6cd5\u6211\u4eec\u79f0\u4e4b\u4e3a \u6309\u79e9\u5408\u5e76 \u3002 1 2 3 4 5 6 7 8 9 10 11 void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } \u5f53\u7136\uff0c\u9664\u4e86\u6309\u7167\u6df1\u5ea6\u5408\u5e76\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u6309\u7167\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u5408\u5e76\u3002\u56e0\u4e3a\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u548c\u6df1\u5ea6\u4e0d\u603b\u4f1a\u51fa\u73b0\u7684\u540c\u4e00\u4fa7\uff08\u5373\u4e00\u4e2a\u96c6\u5408\u7684\u7ed3\u70b9\u6570\u76ee\u591a\u4e14\u6df1\u5ea6\u5927\uff09\uff0c\u6211\u4eec\u901a\u5e38\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u4f5c\u4e3a\u5408\u5e76\u7684\u4f9d\u636e\u3002","title":"\u5408\u5e76"},{"location":"data-structure/unionset/#_6","text":"","title":"\u9898\u76ee"},{"location":"data-structure/unionset/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a n \\times n n \\times n \u7684\u77e9\u9635 friends\uff0cfriends[ i ][ j ] = 1 \u8868\u793a i \u548c j \u4e3a\u670b\u53cb\uff0c\u53cd\u4e4b\uff0c\u8868\u793a\u975e\u670b\u53cb\uff0c\u6839\u636e\u8fd9\u4e2a\u77e9\u9635\u627e\u51fa\u5f53\u524d\u8fd9 n \u4e2a\u4eba\u4e2d\u6709\u51e0\u4e2a\u670b\u53cb\u5708\u3002\u4f8b\u5982\uff0cA \u4e0e B \u662f\u670b\u53cb\uff0cB \u4e0e C \u662f\u670b\u53cb\uff0c\u90a3\u4e48A\u3001B\u3001C \u662f\u4e00\u4e2a\u670b\u53cb\u5708\u7684\uff0c\u5373\u4fbf\u662fA \u4e0e C \u4e0d\u662f\u670b\u53cb\u3002 \u300c\u5206\u6790\u300d \u8fd9\u662f\u5178\u578b\u7684\u5e76\u67e5\u96c6\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u5c06\u6bcf\u4e00\u4e2a\u4eba\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u670b\u53cb\u5708\uff0c\u5982\u679c\u4e24\u4eba\u662f\u670b\u53cb\u5c31\u5c06\u8fd9\u4e24\u4eba\u6240\u5728\u7684\u96c6\u5408\u5408\u5e76\uff0c\u6700\u7ec8\u53ea\u9700\u8981\u7edf\u8ba1 fa[ i ] == i \u7684\u4e2a\u6570\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > fa , dep ; int find ( int x ) { if ( x != fa [ x ]) { fa [ x ] = find ( fa [ x ]); dep [ x ] = 1 ; } dep [ fa [ x ]] = 2 ; return fa [ x ]; } void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } int findCircleNum ( vector < vector < int >>& isConnected ) { int n = ( int ) isConnected . size (); if ( n < 2 ) { return n ; } fa . resize ( n , 0 ); dep . resize ( n , 1 ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isConnected [ i ][ j ]) { unify ( i , j ); } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i == fa [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2} \\log n) O(n^{2} \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u670b\u53cb\u5708\u95ee\u9898"},{"location":"data-structure/unionset/#_8","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [20, 50, 9, 63]\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u6709\u5927\u4e8e 1 \u7684\u516c\u56e0\u6570\uff0c\u8fd9\u4e24\u4e2a\u6570\u5c5e\u4e8e\u540c\u4e00\u4e2a\u7fa4\uff0c\u7fa4\u6210\u5458\u6570\u76ee\u6700\u591a\u662f\u591a\u5c11\uff1f\u7ed9\u51fa\u7684\u4f8b\u5b50\u662f 2\u3002 \u300c\u5206\u6790\u300d \u3010\u56e0\u5b50\u5206\u89e3 + \u5e76\u67e5\u96c6\u3011\u3002\u5c06\u6bcf\u4e00\u4e2a\u6570\u4e0e\u5176\u8d28\u56e0\u5b50\u5212\u5206\u5230\u540c\u4e00\u4e2a\u7fa4\uff0cnums \u4e2d\u7684\u6570\u53ef\u4ee5\u901a\u8fc7\u5171\u540c\u7684\u8d28\u56e0\u5b50\u8fde\u63a5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 vector < int > fa ; int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } int largestComponentSize ( vector < int >& nums ) { int n = * max_element ( nums . begin (), nums . end ()); fa . resize ( n + 1 ); for ( int i = 0 ; i <= n ; i ++ ) { fa [ i ] = i ; } for ( int num : nums ) { for ( int prime = 2 ; prime <= ( int ) sqrt ( num ); prime ++ ) { if ( num % prime == 0 ) { unify ( num , prime ); unify ( num , num / prime ); } } } vector < int > cnt ( n + 1 , 0 ); for ( int num : nums ) { cnt [ find ( num )] ++ ; } return * max_element ( cnt . begin (), cnt . end ()); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\sqrt{n}) O(n \\sqrt{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u5176\u4e2d n \u662f nums \u5217\u8868\u4e2d\u7684\u6700\u5927\u503c\u3002","title":"\u6309\u7167\u516c\u56e0\u6570\u5206\u7fa4"},{"location":"data-structure/unionset/#_9","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums = [7, 21, 3]\uff0c\u5982\u679c\u4e24\u4e2a\u5143\u7d20\u7684\u5171\u56e0\u5b50\u5927\u4e8e 1\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u4ea4\u6362\uff0c\u8bd5\u95ee\uff0c\u80fd\u5426\u6700\u7ec8\u5f97\u5230\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\uff1f \u300c\u5206\u6790\u300d \u3010\u5e76\u67e5\u96c6\u3011\u5982\u679c a \u548c b \u53ef\u4ea4\u6362\uff0cb \u548c c \u53ef\u4ea4\u6362\uff0c\u90a3\u4e48 a \u548c c \u53ef\u4ea4\u6362\u3002\u56e0\u6b64\uff0c\u540c\u4e00\u4e2a\u96c6\u5408\u7684\u5143\u7d20\u4efb\u610f\u4ea4\u6362\uff0c\u5373\u53ef\u5f97\u5230\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\u3002\u6211\u4eec\u501f\u52a9\u4e00\u4e2a\u6570\u4e0e\u5b83\u7684\u6240\u6709\u56e0\u5b50\uff0c\u6784\u9020\u5e76\u67e5\u96c6\uff0c\u8fd9\u6837\u907f\u514d O(n^{2}) O(n^{2}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u6700\u7ec8\uff0c\u6211\u4eec\u7528\u6392\u5e8f\u597d\u7684\u6570\u7ec4\u4e0e\u4e3a\u6392\u5e8f\u7684\u6570\u7ec4\u9010\u4e00\u6bd4\u8f83\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u5b57\u4e0d\u5c5e\u4e8e\u540c\u4e00\u4e2a\u96c6\u5408\uff0c\u90a3\u4e48 nums \u662f\u4e0d\u80fd\u6709\u5e8f\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 vector < int > fa ; int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } bool gcdSort ( vector < int >& nums ) { int n = * max_element ( nums . begin (), nums . end ()) + 1 ; fa . resize ( n ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int num : nums ) { for ( int prime = 2 ; prime <= ( int ) sqrt ( num ); prime ++ ) { if ( num % prime == 0 ) { unify ( num , prime ); unify ( num , num / prime ); } } } vector < int > sortedNums = nums ; sort ( sortedNums . begin (), sortedNums . end ()); for ( int i = 0 ; i < ( int ) nums . size (); i ++ ) { if ( nums [ i ] == sortedNums [ i ]) { continue ; } if ( find ( nums [ i ]) != find ( sortedNums [ i ])) { return false ; } } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(m \\sqrt{m}) O(m \\sqrt{m}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) \uff0c\u5176\u4e2d m \u662f nums \u4e2d\u7684\u6700\u5927\u503c","title":"\u6309\u516c\u56e0\u5b50\u6392\u5e8f\u6570\u7ec4"},{"location":"data-structure/unionset/#_10","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5217\u8868 row = [5, 4, 2, 6, 3, 1, 0, 7]\uff0c\u8868\u793a N \u5bf9\u60c5\u4fa3\uff0c(2 * i, 2 * i + 1) \u662f\u60c5\u4fa3\uff0c\u6709\u4e9b\u60c5\u4fa3\u6ca1\u6709\u76f8\u90bb\u5750\u5728\u4e00\u8d77\uff0c\u6211\u4eec\u53ef\u4ee5\u4efb\u610f\u8c03\u6362\u4e24\u4e2a\u4eba\u7684\u5ea7\u4f4d\uff0c\u6765\u4f7f\u5f97\u60c5\u4fa3\u5750\u5230\u4e00\u8d77\u3002\u8bd5\u95ee\uff0c\u6700\u5c11\u8c03\u6362\u591a\u5c11\u6b21\u5ea7\u4f4d\uff1f \u300c\u5206\u6790\u300d \u3010\u5e76\u67e5\u96c6\u30112i \u548c 2i + 1\uff0c\u662f\u4e00\u5bf9\u60c5\u4fa3\uff0c\u5c5e\u4e8e\u4e00\u4e2a\u96c6\u5408\u3002\u5982\u679c\u6709\u4eba\u5750\u9519\u4e86\u4f4d\u7f6e\uff0c\u5982\u4e09\u5bf9\u60c5\u4fa3 a1 b1 c2 b2 a2 c1\uff0c\u6211\u4eec\u9700\u8c03\u6574\u4e24\u6b21\u624d\u80fd\u56de\u5f52\u6b63\u5e38\u3002\u6211\u4eec\u7edf\u8ba1\u6240\u6709\u7684\u5750\u9519\u4f4d\u7f6e\u7684\u60c5\u4fa3\u96c6\u5408\uff0c\u7136\u540e\u60c5\u4fa3\u6570\u51cf\u53bb\u8fde\u901a\u5206\u91cf\u6570\u76ee\u5373\u4e3a\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 vector < int > fa ; int find ( int x ) { return x == fa [ x ] ? x : fa [ x ] = find ( fa [ x ]); } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } int minSwapsCouples ( vector < int >& row ) { int n = ( int ) row . size () / 2 , cnt = 0 ; fa . resize ( n ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { unify ( row [ 2 * i ] / 2 , row [ 2 * i + 1 ] / 2 ); } for ( int i = 0 ; i < n ; i ++ ) { cnt += ( i == find ( i )); } return n - cnt ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u60c5\u4fa3\u7275\u624b"},{"location":"data-structure/unionset/#_11","text":"\u7ed9\u5b9a\u4e00\u4e2a\u56fe graph = [[1, 2], [0, 3], [0], [1]]\uff0c\u7b2c i \u884c\u5c31\u662f\u8282\u70b9 i \u76f8\u8fde\u63a5\u7684\u8282\u70b9\u53f7\u7801 \uff08i \u4ece 0 \u5f00\u59cb\uff09\uff0c\u5224\u65ad\u80fd\u5426\u5c06\u6240\u6709\u8282\u70b9\u5206\u6210\u4e24\u4e2a\u96c6\u5408\uff0c\u540c\u4e00\u4e2a\u96c6\u5408\u7684\u8282\u70b9\u6ca1\u6709\u76f8\u90bb\u7684\u8fb9\u3002 \u300c\u5206\u6790\u300d \u3010\u5e76\u67e5\u96c6\u3011\u5982\u679c\u8282\u70b9 i \u7684\u76f8\u90bb\u8282\u70b9\u4e3a neighbors\uff0c\u90a3\u4e48 i \u4e0e neighbor \u4e2d\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u4e0d\u5c5e\u4e8e\u540c\u4e00\u4e2a\u96c6\u5408\uff0c\u7531\u6b64\u63a8\u51fa\uff0cneighbor \u4e2d\u7684\u6240\u6709\u8282\u70b9\u5728\u540c\u4e00\u4e2a\u96c6\u5408 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 vector < int > fa ; int find ( int x ) { return x == fa [ x ] ? x : fa [ x ] = find ( fa [ x ]); } void unify ( int x , int y ) { fa [ find ( y )] = find ( x ); } bool isBipartite ( vector < vector < int >>& graph ) { size_t n = graph . size (); fa . resize ( n ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j : graph [ i ]) { if ( find ( i ) == find ( j )) { return false ; } unify ( graph [ i ][ 0 ], j ); } } return true ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2} \\log n) O(n^{2} \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u4e8c\u5206\u56fe"},{"location":"data-structure/vector/","text":"\u5b9a\u4e49 \u00b6 \u6570\u7ec4\uff08\u5411\u91cf\uff09\u662f\u4e00\u79cd\u6392\u5217\u6709\u5e8f\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8fd9\u91cc\u7684\u300c\u6709\u5e8f\u300d\u6307\u7684\u662f\u6570\u7ec4\u7684\u503c\u5728\u5185\u5b58\u5730\u5740\u5185\u7ebf\u5f62\u5b58\u50a8\u3002\u6570\u7ec4\u652f\u6301\u300c\u5bfb\u5740\u8bbf\u95ee\uff08call-by-rank\uff09\u300d\uff0c\u53ef\u4ee5\u5728 O(1) O(1) \u65f6\u95f4\u5185\u627e\u5230\u6570\u636e\u3002 A[0], A[1], A[2], \\cdots, A[n-1] A[0], A[1], A[2], \\cdots, A[n-1] Physical address: \u5185\u5b58\u4e2d\u7684\u7269\u7406\u5730\u5740\uff1a V[ i ]=V[ 0 ]+i\\times s V[ i ]=V[ 0 ]+i\\times s \u8fd9\u91cc s \u4ee3\u8868\u6bcf\u4e00\u4e2a\u5355\u5143\u7684\u7a7a\u95f4\u5927\u5c0f\u3002 \u57fa\u7840\u8fd0\u7b97 \u00b6 \u6839\u636e\u662f\u5426\u4fee\u6539\u6570\u636e\u7ed3\u6784\uff0c\u5927\u7ea6\u53ef\u5206\u4e3a\u4e24\u79cd\u64cd\u4f5c \u9759\u6001 \u52a8\u6001 \u8bfb\uff08\u67e5\uff09 \u5199\uff08\u589e\u3001\u5220\u3001\u6539\uff09 \u53ef\u6269\u5bb9\u6570\u7ec4 \u00b6 \u8d1f\u8f7d\u56e0\u5b50\uff08load factor\uff09 \\lambda = \\frac{size}{capacity} \\lambda = \\frac{size}{capacity} \u4f7f\u7528\u53ef\u6269\u5bb9\u6570\u7ec4\u7684\u76ee\u7684\u662f\u907f\u514d\u6570\u636e\u6ea2\u51fa\uff08overflow\uff09\u6216\u8005\u8fc7\u4f4e\u8d1f\u8f7d\uff08low load factor\uff09\u3002 \u589e\u5bb9\uff08Incremental capacity \u500d\u5bb9\uff08Double capacity\uff09 \u603b\u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) O(n) O(n) \u644a\u5747\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) O(1) O(1) \u8d1f\u8f7d\u56e0\u5b50 \\approx 100% \\approx 100% 50% 50% \u589e\u5bb9 \u00b6 \u6bcf\u6b21\u589e\u52a0\u4e00\u4e2a\u56fa\u5b9a\u957f\u5ea6\u7684\u7a7a\u95f4 1 2 T * oldElem = _elem ; _elem = new T [ _capacity += INCREMENT ]; // Increment \u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5bf9\u4e00\u4e2a\u521d\u59cb\u957f\u5ea6\u4e3a1\u7684\u6570\u7ec4\uff0c\u6301\u7eed\u63d2\u5165\u5143\u7d20 n = m*I\uff0c\u603b\u4f53\u65f6\u95f4\u5982\u4e0b 0, I, 2I, 3I, \\cdots, (m-1)I = I\\frac{(m-1)m}{2} 0, I, 2I, 3I, \\cdots, (m-1)I = I\\frac{(m-1)m}{2} \u644a\u5747\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u500d\u5bb9 \u00b6 \u6bcf\u6b21\u5bf9\u73b0\u6709\u6570\u7ec4\u7684\u957f\u5ea6\u52a0\u500d 1 2 3 4 5 6 7 8 9 10 void Vector < T >:: expand () { if ( _size < _capacity ) return _capacity = max ( _capacity , DEFAULT_CAPACITY ); T * oldElem = _elem ; _elem = new T [ _capacity <<= 1 ]; // Double for ( int i = 0 ; i < _size ; i ++ ) { _elem [ i ] = oldElem [ i ]; } delete [] oldElem ; } \u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5bf9\u4e00\u4e2a\u521d\u59cb\u957f\u5ea6\u4e3a1\u7684\u6570\u7ec4\uff0c\u6301\u7eed\u63d2\u5165\u5143\u7d20 n = 2^{m} 2^{m} \uff0c\u6211\u4eec\u9700\u8981\u5728\u7b2c 1 \u6b21\uff0c\u7b2c 2 \u6b21\uff0c\u7b2c 4 \u6b21\uff0c\u7b2c 8 \u6b21\uff0c\u7b2c 16 \u6b21 \\cdots \\cdots \u65f6\u500d\u5bb9\u3002\u603b\u65f6\u95f4 1, 2, 4, 8, \\cdots, 2^m = n 1, 2, 4, 8, \\cdots, 2^m = n \u644a\u5747\u590d\u6742\u5ea6 O(1) O(1) \u9898\u76ee \u00b6 \u5220\u9664\u6709\u5e8f\u6570\u7ec4\u4e2d\u7684\u91cd\u590d\u9879 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4 nums \uff0c\u8bf7\u4f60 \u539f\u5730 \u5220\u9664\u91cd\u590d\u51fa\u73b0\u7684\u5143\u7d20\uff0c\u4f7f\u5f97\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e24\u6b21\u7684\u5143\u7d20\u53ea\u51fa\u73b0\u4e24\u6b21 \uff0c\u8fd4\u56de\u5220\u9664\u540e\u6570\u7ec4\u7684\u65b0\u957f\u5ea6\u3002\u4e0d\u8981\u4f7f\u7528\u989d\u5916\u7684\u6570\u7ec4\u7a7a\u95f4\uff0c\u4f60\u5fc5\u987b\u5728 \u539f\u5730 \u4fee\u6539\u8f93\u5165\u6570\u7ec4 \u5e76\u5728\u4f7f\u7528 O(1) \u989d\u5916\u7a7a\u95f4\u7684\u6761\u4ef6\u4e0b\u5b8c\u6210\u3002 \u300c\u5206\u6790\u300d \u300c\u6570\u7ec4\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3] Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3] */ int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 3 ) { return n ; } int len = 1 , count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { count ++ ; } else { count = 1 ; } if ( count <= 2 ) { nums [ len ++ ] = nums [ i ]; } } return len ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u6570\u7ec4"},{"location":"data-structure/vector/#_1","text":"\u6570\u7ec4\uff08\u5411\u91cf\uff09\u662f\u4e00\u79cd\u6392\u5217\u6709\u5e8f\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8fd9\u91cc\u7684\u300c\u6709\u5e8f\u300d\u6307\u7684\u662f\u6570\u7ec4\u7684\u503c\u5728\u5185\u5b58\u5730\u5740\u5185\u7ebf\u5f62\u5b58\u50a8\u3002\u6570\u7ec4\u652f\u6301\u300c\u5bfb\u5740\u8bbf\u95ee\uff08call-by-rank\uff09\u300d\uff0c\u53ef\u4ee5\u5728 O(1) O(1) \u65f6\u95f4\u5185\u627e\u5230\u6570\u636e\u3002 A[0], A[1], A[2], \\cdots, A[n-1] A[0], A[1], A[2], \\cdots, A[n-1] Physical address: \u5185\u5b58\u4e2d\u7684\u7269\u7406\u5730\u5740\uff1a V[ i ]=V[ 0 ]+i\\times s V[ i ]=V[ 0 ]+i\\times s \u8fd9\u91cc s \u4ee3\u8868\u6bcf\u4e00\u4e2a\u5355\u5143\u7684\u7a7a\u95f4\u5927\u5c0f\u3002","title":"\u5b9a\u4e49"},{"location":"data-structure/vector/#_2","text":"\u6839\u636e\u662f\u5426\u4fee\u6539\u6570\u636e\u7ed3\u6784\uff0c\u5927\u7ea6\u53ef\u5206\u4e3a\u4e24\u79cd\u64cd\u4f5c \u9759\u6001 \u52a8\u6001 \u8bfb\uff08\u67e5\uff09 \u5199\uff08\u589e\u3001\u5220\u3001\u6539\uff09","title":"\u57fa\u7840\u8fd0\u7b97"},{"location":"data-structure/vector/#_3","text":"\u8d1f\u8f7d\u56e0\u5b50\uff08load factor\uff09 \\lambda = \\frac{size}{capacity} \\lambda = \\frac{size}{capacity} \u4f7f\u7528\u53ef\u6269\u5bb9\u6570\u7ec4\u7684\u76ee\u7684\u662f\u907f\u514d\u6570\u636e\u6ea2\u51fa\uff08overflow\uff09\u6216\u8005\u8fc7\u4f4e\u8d1f\u8f7d\uff08low load factor\uff09\u3002 \u589e\u5bb9\uff08Incremental capacity \u500d\u5bb9\uff08Double capacity\uff09 \u603b\u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) O(n) O(n) \u644a\u5747\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) O(1) O(1) \u8d1f\u8f7d\u56e0\u5b50 \\approx 100% \\approx 100% 50% 50%","title":"\u53ef\u6269\u5bb9\u6570\u7ec4"},{"location":"data-structure/vector/#_4","text":"\u6bcf\u6b21\u589e\u52a0\u4e00\u4e2a\u56fa\u5b9a\u957f\u5ea6\u7684\u7a7a\u95f4 1 2 T * oldElem = _elem ; _elem = new T [ _capacity += INCREMENT ]; // Increment \u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5bf9\u4e00\u4e2a\u521d\u59cb\u957f\u5ea6\u4e3a1\u7684\u6570\u7ec4\uff0c\u6301\u7eed\u63d2\u5165\u5143\u7d20 n = m*I\uff0c\u603b\u4f53\u65f6\u95f4\u5982\u4e0b 0, I, 2I, 3I, \\cdots, (m-1)I = I\\frac{(m-1)m}{2} 0, I, 2I, 3I, \\cdots, (m-1)I = I\\frac{(m-1)m}{2} \u644a\u5747\u590d\u6742\u5ea6 O(n) O(n) \u3002","title":"\u589e\u5bb9"},{"location":"data-structure/vector/#_5","text":"\u6bcf\u6b21\u5bf9\u73b0\u6709\u6570\u7ec4\u7684\u957f\u5ea6\u52a0\u500d 1 2 3 4 5 6 7 8 9 10 void Vector < T >:: expand () { if ( _size < _capacity ) return _capacity = max ( _capacity , DEFAULT_CAPACITY ); T * oldElem = _elem ; _elem = new T [ _capacity <<= 1 ]; // Double for ( int i = 0 ; i < _size ; i ++ ) { _elem [ i ] = oldElem [ i ]; } delete [] oldElem ; } \u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5bf9\u4e00\u4e2a\u521d\u59cb\u957f\u5ea6\u4e3a1\u7684\u6570\u7ec4\uff0c\u6301\u7eed\u63d2\u5165\u5143\u7d20 n = 2^{m} 2^{m} \uff0c\u6211\u4eec\u9700\u8981\u5728\u7b2c 1 \u6b21\uff0c\u7b2c 2 \u6b21\uff0c\u7b2c 4 \u6b21\uff0c\u7b2c 8 \u6b21\uff0c\u7b2c 16 \u6b21 \\cdots \\cdots \u65f6\u500d\u5bb9\u3002\u603b\u65f6\u95f4 1, 2, 4, 8, \\cdots, 2^m = n 1, 2, 4, 8, \\cdots, 2^m = n \u644a\u5747\u590d\u6742\u5ea6 O(1) O(1)","title":"\u500d\u5bb9"},{"location":"data-structure/vector/#_6","text":"","title":"\u9898\u76ee"},{"location":"data-structure/vector/#_7","text":"\u7ed9\u4f60\u4e00\u4e2a\u6709\u5e8f\u6570\u7ec4 nums \uff0c\u8bf7\u4f60 \u539f\u5730 \u5220\u9664\u91cd\u590d\u51fa\u73b0\u7684\u5143\u7d20\uff0c\u4f7f\u5f97\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e24\u6b21\u7684\u5143\u7d20\u53ea\u51fa\u73b0\u4e24\u6b21 \uff0c\u8fd4\u56de\u5220\u9664\u540e\u6570\u7ec4\u7684\u65b0\u957f\u5ea6\u3002\u4e0d\u8981\u4f7f\u7528\u989d\u5916\u7684\u6570\u7ec4\u7a7a\u95f4\uff0c\u4f60\u5fc5\u987b\u5728 \u539f\u5730 \u4fee\u6539\u8f93\u5165\u6570\u7ec4 \u5e76\u5728\u4f7f\u7528 O(1) \u989d\u5916\u7a7a\u95f4\u7684\u6761\u4ef6\u4e0b\u5b8c\u6210\u3002 \u300c\u5206\u6790\u300d \u300c\u6570\u7ec4\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3] Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3] */ int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 3 ) { return n ; } int len = 1 , count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { count ++ ; } else { count = 1 ; } if ( count <= 2 ) { nums [ len ++ ] = nums [ i ]; } } return len ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u5220\u9664\u6709\u5e8f\u6570\u7ec4\u4e2d\u7684\u91cd\u590d\u9879"},{"location":"data-structure/tree/basis/","text":"\u7b80\u4ecb \u00b6 \u6811\u662f\u4e00\u79cd\u975e\u7ebf\u6027\uff08\u53ef\u9000\u5316\u6210\u7ebf\u6027\uff09\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7531\u9876\u70b9\u548c\u8fb9\u7ec4\u6210\uff0c\u4e0d\u5b58\u5728\u4efb\u4f55\u73af\u3002\u6ca1\u6709\u4efb\u4f55\u7ed3\u70b9\u7684\u6811\u53eb\u505a\u7a7a\u6811\u3002 \u672f\u8bed \u00b6 \u6839\u7ed3\u70b9 \u5b69\u5b50\u7ed3\u70b9 \u7236\u7ed3\u70b9 \u5144\u5f1f\u7ed3\u70b9\uff1a\u540c\u4e00\u4e2a\u7236\u7ed3\u70b9\u7684\u5b69\u5b50\u7ed3\u70b9 \u7956\u5148\uff1a\u4ece\u6839\u7ed3\u70b9\u5230\u8be5\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7ed3\u70b9 \u5b50\u5b59\uff1a\u4ee5\u8be5\u7ed3\u70b9\u4e3a\u6839\u7ed3\u70b9\u7684\u6240\u6709\u7ed3\u70b9 \u53f6\u5b50\u7ed3\u70b9\uff1a\u6ca1\u6709\u5b69\u5b50\u7ed3\u70b9\u6216\u5b69\u5b50\u7ed3\u70b9\u4e3a null \u7684\u7ed3\u70b9 \u5ea6\uff1a\u4e0e\u7ed3\u70b9\u76f8\u8fde\u63a5\u7684\u8fb9\u6570\uff0c\u5206\u4e3a\u51fa\u5ea6\u548c\u5165\u5ea6 \u6df1\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u7ed3\u70b9\u7684\u4e2a\u6570 \u9ad8\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u8fb9\u7684\u4e2a\u6570 \u79cd\u7c7b \u00b6 \u4e8c\u53c9\u6811 \u591a\u53c9\u6811 \u5e73\u8861\u6811 B-\u6811 \u7ea2\u9ed1\u6811","title":"\u57fa\u7840"},{"location":"data-structure/tree/basis/#_1","text":"\u6811\u662f\u4e00\u79cd\u975e\u7ebf\u6027\uff08\u53ef\u9000\u5316\u6210\u7ebf\u6027\uff09\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7531\u9876\u70b9\u548c\u8fb9\u7ec4\u6210\uff0c\u4e0d\u5b58\u5728\u4efb\u4f55\u73af\u3002\u6ca1\u6709\u4efb\u4f55\u7ed3\u70b9\u7684\u6811\u53eb\u505a\u7a7a\u6811\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/tree/basis/#_2","text":"\u6839\u7ed3\u70b9 \u5b69\u5b50\u7ed3\u70b9 \u7236\u7ed3\u70b9 \u5144\u5f1f\u7ed3\u70b9\uff1a\u540c\u4e00\u4e2a\u7236\u7ed3\u70b9\u7684\u5b69\u5b50\u7ed3\u70b9 \u7956\u5148\uff1a\u4ece\u6839\u7ed3\u70b9\u5230\u8be5\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7ed3\u70b9 \u5b50\u5b59\uff1a\u4ee5\u8be5\u7ed3\u70b9\u4e3a\u6839\u7ed3\u70b9\u7684\u6240\u6709\u7ed3\u70b9 \u53f6\u5b50\u7ed3\u70b9\uff1a\u6ca1\u6709\u5b69\u5b50\u7ed3\u70b9\u6216\u5b69\u5b50\u7ed3\u70b9\u4e3a null \u7684\u7ed3\u70b9 \u5ea6\uff1a\u4e0e\u7ed3\u70b9\u76f8\u8fde\u63a5\u7684\u8fb9\u6570\uff0c\u5206\u4e3a\u51fa\u5ea6\u548c\u5165\u5ea6 \u6df1\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u7ed3\u70b9\u7684\u4e2a\u6570 \u9ad8\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u8fb9\u7684\u4e2a\u6570","title":"\u672f\u8bed"},{"location":"data-structure/tree/basis/#_3","text":"\u4e8c\u53c9\u6811 \u591a\u53c9\u6811 \u5e73\u8861\u6811 B-\u6811 \u7ea2\u9ed1\u6811","title":"\u79cd\u7c7b"},{"location":"data-structure/tree/binary-tree/","text":"\u7b80\u4ecb \u00b6 \u4e8c\u53c9\u6811\u662f\u6811\u7684\u4e00\u79cd\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u6700\u591a\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\u3002 \u6027\u8d28 \u00b6 \u5018\u82e5\u6839\u7ed3\u70b9\u5728\u7b2c 0 \u5c42\uff0c\u90a3\u4e48\u6bcf\u4e00\u5c42\u7684\u7ed3\u70b9\u6570\u76ee\u6700\u591a\u6709 2^{i} 2^{i} \u4e2a\u3002 \u4e00\u68f5\u6811\u7684\u6df1\u5ea6\u4e3a d\uff0c\u90a3\u4e48\u5b83\u6700\u591a\u6709 2^{d} - 1 2^{d} - 1 \u4e2a\u7ed3\u70b9 \u5982\u679c\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u662f n\uff0c\u90a3\u4e48\u6709\u4e24\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9\u4e2a\u6570\u4e3a n - 1 \u5b8c\u5168\u4e8c\u53c9\u6811\u3001\u5b8c\u6ee1\u4e8c\u53c9\u6811\u548c\u5b8c\u7f8e\u4e8c\u53c9\u6811 \u00b6 A Complete Binary Tree\uff08CBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. \u5b8c\u5168\u4e8c\u53c9\u6811\uff08complete binary tree\uff09\u9664\u4e86\u6700\u540e\u4e00\u5c42\u5916\u5168\u90e8\u586b\u6ee1\uff0c\u6700\u540e\u4e00\u5c42\u7684\u7ed3\u70b9\u9760\u5de6\u586b\u5145 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children. \u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u662f 2\u3002 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} A Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2. \u5b8c\u7f8e\u4e8c\u53c9\u6811\uff08perfec binary tree\uff09\u6240\u6709\u7684\u53f6\u5b50\u7ed3\u70b9\u5904\u4e8e\u540c\u4e00\u5c42\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f 2\u3002 \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix} \u6700\u8fd1\u516c\u5171\u7956\u5148 \u00b6 \u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148 \u00b6 \u7ed9\u5b9a\u4e00\u9897\u4e8c\u53c9\u6811\u548c\u4e24\u4e2a\u8282\u70b9p\u3001q\uff0c\u6c42\u8fd9\u4e24\u4e2a\u8282\u70b9\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148\u3002\u5982\u4e0b\u4f8b \\begin{matrix} & & & & & {\\color{Green} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 2 & & & & & & {\\color{Red} 3} \\\\ & & & \\searrow \\\\ & & & & {\\color{Red} 4} \\end{matrix} \\begin{matrix} & & & & & {\\color{Green} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 2 & & & & & & {\\color{Red} 3} \\\\ & & & \\searrow \\\\ & & & & {\\color{Red} 4} \\end{matrix} \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u7528\u300c\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u300d\u627e\u5230\u552f\u4e00\u8def\u5f84\u3002\u4e4b\u540e\u672c\u9898\u8f6c\u5316\u4e3a\u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868\uff0c\u6c42\u5206\u53c9\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 vector < TreeNode *> dfs ( TreeNode * root , TreeNode * t ) { vector < TreeNode *> ans ; stack < TreeNode *> stk ; if ( root == nullptr || t == nullptr ) { return ans ; } stk . push ( root ); while ( ! stk . empty ()) { TreeNode * curNode = stk . top (); stk . pop (); ans . emplace_back ( curNode ); if ( curNode == t ) { return ans ; } if ( curNode -> right != nullptr ) { stk . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { stk . push ( curNode -> left ); } if ( curNode -> right == nullptr && curNode -> left == nullptr ) { while ( ! ans . empty () && ans . back () -> right != stk . top ()) { ans . pop_back (); } } } return ans ; } TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root == nullptr || p == nullptr || q == nullptr ) { return nullptr ; } vector < TreeNode *> vp = dfs ( root , p ); vector < TreeNode *> vq = dfs ( root , q ); int np = ( int ) vp . size (), nq = ( int ) vq . size (); for ( int i = 1 ; i < min ( np , nq ); i ++ ) { if ( vp [ i ] != vq [ i ]) { return vp [ i - 1 ]; } } return vp [ min ( np , nq ) - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148 \u00b6 \u4e8c\u53c9\u641c\u7d22\u6811\u8981\u6c42\u5143\u7d20\u6709\u5e8f\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u5229\u7528\u3010\u4e8c\u53c9\u641c\u7d22\u6811\u3011\u7684\u7279\u6027\uff0c\u5f53\u524d\u8282\u70b9\u7684\u503c\u4ecb\u4e8e\u5de6\u5b69\u5b50\u548c\u53f3\u5b69\u5b50\u7684\u503c\u4e4b\u95f4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root == nullptr || p == nullptr || q == nullptr ) { return nullptr ; } while ( root != nullptr ) { if ( root -> val < min ( p -> val , q -> val )) { root = root -> right ; } else if ( root -> val > max ( p -> val , q -> val )) { root = root -> left ; } else { return root ; } } return root ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u4e8c\u53c9\u6811\u5e8f\u5217\u5316\u4e0e\u53cd\u5e8f\u5217\u5316 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { if ( root == nullptr ) { return \"#,\" ; } string str = to_string ( root -> val ) + \",\" ; str += serialize ( root -> left ) + serialize ( root -> right ); return str ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { return deserialization ( data ); } TreeNode * deserialization ( string & data ) { if ( data . empty ()) { return nullptr ; } if ( data . front () == '#' ) { data . erase ( data . begin ()); data . erase ( data . begin ()); return nullptr ; } string val = \"\" ; while ( data . front () != ',' ) { val . push_back ( data . front ()); data . erase ( data . begin ()); } data . erase ( data . begin ()); TreeNode * root = new TreeNode ( stoi ( val )); root -> left = deserialization ( data ); root -> right = deserialization ( data ); return root ; } };","title":"\u4e8c\u53c9\u6811"},{"location":"data-structure/tree/binary-tree/#_1","text":"\u4e8c\u53c9\u6811\u662f\u6811\u7684\u4e00\u79cd\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u6700\u591a\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/tree/binary-tree/#_2","text":"\u5018\u82e5\u6839\u7ed3\u70b9\u5728\u7b2c 0 \u5c42\uff0c\u90a3\u4e48\u6bcf\u4e00\u5c42\u7684\u7ed3\u70b9\u6570\u76ee\u6700\u591a\u6709 2^{i} 2^{i} \u4e2a\u3002 \u4e00\u68f5\u6811\u7684\u6df1\u5ea6\u4e3a d\uff0c\u90a3\u4e48\u5b83\u6700\u591a\u6709 2^{d} - 1 2^{d} - 1 \u4e2a\u7ed3\u70b9 \u5982\u679c\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u662f n\uff0c\u90a3\u4e48\u6709\u4e24\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9\u4e2a\u6570\u4e3a n - 1","title":"\u6027\u8d28"},{"location":"data-structure/tree/binary-tree/#_3","text":"A Complete Binary Tree\uff08CBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. \u5b8c\u5168\u4e8c\u53c9\u6811\uff08complete binary tree\uff09\u9664\u4e86\u6700\u540e\u4e00\u5c42\u5916\u5168\u90e8\u586b\u6ee1\uff0c\u6700\u540e\u4e00\u5c42\u7684\u7ed3\u70b9\u9760\u5de6\u586b\u5145 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children. \u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u662f 2\u3002 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} A Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2. \u5b8c\u7f8e\u4e8c\u53c9\u6811\uff08perfec binary tree\uff09\u6240\u6709\u7684\u53f6\u5b50\u7ed3\u70b9\u5904\u4e8e\u540c\u4e00\u5c42\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f 2\u3002 \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix}","title":"\u5b8c\u5168\u4e8c\u53c9\u6811\u3001\u5b8c\u6ee1\u4e8c\u53c9\u6811\u548c\u5b8c\u7f8e\u4e8c\u53c9\u6811"},{"location":"data-structure/tree/binary-tree/#_4","text":"","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"data-structure/tree/binary-tree/#_5","text":"\u7ed9\u5b9a\u4e00\u9897\u4e8c\u53c9\u6811\u548c\u4e24\u4e2a\u8282\u70b9p\u3001q\uff0c\u6c42\u8fd9\u4e24\u4e2a\u8282\u70b9\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148\u3002\u5982\u4e0b\u4f8b \\begin{matrix} & & & & & {\\color{Green} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 2 & & & & & & {\\color{Red} 3} \\\\ & & & \\searrow \\\\ & & & & {\\color{Red} 4} \\end{matrix} \\begin{matrix} & & & & & {\\color{Green} 1} \\\\ & & & \\swarrow & & & & \\searrow \\\\ & & 2 & & & & & & {\\color{Red} 3} \\\\ & & & \\searrow \\\\ & & & & {\\color{Red} 4} \\end{matrix} \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u7528\u300c\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u300d\u627e\u5230\u552f\u4e00\u8def\u5f84\u3002\u4e4b\u540e\u672c\u9898\u8f6c\u5316\u4e3a\u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868\uff0c\u6c42\u5206\u53c9\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 vector < TreeNode *> dfs ( TreeNode * root , TreeNode * t ) { vector < TreeNode *> ans ; stack < TreeNode *> stk ; if ( root == nullptr || t == nullptr ) { return ans ; } stk . push ( root ); while ( ! stk . empty ()) { TreeNode * curNode = stk . top (); stk . pop (); ans . emplace_back ( curNode ); if ( curNode == t ) { return ans ; } if ( curNode -> right != nullptr ) { stk . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { stk . push ( curNode -> left ); } if ( curNode -> right == nullptr && curNode -> left == nullptr ) { while ( ! ans . empty () && ans . back () -> right != stk . top ()) { ans . pop_back (); } } } return ans ; } TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root == nullptr || p == nullptr || q == nullptr ) { return nullptr ; } vector < TreeNode *> vp = dfs ( root , p ); vector < TreeNode *> vq = dfs ( root , q ); int np = ( int ) vp . size (), nq = ( int ) vq . size (); for ( int i = 1 ; i < min ( np , nq ); i ++ ) { if ( vp [ i ] != vq [ i ]) { return vp [ i - 1 ]; } } return vp [ min ( np , nq ) - 1 ]; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"data-structure/tree/binary-tree/#_6","text":"\u4e8c\u53c9\u641c\u7d22\u6811\u8981\u6c42\u5143\u7d20\u6709\u5e8f\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u5229\u7528\u3010\u4e8c\u53c9\u641c\u7d22\u6811\u3011\u7684\u7279\u6027\uff0c\u5f53\u524d\u8282\u70b9\u7684\u503c\u4ecb\u4e8e\u5de6\u5b69\u5b50\u548c\u53f3\u5b69\u5b50\u7684\u503c\u4e4b\u95f4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root == nullptr || p == nullptr || q == nullptr ) { return nullptr ; } while ( root != nullptr ) { if ( root -> val < min ( p -> val , q -> val )) { root = root -> right ; } else if ( root -> val > max ( p -> val , q -> val )) { root = root -> left ; } else { return root ; } } return root ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"data-structure/tree/binary-tree/#_7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { if ( root == nullptr ) { return \"#,\" ; } string str = to_string ( root -> val ) + \",\" ; str += serialize ( root -> left ) + serialize ( root -> right ); return str ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { return deserialization ( data ); } TreeNode * deserialization ( string & data ) { if ( data . empty ()) { return nullptr ; } if ( data . front () == '#' ) { data . erase ( data . begin ()); data . erase ( data . begin ()); return nullptr ; } string val = \"\" ; while ( data . front () != ',' ) { val . push_back ( data . front ()); data . erase ( data . begin ()); } data . erase ( data . begin ()); TreeNode * root = new TreeNode ( stoi ( val )); root -> left = deserialization ( data ); root -> right = deserialization ( data ); return root ; } };","title":"\u4e8c\u53c9\u6811\u5e8f\u5217\u5316\u4e0e\u53cd\u5e8f\u5217\u5316"},{"location":"data-structure/tree/prefix-tree/","text":"\u524d\u7f00\u6811 \u00b6 \u524d\u7f00\u6811\uff08\u5b57\u5178\u6811\uff09\u662f\u4e00\u79cd\u5b58\u50a8\u548c\u67e5\u8be2\u90fd\u9ad8\u6548\u7684\u6570\u636e\u7ed3\u6784\uff0c\u901a\u5e38\u7528\u4e8e\u5b57\u7b26\u4e32\u6570\u636e\uff0c\u4e14\u516c\u5171\u524d\u7f00\u8d8a\u591a\uff0c\u6548\u7387\u8d8a\u9ad8\u3002\u524d\u7f00\u6811\u672c\u8d28\u4e0a\u662f\u591a\u53c9\u6811\u3002\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e00\u7ec4\u6570\u636e\u4e2d\u5b57\u7b26\u7684\u5168\u96c6 \\Sigma \\Sigma \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5bf9\u6bcf\u4e00\u4e2a\u8282\u70b9\u8bbe\u7f6e\u540c\u7b49\u6570\u76ee\u7684\u5206\u652f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 struct TrieNode { char val ; vector < TrieNode *> nexts ; bool isEnd ; TrieNode () { val = ' ' ; nexts . resize ( 26 , nullptr ); isEnd = false ; } TrieNode ( char x ) : val ( x ) { nexts . resize ( 26 , nullptr ); isEnd = false ; } }; class Trie { TrieNode * root ; public : Trie () { root = new TrieNode (); } void insert ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { int idx = ch - 'a' ; if ( cur -> nexts [ idx ] == nullptr ) { cur -> nexts [ idx ] = new TrieNode ( ch ); } cur = cur -> nexts [ idx ]; } cur -> isEnd = true ; } bool search ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return cur -> isEnd ; } bool startsWith ( string prefix ) { TrieNode * cur = root ; for ( const char & ch : prefix ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return true ; } }; \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\Sigma \\times n) O(\\Sigma \\times n) \uff1b\u63d2\u5165\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u67e5\u8be2\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002n \u4e3a\u63d2\u5165/\u67e5\u8be2\u7684\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c \\Sigma \\Sigma \u4e3a\u5b57\u7b26\u7684\u96c6\u5408\u4e2a\u6570 \u9898\u76ee \u00b6 \u6570\u7ec4\u4e2d\u4e24\u4e2a\u6570\u7684\u6700\u5927\u5f02\u6216\u503c \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8fd4\u56de nums[i] XOR nums[j] \u7684\u6700\u5927\u8fd0\u7b97\u7ed3\u679c\uff0c\u5176\u4e2d 0 \u2264 i \u2264 j < n \u3002 \u300c\u5206\u6790\u300d \u3010\u524d\u7f00\u6811\u3011\u5c06\u6bcf\u4e00\u4e2a\u6570\u8868\u793a\u6210\u4e8c\u8fdb\u5236\u5f62\u5f0f\uff0c\u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d\u63d2\u5165\u5230\u4e00\u9897\u524d\u7f00\u6811\u4e2d\u3002\u6bcf\u4e00\u4e2a\u540e\u7eed\u7684\u6570\u5c3d\u53ef\u80fd\u5730\u627e\u5230\u6bcf\u4e00\u4f4d\u4e0a\u4e0d\u540c\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 struct BinaryTrieNode { int val ; bool isEnd ; vector < BinaryTrieNode *> nexts ; BinaryTrieNode ( int x ) { val = x ; nexts . resize ( 2 , nullptr ); } }; class BinaryTrie { BinaryTrieNode * root ; public : BinaryTrie () { root = new BinaryTrieNode ( 0 ); } void insert ( int n ) { BinaryTrieNode * cur = root ; for ( int i = 30 ; i >= 0 ; i -- ) { int val = ( n >> i ) & 1 ; if ( cur -> nexts [ val ] == nullptr ) { cur -> nexts [ val ] = new BinaryTrieNode ( val ); } cur = cur -> nexts [ val ]; } } int search ( int n ) { BinaryTrieNode * cur = root ; int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int val = 1 - (( n >> i ) & 1 ); if ( cur -> nexts [ val ] == nullptr ) { val = 1 - val ; } if ( cur -> nexts [ val ] == nullptr ) { break ; } ans |= val * ( 1 << i ); cur = cur -> nexts [ val ]; } return ans ; } }; class Solution { public : int findMaximumXOR ( vector < int >& nums ) { BinaryTrie bt ; int ans = 0 ; for ( int num : nums ) { bt . insert ( num ); ans = max ( ans , bt . search ( num ) ^ num ); } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u8fde\u63a5\u8bcd \u00b6 \u7ed9\u4f60\u4e00\u4e2a \u4e0d\u542b\u91cd\u590d \u5355\u8bcd\u7684\u5b57\u7b26\u4e32\u6570\u7ec4 words \uff0c\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de words \u4e2d\u7684\u6240\u6709 \u8fde\u63a5\u8bcd \u3002\u8fde\u63a5\u8bcd \u5b9a\u4e49\u4e3a\uff1a\u4e00\u4e2a\u5b8c\u5168\u7531\u7ed9\u5b9a\u6570\u7ec4\u4e2d\u7684\u81f3\u5c11\u4e24\u4e2a\u8f83\u77ed\u5355\u8bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002\u4f8b\u5982\uff0cwords = [\"cat\", \"dog\", \"catdog\"]\uff0c\u8fd4\u56de\u7ed3\u679c [\"catdog\"] \u300c\u5206\u6790\u300d \u3010\u5b57\u5178\u6811 + DFS\u3011\u5c06 words \u6309\u7167\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u7531\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u8fd9\u6837\u4fdd\u8bc1\u6240\u6709\u7684\u53ef\u80fd\u7ec4\u6210\u5176\u4ed6\u5355\u8bcd\u7684\u201c\u5c0f\u5355\u8bcd\u201d\u51fa\u73b0\u5728\u524d\u9762 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 struct TrieNode { char val ; vector < TrieNode *> nexts ; bool isEnd ; TrieNode () { val = ' ' ; nexts . resize ( 26 , nullptr ); isEnd = false ; } TrieNode ( char x ) : val ( x ) { nexts . resize ( 26 , nullptr ); isEnd = false ; } }; class Trie { TrieNode * root ; public : Trie () { root = new TrieNode (); } void insert ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { int idx = ch - 'a' ; if ( cur -> nexts [ idx ] == nullptr ) { cur -> nexts [ idx ] = new TrieNode ( ch ); } cur = cur -> nexts [ idx ]; } cur -> isEnd = true ; } bool search ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return cur -> isEnd ; } bool startsWith ( string prefix ) { TrieNode * cur = root ; for ( const char & ch : prefix ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return true ; } bool search ( string word , int b ) { if ( b == word . length ()) { return true ; } TrieNode * cur = root ; for ( int i = b ; i < word . length (); i ++ ) { char ch = word [ i ]; if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; if ( cur -> isEnd && search ( word , i + 1 )) { return true ; } } return false ; } }; class Solution { public : vector < string > findAllConcatenatedWordsInADict ( vector < string >& words ) { vector < string > ans ; sort ( words . begin (), words . end (), []( const string & s1 , const string & s2 ){ return s1 . length () < s2 . length (); }); Trie t ; for ( string word : words ) { if ( word . empty ()) { continue ; } if ( t . search ( word , 0 )) { ans . emplace_back ( word ); } else { t . insert ( word ); } } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u524d\u7f00\u6811"},{"location":"data-structure/tree/prefix-tree/#_1","text":"\u524d\u7f00\u6811\uff08\u5b57\u5178\u6811\uff09\u662f\u4e00\u79cd\u5b58\u50a8\u548c\u67e5\u8be2\u90fd\u9ad8\u6548\u7684\u6570\u636e\u7ed3\u6784\uff0c\u901a\u5e38\u7528\u4e8e\u5b57\u7b26\u4e32\u6570\u636e\uff0c\u4e14\u516c\u5171\u524d\u7f00\u8d8a\u591a\uff0c\u6548\u7387\u8d8a\u9ad8\u3002\u524d\u7f00\u6811\u672c\u8d28\u4e0a\u662f\u591a\u53c9\u6811\u3002\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e00\u7ec4\u6570\u636e\u4e2d\u5b57\u7b26\u7684\u5168\u96c6 \\Sigma \\Sigma \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5bf9\u6bcf\u4e00\u4e2a\u8282\u70b9\u8bbe\u7f6e\u540c\u7b49\u6570\u76ee\u7684\u5206\u652f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 struct TrieNode { char val ; vector < TrieNode *> nexts ; bool isEnd ; TrieNode () { val = ' ' ; nexts . resize ( 26 , nullptr ); isEnd = false ; } TrieNode ( char x ) : val ( x ) { nexts . resize ( 26 , nullptr ); isEnd = false ; } }; class Trie { TrieNode * root ; public : Trie () { root = new TrieNode (); } void insert ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { int idx = ch - 'a' ; if ( cur -> nexts [ idx ] == nullptr ) { cur -> nexts [ idx ] = new TrieNode ( ch ); } cur = cur -> nexts [ idx ]; } cur -> isEnd = true ; } bool search ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return cur -> isEnd ; } bool startsWith ( string prefix ) { TrieNode * cur = root ; for ( const char & ch : prefix ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return true ; } }; \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\Sigma \\times n) O(\\Sigma \\times n) \uff1b\u63d2\u5165\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u67e5\u8be2\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002n \u4e3a\u63d2\u5165/\u67e5\u8be2\u7684\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c \\Sigma \\Sigma \u4e3a\u5b57\u7b26\u7684\u96c6\u5408\u4e2a\u6570","title":"\u524d\u7f00\u6811"},{"location":"data-structure/tree/prefix-tree/#_2","text":"","title":"\u9898\u76ee"},{"location":"data-structure/tree/prefix-tree/#_3","text":"\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8fd4\u56de nums[i] XOR nums[j] \u7684\u6700\u5927\u8fd0\u7b97\u7ed3\u679c\uff0c\u5176\u4e2d 0 \u2264 i \u2264 j < n \u3002 \u300c\u5206\u6790\u300d \u3010\u524d\u7f00\u6811\u3011\u5c06\u6bcf\u4e00\u4e2a\u6570\u8868\u793a\u6210\u4e8c\u8fdb\u5236\u5f62\u5f0f\uff0c\u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d\u63d2\u5165\u5230\u4e00\u9897\u524d\u7f00\u6811\u4e2d\u3002\u6bcf\u4e00\u4e2a\u540e\u7eed\u7684\u6570\u5c3d\u53ef\u80fd\u5730\u627e\u5230\u6bcf\u4e00\u4f4d\u4e0a\u4e0d\u540c\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 struct BinaryTrieNode { int val ; bool isEnd ; vector < BinaryTrieNode *> nexts ; BinaryTrieNode ( int x ) { val = x ; nexts . resize ( 2 , nullptr ); } }; class BinaryTrie { BinaryTrieNode * root ; public : BinaryTrie () { root = new BinaryTrieNode ( 0 ); } void insert ( int n ) { BinaryTrieNode * cur = root ; for ( int i = 30 ; i >= 0 ; i -- ) { int val = ( n >> i ) & 1 ; if ( cur -> nexts [ val ] == nullptr ) { cur -> nexts [ val ] = new BinaryTrieNode ( val ); } cur = cur -> nexts [ val ]; } } int search ( int n ) { BinaryTrieNode * cur = root ; int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int val = 1 - (( n >> i ) & 1 ); if ( cur -> nexts [ val ] == nullptr ) { val = 1 - val ; } if ( cur -> nexts [ val ] == nullptr ) { break ; } ans |= val * ( 1 << i ); cur = cur -> nexts [ val ]; } return ans ; } }; class Solution { public : int findMaximumXOR ( vector < int >& nums ) { BinaryTrie bt ; int ans = 0 ; for ( int num : nums ) { bt . insert ( num ); ans = max ( ans , bt . search ( num ) ^ num ); } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u6570\u7ec4\u4e2d\u4e24\u4e2a\u6570\u7684\u6700\u5927\u5f02\u6216\u503c"},{"location":"data-structure/tree/prefix-tree/#_4","text":"\u7ed9\u4f60\u4e00\u4e2a \u4e0d\u542b\u91cd\u590d \u5355\u8bcd\u7684\u5b57\u7b26\u4e32\u6570\u7ec4 words \uff0c\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de words \u4e2d\u7684\u6240\u6709 \u8fde\u63a5\u8bcd \u3002\u8fde\u63a5\u8bcd \u5b9a\u4e49\u4e3a\uff1a\u4e00\u4e2a\u5b8c\u5168\u7531\u7ed9\u5b9a\u6570\u7ec4\u4e2d\u7684\u81f3\u5c11\u4e24\u4e2a\u8f83\u77ed\u5355\u8bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002\u4f8b\u5982\uff0cwords = [\"cat\", \"dog\", \"catdog\"]\uff0c\u8fd4\u56de\u7ed3\u679c [\"catdog\"] \u300c\u5206\u6790\u300d \u3010\u5b57\u5178\u6811 + DFS\u3011\u5c06 words \u6309\u7167\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u7531\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u8fd9\u6837\u4fdd\u8bc1\u6240\u6709\u7684\u53ef\u80fd\u7ec4\u6210\u5176\u4ed6\u5355\u8bcd\u7684\u201c\u5c0f\u5355\u8bcd\u201d\u51fa\u73b0\u5728\u524d\u9762 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 struct TrieNode { char val ; vector < TrieNode *> nexts ; bool isEnd ; TrieNode () { val = ' ' ; nexts . resize ( 26 , nullptr ); isEnd = false ; } TrieNode ( char x ) : val ( x ) { nexts . resize ( 26 , nullptr ); isEnd = false ; } }; class Trie { TrieNode * root ; public : Trie () { root = new TrieNode (); } void insert ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { int idx = ch - 'a' ; if ( cur -> nexts [ idx ] == nullptr ) { cur -> nexts [ idx ] = new TrieNode ( ch ); } cur = cur -> nexts [ idx ]; } cur -> isEnd = true ; } bool search ( string word ) { TrieNode * cur = root ; for ( const char & ch : word ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return cur -> isEnd ; } bool startsWith ( string prefix ) { TrieNode * cur = root ; for ( const char & ch : prefix ) { if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; } return true ; } bool search ( string word , int b ) { if ( b == word . length ()) { return true ; } TrieNode * cur = root ; for ( int i = b ; i < word . length (); i ++ ) { char ch = word [ i ]; if ( cur == nullptr || cur -> nexts [ ch - 'a' ] == nullptr ) { return false ; } cur = cur -> nexts [ ch - 'a' ]; if ( cur -> isEnd && search ( word , i + 1 )) { return true ; } } return false ; } }; class Solution { public : vector < string > findAllConcatenatedWordsInADict ( vector < string >& words ) { vector < string > ans ; sort ( words . begin (), words . end (), []( const string & s1 , const string & s2 ){ return s1 . length () < s2 . length (); }); Trie t ; for ( string word : words ) { if ( word . empty ()) { continue ; } if ( t . search ( word , 0 )) { ans . emplace_back ( word ); } else { t . insert ( word ); } } return ans ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n)","title":"\u8fde\u63a5\u8bcd"},{"location":"data-structure/tree/traversal/","text":"\u904d\u5386 \u00b6 \u904d\u5386\u662f\u5bf9\u4e8c\u53c9\u6811\u7684\u6240\u6709\u8282\u70b9\u505a\u4e00\u6b21\u65e0\u91cd\u590d\u7684\u8bbf\u95ee\u3002 \u524d\u5e8f\u904d\u5386 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // \u8fed\u4ee3\u7248 vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { curNode = st . top (); st . pop (); ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { st . push ( curNode -> left ); } } return ans ; } // \u9012\u5f52\u7248 vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; while ( true ) { while ( curNode != nullptr ) { ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } curNode = curNode -> left ; } if ( st . empty ()) { break ; } curNode = st . top (); st . pop (); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002 \u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u4ece\u53f3\u5411\u5de6\u770b\uff0c\u8fd4\u56de\u770b\u5230\u7684\u5e8f\u5217\uff08\u7531\u4e0a\u53ca\u4e0b\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } int maxLevel = - 1 ; rightOrder ( root , ans , 0 , maxLevel ); return ans ; } void rightOrder ( TreeNode * root , vector < int > & ans , int level , int & maxLevel ) { if ( root != nullptr ) { if ( level > maxLevel ) { ans . emplace_back ( root -> val ); maxLevel = level ; } rightOrder ( root -> right , ans , level + 1 , maxLevel ); rightOrder ( root -> left , ans , level + 1 , maxLevel ); } } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002 \u4e2d\u5e8f\u904d\u5386 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // \u8fed\u4ee3\u7248 vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; stack < TreeNode *> st ; TreeNode * curNode = root ; while ( curNode != nullptr ) { while ( curNode != nullptr ) { if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } st . push ( curNode ); curNode = curNode -> left ; } curNode = st . top (); st . pop (); while ( ! st . empty () && curNode -> right == nullptr ) { res . push_back ( curNode -> val ); curNode = st . top (); st . pop (); } res . push_back ( curNode -> val ); if ( ! st . empty ()) { curNode = st . top (); st . pop (); } else { curNode = nullptr ; } } return res ; } // \u9012\u5f52\u7248 void inOrder ( TreeNode * root , vector < int > & res ) { if ( root != nullptr ) { inOrder ( root -> left , res ); res . push_back ( root -> val ); inOrder ( root -> right , res ); } } vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; inOrder ( root , res ); return res ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002 \u540e\u5e8f\u904d\u5386 \u00b6 \u4e8c\u53c9\u6811\u6700\u8fd1\u516c\u5171\u7956\u5148 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* 3 / \\ 5 1 / \\ / \\ 6 2 0 8 / \\ 7 4 p = 5, q = 1 nearest common ancester is 3 */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { vector < TreeNode *> t1 , t2 , t ; dfs ( root , p , t1 , t ); t . clear (); dfs ( root , q , t2 , t ); TreeNode * ans = nullptr ; for ( int i = 0 ; i < t1 . size () && i < t2 . size (); i ++ ) { if ( t1 [ i ] != t2 [ i ]) { break ; } ans = t1 [ i ]; } return ans ; } void dfs ( TreeNode * root , TreeNode * node , vector < TreeNode *> & res , vector < TreeNode *> & t ) { if ( root == nullptr ) { return ; } t . emplace_back ( root ); if ( root == node ) { for ( auto ele : t ) { res . emplace_back ( ele ); } return ; } dfs ( root -> left , node , res , t ); dfs ( root -> right , node , res , t ); t . pop_back (); } }; \u4e8c\u53c9\u6811\u7684\u76f4\u5f84 \u00b6 \u7ed9\u4f60\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9\uff0c\u8fd4\u56de\u8be5\u6811\u7684\u76f4\u5f84\u3002\u4e8c\u53c9\u6811\u7684\u76f4\u5f84\u662f\u6307\u6811\u4e2d\u4efb\u610f\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6\u3002\u8fd9\u6761\u8def\u5f84\u53ef\u80fd\u7ecf\u8fc7\u4e5f\u53ef\u80fd\u4e0d\u7ecf\u8fc7\u6839\u8282\u70b9 root \u3002 \\begin{matrix} & & & & & 1 \\\\ & & & & \\swarrow & & \\searrow \\\\ & & & 2 & & & & 3 \\\\ & & \\swarrow & & \\searrow \\\\ & 4 & & & & 5 \\end{matrix} \\begin{matrix} & & & & & 1 \\\\ & & & & \\swarrow & & \\searrow \\\\ & & & 2 & & & & 3 \\\\ & & \\swarrow & & \\searrow \\\\ & 4 & & & & 5 \\end{matrix} \u8fd4\u56de 3\u3002 \u300c\u5206\u6790\u300d \u300c\u540e\u5e8f\u904d\u5386\u300d\u6c42\u51fa\u6bcf\u4e00\u4e2a\u5b50\u6811\u7684\u957f\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int getDepth ( TreeNode * root , int & maxDiameter ) { if ( root == nullptr ) { return 0 ; } int left = getDepth ( root -> left , maxDiameter ); int right = getDepth ( root -> right , maxDiameter ); maxDiameter = max ( maxDiameter , left + right ); return max ( left , right ) + 1 ; } int diameterOfBinaryTree ( TreeNode * root ) { int ans = 0 ; getDepth ( root , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002 \u4e8c\u53c9\u6811\u7684\u6700\u5927\u6df1\u5ea6 \u00b6 \u4e8c\u53c9\u6811\u7684 \u6700\u5927\u6df1\u5ea6 \u662f\u6307\u4ece\u6839\u8282\u70b9\u5230\u6700\u8fdc\u53f6\u5b50\u8282\u70b9\u7684\u6700\u957f\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 3 / \\ 9 20 / \\ 15 7 max depth = 3 */ int maxDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = maxDepth ( root -> left ); int rightDep = maxDepth ( root -> right ); return 1 + max ( leftDep , rightDep ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002 \u4e8c\u53c9\u6811\u7684\u6700\u5c0f\u6df1\u5ea6 \u00b6 \u6700\u5c0f\u6df1\u5ea6\u662f\u4ece\u6839\u8282\u70b9\u5230\u6700\u8fd1\u53f6\u5b50\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u6570\u91cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 3 / \\ 9 20 / \\ 15 7 min depth = 2 */ int minDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = minDepth ( root -> left ); int rightDep = minDepth ( root -> right ); if ( leftDep != 0 && rightDep != 0 ) { return 1 + min ( leftDep , rightDep ); } return 1 + max ( leftDep , rightDep ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002 \u4e8c\u53c9\u6811\u4e2d\u7684\u6700\u5927\u8def\u5f84\u548c \u00b6 \u4e8c\u53c9\u6811\u4e2d\u7684 \u8def\u5f84 \u88ab\u5b9a\u4e49\u4e3a\u4e00\u6761\u8282\u70b9\u5e8f\u5217\uff0c\u5e8f\u5217\u4e2d\u6bcf\u5bf9\u76f8\u90bb\u8282\u70b9\u4e4b\u95f4\u90fd\u5b58\u5728\u4e00\u6761\u8fb9\u3002\u540c\u4e00\u4e2a\u8282\u70b9\u5728\u4e00\u6761\u8def\u5f84\u5e8f\u5217\u4e2d \u81f3\u591a\u51fa\u73b0\u4e00\u6b21 \u3002\u8be5\u8def\u5f84 \u81f3\u5c11\u5305\u542b\u4e00\u4e2a \u8282\u70b9\uff0c\u4e14\u4e0d\u4e00\u5b9a\u7ecf\u8fc7\u6839\u8282\u70b9\u3002\u8def\u5f84\u548c\u662f\u8def\u5f84\u4e2d\u5404\u8282\u70b9\u503c\u7684\u603b\u548c\u3002\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9 root \uff0c\u8fd4\u56de\u5176 \u6700\u5927\u8def\u5f84\u548c \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* -10 / \\ 9 20 / \\ 15 7 \u8fd4\u56de 42 */ int dfs ( TreeNode * root , int & ans ) { if ( root == nullptr ) { return 0 ; } int left = dfs ( root -> left , ans ); int right = dfs ( root -> right , ans ); int sum = max ( root -> val + left + right , root -> val + max ( left , right )); if ( ans < sum ) { ans = sum ; } return max ( 0 , root -> val + max ( left , right )); } int maxPathSum ( TreeNode * root ) { int ans = INT_MIN ; dfs ( root , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002 \u5c42\u5e8f\u904d\u5386 \u00b6 \u5c42\u5e8f\u904d\u5386\u901a\u5e38\u4f7f\u7528\u3010\u961f\u5217\u3011\u4f5c\u4e3a\u8f85\u52a9\u6570\u636e\u7ed3\u6784\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { ans . emplace_back ( arr ); arr . clear (); last = nextLast ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002 \u586b\u5145\u4e8c\u53c9\u6811\u7684 next \u6307\u9488 \u00b6 \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6bcf\u4e00\u4e2a\u8282\u70b9\u9664\u4e86 left \u548c right \u6307\u9488\uff0c\u8fd8\u6709\u4e00\u4e2a\u6307\u5411\u540c\u5c42\u53f3\u4fa7 next \u6307\u9488\uff0c\u521d\u59cb\u4e3a nullptr\uff0c\u5b9e\u73b0\u4e00\u4e2a\u7b97\u6cd5\uff0c\u586b\u5145 next\u3002 \\begin{matrix} & & & & 1 \\\\ & & & \\swarrow & & \\searrow \\\\ & & 2 & & {\\color{Red} \\Rightarrow} & & 3 \\\\ & \\swarrow & & \\searrow & & & & \\searrow \\\\ 4 & & {\\color{Red} \\Rightarrow} & & 5 & & {\\color{Red} \\Rightarrow} & & 6 \\end{matrix} \\begin{matrix} & & & & 1 \\\\ & & & \\swarrow & & \\searrow \\\\ & & 2 & & {\\color{Red} \\Rightarrow} & & 3 \\\\ & \\swarrow & & \\searrow & & & & \\searrow \\\\ 4 & & {\\color{Red} \\Rightarrow} & & 5 & & {\\color{Red} \\Rightarrow} & & 6 \\end{matrix} \u300c\u5206\u6790\u300d \u3010\u5c42\u5e8f\u904d\u5386\u3011\u5229\u7528 next \u6307\u9488\uff0c\u65e0\u9700 queue \u8f85\u52a9\u7a7a\u95f4 \u3002\u5047\u8bbe\u5f53\u524d\u8282\u70b9\u662f cur\uff0ccur->left\uff08\u5982\u679c\u5b58\u5728\uff09\u6307\u5411 cur->right \u6216\u8005 cur->next->left / right\uff08\u627e\u5230 cur \u7684\u7b2c\u4e00\u4e2a left \u6216 right \u4e0d\u7a7a\u7684 next\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Node { public : int val ; Node * left ; Node * right ; Node * next ; Node () : val ( 0 ), left ( NULL ), right ( NULL ), next ( NULL ) {} Node ( int _val ) : val ( _val ), left ( NULL ), right ( NULL ), next ( NULL ) {} Node ( int _val , Node * _left , Node * _right , Node * _next ) : val ( _val ), left ( _left ), right ( _right ), next ( _next ) {} }; Node * connect ( Node * root ) { if ( root == nullptr ) { return root ; } Node * nextFirst = root , * cur = root ; while ( cur != nullptr ) { Node * left = cur -> left , * right = cur -> right , * next = cur -> next ; if ( left != nullptr ) { if ( right != nullptr ) { left -> next = right ; } if ( nextFirst == nullptr ) { nextFirst = left ; } } if ( right != nullptr && nextFirst == nullptr ) { nextFirst = cur -> right ; } while ( next != nullptr ) { if ( next -> left != nullptr ) { if ( left != nullptr && left -> next == nullptr ) { left -> next = next -> left ; } if ( right != nullptr ) { right -> next = next -> left ; } break ; } if ( next -> right != nullptr ) { if ( left != nullptr && left -> next == nullptr ) { left -> next = next -> right ; } if ( right != nullptr ) { right -> next = next -> right ; } break ; } next = next -> next ; } if ( next == nullptr ) { cur = nextFirst ; nextFirst = nullptr ; } else { cur = next ; } } return root ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u904d\u5386"},{"location":"data-structure/tree/traversal/#_1","text":"\u904d\u5386\u662f\u5bf9\u4e8c\u53c9\u6811\u7684\u6240\u6709\u8282\u70b9\u505a\u4e00\u6b21\u65e0\u91cd\u590d\u7684\u8bbf\u95ee\u3002","title":"\u904d\u5386"},{"location":"data-structure/tree/traversal/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // \u8fed\u4ee3\u7248 vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { curNode = st . top (); st . pop (); ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { st . push ( curNode -> left ); } } return ans ; } // \u9012\u5f52\u7248 vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; while ( true ) { while ( curNode != nullptr ) { ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } curNode = curNode -> left ; } if ( st . empty ()) { break ; } curNode = st . top (); st . pop (); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002","title":"\u524d\u5e8f\u904d\u5386"},{"location":"data-structure/tree/traversal/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u4ece\u53f3\u5411\u5de6\u770b\uff0c\u8fd4\u56de\u770b\u5230\u7684\u5e8f\u5217\uff08\u7531\u4e0a\u53ca\u4e0b\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } int maxLevel = - 1 ; rightOrder ( root , ans , 0 , maxLevel ); return ans ; } void rightOrder ( TreeNode * root , vector < int > & ans , int level , int & maxLevel ) { if ( root != nullptr ) { if ( level > maxLevel ) { ans . emplace_back ( root -> val ); maxLevel = level ; } rightOrder ( root -> right , ans , level + 1 , maxLevel ); rightOrder ( root -> left , ans , level + 1 , maxLevel ); } } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002","title":"\u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe"},{"location":"data-structure/tree/traversal/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // \u8fed\u4ee3\u7248 vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; stack < TreeNode *> st ; TreeNode * curNode = root ; while ( curNode != nullptr ) { while ( curNode != nullptr ) { if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } st . push ( curNode ); curNode = curNode -> left ; } curNode = st . top (); st . pop (); while ( ! st . empty () && curNode -> right == nullptr ) { res . push_back ( curNode -> val ); curNode = st . top (); st . pop (); } res . push_back ( curNode -> val ); if ( ! st . empty ()) { curNode = st . top (); st . pop (); } else { curNode = nullptr ; } } return res ; } // \u9012\u5f52\u7248 void inOrder ( TreeNode * root , vector < int > & res ) { if ( root != nullptr ) { inOrder ( root -> left , res ); res . push_back ( root -> val ); inOrder ( root -> right , res ); } } vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; inOrder ( root , res ); return res ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002","title":"\u4e2d\u5e8f\u904d\u5386"},{"location":"data-structure/tree/traversal/#_5","text":"","title":"\u540e\u5e8f\u904d\u5386"},{"location":"data-structure/tree/traversal/#_6","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* 3 / \\ 5 1 / \\ / \\ 6 2 0 8 / \\ 7 4 p = 5, q = 1 nearest common ancester is 3 */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { vector < TreeNode *> t1 , t2 , t ; dfs ( root , p , t1 , t ); t . clear (); dfs ( root , q , t2 , t ); TreeNode * ans = nullptr ; for ( int i = 0 ; i < t1 . size () && i < t2 . size (); i ++ ) { if ( t1 [ i ] != t2 [ i ]) { break ; } ans = t1 [ i ]; } return ans ; } void dfs ( TreeNode * root , TreeNode * node , vector < TreeNode *> & res , vector < TreeNode *> & t ) { if ( root == nullptr ) { return ; } t . emplace_back ( root ); if ( root == node ) { for ( auto ele : t ) { res . emplace_back ( ele ); } return ; } dfs ( root -> left , node , res , t ); dfs ( root -> right , node , res , t ); t . pop_back (); } };","title":"\u4e8c\u53c9\u6811\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"data-structure/tree/traversal/#_7","text":"\u7ed9\u4f60\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9\uff0c\u8fd4\u56de\u8be5\u6811\u7684\u76f4\u5f84\u3002\u4e8c\u53c9\u6811\u7684\u76f4\u5f84\u662f\u6307\u6811\u4e2d\u4efb\u610f\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6\u3002\u8fd9\u6761\u8def\u5f84\u53ef\u80fd\u7ecf\u8fc7\u4e5f\u53ef\u80fd\u4e0d\u7ecf\u8fc7\u6839\u8282\u70b9 root \u3002 \\begin{matrix} & & & & & 1 \\\\ & & & & \\swarrow & & \\searrow \\\\ & & & 2 & & & & 3 \\\\ & & \\swarrow & & \\searrow \\\\ & 4 & & & & 5 \\end{matrix} \\begin{matrix} & & & & & 1 \\\\ & & & & \\swarrow & & \\searrow \\\\ & & & 2 & & & & 3 \\\\ & & \\swarrow & & \\searrow \\\\ & 4 & & & & 5 \\end{matrix} \u8fd4\u56de 3\u3002 \u300c\u5206\u6790\u300d \u300c\u540e\u5e8f\u904d\u5386\u300d\u6c42\u51fa\u6bcf\u4e00\u4e2a\u5b50\u6811\u7684\u957f\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int getDepth ( TreeNode * root , int & maxDiameter ) { if ( root == nullptr ) { return 0 ; } int left = getDepth ( root -> left , maxDiameter ); int right = getDepth ( root -> right , maxDiameter ); maxDiameter = max ( maxDiameter , left + right ); return max ( left , right ) + 1 ; } int diameterOfBinaryTree ( TreeNode * root ) { int ans = 0 ; getDepth ( root , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002","title":"\u4e8c\u53c9\u6811\u7684\u76f4\u5f84"},{"location":"data-structure/tree/traversal/#_8","text":"\u4e8c\u53c9\u6811\u7684 \u6700\u5927\u6df1\u5ea6 \u662f\u6307\u4ece\u6839\u8282\u70b9\u5230\u6700\u8fdc\u53f6\u5b50\u8282\u70b9\u7684\u6700\u957f\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 3 / \\ 9 20 / \\ 15 7 max depth = 3 */ int maxDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = maxDepth ( root -> left ); int rightDep = maxDepth ( root -> right ); return 1 + max ( leftDep , rightDep ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002","title":"\u4e8c\u53c9\u6811\u7684\u6700\u5927\u6df1\u5ea6"},{"location":"data-structure/tree/traversal/#_9","text":"\u6700\u5c0f\u6df1\u5ea6\u662f\u4ece\u6839\u8282\u70b9\u5230\u6700\u8fd1\u53f6\u5b50\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u6570\u91cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 3 / \\ 9 20 / \\ 15 7 min depth = 2 */ int minDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = minDepth ( root -> left ); int rightDep = minDepth ( root -> right ); if ( leftDep != 0 && rightDep != 0 ) { return 1 + min ( leftDep , rightDep ); } return 1 + max ( leftDep , rightDep ); } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002","title":"\u4e8c\u53c9\u6811\u7684\u6700\u5c0f\u6df1\u5ea6"},{"location":"data-structure/tree/traversal/#_10","text":"\u4e8c\u53c9\u6811\u4e2d\u7684 \u8def\u5f84 \u88ab\u5b9a\u4e49\u4e3a\u4e00\u6761\u8282\u70b9\u5e8f\u5217\uff0c\u5e8f\u5217\u4e2d\u6bcf\u5bf9\u76f8\u90bb\u8282\u70b9\u4e4b\u95f4\u90fd\u5b58\u5728\u4e00\u6761\u8fb9\u3002\u540c\u4e00\u4e2a\u8282\u70b9\u5728\u4e00\u6761\u8def\u5f84\u5e8f\u5217\u4e2d \u81f3\u591a\u51fa\u73b0\u4e00\u6b21 \u3002\u8be5\u8def\u5f84 \u81f3\u5c11\u5305\u542b\u4e00\u4e2a \u8282\u70b9\uff0c\u4e14\u4e0d\u4e00\u5b9a\u7ecf\u8fc7\u6839\u8282\u70b9\u3002\u8def\u5f84\u548c\u662f\u8def\u5f84\u4e2d\u5404\u8282\u70b9\u503c\u7684\u603b\u548c\u3002\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9 root \uff0c\u8fd4\u56de\u5176 \u6700\u5927\u8def\u5f84\u548c \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* -10 / \\ 9 20 / \\ 15 7 \u8fd4\u56de 42 */ int dfs ( TreeNode * root , int & ans ) { if ( root == nullptr ) { return 0 ; } int left = dfs ( root -> left , ans ); int right = dfs ( root -> right , ans ); int sum = max ( root -> val + left + right , root -> val + max ( left , right )); if ( ans < sum ) { ans = sum ; } return max ( 0 , root -> val + max ( left , right )); } int maxPathSum ( TreeNode * root ) { int ans = INT_MIN ; dfs ( root , ans ); return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(\\log n) O(\\log n) \u3002","title":"\u4e8c\u53c9\u6811\u4e2d\u7684\u6700\u5927\u8def\u5f84\u548c"},{"location":"data-structure/tree/traversal/#_11","text":"\u5c42\u5e8f\u904d\u5386\u901a\u5e38\u4f7f\u7528\u3010\u961f\u5217\u3011\u4f5c\u4e3a\u8f85\u52a9\u6570\u636e\u7ed3\u6784\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { ans . emplace_back ( arr ); arr . clear (); last = nextLast ; } } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \u3002","title":"\u5c42\u5e8f\u904d\u5386"},{"location":"data-structure/tree/traversal/#next","text":"\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6bcf\u4e00\u4e2a\u8282\u70b9\u9664\u4e86 left \u548c right \u6307\u9488\uff0c\u8fd8\u6709\u4e00\u4e2a\u6307\u5411\u540c\u5c42\u53f3\u4fa7 next \u6307\u9488\uff0c\u521d\u59cb\u4e3a nullptr\uff0c\u5b9e\u73b0\u4e00\u4e2a\u7b97\u6cd5\uff0c\u586b\u5145 next\u3002 \\begin{matrix} & & & & 1 \\\\ & & & \\swarrow & & \\searrow \\\\ & & 2 & & {\\color{Red} \\Rightarrow} & & 3 \\\\ & \\swarrow & & \\searrow & & & & \\searrow \\\\ 4 & & {\\color{Red} \\Rightarrow} & & 5 & & {\\color{Red} \\Rightarrow} & & 6 \\end{matrix} \\begin{matrix} & & & & 1 \\\\ & & & \\swarrow & & \\searrow \\\\ & & 2 & & {\\color{Red} \\Rightarrow} & & 3 \\\\ & \\swarrow & & \\searrow & & & & \\searrow \\\\ 4 & & {\\color{Red} \\Rightarrow} & & 5 & & {\\color{Red} \\Rightarrow} & & 6 \\end{matrix} \u300c\u5206\u6790\u300d \u3010\u5c42\u5e8f\u904d\u5386\u3011\u5229\u7528 next \u6307\u9488\uff0c\u65e0\u9700 queue \u8f85\u52a9\u7a7a\u95f4 \u3002\u5047\u8bbe\u5f53\u524d\u8282\u70b9\u662f cur\uff0ccur->left\uff08\u5982\u679c\u5b58\u5728\uff09\u6307\u5411 cur->right \u6216\u8005 cur->next->left / right\uff08\u627e\u5230 cur \u7684\u7b2c\u4e00\u4e2a left \u6216 right \u4e0d\u7a7a\u7684 next\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Node { public : int val ; Node * left ; Node * right ; Node * next ; Node () : val ( 0 ), left ( NULL ), right ( NULL ), next ( NULL ) {} Node ( int _val ) : val ( _val ), left ( NULL ), right ( NULL ), next ( NULL ) {} Node ( int _val , Node * _left , Node * _right , Node * _next ) : val ( _val ), left ( _left ), right ( _right ), next ( _next ) {} }; Node * connect ( Node * root ) { if ( root == nullptr ) { return root ; } Node * nextFirst = root , * cur = root ; while ( cur != nullptr ) { Node * left = cur -> left , * right = cur -> right , * next = cur -> next ; if ( left != nullptr ) { if ( right != nullptr ) { left -> next = right ; } if ( nextFirst == nullptr ) { nextFirst = left ; } } if ( right != nullptr && nextFirst == nullptr ) { nextFirst = cur -> right ; } while ( next != nullptr ) { if ( next -> left != nullptr ) { if ( left != nullptr && left -> next == nullptr ) { left -> next = next -> left ; } if ( right != nullptr ) { right -> next = next -> left ; } break ; } if ( next -> right != nullptr ) { if ( left != nullptr && left -> next == nullptr ) { left -> next = next -> right ; } if ( right != nullptr ) { right -> next = next -> right ; } break ; } next = next -> next ; } if ( next == nullptr ) { cur = nextFirst ; nextFirst = nullptr ; } else { cur = next ; } } return root ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1)","title":"\u586b\u5145\u4e8c\u53c9\u6811\u7684 next \u6307\u9488"},{"location":"machine-learning/activation/","text":"\u5fc5\u8981\u6027 \u00b6 \u9996\u5148\u8981\u660e\u786e\uff0c\u4e00\u7cfb\u5217\u7684\u7ebf\u6027\u53d8\u5316\u7684\u7ed3\u679c\u4f9d\u65e7\u662f\u7ebf\u6027\u53d8\u6362\uff0c\u8fd9\u4e0d\u4f1a\u6709\u52a9\u4e8e\u795e\u7ecf\u7f51\u7edc\u8868\u8fbe\u80fd\u529b\u7684\u63d0\u9ad8\u3002\u56e0\u6b64\uff0c\u5f15\u5165\u975e\u7ebf\u5f62\u53d8\u5316\u662f\u5fc5\u8981\u7684\u3002\u901a\u5e38\u7684\u65b9\u6cd5\u662f\u52a0\u5165\u6fc0\u6d3b\u51fd\u6570\u3002 ReLU \u00b6 \\begin{aligned} & g(z) = \\begin{cases} z, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\\\ & g(z)' = \\begin{cases} 1, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\end{aligned} \\begin{aligned} & g(z) = \\begin{cases} z, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\\\ & g(z)' = \\begin{cases} 1, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\end{aligned} \\bigstar \\bigstar \u4fbf\u4e8e\u8ba1\u7b97\uff0c\u5b9e\u9645\u60c5\u51b5\u4e0b\u80fd\u5feb\u901f\u6536\u655b \\bigstar \\bigstar x > 0 \u65f6 \u68af\u5ea6\u4e0d\u4f1a\u7206\u70b8\u4e5f\u4e0d\u4f1a\u6d88\u5931\uff1bx < 0 \u65f6\uff0c\u65e0\u68af\u5ea6\u66f4\u65b0 \\bigstar \\bigstar \u4e0d\u662f 0 \u4e2d\u5fc3\u5bf9\u79f0 Leaky ReLU \u00b6 \\begin{aligned} f(x) &= \\begin{cases} x, \\quad & x \\geq 0 \\\\ ax, \\quad & x < 0 \\end{cases} \\\\ &= \\max(ax, x), \\quad \\text{where } a \\in (0, 1) \\end{aligned} \\begin{aligned} f(x) &= \\begin{cases} x, \\quad & x \\geq 0 \\\\ ax, \\quad & x < 0 \\end{cases} \\\\ &= \\max(ax, x), \\quad \\text{where } a \\in (0, 1) \\end{aligned} \\bigstar \\bigstar \u4e0d\u4f1a\u51fa\u73b0\u68af\u5ea6\u4e3a0\u7684\u60c5\u51b5 \\bigstar \\bigstar a \\neq 1 a \\neq 1 , \u56e0\u4e3a a = 1 \u4f1a\u5931\u53bb\u6fc0\u6d3b\u51fd\u6570\u7684\u4f5c\u7528 Sigmoid \u00b6 \\begin{aligned} & \\text{Sigmoid}(Z) = \\pi(Z) = \\frac{1}{1 + e^{-Z}} \\\\ & \\frac{\\partial \\pi(Z)}{\\partial Z} = \\pi(Z) (1 - \\pi(Z)) \\leq \\frac{1}{4} \\end{aligned} \\begin{aligned} & \\text{Sigmoid}(Z) = \\pi(Z) = \\frac{1}{1 + e^{-Z}} \\\\ & \\frac{\\partial \\pi(Z)}{\\partial Z} = \\pi(Z) (1 - \\pi(Z)) \\leq \\frac{1}{4} \\end{aligned} \\bigstar \\bigstar \u4e8c\u5206\u7d2f\u95ee\u9898\u7684\u8f93\u51fa\u5c42\uff0c\u7528\u4f5c\u9690\u85cf\u5c42\u6fc0\u6d3b\u51fd\u6570\u5bb9\u6613\u5bfc\u81f4 \\bigstar \\bigstar \u975e 0 \u4e2d\u5fc3 \\bigstar \\bigstar e^{x} e^{x} \u8ba1\u7b97\u6210\u672c\u5927 Tanh \u00b6 \\begin{aligned} & \\text{tanh}(x) = g(x) = \\frac{2}{1 + e^{-2x}} - 1 = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} \\\\ & \\frac{\\partial}{\\partial x} \\text{tanh}(x) = \\frac{\\partial}{\\partial x} g(x) = 4 \\frac{e^{-2x}}{(1 + e^{-2x})^{2}} = 1 - (g(x))^{2} \\leq 1 \\end{aligned} \\begin{aligned} & \\text{tanh}(x) = g(x) = \\frac{2}{1 + e^{-2x}} - 1 = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} \\\\ & \\frac{\\partial}{\\partial x} \\text{tanh}(x) = \\frac{\\partial}{\\partial x} g(x) = 4 \\frac{e^{-2x}}{(1 + e^{-2x})^{2}} = 1 - (g(x))^{2} \\leq 1 \\end{aligned} \\bigstar \\bigstar 0 \u4e2d\u5fc3\u6709\u52a9\u4e8e\u6570\u503c\u8ba1\u7b97\uff0c\u53cc\u8fb9\u9971\u548c\u5bfc\u81f4\u68af\u5ea6\u6d88\u5931\u3002 Softmax \u00b6 \\begin{aligned} & Z = (Z_{1}, Z_{2}, ..., Z_{K}) = (w_{1}^{T}x, w_{2}^{T}x, ..., w_{K}^{T}x) \\\\ & \\text{Softmax}(Z) = (\\frac{e^{Z_{1}}}{\\sum_{k=1}^{K}e^{Z_{k}}}, \\frac{e^{Z_{2}}}{\\sum_{k=1}^{K}e^{Z_{k}}},..., \\frac{e^{Z_{K}}}{\\sum_{k=1}^{K}e^{Z_{k}}}) \\\\ & \\text{e.g. } Z = (7, -7.5, 10) \\rightarrow \\text{Softmax}(Z) \\approx (0.05, 0, 0.95) \\end{aligned} \\begin{aligned} & Z = (Z_{1}, Z_{2}, ..., Z_{K}) = (w_{1}^{T}x, w_{2}^{T}x, ..., w_{K}^{T}x) \\\\ & \\text{Softmax}(Z) = (\\frac{e^{Z_{1}}}{\\sum_{k=1}^{K}e^{Z_{k}}}, \\frac{e^{Z_{2}}}{\\sum_{k=1}^{K}e^{Z_{k}}},..., \\frac{e^{Z_{K}}}{\\sum_{k=1}^{K}e^{Z_{k}}}) \\\\ & \\text{e.g. } Z = (7, -7.5, 10) \\rightarrow \\text{Softmax}(Z) \\approx (0.05, 0, 0.95) \\end{aligned} \\bigstar \\bigstar \u4ea4\u53c9\u71b5\u4f5c\u4e3a\u5206\u7c7b\u95ee\u9898\u7684\u635f\u5931\u51fd\u6570\u5bb9\u6613\u5fae\u5206 \\begin{aligned} J(w,b) &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{Z_{i, k}}}{\\sum_{j=1}^{K} e^{Z_{i, j}} } \\\\ &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{w_{k}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} \\log\\frac{e^{w_{y_{i}}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} (w_{y_{i}}^{T}x_{i} - \\log \\sum_{j=1}^{K}e^{w_j^{T}x_{j}}) \\\\ &= -\\sum_{i=1}^{m} (Z_{i, y_{i}} - \\log \\sum_{j=1}^{K} e^{Z_{i, j}}) \\\\ &\\rightarrow \\min_{w,b} \\end{aligned} \\begin{aligned} J(w,b) &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{Z_{i, k}}}{\\sum_{j=1}^{K} e^{Z_{i, j}} } \\\\ &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{w_{k}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} \\log\\frac{e^{w_{y_{i}}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} (w_{y_{i}}^{T}x_{i} - \\log \\sum_{j=1}^{K}e^{w_j^{T}x_{j}}) \\\\ &= -\\sum_{i=1}^{m} (Z_{i, y_{i}} - \\log \\sum_{j=1}^{K} e^{Z_{i, j}}) \\\\ &\\rightarrow \\min_{w,b} \\end{aligned} \\bigstar \\bigstar Log-softmax \u597d\u4e8e naive log(softmax(a))\uff0c\u56e0\u4e3a 1\uff09\u6570\u503c\u8ba1\u7b97\u4e0a\u7a33\u5b9a\uff0c2\uff09\u5bb9\u6613\u5fae\u5206\uff0c3\uff09\u5bb9\u6613\u6c42 margin","title":"\u6fc0\u6d3b\u51fd\u6570"},{"location":"machine-learning/activation/#_1","text":"\u9996\u5148\u8981\u660e\u786e\uff0c\u4e00\u7cfb\u5217\u7684\u7ebf\u6027\u53d8\u5316\u7684\u7ed3\u679c\u4f9d\u65e7\u662f\u7ebf\u6027\u53d8\u6362\uff0c\u8fd9\u4e0d\u4f1a\u6709\u52a9\u4e8e\u795e\u7ecf\u7f51\u7edc\u8868\u8fbe\u80fd\u529b\u7684\u63d0\u9ad8\u3002\u56e0\u6b64\uff0c\u5f15\u5165\u975e\u7ebf\u5f62\u53d8\u5316\u662f\u5fc5\u8981\u7684\u3002\u901a\u5e38\u7684\u65b9\u6cd5\u662f\u52a0\u5165\u6fc0\u6d3b\u51fd\u6570\u3002","title":"\u5fc5\u8981\u6027"},{"location":"machine-learning/activation/#relu","text":"\\begin{aligned} & g(z) = \\begin{cases} z, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\\\ & g(z)' = \\begin{cases} 1, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\end{aligned} \\begin{aligned} & g(z) = \\begin{cases} z, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\\\ & g(z)' = \\begin{cases} 1, \\quad z > 0 \\\\ 0, \\quad \\text{otherwise} \\end{cases} \\end{aligned} \\bigstar \\bigstar \u4fbf\u4e8e\u8ba1\u7b97\uff0c\u5b9e\u9645\u60c5\u51b5\u4e0b\u80fd\u5feb\u901f\u6536\u655b \\bigstar \\bigstar x > 0 \u65f6 \u68af\u5ea6\u4e0d\u4f1a\u7206\u70b8\u4e5f\u4e0d\u4f1a\u6d88\u5931\uff1bx < 0 \u65f6\uff0c\u65e0\u68af\u5ea6\u66f4\u65b0 \\bigstar \\bigstar \u4e0d\u662f 0 \u4e2d\u5fc3\u5bf9\u79f0","title":"ReLU"},{"location":"machine-learning/activation/#leaky-relu","text":"\\begin{aligned} f(x) &= \\begin{cases} x, \\quad & x \\geq 0 \\\\ ax, \\quad & x < 0 \\end{cases} \\\\ &= \\max(ax, x), \\quad \\text{where } a \\in (0, 1) \\end{aligned} \\begin{aligned} f(x) &= \\begin{cases} x, \\quad & x \\geq 0 \\\\ ax, \\quad & x < 0 \\end{cases} \\\\ &= \\max(ax, x), \\quad \\text{where } a \\in (0, 1) \\end{aligned} \\bigstar \\bigstar \u4e0d\u4f1a\u51fa\u73b0\u68af\u5ea6\u4e3a0\u7684\u60c5\u51b5 \\bigstar \\bigstar a \\neq 1 a \\neq 1 , \u56e0\u4e3a a = 1 \u4f1a\u5931\u53bb\u6fc0\u6d3b\u51fd\u6570\u7684\u4f5c\u7528","title":"Leaky ReLU"},{"location":"machine-learning/activation/#sigmoid","text":"\\begin{aligned} & \\text{Sigmoid}(Z) = \\pi(Z) = \\frac{1}{1 + e^{-Z}} \\\\ & \\frac{\\partial \\pi(Z)}{\\partial Z} = \\pi(Z) (1 - \\pi(Z)) \\leq \\frac{1}{4} \\end{aligned} \\begin{aligned} & \\text{Sigmoid}(Z) = \\pi(Z) = \\frac{1}{1 + e^{-Z}} \\\\ & \\frac{\\partial \\pi(Z)}{\\partial Z} = \\pi(Z) (1 - \\pi(Z)) \\leq \\frac{1}{4} \\end{aligned} \\bigstar \\bigstar \u4e8c\u5206\u7d2f\u95ee\u9898\u7684\u8f93\u51fa\u5c42\uff0c\u7528\u4f5c\u9690\u85cf\u5c42\u6fc0\u6d3b\u51fd\u6570\u5bb9\u6613\u5bfc\u81f4 \\bigstar \\bigstar \u975e 0 \u4e2d\u5fc3 \\bigstar \\bigstar e^{x} e^{x} \u8ba1\u7b97\u6210\u672c\u5927","title":"Sigmoid"},{"location":"machine-learning/activation/#tanh","text":"\\begin{aligned} & \\text{tanh}(x) = g(x) = \\frac{2}{1 + e^{-2x}} - 1 = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} \\\\ & \\frac{\\partial}{\\partial x} \\text{tanh}(x) = \\frac{\\partial}{\\partial x} g(x) = 4 \\frac{e^{-2x}}{(1 + e^{-2x})^{2}} = 1 - (g(x))^{2} \\leq 1 \\end{aligned} \\begin{aligned} & \\text{tanh}(x) = g(x) = \\frac{2}{1 + e^{-2x}} - 1 = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} \\\\ & \\frac{\\partial}{\\partial x} \\text{tanh}(x) = \\frac{\\partial}{\\partial x} g(x) = 4 \\frac{e^{-2x}}{(1 + e^{-2x})^{2}} = 1 - (g(x))^{2} \\leq 1 \\end{aligned} \\bigstar \\bigstar 0 \u4e2d\u5fc3\u6709\u52a9\u4e8e\u6570\u503c\u8ba1\u7b97\uff0c\u53cc\u8fb9\u9971\u548c\u5bfc\u81f4\u68af\u5ea6\u6d88\u5931\u3002","title":"Tanh"},{"location":"machine-learning/activation/#softmax","text":"\\begin{aligned} & Z = (Z_{1}, Z_{2}, ..., Z_{K}) = (w_{1}^{T}x, w_{2}^{T}x, ..., w_{K}^{T}x) \\\\ & \\text{Softmax}(Z) = (\\frac{e^{Z_{1}}}{\\sum_{k=1}^{K}e^{Z_{k}}}, \\frac{e^{Z_{2}}}{\\sum_{k=1}^{K}e^{Z_{k}}},..., \\frac{e^{Z_{K}}}{\\sum_{k=1}^{K}e^{Z_{k}}}) \\\\ & \\text{e.g. } Z = (7, -7.5, 10) \\rightarrow \\text{Softmax}(Z) \\approx (0.05, 0, 0.95) \\end{aligned} \\begin{aligned} & Z = (Z_{1}, Z_{2}, ..., Z_{K}) = (w_{1}^{T}x, w_{2}^{T}x, ..., w_{K}^{T}x) \\\\ & \\text{Softmax}(Z) = (\\frac{e^{Z_{1}}}{\\sum_{k=1}^{K}e^{Z_{k}}}, \\frac{e^{Z_{2}}}{\\sum_{k=1}^{K}e^{Z_{k}}},..., \\frac{e^{Z_{K}}}{\\sum_{k=1}^{K}e^{Z_{k}}}) \\\\ & \\text{e.g. } Z = (7, -7.5, 10) \\rightarrow \\text{Softmax}(Z) \\approx (0.05, 0, 0.95) \\end{aligned} \\bigstar \\bigstar \u4ea4\u53c9\u71b5\u4f5c\u4e3a\u5206\u7c7b\u95ee\u9898\u7684\u635f\u5931\u51fd\u6570\u5bb9\u6613\u5fae\u5206 \\begin{aligned} J(w,b) &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{Z_{i, k}}}{\\sum_{j=1}^{K} e^{Z_{i, j}} } \\\\ &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{w_{k}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} \\log\\frac{e^{w_{y_{i}}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} (w_{y_{i}}^{T}x_{i} - \\log \\sum_{j=1}^{K}e^{w_j^{T}x_{j}}) \\\\ &= -\\sum_{i=1}^{m} (Z_{i, y_{i}} - \\log \\sum_{j=1}^{K} e^{Z_{i, j}}) \\\\ &\\rightarrow \\min_{w,b} \\end{aligned} \\begin{aligned} J(w,b) &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{Z_{i, k}}}{\\sum_{j=1}^{K} e^{Z_{i, j}} } \\\\ &= -\\sum_{i=1}^{m} \\sum_{k=1}^{K} \\mathbf{I}_{y_{i}=k} \\log \\frac{e^{w_{k}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} \\log\\frac{e^{w_{y_{i}}^{T}x_{i}}}{\\sum_{j=1}^{K}e^{w_j^{T}x_{j}}} \\\\ &= -\\sum_{i=1}^{m} (w_{y_{i}}^{T}x_{i} - \\log \\sum_{j=1}^{K}e^{w_j^{T}x_{j}}) \\\\ &= -\\sum_{i=1}^{m} (Z_{i, y_{i}} - \\log \\sum_{j=1}^{K} e^{Z_{i, j}}) \\\\ &\\rightarrow \\min_{w,b} \\end{aligned} \\bigstar \\bigstar Log-softmax \u597d\u4e8e naive log(softmax(a))\uff0c\u56e0\u4e3a 1\uff09\u6570\u503c\u8ba1\u7b97\u4e0a\u7a33\u5b9a\uff0c2\uff09\u5bb9\u6613\u5fae\u5206\uff0c3\uff09\u5bb9\u6613\u6c42 margin","title":"Softmax"},{"location":"machine-learning/cnn/","text":"\u5377\u79ef \u00b6 \\begin{bmatrix} 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 1 & 0 & 1 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix} = \\begin{bmatrix} 5 & 9 & 4 \\\\ 5 & 7 & 4 \\\\ 4 & 6 & 8 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 1 & 0 & 1 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix} = \\begin{bmatrix} 5 & 9 & 4 \\\\ 5 & 7 & 4 \\\\ 4 & 6 & 8 \\end{bmatrix} \u4e0d\u540c\u5377\u79ef\u6838\u7684\u6548\u679c\u5982\u4e0b \\bigstar \\bigstar \u5377\u79ef\u7684\u4f18\u70b9\uff1a\u5e73\u79fb\u4e0d\u53d8\u6027\uff08Translational Equivariance\uff09 \\begin{aligned} & \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 2 \\end{bmatrix} \\\\ & \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix} \\end{aligned} \\begin{aligned} & \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 2 \\end{bmatrix} \\\\ & \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix} \\end{aligned} \u53c2\u6570\u4e2a\u6570 \u00b6 \u5047\u8bbe\u6211\u4eec\u7684\u8f93\u5165\u548c\u8f93\u51fa\u5927\u5c0f\u90fd\u662f 300 \\times 300 300 \\times 300 \uff0c\u5982\u679c\u7528\u4e00\u4e2a $5 \\times5 \u5377\u79ef\u6838\uff0c\u53ea\u9700\u8981 26 \u4e2a\u53c2\u6570\uff1b\u5982\u679c\u7528\u5168\u8fde\u63a5\u5c42\uff0c\u9700\u8981 8.1\\times10^{9} 8.1\\times10^{9} \u4e2a\u53c2\u6570\u3002\u5377\u79ef\u5c42\u53ef\u4ee5\u770b\u4f5c\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u5168\u8fde\u63a5\u5c42\uff0c\u56e0\u4e3a\u53ef\u4ee5\u628a\u611f\u53d7\u91ce\u4e4b\u5916\u7684\u53c2\u6570\u770b\u4f5c\u662f 0\uff0c\u5377\u79ef\u6838\u7684\u53c2\u6570\u5728\u4e0d\u540c\u795e\u7ecf\u5143\u4e4b\u95f4\u662f\u5171\u4eab\u7684\u3002 C_{out} C_{out} \u4e2a\u5377\u79ef\u6838\uff0c\u5c3a\u5bf8\u662f W \\times H \\times C_{in} W \\times H \\times C_{in} \uff0cW \u548c H \u5206\u522b\u662f\u56fe\u7247\u7684\u5bbd\u548c\u9ad8\uff0c C_{in} C_{in} \u662f\u8f93\u5165\u901a\u9053\u7684\u4e2a\u6570\uff08RGB\u901a\u5e38\u662f3\uff09\uff0c C_{out} C_{out} \u662f\u6838\u7684\u4e2a\u6570\u3002\u6240\u6709\u7684\u53c2\u6570\u4e2a\u6570\u662f (W_{k} \\times H_{k} \\times C_{in} + 1) \\times C_{out} (W_{k} \\times H_{k} \\times C_{in} + 1) \\times C_{out} \u4f8b\u5982\uff0c\u6211\u4eec\u6709\u4e00\u4e2a 10x10x3 \u7684\u5f69\u8272\u56fe\u7247\uff0c\u6211\u4eec\u50cf\u5806\u4e24\u5c42\u5377\u79ef\u5c42\uff0c\u5377\u79ef\u6838\u5927\u5c0f 3x3\uff0c\u4e24\u5c42\u4e2a\u6570\u5206\u522b\u662f10 \u548c 20\uff0c\u7b97\u4e0a bias\uff0c\u4e00\u5171\u9700\u8981\u7684\u53c2\u6570\u4e2a\u6570\u662f (3 \\times 3 \\times 3 + 1) \\times 10 + (3 \\times 3 \\times 10 + 1) \\times 20 = 2100 (3 \\times 3 \\times 3 + 1) \\times 10 + (3 \\times 3 \\times 10 + 1) \\times 20 = 2100 Receptive field \u00b6 \u5806\u79ef\u4e86 n \u5c42\u5377\u79ef\uff08\u6838\u5c3a\u5bf8 k\u00d7k\uff0c\u6b65\u957f\u4e3a 1\uff09\u5c42\uff0c\u611f\u53d7\u91ce\u7684\u8fb9\u957f\u662f nk-n+1\u3002 Edge detection \u00b6 \u5782\u76f4\u65b9\u5411 \\begin{bmatrix} 1 & 0 & -1\\\\ 1 & 0 & -1\\\\ 1 & 0 & -1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & -1\\\\ 1 & 0 & -1\\\\ 1 & 0 & -1 \\end{bmatrix} \u6c34\u5e73\u65b9\u5411 \\begin{bmatrix} 1 & 1 & 1\\\\ 0 & 0 & 0\\\\ -1 & -1 & -1 \\end{bmatrix} \\begin{bmatrix} 1 & 1 & 1\\\\ 0 & 0 & 0\\\\ -1 & -1 & -1 \\end{bmatrix} Sobel operator \\begin{bmatrix} 1 & 0 & 1\\\\ 2 & 0 & -2\\\\ 1 & 0 & -1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 1\\\\ 2 & 0 & -2\\\\ 1 & 0 & -1 \\end{bmatrix} Sharp filter \\begin{bmatrix} 3 & 0 & -3\\\\ 10 & 0 & -10\\\\ 3 & 0 & -3 \\end{bmatrix} \\begin{bmatrix} 3 & 0 & -3\\\\ 10 & 0 & -10\\\\ 3 & 0 & -3 \\end{bmatrix} Padding \u00b6 \"Valid\": n \\times n n \\times n * f \\times f f \\times f \\rightarrow \\rightarrow (n - f +1) \\times (n - f + 1) (n - f +1) \\times (n - f + 1) \"same\": \u586b\u5145\u540e\u7684\u5c3a\u5bf8\u548c\u8f93\u5165\u5c3a\u5bf8\u76f8\u901a Strided Convolutions \u00b6 (n \\times n) * (f \\times f) \\rightarrow (\\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor \\times \\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor) (n \\times n) * (f \\times f) \\rightarrow (\\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor \\times \\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor) \u5047\u5982\u6211\u4eec\u6709\u4e00\u5f20 7 \\times 7 7 \\times 7 \u7684\u56fe\u7247\uff0c\u5377\u79ef\u6838 3 \\times 3 3 \\times 3 \uff0cpadding = 'valid'\uff0cstride = 2\uff0c\u90a3\u4e48\u8f93\u51fa\u7684\u5c3a\u5bf8\u662f (\\frac{7 + 0 - 3}{2} + 1, \\frac{7 + 0 - 3}{2} + 1) = (3, 3) (\\frac{7 + 0 - 3}{2} + 1, \\frac{7 + 0 - 3}{2} + 1) = (3, 3) \u4e00\u5c42\u5377\u79ef\u5c42\uff0c10 \u4e2a\u6838\uff0c\u5c3a\u5bf8 3 \\times 3 \\times 3 3 \\times 3 \\times 3 \uff0c\u53c2\u6570\u4e2a\u6570\uff1a (3 \\times 3 \\times 3 + 1) \\times 10 = 280 (3 \\times 3 \\times 3 + 1) \\times 10 = 280 \u5377\u79ef\u5c42 l f^{[l]} = \\text{filter size}, \\quad p^{[l]} = \\text{padding}, \\quad s^{[l]} = \\text{stride}, \\quad n_{c}^{[l]} = \\text{number of filters} f^{[l]} = \\text{filter size}, \\quad p^{[l]} = \\text{padding}, \\quad s^{[l]} = \\text{stride}, \\quad n_{c}^{[l]} = \\text{number of filters} \u6bcf\u4e00\u5c42\u8fc7\u6ee4\u7684\u5c3a\u5bf8 f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} \u8fd9\u4e00\u5c42\u7684\u8f93\u5165 n_{H}^{[l-1]} \\times n_{W}^{[l-1]} \\times n_{c}^{[l-1]} n_{H}^{[l-1]} \\times n_{W}^{[l-1]} \\times n_{c}^{[l-1]} \u8fd9\u4e00\u5c42\u7684\u8f93\u51fa n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} n_{H}^{[l]} = \\left \\lfloor \\frac{n_{H}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor, \\quad n_{W}^{[l]} = \\left \\lfloor \\frac{n_{W}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor n_{H}^{[l]} = \\left \\lfloor \\frac{n_{H}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor, \\quad n_{W}^{[l]} = \\left \\lfloor \\frac{n_{W}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor \u6fc0\u6d3b\u51fd\u6570 A^{[l]} \\rightarrow m \\times n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} A^{[l]} \\rightarrow m \\times n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} \u53c2\u6570 f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} \\times n_{c}^{[l]} f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} \\times n_{c}^{[l]} bias n_{c}^{[l]} \\rightarrow (1, 1, 1, n_{c}^{[l]}) n_{c}^{[l]} \\rightarrow (1, 1, 1, n_{c}^{[l]}) \u8f93\u5165\u5927\u5c0f 63x63x16\uff0c32 \u6838\uff0c\u6838\u5c3a\u5bf8 7x7\uff0cstride = 2\uff0c\u65e0 padding\uff0c\u8f93\u51fa\u5c3a\u5bf8 29x29x32 \u8f93\u5165\u5927\u5c0f 15x15x8\uff0c\u201cpad=2\u201d\uff0cpadding \u540e\u7684\u8f93\u51fa\u5c3a\u5bf8 19x19x8 \u8f93\u5165\u5927\u5c0f 63x63x16\uff0c32 \u6838\uff0c\u6838\u5c3a\u5bf8 7x7\uff0cstride = 1\uff0cpadding \u4e3a \u201csame\u201d\uff0cpadding \u4e3a 3 \u8f93\u5165\u5927\u5c0f 32x32x16\uff0c\u4f7f\u7528 max pooling \u4e14 stride = 2\uff0c\u8fc7\u6ee4\u5927\u5c0f\u4e3a 2\uff0c\u8f93\u51fa\u5c3a\u5bf8 16x16x16 \u6c60\u5316 \u00b6 \\begin{aligned} & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 9 & 2\\\\ 6 & 3 \\end{bmatrix} & \\text{Max pooling} \\\\ & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{15}{4} & \\frac{5}{4}\\\\ \\frac{15}{4} & 2 \\end{bmatrix} & \\text{Average pooling} \\end{aligned} \\begin{aligned} & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 9 & 2\\\\ 6 & 3 \\end{bmatrix} & \\text{Max pooling} \\\\ & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{15}{4} & \\frac{5}{4}\\\\ \\frac{15}{4} & 2 \\end{bmatrix} & \\text{Average pooling} \\end{aligned} \\bigstar \\bigstar \u8d85\u53c2\u6570\uff1a\u8fc7\u6ee4\u5927\u5c0f\uff0c\u6b65\u957f\uff0c\u6c60\u5316\u7c7b\u578b","title":"CNN"},{"location":"machine-learning/cnn/#_1","text":"\\begin{bmatrix} 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 1 & 0 & 1 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix} = \\begin{bmatrix} 5 & 9 & 4 \\\\ 5 & 7 & 4 \\\\ 4 & 6 & 8 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 1 & 0 & 1 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix} = \\begin{bmatrix} 5 & 9 & 4 \\\\ 5 & 7 & 4 \\\\ 4 & 6 & 8 \\end{bmatrix} \u4e0d\u540c\u5377\u79ef\u6838\u7684\u6548\u679c\u5982\u4e0b \\bigstar \\bigstar \u5377\u79ef\u7684\u4f18\u70b9\uff1a\u5e73\u79fb\u4e0d\u53d8\u6027\uff08Translational Equivariance\uff09 \\begin{aligned} & \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 2 \\end{bmatrix} \\\\ & \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix} \\end{aligned} \\begin{aligned} & \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 2 \\end{bmatrix} \\\\ & \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix} \\end{aligned}","title":"\u5377\u79ef"},{"location":"machine-learning/cnn/#_2","text":"\u5047\u8bbe\u6211\u4eec\u7684\u8f93\u5165\u548c\u8f93\u51fa\u5927\u5c0f\u90fd\u662f 300 \\times 300 300 \\times 300 \uff0c\u5982\u679c\u7528\u4e00\u4e2a $5 \\times5 \u5377\u79ef\u6838\uff0c\u53ea\u9700\u8981 26 \u4e2a\u53c2\u6570\uff1b\u5982\u679c\u7528\u5168\u8fde\u63a5\u5c42\uff0c\u9700\u8981 8.1\\times10^{9} 8.1\\times10^{9} \u4e2a\u53c2\u6570\u3002\u5377\u79ef\u5c42\u53ef\u4ee5\u770b\u4f5c\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u5168\u8fde\u63a5\u5c42\uff0c\u56e0\u4e3a\u53ef\u4ee5\u628a\u611f\u53d7\u91ce\u4e4b\u5916\u7684\u53c2\u6570\u770b\u4f5c\u662f 0\uff0c\u5377\u79ef\u6838\u7684\u53c2\u6570\u5728\u4e0d\u540c\u795e\u7ecf\u5143\u4e4b\u95f4\u662f\u5171\u4eab\u7684\u3002 C_{out} C_{out} \u4e2a\u5377\u79ef\u6838\uff0c\u5c3a\u5bf8\u662f W \\times H \\times C_{in} W \\times H \\times C_{in} \uff0cW \u548c H \u5206\u522b\u662f\u56fe\u7247\u7684\u5bbd\u548c\u9ad8\uff0c C_{in} C_{in} \u662f\u8f93\u5165\u901a\u9053\u7684\u4e2a\u6570\uff08RGB\u901a\u5e38\u662f3\uff09\uff0c C_{out} C_{out} \u662f\u6838\u7684\u4e2a\u6570\u3002\u6240\u6709\u7684\u53c2\u6570\u4e2a\u6570\u662f (W_{k} \\times H_{k} \\times C_{in} + 1) \\times C_{out} (W_{k} \\times H_{k} \\times C_{in} + 1) \\times C_{out} \u4f8b\u5982\uff0c\u6211\u4eec\u6709\u4e00\u4e2a 10x10x3 \u7684\u5f69\u8272\u56fe\u7247\uff0c\u6211\u4eec\u50cf\u5806\u4e24\u5c42\u5377\u79ef\u5c42\uff0c\u5377\u79ef\u6838\u5927\u5c0f 3x3\uff0c\u4e24\u5c42\u4e2a\u6570\u5206\u522b\u662f10 \u548c 20\uff0c\u7b97\u4e0a bias\uff0c\u4e00\u5171\u9700\u8981\u7684\u53c2\u6570\u4e2a\u6570\u662f (3 \\times 3 \\times 3 + 1) \\times 10 + (3 \\times 3 \\times 10 + 1) \\times 20 = 2100 (3 \\times 3 \\times 3 + 1) \\times 10 + (3 \\times 3 \\times 10 + 1) \\times 20 = 2100","title":"\u53c2\u6570\u4e2a\u6570"},{"location":"machine-learning/cnn/#receptive-field","text":"\u5806\u79ef\u4e86 n \u5c42\u5377\u79ef\uff08\u6838\u5c3a\u5bf8 k\u00d7k\uff0c\u6b65\u957f\u4e3a 1\uff09\u5c42\uff0c\u611f\u53d7\u91ce\u7684\u8fb9\u957f\u662f nk-n+1\u3002","title":"Receptive field"},{"location":"machine-learning/cnn/#edge-detection","text":"\u5782\u76f4\u65b9\u5411 \\begin{bmatrix} 1 & 0 & -1\\\\ 1 & 0 & -1\\\\ 1 & 0 & -1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & -1\\\\ 1 & 0 & -1\\\\ 1 & 0 & -1 \\end{bmatrix} \u6c34\u5e73\u65b9\u5411 \\begin{bmatrix} 1 & 1 & 1\\\\ 0 & 0 & 0\\\\ -1 & -1 & -1 \\end{bmatrix} \\begin{bmatrix} 1 & 1 & 1\\\\ 0 & 0 & 0\\\\ -1 & -1 & -1 \\end{bmatrix} Sobel operator \\begin{bmatrix} 1 & 0 & 1\\\\ 2 & 0 & -2\\\\ 1 & 0 & -1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 1\\\\ 2 & 0 & -2\\\\ 1 & 0 & -1 \\end{bmatrix} Sharp filter \\begin{bmatrix} 3 & 0 & -3\\\\ 10 & 0 & -10\\\\ 3 & 0 & -3 \\end{bmatrix} \\begin{bmatrix} 3 & 0 & -3\\\\ 10 & 0 & -10\\\\ 3 & 0 & -3 \\end{bmatrix}","title":"Edge detection"},{"location":"machine-learning/cnn/#padding","text":"\"Valid\": n \\times n n \\times n * f \\times f f \\times f \\rightarrow \\rightarrow (n - f +1) \\times (n - f + 1) (n - f +1) \\times (n - f + 1) \"same\": \u586b\u5145\u540e\u7684\u5c3a\u5bf8\u548c\u8f93\u5165\u5c3a\u5bf8\u76f8\u901a","title":"Padding"},{"location":"machine-learning/cnn/#strided-convolutions","text":"(n \\times n) * (f \\times f) \\rightarrow (\\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor \\times \\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor) (n \\times n) * (f \\times f) \\rightarrow (\\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor \\times \\left \\lfloor \\frac{n + 2p - f}{s} + 1 \\right \\rfloor) \u5047\u5982\u6211\u4eec\u6709\u4e00\u5f20 7 \\times 7 7 \\times 7 \u7684\u56fe\u7247\uff0c\u5377\u79ef\u6838 3 \\times 3 3 \\times 3 \uff0cpadding = 'valid'\uff0cstride = 2\uff0c\u90a3\u4e48\u8f93\u51fa\u7684\u5c3a\u5bf8\u662f (\\frac{7 + 0 - 3}{2} + 1, \\frac{7 + 0 - 3}{2} + 1) = (3, 3) (\\frac{7 + 0 - 3}{2} + 1, \\frac{7 + 0 - 3}{2} + 1) = (3, 3) \u4e00\u5c42\u5377\u79ef\u5c42\uff0c10 \u4e2a\u6838\uff0c\u5c3a\u5bf8 3 \\times 3 \\times 3 3 \\times 3 \\times 3 \uff0c\u53c2\u6570\u4e2a\u6570\uff1a (3 \\times 3 \\times 3 + 1) \\times 10 = 280 (3 \\times 3 \\times 3 + 1) \\times 10 = 280 \u5377\u79ef\u5c42 l f^{[l]} = \\text{filter size}, \\quad p^{[l]} = \\text{padding}, \\quad s^{[l]} = \\text{stride}, \\quad n_{c}^{[l]} = \\text{number of filters} f^{[l]} = \\text{filter size}, \\quad p^{[l]} = \\text{padding}, \\quad s^{[l]} = \\text{stride}, \\quad n_{c}^{[l]} = \\text{number of filters} \u6bcf\u4e00\u5c42\u8fc7\u6ee4\u7684\u5c3a\u5bf8 f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} \u8fd9\u4e00\u5c42\u7684\u8f93\u5165 n_{H}^{[l-1]} \\times n_{W}^{[l-1]} \\times n_{c}^{[l-1]} n_{H}^{[l-1]} \\times n_{W}^{[l-1]} \\times n_{c}^{[l-1]} \u8fd9\u4e00\u5c42\u7684\u8f93\u51fa n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} n_{H}^{[l]} = \\left \\lfloor \\frac{n_{H}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor, \\quad n_{W}^{[l]} = \\left \\lfloor \\frac{n_{W}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor n_{H}^{[l]} = \\left \\lfloor \\frac{n_{H}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor, \\quad n_{W}^{[l]} = \\left \\lfloor \\frac{n_{W}^{[l-1]} +2p^{[l]} -f^{[l]}}{s^{[l]}} + 1 \\right \\rfloor \u6fc0\u6d3b\u51fd\u6570 A^{[l]} \\rightarrow m \\times n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} A^{[l]} \\rightarrow m \\times n_{H}^{[l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]} \u53c2\u6570 f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} \\times n_{c}^{[l]} f^{[l]} \\times f^{[l]} \\times n_{c}^{[l-1]} \\times n_{c}^{[l]} bias n_{c}^{[l]} \\rightarrow (1, 1, 1, n_{c}^{[l]}) n_{c}^{[l]} \\rightarrow (1, 1, 1, n_{c}^{[l]}) \u8f93\u5165\u5927\u5c0f 63x63x16\uff0c32 \u6838\uff0c\u6838\u5c3a\u5bf8 7x7\uff0cstride = 2\uff0c\u65e0 padding\uff0c\u8f93\u51fa\u5c3a\u5bf8 29x29x32 \u8f93\u5165\u5927\u5c0f 15x15x8\uff0c\u201cpad=2\u201d\uff0cpadding \u540e\u7684\u8f93\u51fa\u5c3a\u5bf8 19x19x8 \u8f93\u5165\u5927\u5c0f 63x63x16\uff0c32 \u6838\uff0c\u6838\u5c3a\u5bf8 7x7\uff0cstride = 1\uff0cpadding \u4e3a \u201csame\u201d\uff0cpadding \u4e3a 3 \u8f93\u5165\u5927\u5c0f 32x32x16\uff0c\u4f7f\u7528 max pooling \u4e14 stride = 2\uff0c\u8fc7\u6ee4\u5927\u5c0f\u4e3a 2\uff0c\u8f93\u51fa\u5c3a\u5bf8 16x16x16","title":"Strided Convolutions"},{"location":"machine-learning/cnn/#_3","text":"\\begin{aligned} & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 9 & 2\\\\ 6 & 3 \\end{bmatrix} & \\text{Max pooling} \\\\ & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{15}{4} & \\frac{5}{4}\\\\ \\frac{15}{4} & 2 \\end{bmatrix} & \\text{Average pooling} \\end{aligned} \\begin{aligned} & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 9 & 2\\\\ 6 & 3 \\end{bmatrix} & \\text{Max pooling} \\\\ & \\begin{bmatrix} 1 & 3 & 2 & 1\\\\ 2 & 9 & 1 & 1\\\\ 1 & 3 & 2 & 3\\\\ 5 & 6 & 1 & 2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{15}{4} & \\frac{5}{4}\\\\ \\frac{15}{4} & 2 \\end{bmatrix} & \\text{Average pooling} \\end{aligned} \\bigstar \\bigstar \u8d85\u53c2\u6570\uff1a\u8fc7\u6ee4\u5927\u5c0f\uff0c\u6b65\u957f\uff0c\u6c60\u5316\u7c7b\u578b","title":"\u6c60\u5316"},{"location":"machine-learning/decision-tree/","text":"ID3 \u00b6 \\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned} \\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned} C4.5 \u00b6 g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)} g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)} CART \u00b6 \u5206\u7c7b\u6811 \u00b6 \\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned} \\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned} \u51b3\u7b56\u6811 \u00b6","title":"\u51b3\u7b56\u6811"},{"location":"machine-learning/decision-tree/#id3","text":"\\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned} \\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned}","title":"ID3"},{"location":"machine-learning/decision-tree/#c45","text":"g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)} g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)}","title":"C4.5"},{"location":"machine-learning/decision-tree/#cart","text":"","title":"CART"},{"location":"machine-learning/decision-tree/#_1","text":"\\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned} \\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned}","title":"\u5206\u7c7b\u6811"},{"location":"machine-learning/decision-tree/#_2","text":"","title":"\u51b3\u7b56\u6811"},{"location":"machine-learning/embs/","text":"\u5b9a\u4e49 \u00b6 \u8bcd\u5411\u91cf\u662f\u4e00\u79cd\u5c06\u5355\u8bcd\u6570\u5b57\u5316\u8868\u8fbe\u7684\u65b9\u6cd5\uff0c\u5373\u5c06\u5355\u8bcd\u7a7a\u95f4\u6295\u5f71\u5230\u5411\u91cf\u7a7a\u95f4\u3002 Word2vec \u00b6 Word2vec\uff08Mikolov et al. 2013\uff09\u662f\u4e00\u79cd\u751f\u6210\u8bcd\u5411\u91cf\u7684\u6846\u67b6\u3002 \u601d\u8def \u00b6 1\uff09\u4e00\u4e2a\u5927\u8bed\u6599\u5e93 2\uff09\u6bcf\u4e00\u4e2a\u5355\u8bcd\u53ef\u4ee5\u88ab\u5411\u91cf\u8bdd 3\uff09\u672c\u6587\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u8bcd\u90fd\u4f1a\u6709\u4e2d\u5fc3\u8bcd\uff08center\uff09\u548c\u4e0a\u4e0b\u6587\uff08outside\uff09 4\uff09\u7528 c \u548c o \u7684\u8bcd\u5411\u91cf\u76f8\u4f3c\u5ea6\u6765\u8ba1\u7b97\u6761\u4ef6\u6982\u7387 P(o | c) \u6216\u8005 P(c | o) 5\uff09\u8c03\u6574\u8bcd\u5411\u91cf\uff0c\u4ee5\u8fbe\u5230\u6700\u5927\u6982\u7387 \u6761\u4ef6\u6982\u7387 \u00b6 \u5bf9\u4e00\u6761\u6587\u672c\u300c\u6211\u7231\u5929\u5b89\u95e8\u300d\u6765\u8bf4\uff0c\u5982\u679c\u7ed9\u51fa\u4e2d\u5fc3\u8bcd\u300c\u5929\u300d\uff0c\u90a3\u4e48\u6211\u60f3\u77e5\u9053\u300c\u7231\u300d\u548c\u300c\u95e8\u300d\u7684\u6761\u4ef6\u6982\u7387\u662f\u591a\u5c11\u5462\uff1f P(o | c) = P(w_{t+j} | w_{t}) = P(\\text{\u5929} | \\text{\u7231}) P(o | c) = P(w_{t+j} | w_{t}) = P(\\text{\u5929} | \\text{\u7231}) \u8fd9\u91cc\u5c31\u662f\u7528\u5230\u7ed9\u5b9a\u4e2d\u5fc3\u8bcd c \u6765\u6c42\u4e0a\u4e0b\u6587\u8bcd o \u7684\u6761\u4ef6\u6982\u7387\u3002\u4e00\u822c\u800c\u8a00\uff0c\u4e0a\u4e0b\u6587\u8bcd\u5904\u4e8e\u4e2d\u5fc3\u7684\u7a97\u53e3\u5185\u3002\u5982\u679c\u4f9d\u6b21\u904d\u5386\u4e2d\u5fc3\u8bcd\uff08\u6ed1\u52a8\u7a97\u53e3\uff09\uff0c\u5373\u53ef\u6c42\u51fa\u6240\u6709\u7684\u6761\u4ef6\u6982\u7387\u3002 \u76ee\u6807\u51fd\u6570 \u00b6 \u4e00\u4e2a\u56fa\u5b9a\u7684\u7a97\u53e3\u957f\u5ea6 m\uff0c\u5bf9\u6bcf\u4e2a\u4f4d\u7f6e\uff0c\u9884\u6d4b\u6240\u6709\u4e0a\u4e0b\u6587\u8bcd o\u3002\u4f7f\u7528\u6781\u5927\u4f3c\u7136\u4f30\u8ba1\uff08MLE\uff09 L(\\theta) = \\prod_{t \\in [1, T]} \\prod_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} P(w_{t+j} | w_{t}; \\theta) L(\\theta) = \\prod_{t \\in [1, T]} \\prod_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} P(w_{t+j} | w_{t}; \\theta) \u5bf9\u6570\u635f\u5931\u51fd\u6570 J(\\theta) = -\\frac{1}{T} \\log L(\\theta) = -\\frac{1}{T} \\sum_{t \\in [1, T]} \\sum_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} \\log P(w_{t+j} | w_{t}; \\theta) J(\\theta) = -\\frac{1}{T} \\log L(\\theta) = -\\frac{1}{T} \\sum_{t \\in [1, T]} \\sum_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} \\log P(w_{t+j} | w_{t}; \\theta) \u6700\u5c0f\u5316\u635f\u5931\u51fd\u6570\u524d\uff0c\u9700\u8981\u8ba1\u7b97\u6761\u4ef6\u6982\u7387\u3002\u5bf9\u6bcf\u4e00\u4e2a\u8bcd\uff0c\u6211\u4eec\u8bbe\u8ba1\u4e24\u4e2a\u8bcd\u5411\u91cf\uff0c v_{w} v_{w} \u8868\u793a w \u662f\u4e00\u4e2a\u4e2d\u5fc3\u8bcd\u65f6\u7684\u5411\u91cf\uff0c u_{w} u_{w} \u8868\u793a w \u662f\u4e00\u4e2a\u4e0a\u4e0b\u6587\u8bcd\u7684\u5411\u91cf\u3002 P(o | c) = \\frac{\\exp(u_{o}^{T} v_{c})}{\\sum_{w \\in V}\\exp(u_{w}^{T} v_{c})} P(o | c) = \\frac{\\exp(u_{o}^{T} v_{c})}{\\sum_{w \\in V}\\exp(u_{w}^{T} v_{c})} \u8fd9\u91cc V \u4ee3\u8868\u8bed\u6599\u5e93\u7684\u5927\u5c0f\uff0c \\theta \\theta \u4ee3\u8868\u5168\u90e8\u53ef\u5b66\u4e60\u7684\u53c2\u6570\uff0c\u6bcf\u4e2a\u8bcd\u6709\u4e24\u4e2a\u5411\u91cf\u3002 \\theta = \\begin{bmatrix} v_{1} \\\\ \\vdots \\\\ v_{V} \\\\ u_{1} \\\\ \\vdots \\\\ u_{V} \\\\ \\end{bmatrix} \\in R^{2dV} \\theta = \\begin{bmatrix} v_{1} \\\\ \\vdots \\\\ v_{V} \\\\ u_{1} \\\\ \\vdots \\\\ u_{V} \\\\ \\end{bmatrix} \\in R^{2dV} \u68af\u5ea6\u4e0b\u964d \u00b6 \u5bf9 v_{c} v_{c} \u6c42\u5bfc \\begin{aligned} \\frac{\\partial}{\\partial v_{c}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial v_{c}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial v_{c}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial v_{c}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\frac{\\partial} {\\partial v_{c}} \\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\exp(u_{w}^{T}v_{c}) u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} \\frac{\\exp(u_{w}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} P(w | c) u_{w} \\end{aligned} \\begin{aligned} \\frac{\\partial}{\\partial v_{c}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial v_{c}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial v_{c}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial v_{c}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\frac{\\partial} {\\partial v_{c}} \\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\exp(u_{w}^{T}v_{c}) u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} \\frac{\\exp(u_{w}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} P(w | c) u_{w} \\end{aligned} u_{o} u_{o} \u8868\u793a\u89c2\u5bdf\u5230\u7684\u4e0a\u4e0b\u6587\u8bcd\u7684\u5411\u91cf\uff0c \\sum_{w=1}^{V} P(w | c) u_{w} \\sum_{w=1}^{V} P(w | c) u_{w} \u8868\u793a\u4e00\u4e2a\u671f\u671b\u503c\uff0c\u7ed9\u51fa\u4e2d\u5fc3\u8bcd\u540e\uff0c\u6240\u6709\u6587\u672c\u6b21\u7684\u52a0\u6743\u5e73\u5747\u3002 \u5bf9 u_{o} u_{o} \u6c42\u5bfc \\begin{aligned} \\frac{\\partial}{\\partial u_{0}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial u_{0}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial u_{0}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial u_{0}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= v_{c} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\frac{\\partial}{\\partial u_{0}} \\exp(u_{o}^{T}v_{c}) \\\\ &= v_{c} - \\frac{\\exp{u_{o}^{T}v_{c}}}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} v_{c} \\\\ &= v_{c} - P(o | c) v_{c} \\end{aligned} \\begin{aligned} \\frac{\\partial}{\\partial u_{0}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial u_{0}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial u_{0}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial u_{0}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= v_{c} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\frac{\\partial}{\\partial u_{0}} \\exp(u_{o}^{T}v_{c}) \\\\ &= v_{c} - \\frac{\\exp{u_{o}^{T}v_{c}}}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} v_{c} \\\\ &= v_{c} - P(o | c) v_{c} \\end{aligned} \u53c2\u6570\u66f4\u65b0 \\theta^{new} = \\theta^{old} - \\alpha \\nabla_{theta} J(\\theta) \\theta^{new} = \\theta^{old} - \\alpha \\nabla_{theta} J(\\theta) \u4e24\u79cd\u65b9\u6848 \u00b6 skip-gram\uff08SG\uff09\uff1a\u7528\u4e2d\u5fc3\u8bcd\u9884\u6d4b\u4e0a\u4e0b\u6587\u8bcd Continuous Bag of Words\uff08CBOW\uff09\uff1a\u7528\u4e0a\u4e0b\u6587\u9884\u6d4b\u4e2d\u5fc3\u8bcd \u8bad\u7ec3\u65b9\u6cd5 \u00b6 Negative Sampling \u00b6 \u5bf9\u6574\u4e2a\u8bed\u6599\u5e93\u6c42\u6761\u4ef6\u6982\u7387\u7684\u6210\u672c\u9ad8\u6602\uff0c\u8003\u8651\u5bf9\u8d1f\u6837\u672c\u968f\u673a\u91c7\u6837\uff0c\u964d\u4f4e\u8ba1\u7b97\u590d\u6742\u5ea6\u3002\u5047\u8bbe\u6bcf\u6b21\u91c7\u6837 k \u4e2a\u8d1f\u6837\u672c\uff0c\u90a3\u4e48\u5728\u4e00\u6b21\u7a97\u53e3\u4e2d\uff0c\u6700\u591a\u6709 2m+1 \u7684\u5355\u8bcd\u548c 2km \u7684\u8d1f\u6837\u672c\u3002 Hierarchical Softmax \u00b6","title":"\u8bcd\u5411\u91cf"},{"location":"machine-learning/embs/#_1","text":"\u8bcd\u5411\u91cf\u662f\u4e00\u79cd\u5c06\u5355\u8bcd\u6570\u5b57\u5316\u8868\u8fbe\u7684\u65b9\u6cd5\uff0c\u5373\u5c06\u5355\u8bcd\u7a7a\u95f4\u6295\u5f71\u5230\u5411\u91cf\u7a7a\u95f4\u3002","title":"\u5b9a\u4e49"},{"location":"machine-learning/embs/#word2vec","text":"Word2vec\uff08Mikolov et al. 2013\uff09\u662f\u4e00\u79cd\u751f\u6210\u8bcd\u5411\u91cf\u7684\u6846\u67b6\u3002","title":"Word2vec"},{"location":"machine-learning/embs/#_2","text":"1\uff09\u4e00\u4e2a\u5927\u8bed\u6599\u5e93 2\uff09\u6bcf\u4e00\u4e2a\u5355\u8bcd\u53ef\u4ee5\u88ab\u5411\u91cf\u8bdd 3\uff09\u672c\u6587\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u8bcd\u90fd\u4f1a\u6709\u4e2d\u5fc3\u8bcd\uff08center\uff09\u548c\u4e0a\u4e0b\u6587\uff08outside\uff09 4\uff09\u7528 c \u548c o \u7684\u8bcd\u5411\u91cf\u76f8\u4f3c\u5ea6\u6765\u8ba1\u7b97\u6761\u4ef6\u6982\u7387 P(o | c) \u6216\u8005 P(c | o) 5\uff09\u8c03\u6574\u8bcd\u5411\u91cf\uff0c\u4ee5\u8fbe\u5230\u6700\u5927\u6982\u7387","title":"\u601d\u8def"},{"location":"machine-learning/embs/#_3","text":"\u5bf9\u4e00\u6761\u6587\u672c\u300c\u6211\u7231\u5929\u5b89\u95e8\u300d\u6765\u8bf4\uff0c\u5982\u679c\u7ed9\u51fa\u4e2d\u5fc3\u8bcd\u300c\u5929\u300d\uff0c\u90a3\u4e48\u6211\u60f3\u77e5\u9053\u300c\u7231\u300d\u548c\u300c\u95e8\u300d\u7684\u6761\u4ef6\u6982\u7387\u662f\u591a\u5c11\u5462\uff1f P(o | c) = P(w_{t+j} | w_{t}) = P(\\text{\u5929} | \\text{\u7231}) P(o | c) = P(w_{t+j} | w_{t}) = P(\\text{\u5929} | \\text{\u7231}) \u8fd9\u91cc\u5c31\u662f\u7528\u5230\u7ed9\u5b9a\u4e2d\u5fc3\u8bcd c \u6765\u6c42\u4e0a\u4e0b\u6587\u8bcd o \u7684\u6761\u4ef6\u6982\u7387\u3002\u4e00\u822c\u800c\u8a00\uff0c\u4e0a\u4e0b\u6587\u8bcd\u5904\u4e8e\u4e2d\u5fc3\u7684\u7a97\u53e3\u5185\u3002\u5982\u679c\u4f9d\u6b21\u904d\u5386\u4e2d\u5fc3\u8bcd\uff08\u6ed1\u52a8\u7a97\u53e3\uff09\uff0c\u5373\u53ef\u6c42\u51fa\u6240\u6709\u7684\u6761\u4ef6\u6982\u7387\u3002","title":"\u6761\u4ef6\u6982\u7387"},{"location":"machine-learning/embs/#_4","text":"\u4e00\u4e2a\u56fa\u5b9a\u7684\u7a97\u53e3\u957f\u5ea6 m\uff0c\u5bf9\u6bcf\u4e2a\u4f4d\u7f6e\uff0c\u9884\u6d4b\u6240\u6709\u4e0a\u4e0b\u6587\u8bcd o\u3002\u4f7f\u7528\u6781\u5927\u4f3c\u7136\u4f30\u8ba1\uff08MLE\uff09 L(\\theta) = \\prod_{t \\in [1, T]} \\prod_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} P(w_{t+j} | w_{t}; \\theta) L(\\theta) = \\prod_{t \\in [1, T]} \\prod_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} P(w_{t+j} | w_{t}; \\theta) \u5bf9\u6570\u635f\u5931\u51fd\u6570 J(\\theta) = -\\frac{1}{T} \\log L(\\theta) = -\\frac{1}{T} \\sum_{t \\in [1, T]} \\sum_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} \\log P(w_{t+j} | w_{t}; \\theta) J(\\theta) = -\\frac{1}{T} \\log L(\\theta) = -\\frac{1}{T} \\sum_{t \\in [1, T]} \\sum_{j \\in [-m, 0) \\bigcup_{}^{} (0,m]} \\log P(w_{t+j} | w_{t}; \\theta) \u6700\u5c0f\u5316\u635f\u5931\u51fd\u6570\u524d\uff0c\u9700\u8981\u8ba1\u7b97\u6761\u4ef6\u6982\u7387\u3002\u5bf9\u6bcf\u4e00\u4e2a\u8bcd\uff0c\u6211\u4eec\u8bbe\u8ba1\u4e24\u4e2a\u8bcd\u5411\u91cf\uff0c v_{w} v_{w} \u8868\u793a w \u662f\u4e00\u4e2a\u4e2d\u5fc3\u8bcd\u65f6\u7684\u5411\u91cf\uff0c u_{w} u_{w} \u8868\u793a w \u662f\u4e00\u4e2a\u4e0a\u4e0b\u6587\u8bcd\u7684\u5411\u91cf\u3002 P(o | c) = \\frac{\\exp(u_{o}^{T} v_{c})}{\\sum_{w \\in V}\\exp(u_{w}^{T} v_{c})} P(o | c) = \\frac{\\exp(u_{o}^{T} v_{c})}{\\sum_{w \\in V}\\exp(u_{w}^{T} v_{c})} \u8fd9\u91cc V \u4ee3\u8868\u8bed\u6599\u5e93\u7684\u5927\u5c0f\uff0c \\theta \\theta \u4ee3\u8868\u5168\u90e8\u53ef\u5b66\u4e60\u7684\u53c2\u6570\uff0c\u6bcf\u4e2a\u8bcd\u6709\u4e24\u4e2a\u5411\u91cf\u3002 \\theta = \\begin{bmatrix} v_{1} \\\\ \\vdots \\\\ v_{V} \\\\ u_{1} \\\\ \\vdots \\\\ u_{V} \\\\ \\end{bmatrix} \\in R^{2dV} \\theta = \\begin{bmatrix} v_{1} \\\\ \\vdots \\\\ v_{V} \\\\ u_{1} \\\\ \\vdots \\\\ u_{V} \\\\ \\end{bmatrix} \\in R^{2dV}","title":"\u76ee\u6807\u51fd\u6570"},{"location":"machine-learning/embs/#_5","text":"\u5bf9 v_{c} v_{c} \u6c42\u5bfc \\begin{aligned} \\frac{\\partial}{\\partial v_{c}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial v_{c}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial v_{c}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial v_{c}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\frac{\\partial} {\\partial v_{c}} \\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\exp(u_{w}^{T}v_{c}) u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} \\frac{\\exp(u_{w}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} P(w | c) u_{w} \\end{aligned} \\begin{aligned} \\frac{\\partial}{\\partial v_{c}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial v_{c}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial v_{c}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial v_{c}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\frac{\\partial} {\\partial v_{c}} \\exp(u_{w}^{T}v_{c}) \\\\ &= u_{o} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\sum_{w=1}^{V} \\exp(u_{w}^{T}v_{c}) u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} \\frac{\\exp(u_{w}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} u_{w} \\\\ &= u_{o} - \\sum_{w=1}^{V} P(w | c) u_{w} \\end{aligned} u_{o} u_{o} \u8868\u793a\u89c2\u5bdf\u5230\u7684\u4e0a\u4e0b\u6587\u8bcd\u7684\u5411\u91cf\uff0c \\sum_{w=1}^{V} P(w | c) u_{w} \\sum_{w=1}^{V} P(w | c) u_{w} \u8868\u793a\u4e00\u4e2a\u671f\u671b\u503c\uff0c\u7ed9\u51fa\u4e2d\u5fc3\u8bcd\u540e\uff0c\u6240\u6709\u6587\u672c\u6b21\u7684\u52a0\u6743\u5e73\u5747\u3002 \u5bf9 u_{o} u_{o} \u6c42\u5bfc \\begin{aligned} \\frac{\\partial}{\\partial u_{0}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial u_{0}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial u_{0}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial u_{0}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= v_{c} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\frac{\\partial}{\\partial u_{0}} \\exp(u_{o}^{T}v_{c}) \\\\ &= v_{c} - \\frac{\\exp{u_{o}^{T}v_{c}}}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} v_{c} \\\\ &= v_{c} - P(o | c) v_{c} \\end{aligned} \\begin{aligned} \\frac{\\partial}{\\partial u_{0}} \\log \\frac{\\exp(u_{o}^{T}v_{c})}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} &= \\frac{\\partial}{\\partial u_{0}} [\\log \\exp(u_{o}^{T}v_{c}) - \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})] \\\\ &= \\frac{\\partial}{\\partial u_{0}} u_{o}^{T}v_{c} - \\frac{\\partial}{\\partial u_{0}} \\log \\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c}) \\\\ &= v_{c} - \\frac{1}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} \\frac{\\partial}{\\partial u_{0}} \\exp(u_{o}^{T}v_{c}) \\\\ &= v_{c} - \\frac{\\exp{u_{o}^{T}v_{c}}}{\\sum_{w=1}^{V}\\exp(u_{w}^{T}v_{c})} v_{c} \\\\ &= v_{c} - P(o | c) v_{c} \\end{aligned} \u53c2\u6570\u66f4\u65b0 \\theta^{new} = \\theta^{old} - \\alpha \\nabla_{theta} J(\\theta) \\theta^{new} = \\theta^{old} - \\alpha \\nabla_{theta} J(\\theta)","title":"\u68af\u5ea6\u4e0b\u964d"},{"location":"machine-learning/embs/#_6","text":"skip-gram\uff08SG\uff09\uff1a\u7528\u4e2d\u5fc3\u8bcd\u9884\u6d4b\u4e0a\u4e0b\u6587\u8bcd Continuous Bag of Words\uff08CBOW\uff09\uff1a\u7528\u4e0a\u4e0b\u6587\u9884\u6d4b\u4e2d\u5fc3\u8bcd","title":"\u4e24\u79cd\u65b9\u6848"},{"location":"machine-learning/embs/#_7","text":"","title":"\u8bad\u7ec3\u65b9\u6cd5"},{"location":"machine-learning/embs/#negative-sampling","text":"\u5bf9\u6574\u4e2a\u8bed\u6599\u5e93\u6c42\u6761\u4ef6\u6982\u7387\u7684\u6210\u672c\u9ad8\u6602\uff0c\u8003\u8651\u5bf9\u8d1f\u6837\u672c\u968f\u673a\u91c7\u6837\uff0c\u964d\u4f4e\u8ba1\u7b97\u590d\u6742\u5ea6\u3002\u5047\u8bbe\u6bcf\u6b21\u91c7\u6837 k \u4e2a\u8d1f\u6837\u672c\uff0c\u90a3\u4e48\u5728\u4e00\u6b21\u7a97\u53e3\u4e2d\uff0c\u6700\u591a\u6709 2m+1 \u7684\u5355\u8bcd\u548c 2km \u7684\u8d1f\u6837\u672c\u3002","title":"Negative Sampling"},{"location":"machine-learning/embs/#hierarchical-softmax","text":"","title":"Hierarchical Softmax"},{"location":"machine-learning/initialization/","text":"\u968f\u673a\u521d\u59cb\u5316 \u00b6 \u5982\u679c\u6743\u91cd\u521d\u59cb\u5316\u4e3a0\uff0c\u90a3\u4e48\u6bcf\u4e00\u4e2a\u795e\u7ecf\u5143\u4f1a\u6267\u884c\u76f8\u540c\u7684\u8ba1\u7b97\uff0c\u6700\u7ec8\u6240\u6709\u7684\u795e\u7ecf\u5143\u6ca1\u6709\u5dee\u5f02\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5bf9\u6743\u91cd\u505a\u968f\u673a\u521d\u59cb\u5316\uff0c\u8fd9\u4e00\u64cd\u4f5c\u53eb\u300cbreak symmetry\u300d\u3002 Xavier\u521d\u59cb\u5316 \u00b6 \u5728\u6fc0\u6d3b\u51fd\u6570\u4e4b\u524d\uff0c\u6211\u4eec\u505a\u4e86\u4e00\u6b21\u5168\u8fde\u63a5\u3002\u56e0\u4e3a\u6743\u91cd\u662f\u968f\u673a\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u6743\u91cd\u548c\u7279\u5f81\u7684\u5206\u5e03\u662f\u72ec\u7acb\u7684\u3002 \\sum_{i=1}^{n}x_{i}w_{i} \\sum_{i=1}^{n}x_{i}w_{i} \u5982\u679c\uff0c\u7279\u5f81\u548c\u53c2\u6570\u7684\u671f\u671b\u503c\u5747\u4e3a0\u7684\u8bdd\uff0c\u6700\u540e\u7684\u4e58\u79ef\u4e5f\u662f0\u671f\u671b\u3002\u5373 \\begin{matrix} & E(x_{i}) = E(w_{i}) = 0 & \\\\ & \\Downarrow & \\\\ & E(\\sum_{i=1}^{n}x_{i}w_{i}) = 0 & \\end{matrix} \\begin{matrix} & E(x_{i}) = E(w_{i}) = 0 & \\\\ & \\Downarrow & \\\\ & E(\\sum_{i=1}^{n}x_{i}w_{i}) = 0 & \\end{matrix} \u4f46\u8fd9\u6837\u505a\u7684\u7ed3\u679c\u5c31\u662f\u65b9\u5dee\u5728\u540e\u7eed\u7684\u5c42\u4e2d\u589e\u52a0\uff0c\u5373 \\begin{matrix} & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i}w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(x_{i}w_{i}) = [ E(x_{i}) ]^{2}Var(w_{i}) + [ E(w_{i}) ]^{2}Var(x_{i}) + Var(x_{i})Var(w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i})Var(w_{i}) = Var(x)[ nVar(w) ] & \\end{matrix} \\begin{matrix} & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i}w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(x_{i}w_{i}) = [ E(x_{i}) ]^{2}Var(w_{i}) + [ E(w_{i}) ]^{2}Var(x_{i}) + Var(x_{i})Var(w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i})Var(w_{i}) = Var(x)[ nVar(w) ] & \\end{matrix} \u8fd9\u4e0d\u5229\u4e8e\u6df1\u5c42\u7f51\u7edc\u7684\u6536\u655b\u3002\u5982\u679c\u6211\u4eec\u60f3 nVar(w) = 1 nVar(w) = 1 \uff0c\u6211\u4eec\u9700\u8981\u5bf9\u968f\u673a\u521d\u59cb\u5316\u7684\u6743\u91cd\u5206\u5e03\uff08 N(0, 1) N(0, 1) \uff09\u4e58\u4e00\u4e2a\u7cfb\u6570 a = \\frac{1}{\\sqrt{n}} a = \\frac{1}{\\sqrt{n}} \u3002Xavier\u521d\u59cb\u5316\u4e2d\u4e58\u7684\u7cfb\u6570\u662f \\frac{\\sqrt{2}}{\\sqrt{n_{in}+n_{out}}} \\frac{\\sqrt{2}}{\\sqrt{n_{in}+n_{out}}} \u3002 He\u521d\u59cb\u5316 \u00b6 \u5bf9\u6fc0\u6d3b\u51fd\u6570\u662fReLU\uff0che\u521d\u59cb\u5316\u4e58\u7cfb\u6570\u4e3a \\frac{\\sqrt{2}}{\\sqrt{n_{in}}} \\frac{\\sqrt{2}}{\\sqrt{n_{in}}}","title":"\u521d\u59cb\u5316"},{"location":"machine-learning/initialization/#_1","text":"\u5982\u679c\u6743\u91cd\u521d\u59cb\u5316\u4e3a0\uff0c\u90a3\u4e48\u6bcf\u4e00\u4e2a\u795e\u7ecf\u5143\u4f1a\u6267\u884c\u76f8\u540c\u7684\u8ba1\u7b97\uff0c\u6700\u7ec8\u6240\u6709\u7684\u795e\u7ecf\u5143\u6ca1\u6709\u5dee\u5f02\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5bf9\u6743\u91cd\u505a\u968f\u673a\u521d\u59cb\u5316\uff0c\u8fd9\u4e00\u64cd\u4f5c\u53eb\u300cbreak symmetry\u300d\u3002","title":"\u968f\u673a\u521d\u59cb\u5316"},{"location":"machine-learning/initialization/#xavier","text":"\u5728\u6fc0\u6d3b\u51fd\u6570\u4e4b\u524d\uff0c\u6211\u4eec\u505a\u4e86\u4e00\u6b21\u5168\u8fde\u63a5\u3002\u56e0\u4e3a\u6743\u91cd\u662f\u968f\u673a\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u6743\u91cd\u548c\u7279\u5f81\u7684\u5206\u5e03\u662f\u72ec\u7acb\u7684\u3002 \\sum_{i=1}^{n}x_{i}w_{i} \\sum_{i=1}^{n}x_{i}w_{i} \u5982\u679c\uff0c\u7279\u5f81\u548c\u53c2\u6570\u7684\u671f\u671b\u503c\u5747\u4e3a0\u7684\u8bdd\uff0c\u6700\u540e\u7684\u4e58\u79ef\u4e5f\u662f0\u671f\u671b\u3002\u5373 \\begin{matrix} & E(x_{i}) = E(w_{i}) = 0 & \\\\ & \\Downarrow & \\\\ & E(\\sum_{i=1}^{n}x_{i}w_{i}) = 0 & \\end{matrix} \\begin{matrix} & E(x_{i}) = E(w_{i}) = 0 & \\\\ & \\Downarrow & \\\\ & E(\\sum_{i=1}^{n}x_{i}w_{i}) = 0 & \\end{matrix} \u4f46\u8fd9\u6837\u505a\u7684\u7ed3\u679c\u5c31\u662f\u65b9\u5dee\u5728\u540e\u7eed\u7684\u5c42\u4e2d\u589e\u52a0\uff0c\u5373 \\begin{matrix} & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i}w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(x_{i}w_{i}) = [ E(x_{i}) ]^{2}Var(w_{i}) + [ E(w_{i}) ]^{2}Var(x_{i}) + Var(x_{i})Var(w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i})Var(w_{i}) = Var(x)[ nVar(w) ] & \\end{matrix} \\begin{matrix} & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i}w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(x_{i}w_{i}) = [ E(x_{i}) ]^{2}Var(w_{i}) + [ E(w_{i}) ]^{2}Var(x_{i}) + Var(x_{i})Var(w_{i}) & \\\\ & \\Downarrow & \\\\ & Var(\\sum_{i=1}^{n}x_{i}w_{i}) = \\sum_{i=1}^{n}Var(x_{i})Var(w_{i}) = Var(x)[ nVar(w) ] & \\end{matrix} \u8fd9\u4e0d\u5229\u4e8e\u6df1\u5c42\u7f51\u7edc\u7684\u6536\u655b\u3002\u5982\u679c\u6211\u4eec\u60f3 nVar(w) = 1 nVar(w) = 1 \uff0c\u6211\u4eec\u9700\u8981\u5bf9\u968f\u673a\u521d\u59cb\u5316\u7684\u6743\u91cd\u5206\u5e03\uff08 N(0, 1) N(0, 1) \uff09\u4e58\u4e00\u4e2a\u7cfb\u6570 a = \\frac{1}{\\sqrt{n}} a = \\frac{1}{\\sqrt{n}} \u3002Xavier\u521d\u59cb\u5316\u4e2d\u4e58\u7684\u7cfb\u6570\u662f \\frac{\\sqrt{2}}{\\sqrt{n_{in}+n_{out}}} \\frac{\\sqrt{2}}{\\sqrt{n_{in}+n_{out}}} \u3002","title":"Xavier\u521d\u59cb\u5316"},{"location":"machine-learning/initialization/#he","text":"\u5bf9\u6fc0\u6d3b\u51fd\u6570\u662fReLU\uff0che\u521d\u59cb\u5316\u4e58\u7cfb\u6570\u4e3a \\frac{\\sqrt{2}}{\\sqrt{n_{in}}} \\frac{\\sqrt{2}}{\\sqrt{n_{in}}}","title":"He\u521d\u59cb\u5316"},{"location":"machine-learning/linear-regression/","text":"\u5b9a\u4e49 \u00b6 \u4e0d\u540c\u4e8e\u5206\u7c7b\u95ee\u9898\uff0c\u56de\u5f52\u95ee\u9898\u7684 label \u662f\u4e00\u4e2a\u8fde\u7eed\u503c\u3002\u7ebf\u5f62\u56de\u5f52\u5219\u662f\u7528\u4e00\u6b21\u591a\u53d8\u91cf\u7684\u7ebf\u5f62\u53e0\u52a0\u6a21\u578b label\u3002\u5f62\u5982 \\hat{y} = \\sum_{i = 0}^{m} a_{i}x_{i} \\hat{y} = \\sum_{i = 0}^{m} a_{i}x_{i} \u89e3\u6790\u89e3 \u00b6 \\begin{aligned} (\\frac{1}{n}\\left \\| Xw-y \\right \\|^{2})^{'} &= \\frac{2}{n}X^{T}(Xw-y) \\\\ &= \\frac{2}{n}(X^{T}Xw-X^{T}y) = 0 \\\\ w &= (X^{T}X)^{-1}X^{T}y \\end{aligned} \\begin{aligned} (\\frac{1}{n}\\left \\| Xw-y \\right \\|^{2})^{'} &= \\frac{2}{n}X^{T}(Xw-y) \\\\ &= \\frac{2}{n}(X^{T}Xw-X^{T}y) = 0 \\\\ w &= (X^{T}X)^{-1}X^{T}y \\end{aligned} \\bigstar \\bigstar \u89e3\u6790\u89e3\u9700\u8981\u5bf9\u77e9\u9635\u6c42\u9006\uff0c\u5f53\u7ef4\u5ea6\u8f83\u9ad8\u65f6\uff0c\u6210\u672c\u5927 \u6570\u503c\u89e3 \u00b6 \u635f\u5931\u51fd\u6570\uff1aMSE (mean square error) \\begin{aligned} L(w) &= \\frac{1}{n}\\sum_{i=1}^{n}(w^{T}x_{i}-y_{i})^{2} \\\\ &= \\frac{1}{n}\\left \\| Xw-y \\right \\|^{2} \\\\ &\\rightarrow \\min_{w} \\end{aligned} \\begin{aligned} L(w) &= \\frac{1}{n}\\sum_{i=1}^{n}(w^{T}x_{i}-y_{i})^{2} \\\\ &= \\frac{1}{n}\\left \\| Xw-y \\right \\|^{2} \\\\ &\\rightarrow \\min_{w} \\end{aligned}","title":"\u7ebf\u6027\u56de\u5f52"},{"location":"machine-learning/linear-regression/#_1","text":"\u4e0d\u540c\u4e8e\u5206\u7c7b\u95ee\u9898\uff0c\u56de\u5f52\u95ee\u9898\u7684 label \u662f\u4e00\u4e2a\u8fde\u7eed\u503c\u3002\u7ebf\u5f62\u56de\u5f52\u5219\u662f\u7528\u4e00\u6b21\u591a\u53d8\u91cf\u7684\u7ebf\u5f62\u53e0\u52a0\u6a21\u578b label\u3002\u5f62\u5982 \\hat{y} = \\sum_{i = 0}^{m} a_{i}x_{i} \\hat{y} = \\sum_{i = 0}^{m} a_{i}x_{i}","title":"\u5b9a\u4e49"},{"location":"machine-learning/linear-regression/#_2","text":"\\begin{aligned} (\\frac{1}{n}\\left \\| Xw-y \\right \\|^{2})^{'} &= \\frac{2}{n}X^{T}(Xw-y) \\\\ &= \\frac{2}{n}(X^{T}Xw-X^{T}y) = 0 \\\\ w &= (X^{T}X)^{-1}X^{T}y \\end{aligned} \\begin{aligned} (\\frac{1}{n}\\left \\| Xw-y \\right \\|^{2})^{'} &= \\frac{2}{n}X^{T}(Xw-y) \\\\ &= \\frac{2}{n}(X^{T}Xw-X^{T}y) = 0 \\\\ w &= (X^{T}X)^{-1}X^{T}y \\end{aligned} \\bigstar \\bigstar \u89e3\u6790\u89e3\u9700\u8981\u5bf9\u77e9\u9635\u6c42\u9006\uff0c\u5f53\u7ef4\u5ea6\u8f83\u9ad8\u65f6\uff0c\u6210\u672c\u5927","title":"\u89e3\u6790\u89e3"},{"location":"machine-learning/linear-regression/#_3","text":"\u635f\u5931\u51fd\u6570\uff1aMSE (mean square error) \\begin{aligned} L(w) &= \\frac{1}{n}\\sum_{i=1}^{n}(w^{T}x_{i}-y_{i})^{2} \\\\ &= \\frac{1}{n}\\left \\| Xw-y \\right \\|^{2} \\\\ &\\rightarrow \\min_{w} \\end{aligned} \\begin{aligned} L(w) &= \\frac{1}{n}\\sum_{i=1}^{n}(w^{T}x_{i}-y_{i})^{2} \\\\ &= \\frac{1}{n}\\left \\| Xw-y \\right \\|^{2} \\\\ &\\rightarrow \\min_{w} \\end{aligned}","title":"\u6570\u503c\u89e3"},{"location":"machine-learning/logistic-regression/","text":"\u57fa\u7840 \u00b6 \u7279\u5f81\u7a7a\u95f4 x \\in R^{n} x \\in R^{n} \uff0c\u9884\u6d4b\u503c\uff1a \\hat{y_{}} = P(y = 1 \\mid x) \\rightarrow \\hat{y_{}} \\in [0, 1] \\hat{y_{}} = P(y = 1 \\mid x) \\rightarrow \\hat{y_{}} \\in [0, 1] \u9700\u8981\u5b66\u4e60\u7684\u53c2\u6570\uff1a w \\in R^{n}, b \\in R w \\in R^{n}, b \\in R \uff0c\u9884\u4f30\u503c \\begin{aligned} \\hat{y_{}} &= \\sigma(w^{T}x + b) \\\\ &= \\frac{1}{1 + e^{-(w^{T}x + b)}} \\end{aligned} \\begin{aligned} \\hat{y_{}} &= \\sigma(w^{T}x + b) \\\\ &= \\frac{1}{1 + e^{-(w^{T}x + b)}} \\end{aligned} \u635f\u5931\u51fd\u6570 \u00b6 \u5e73\u65b9\u5dee\u635f\u5931\u51fd\u6570\u4e0d\u662f\u4e00\u4e2a\u597d\u7684\u9009\u62e9\uff0c\u56e0\u4e3a\u5b83\u4e0d\u662f\u51f8\u51fd\u6570\uff0c\u5bb9\u6613\u9677\u5165\u6781\u5c0f\u503c\u9677\u9631\u3002 L(\\hat{y_{}}, y) = \\frac{1}{2} (\\hat{y_{}} - y)^{2} L(\\hat{y_{}}, y) = \\frac{1}{2} (\\hat{y_{}} - y)^{2} \u903b\u8f91\u56de\u5f52\u7684\u635f\u5931\u51fd\u6570\uff1a \u4ea4\u53c9\u71b5 L(\\hat{y_{}}, y) = -[y \\log\\hat{y_{}} + (1-y)\\log(1-\\hat{y_{}})] L(\\hat{y_{}}, y) = -[y \\log\\hat{y_{}} + (1-y)\\log(1-\\hat{y_{}})] \u76f4\u89c2\u5730\uff0c\u5f53 y = 1 \u65f6\uff0c\u6211\u4eec\u4f1a\u8ba9 \\hat{y_{i}} \\hat{y_{i}} \u5927\u4e00\u70b9\u4ece\u800c\u83b7\u5f97\u4e00\u4e2a\u8f83\u5c0f\u7684\u635f\u5931\uff1b\u5f53 y = 0 \u65f6\uff0c\u6211\u4eec\u8ba9 \\hat{y_{i}} \\hat{y_{i}} \u5c0f\u4e00\u70b9\u3002 \u63a8\u5e7f\u5230\u5168\u6837\u672c {( x^{1} x^{1} , y^{1} y^{1} ), ..., ( x^{m} x^{m} , y^{m} y^{m} )}, \u6211\u4eec\u5e0c\u671b \\hat{y^{i}} \\approx y^{i} \\hat{y^{i}} \\approx y^{i} \\begin{aligned} J(w, b) &= \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) \\\\ &= -\\frac{1}{m} \\sum_{i=1}^{m} [y^{i} \\log\\hat{y^{i}} + (1-y^{i}) \\log(1-\\hat{y^{i}})] \\\\ & \\Rightarrow \\arg\\min_{w, b} J(w, b) \\end{aligned} \\begin{aligned} J(w, b) &= \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) \\\\ &= -\\frac{1}{m} \\sum_{i=1}^{m} [y^{i} \\log\\hat{y^{i}} + (1-y^{i}) \\log(1-\\hat{y^{i}})] \\\\ & \\Rightarrow \\arg\\min_{w, b} J(w, b) \\end{aligned} \u68af\u5ea6\u4e0b\u964d \u00b6 \\begin{aligned} & z = w^{T}x + b \\\\ & \\hat{y_{}} = a = \\sigma(z) \\\\ & L(a, y) = -[y \\log a + (1-y) \\log(1-a)] \\\\ & \\begin{aligned} \\frac{\\partial L(a, y)}{\\partial z} &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] \\frac{\\partial a}{\\partial z} \\\\ &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] a(1-a) \\\\ &= a-y \\end{aligned} \\end{aligned} \\begin{aligned} & z = w^{T}x + b \\\\ & \\hat{y_{}} = a = \\sigma(z) \\\\ & L(a, y) = -[y \\log a + (1-y) \\log(1-a)] \\\\ & \\begin{aligned} \\frac{\\partial L(a, y)}{\\partial z} &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] \\frac{\\partial a}{\\partial z} \\\\ &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] a(1-a) \\\\ &= a-y \\end{aligned} \\end{aligned} \\begin{aligned} & w := w - \\alpha \\frac{\\partial J(w, b)}{\\partial w} \\\\ & b := b - \\alpha \\frac{\\partial J(w, b)}{\\partial b} \\end{aligned} \\begin{aligned} & w := w - \\alpha \\frac{\\partial J(w, b)}{\\partial w} \\\\ & b := b - \\alpha \\frac{\\partial J(w, b)}{\\partial b} \\end{aligned} \u77e9\u9635\u5316 \u00b6 \u8003\u8651 m \u6761\u8bad\u7ec3\u6837\u672c\uff0c\u6bcf\u6761\u6837\u672c\u6709 n \u4e2a\u7279\u5f81\u3002\u7528\u77e9\u9635\u8868\u793a\uff0cX \u7684\u5c3a\u5bf8\u662f n \\times m n \\times m \uff0cW \u7684\u5c3a\u5bf8 n \\times 1 n \\times 1 \uff0cY \u7684\u5c3a\u5bf8 1 \\times m 1 \\times m \uff0cb \u662f\u4e00\u4e2a\u6807\u91cf\u3002 \\begin{aligned} & X = \\begin{bmatrix} x_{11} & \\cdots & x_{1m}\\\\ \\vdots & \\ddots & \\vdots\\\\ x_{n1} & \\cdots & x_{nm} \\end{bmatrix}, \\quad Y = \\begin{bmatrix} y_{11} & \\cdots & y_{1m} \\end{bmatrix} \\\\ & W = \\begin{bmatrix} w_{11} \\\\ \\vdots \\\\ w_{n1} \\end{bmatrix}, \\quad b = \\begin{bmatrix} R \\end{bmatrix} \\\\ & Z = W^{T}X + b \\\\ & A = \\sigma(Z) \\\\ & dZ = A - Y \\\\ & dW = \\frac{1}{m} X (dZ)^{T} \\\\ & db = \\frac{1}{m} \\sum_{i=1}^{m}dZ \\end{aligned} \\begin{aligned} & X = \\begin{bmatrix} x_{11} & \\cdots & x_{1m}\\\\ \\vdots & \\ddots & \\vdots\\\\ x_{n1} & \\cdots & x_{nm} \\end{bmatrix}, \\quad Y = \\begin{bmatrix} y_{11} & \\cdots & y_{1m} \\end{bmatrix} \\\\ & W = \\begin{bmatrix} w_{11} \\\\ \\vdots \\\\ w_{n1} \\end{bmatrix}, \\quad b = \\begin{bmatrix} R \\end{bmatrix} \\\\ & Z = W^{T}X + b \\\\ & A = \\sigma(Z) \\\\ & dZ = A - Y \\\\ & dW = \\frac{1}{m} X (dZ)^{T} \\\\ & db = \\frac{1}{m} \\sum_{i=1}^{m}dZ \\end{aligned} \u5047\u8bbe 10 \u6761\u6837\u672c\uff0c\u6bcf\u6761\u6837\u672c 5 \u4e2a\u7279\u5f81\uff0cX \u603b\u5171\u6709 10*(5+1)=60 \u4e2a\u503c\u3002","title":"\u903b\u8f91\u56de\u5f52"},{"location":"machine-learning/logistic-regression/#_1","text":"\u7279\u5f81\u7a7a\u95f4 x \\in R^{n} x \\in R^{n} \uff0c\u9884\u6d4b\u503c\uff1a \\hat{y_{}} = P(y = 1 \\mid x) \\rightarrow \\hat{y_{}} \\in [0, 1] \\hat{y_{}} = P(y = 1 \\mid x) \\rightarrow \\hat{y_{}} \\in [0, 1] \u9700\u8981\u5b66\u4e60\u7684\u53c2\u6570\uff1a w \\in R^{n}, b \\in R w \\in R^{n}, b \\in R \uff0c\u9884\u4f30\u503c \\begin{aligned} \\hat{y_{}} &= \\sigma(w^{T}x + b) \\\\ &= \\frac{1}{1 + e^{-(w^{T}x + b)}} \\end{aligned} \\begin{aligned} \\hat{y_{}} &= \\sigma(w^{T}x + b) \\\\ &= \\frac{1}{1 + e^{-(w^{T}x + b)}} \\end{aligned}","title":"\u57fa\u7840"},{"location":"machine-learning/logistic-regression/#_2","text":"\u5e73\u65b9\u5dee\u635f\u5931\u51fd\u6570\u4e0d\u662f\u4e00\u4e2a\u597d\u7684\u9009\u62e9\uff0c\u56e0\u4e3a\u5b83\u4e0d\u662f\u51f8\u51fd\u6570\uff0c\u5bb9\u6613\u9677\u5165\u6781\u5c0f\u503c\u9677\u9631\u3002 L(\\hat{y_{}}, y) = \\frac{1}{2} (\\hat{y_{}} - y)^{2} L(\\hat{y_{}}, y) = \\frac{1}{2} (\\hat{y_{}} - y)^{2} \u903b\u8f91\u56de\u5f52\u7684\u635f\u5931\u51fd\u6570\uff1a \u4ea4\u53c9\u71b5 L(\\hat{y_{}}, y) = -[y \\log\\hat{y_{}} + (1-y)\\log(1-\\hat{y_{}})] L(\\hat{y_{}}, y) = -[y \\log\\hat{y_{}} + (1-y)\\log(1-\\hat{y_{}})] \u76f4\u89c2\u5730\uff0c\u5f53 y = 1 \u65f6\uff0c\u6211\u4eec\u4f1a\u8ba9 \\hat{y_{i}} \\hat{y_{i}} \u5927\u4e00\u70b9\u4ece\u800c\u83b7\u5f97\u4e00\u4e2a\u8f83\u5c0f\u7684\u635f\u5931\uff1b\u5f53 y = 0 \u65f6\uff0c\u6211\u4eec\u8ba9 \\hat{y_{i}} \\hat{y_{i}} \u5c0f\u4e00\u70b9\u3002 \u63a8\u5e7f\u5230\u5168\u6837\u672c {( x^{1} x^{1} , y^{1} y^{1} ), ..., ( x^{m} x^{m} , y^{m} y^{m} )}, \u6211\u4eec\u5e0c\u671b \\hat{y^{i}} \\approx y^{i} \\hat{y^{i}} \\approx y^{i} \\begin{aligned} J(w, b) &= \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) \\\\ &= -\\frac{1}{m} \\sum_{i=1}^{m} [y^{i} \\log\\hat{y^{i}} + (1-y^{i}) \\log(1-\\hat{y^{i}})] \\\\ & \\Rightarrow \\arg\\min_{w, b} J(w, b) \\end{aligned} \\begin{aligned} J(w, b) &= \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) \\\\ &= -\\frac{1}{m} \\sum_{i=1}^{m} [y^{i} \\log\\hat{y^{i}} + (1-y^{i}) \\log(1-\\hat{y^{i}})] \\\\ & \\Rightarrow \\arg\\min_{w, b} J(w, b) \\end{aligned}","title":"\u635f\u5931\u51fd\u6570"},{"location":"machine-learning/logistic-regression/#_3","text":"\\begin{aligned} & z = w^{T}x + b \\\\ & \\hat{y_{}} = a = \\sigma(z) \\\\ & L(a, y) = -[y \\log a + (1-y) \\log(1-a)] \\\\ & \\begin{aligned} \\frac{\\partial L(a, y)}{\\partial z} &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] \\frac{\\partial a}{\\partial z} \\\\ &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] a(1-a) \\\\ &= a-y \\end{aligned} \\end{aligned} \\begin{aligned} & z = w^{T}x + b \\\\ & \\hat{y_{}} = a = \\sigma(z) \\\\ & L(a, y) = -[y \\log a + (1-y) \\log(1-a)] \\\\ & \\begin{aligned} \\frac{\\partial L(a, y)}{\\partial z} &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] \\frac{\\partial a}{\\partial z} \\\\ &= - [y \\frac{1}{a} - (1- y)\\frac{1}{1-a}] a(1-a) \\\\ &= a-y \\end{aligned} \\end{aligned} \\begin{aligned} & w := w - \\alpha \\frac{\\partial J(w, b)}{\\partial w} \\\\ & b := b - \\alpha \\frac{\\partial J(w, b)}{\\partial b} \\end{aligned} \\begin{aligned} & w := w - \\alpha \\frac{\\partial J(w, b)}{\\partial w} \\\\ & b := b - \\alpha \\frac{\\partial J(w, b)}{\\partial b} \\end{aligned}","title":"\u68af\u5ea6\u4e0b\u964d"},{"location":"machine-learning/logistic-regression/#_4","text":"\u8003\u8651 m \u6761\u8bad\u7ec3\u6837\u672c\uff0c\u6bcf\u6761\u6837\u672c\u6709 n \u4e2a\u7279\u5f81\u3002\u7528\u77e9\u9635\u8868\u793a\uff0cX \u7684\u5c3a\u5bf8\u662f n \\times m n \\times m \uff0cW \u7684\u5c3a\u5bf8 n \\times 1 n \\times 1 \uff0cY \u7684\u5c3a\u5bf8 1 \\times m 1 \\times m \uff0cb \u662f\u4e00\u4e2a\u6807\u91cf\u3002 \\begin{aligned} & X = \\begin{bmatrix} x_{11} & \\cdots & x_{1m}\\\\ \\vdots & \\ddots & \\vdots\\\\ x_{n1} & \\cdots & x_{nm} \\end{bmatrix}, \\quad Y = \\begin{bmatrix} y_{11} & \\cdots & y_{1m} \\end{bmatrix} \\\\ & W = \\begin{bmatrix} w_{11} \\\\ \\vdots \\\\ w_{n1} \\end{bmatrix}, \\quad b = \\begin{bmatrix} R \\end{bmatrix} \\\\ & Z = W^{T}X + b \\\\ & A = \\sigma(Z) \\\\ & dZ = A - Y \\\\ & dW = \\frac{1}{m} X (dZ)^{T} \\\\ & db = \\frac{1}{m} \\sum_{i=1}^{m}dZ \\end{aligned} \\begin{aligned} & X = \\begin{bmatrix} x_{11} & \\cdots & x_{1m}\\\\ \\vdots & \\ddots & \\vdots\\\\ x_{n1} & \\cdots & x_{nm} \\end{bmatrix}, \\quad Y = \\begin{bmatrix} y_{11} & \\cdots & y_{1m} \\end{bmatrix} \\\\ & W = \\begin{bmatrix} w_{11} \\\\ \\vdots \\\\ w_{n1} \\end{bmatrix}, \\quad b = \\begin{bmatrix} R \\end{bmatrix} \\\\ & Z = W^{T}X + b \\\\ & A = \\sigma(Z) \\\\ & dZ = A - Y \\\\ & dW = \\frac{1}{m} X (dZ)^{T} \\\\ & db = \\frac{1}{m} \\sum_{i=1}^{m}dZ \\end{aligned} \u5047\u8bbe 10 \u6761\u6837\u672c\uff0c\u6bcf\u6761\u6837\u672c 5 \u4e2a\u7279\u5f81\uff0cX \u603b\u5171\u6709 10*(5+1)=60 \u4e2a\u503c\u3002","title":"\u77e9\u9635\u5316"},{"location":"machine-learning/ml-strategies/","text":"\u5047\u8bbe \u00b6 \\bigstar \\bigstar \u8bad\u7ec3\u96c6\u3001\u9a8c\u8bc1\u96c6\u548c\u6d4b\u8bd5\u96c6\u670d\u4ece i.i.d \u72ec\u7acb\u540c\u5206\u5e03 \\bigstar \\bigstar \u8bad\u7ec3\u96c6\u3001\u9a8c\u8bc1\u96c6\u548c\u6d4b\u8bd5\u96c6\u8868\u73b0\u5747\u8981\u826f\u597d\uff0c\u6cdb\u5316\u80fd\u529b\u597d \\bigstar \\bigstar \u8bad\u7ec3\u96c6\uff1a\u9a8c\u8bc1\u96c6\uff1a\u6d4b\u8bd5\u96c6 = 7\uff1a3\uff1a1\uff0c\u5bf9\u5927\u89c4\u6a21\u6570\u636e\uff0c98\uff1a1\uff1a1 \u4ea4\u53c9\u9a8c\u8bc1 \u00b6 k-\u6298\u4ea4\u53c9\u9a8c\u8bc1\uff1a\u8bb2\u8bad\u7ec3\u6570\u636e\u968f\u673a\u5206\u6210 k \u4efd\uff0c\u6bcf\u6b21\u9009\u62e9\u4e00\u4efd\u4f5c\u4e3a\u9a8c\u8bc1\u96c6\uff0c\u5269\u4e0b\u7684\u4f5c\u4e3a\u8bad\u7ec3\u96c6\uff0c\u91cd\u590d k \u6b21\uff0c\u83b7\u5f97 k \u6b21\u635f\u5931\u503c\uff0c\u53d6\u5e73\u5747\u3002 \\bigstar \\bigstar \u9002\u5408\u4e8e\u5c0f\u6837\u672c \\bigstar \\bigstar \u5728\u6df1\u5ea6\u5b66\u5386\u91cc\uff0c\u9a8c\u8bc1\u96c6\uff08holdout samples\uff09\u66f4\u9002\u5408 Variance vs Bias \u00b6 \u9ad8\u504f\u5dee\u4e5f\u53eb\u6b20\u62df\u5408\uff08underfitting\uff09\uff0c\u5177\u4f53\u6307\u8bad\u7ec3\u635f\u5931\u503c\u8f83\u5927\uff1b\u9ad8\u65b9\u5dee\u4e5f\u53eb\u8fc7\u62df\u5408\uff08overfitting\uff09\uff0c\u5728\u8bad\u7ec3\u6570\u636e\u96c6\u4e0a\u4f4e\u8bef\u5dee\uff0c\u4f46\u6d4b\u8bd5\u6570\u636e\u96c6\u4e0a\u9ad8\u8bef\u5dee\u3002 \\bigstar \\bigstar \u907f\u514d\u9ad8\u504f\u5dee\uff1a1\uff09\u66f4\u590d\u6742\u7684\u6a21\u578b\uff0c2\uff09\u5ef6\u957f\u8bad\u7ec3\u65f6\u95f4 \\bigstar \\bigstar \u907f\u514d\u9ad8\u65b9\u5dee\uff1a1\uff09\u66f4\u591a\u7684\u8bad\u7ec3\u6570\u636e\uff0c2\uff09\u6b63\u5219\u5316\uff0c3\uff09dropout\uff0c4\uff09\u964d\u4f4e\u6a21\u578b\u590d\u6742\u5ea6 \u7aef\u5230\u7aef\u5b66\u4e60 \u00b6 \u7aef\u5230\u7aef\u5b66\u4e60\uff08End-to-end learning\uff09\u5c06\u5404\u4e2a\u9636\u6bb5\u7684\u5904\u7406\u5408\u5e76\u6210\u4e00\u4e2a\u3002\u4f8b\u5982 \\begin{matrix} & \\text{Audio} \\rightarrow \\text{Features} \\rightarrow \\text{Phenome} \\rightarrow \\rightarrow \\text{Words} \\rightarrow \\text{Transcript} & \\\\ & \\Downarrow & \\\\ & \\text{Audio} \\rightarrow \\text{Transcript} & \\end{matrix} \\begin{matrix} & \\text{Audio} \\rightarrow \\text{Features} \\rightarrow \\text{Phenome} \\rightarrow \\rightarrow \\text{Words} \\rightarrow \\text{Transcript} & \\\\ & \\Downarrow & \\\\ & \\text{Audio} \\rightarrow \\text{Transcript} & \\end{matrix} \\bigstar \\bigstar \u4f18\u70b9\uff1a\u8f83\u5c11\u7684\u4eba\u5de5\u8bbe\u8ba1\u6a21\u5757 \\bigstar \\bigstar \u7f3a\u70b9\uff1a\u9700\u8981\u5927\u91cf\u7684\u6570\u636e","title":"\u673a\u5668\u5b66\u4e60\u7b56\u7565"},{"location":"machine-learning/ml-strategies/#_1","text":"\\bigstar \\bigstar \u8bad\u7ec3\u96c6\u3001\u9a8c\u8bc1\u96c6\u548c\u6d4b\u8bd5\u96c6\u670d\u4ece i.i.d \u72ec\u7acb\u540c\u5206\u5e03 \\bigstar \\bigstar \u8bad\u7ec3\u96c6\u3001\u9a8c\u8bc1\u96c6\u548c\u6d4b\u8bd5\u96c6\u8868\u73b0\u5747\u8981\u826f\u597d\uff0c\u6cdb\u5316\u80fd\u529b\u597d \\bigstar \\bigstar \u8bad\u7ec3\u96c6\uff1a\u9a8c\u8bc1\u96c6\uff1a\u6d4b\u8bd5\u96c6 = 7\uff1a3\uff1a1\uff0c\u5bf9\u5927\u89c4\u6a21\u6570\u636e\uff0c98\uff1a1\uff1a1","title":"\u5047\u8bbe"},{"location":"machine-learning/ml-strategies/#_2","text":"k-\u6298\u4ea4\u53c9\u9a8c\u8bc1\uff1a\u8bb2\u8bad\u7ec3\u6570\u636e\u968f\u673a\u5206\u6210 k \u4efd\uff0c\u6bcf\u6b21\u9009\u62e9\u4e00\u4efd\u4f5c\u4e3a\u9a8c\u8bc1\u96c6\uff0c\u5269\u4e0b\u7684\u4f5c\u4e3a\u8bad\u7ec3\u96c6\uff0c\u91cd\u590d k \u6b21\uff0c\u83b7\u5f97 k \u6b21\u635f\u5931\u503c\uff0c\u53d6\u5e73\u5747\u3002 \\bigstar \\bigstar \u9002\u5408\u4e8e\u5c0f\u6837\u672c \\bigstar \\bigstar \u5728\u6df1\u5ea6\u5b66\u5386\u91cc\uff0c\u9a8c\u8bc1\u96c6\uff08holdout samples\uff09\u66f4\u9002\u5408","title":"\u4ea4\u53c9\u9a8c\u8bc1"},{"location":"machine-learning/ml-strategies/#variance-vs-bias","text":"\u9ad8\u504f\u5dee\u4e5f\u53eb\u6b20\u62df\u5408\uff08underfitting\uff09\uff0c\u5177\u4f53\u6307\u8bad\u7ec3\u635f\u5931\u503c\u8f83\u5927\uff1b\u9ad8\u65b9\u5dee\u4e5f\u53eb\u8fc7\u62df\u5408\uff08overfitting\uff09\uff0c\u5728\u8bad\u7ec3\u6570\u636e\u96c6\u4e0a\u4f4e\u8bef\u5dee\uff0c\u4f46\u6d4b\u8bd5\u6570\u636e\u96c6\u4e0a\u9ad8\u8bef\u5dee\u3002 \\bigstar \\bigstar \u907f\u514d\u9ad8\u504f\u5dee\uff1a1\uff09\u66f4\u590d\u6742\u7684\u6a21\u578b\uff0c2\uff09\u5ef6\u957f\u8bad\u7ec3\u65f6\u95f4 \\bigstar \\bigstar \u907f\u514d\u9ad8\u65b9\u5dee\uff1a1\uff09\u66f4\u591a\u7684\u8bad\u7ec3\u6570\u636e\uff0c2\uff09\u6b63\u5219\u5316\uff0c3\uff09dropout\uff0c4\uff09\u964d\u4f4e\u6a21\u578b\u590d\u6742\u5ea6","title":"Variance vs Bias"},{"location":"machine-learning/ml-strategies/#_3","text":"\u7aef\u5230\u7aef\u5b66\u4e60\uff08End-to-end learning\uff09\u5c06\u5404\u4e2a\u9636\u6bb5\u7684\u5904\u7406\u5408\u5e76\u6210\u4e00\u4e2a\u3002\u4f8b\u5982 \\begin{matrix} & \\text{Audio} \\rightarrow \\text{Features} \\rightarrow \\text{Phenome} \\rightarrow \\rightarrow \\text{Words} \\rightarrow \\text{Transcript} & \\\\ & \\Downarrow & \\\\ & \\text{Audio} \\rightarrow \\text{Transcript} & \\end{matrix} \\begin{matrix} & \\text{Audio} \\rightarrow \\text{Features} \\rightarrow \\text{Phenome} \\rightarrow \\rightarrow \\text{Words} \\rightarrow \\text{Transcript} & \\\\ & \\Downarrow & \\\\ & \\text{Audio} \\rightarrow \\text{Transcript} & \\end{matrix} \\bigstar \\bigstar \u4f18\u70b9\uff1a\u8f83\u5c11\u7684\u4eba\u5de5\u8bbe\u8ba1\u6a21\u5757 \\bigstar \\bigstar \u7f3a\u70b9\uff1a\u9700\u8981\u5927\u91cf\u7684\u6570\u636e","title":"\u7aef\u5230\u7aef\u5b66\u4e60"},{"location":"machine-learning/mlp/","text":"\u57fa\u7840 \u00b6 \u795e\u7ecf\u7f51\u7edc\u8868\u793a \\bigstar \\bigstar X \u662f\u4e00\u4e2a\u77e9\u9635\uff0c\u6bcf\u4e00\u884c\u662f\u4e00\u6761\u6837\u672c \\bigstar \\bigstar a^{[2]} a^{[2]} \u4ee3\u8868\u7b2c\u4e8c\u5c42\u6fc0\u6d3b\u51fd\u6570\u540e\u7684\u5411\u91cf\uff0c a^{[2](12)} a^{[2](12)} \u4ee3\u8868\u7b2c\u4e8c\u5c42\u7b2c12\u4e2a\u8bad\u7ec3\u6837\u672c \\bigstar \\bigstar a_{4}^{[2]} a_{4}^{[2]} \u662f\u7b2c2\u5c42\u91cc\u7b2c4\u4e2a\u795e\u7ecf\u5143\u7684\u6fc0\u6d3b\u51fd\u6570\u503c \\bigstar \\bigstar \u5c42\u7684\u6570\u76ee\u7b49\u4e8en\u5c42\u9690\u5c42\u548c1\u5c42\u8f93\u51fa\u5c42 \u524d\u9988\u7f51\u7edc \u00b6 \u5411\u91cf\u5316\u8868\u793a\u5c42 l \\in [1, L] l \\in [1, L] \uff0c\u5728\u7b2c l^{th} l^{th} \u5c42\uff0c W^{[l]} W^{[l]} \u7684\u5c3a\u5bf8\u662f\uff08 n^{[l]} n^{[l]} , n^{[l-1]} n^{[l-1]} \uff09\uff0c b^{[l]} b^{[l]} \u7684\u5c3a\u5bf8\u662f\uff08 n^{[l]} n^{[l]} , 1\uff09\uff0c\u8fd9\u91cc n^{[l]} n^{[l]} \u662f l^{th} l^{th} \u5c42\u7684\u795e\u7ecf\u5143\u6570\u76ee\u3002l = 0 \u8868\u793a\u8f93\u5165\u5c42\u3002\u4f8b\u5982\uff1a W^{[1]} W^{[1]} \u7684\u5c3a\u5bf8\u662f (4, 3), b^{[1]} b^{[1]} \u662f (4, 1), W^{[2]} W^{[2]} \u662f (1, 4), b^{[2]} b^{[2]} \u662f (1, 1), Z^{[1]} Z^{[1]} \u662f (4, m)\u3002 \u5bf9\u5355\u4e00\u795e\u7ecf\u5143\u800c\u8a00 \\begin{aligned} & a_{1}^{[1]} = \\sigma(z_{1}^{[1]}) \\\\ & z_{1}^{[1]} = w_{1}^{[1]T} x + b_{1}^{[1]} \\\\ & x = \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} \\\\ & w_{1}^{[1]T} = \\begin{bmatrix} w_{1,1} & w_{1,2} & w_{1, 3} \\end{bmatrix} \\\\ & b_{1}^{[1]} = \\begin{bmatrix} R \\end{bmatrix} \\end{aligned} \\begin{aligned} & a_{1}^{[1]} = \\sigma(z_{1}^{[1]}) \\\\ & z_{1}^{[1]} = w_{1}^{[1]T} x + b_{1}^{[1]} \\\\ & x = \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} \\\\ & w_{1}^{[1]T} = \\begin{bmatrix} w_{1,1} & w_{1,2} & w_{1, 3} \\end{bmatrix} \\\\ & b_{1}^{[1]} = \\begin{bmatrix} R \\end{bmatrix} \\end{aligned} \u591a\u4e2a\u795e\u7ecf\u5143\u5982\u4e0b\uff1a \\begin{aligned} & \\begin{bmatrix} z_{1}^{[1]}\\\\ z_{2}^{[1]}\\\\ z_{3}^{[1]}\\\\ z_{4}^{[1]} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}x + b^{[1]} \\\\ & A^{[1]} = \\sigma(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]} A^{[1]} + b^{[2]} \\\\ & A^{[2]} = \\sigma(Z^{[2]}) \\end{aligned} \\begin{aligned} & \\begin{bmatrix} z_{1}^{[1]}\\\\ z_{2}^{[1]}\\\\ z_{3}^{[1]}\\\\ z_{4}^{[1]} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}x + b^{[1]} \\\\ & A^{[1]} = \\sigma(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]} A^{[1]} + b^{[2]} \\\\ & A^{[2]} = \\sigma(Z^{[2]}) \\end{aligned} \u6240\u4ee5\uff0c W^{[1]} W^{[1]} \u7684\u5c3a\u5bf8\u662f 4 \\times 3 4 \\times 3 \uff0c b^{[1]} b^{[1]} \u662f 4 \\times 1 4 \\times 1 (scalar)\uff1b W^{[2]} W^{[2]} \u662f 1 \\times 4 1 \\times 4 \uff0c b^{[2]} b^{[2]} \u662f 1 \\times 1 1 \\times 1 x \u4ee5\u5217\u5411\u91cf\u7684\u5f62\u5f0f\u8868\u793a\u4e00\u6761\u6837\u672c\uff0c\u6269\u5145\u5230 m \u6761\u6837\u672c\u540e\u3002 \\begin{aligned} & Z^{[l]} = W^{[l]} A^{[l-1]} + b^{[l]}, \\quad A^{[l]} = g^{[l]}(Z^{[l]}) \\\\ & X = \\begin{bmatrix} | & | & ... & |\\\\ x^{(1)} & x^{(2)} & ... & x^{(m)}\\\\ | & | & ... & | \\end{bmatrix}, \\quad x^{(i)} = \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} \\\\ & A^{[1]} = \\begin{bmatrix} | & | & ... & |\\\\ a^{[1](1)} & a^{[1](2)} & ... & a^{[1](m)}\\\\ | & | & ... & | \\end{bmatrix} \\\\ & a^{[1](i)} = \\sigma(z^{[1](i)}) \\\\ & z^{[1](i)} = \\begin{bmatrix} z_{1}^{[1](i)}\\\\ z_{2}^{[1](i)}\\\\ z_{3}^{[1](i)}\\\\ z_{4}^{[1](i)} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}X + b^{[1]} \\\\ & A^{[1]} = g^{[1]}(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]}A^{[1]} + b^{[2]} \\\\ & A^{[2]} = g^{[2]}(Z^{[2]}) = \\hat{Y_{}} \\end{aligned} \\begin{aligned} & Z^{[l]} = W^{[l]} A^{[l-1]} + b^{[l]}, \\quad A^{[l]} = g^{[l]}(Z^{[l]}) \\\\ & X = \\begin{bmatrix} | & | & ... & |\\\\ x^{(1)} & x^{(2)} & ... & x^{(m)}\\\\ | & | & ... & | \\end{bmatrix}, \\quad x^{(i)} = \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} \\\\ & A^{[1]} = \\begin{bmatrix} | & | & ... & |\\\\ a^{[1](1)} & a^{[1](2)} & ... & a^{[1](m)}\\\\ | & | & ... & | \\end{bmatrix} \\\\ & a^{[1](i)} = \\sigma(z^{[1](i)}) \\\\ & z^{[1](i)} = \\begin{bmatrix} z_{1}^{[1](i)}\\\\ z_{2}^{[1](i)}\\\\ z_{3}^{[1](i)}\\\\ z_{4}^{[1](i)} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}X + b^{[1]} \\\\ & A^{[1]} = g^{[1]}(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]}A^{[1]} + b^{[2]} \\\\ & A^{[2]} = g^{[2]}(Z^{[2]}) = \\hat{Y_{}} \\end{aligned} \u53cd\u5411\u4f20\u64ad \u00b6 \\begin{aligned} & dA^{[l]} = (W^{[l+1]})^{T} dZ^{[l+1]} \\\\ & dZ^{[l]} = dA^{[l]} * [g^{[l]}(Z^{[l]})]' \\quad \\text{where * means element-wise multiplication} \\\\ & dW^{[l]} = \\frac{1}{m} dZ^{[l]} (A^{[l-1]})^{T} \\\\ & db^{[l]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[l]} \\end{aligned} \\begin{aligned} & dA^{[l]} = (W^{[l+1]})^{T} dZ^{[l+1]} \\\\ & dZ^{[l]} = dA^{[l]} * [g^{[l]}(Z^{[l]})]' \\quad \\text{where * means element-wise multiplication} \\\\ & dW^{[l]} = \\frac{1}{m} dZ^{[l]} (A^{[l-1]})^{T} \\\\ & db^{[l]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[l]} \\end{aligned} \\begin{aligned} & L(\\hat{Y_{}}, Y) = -[Y \\log\\hat{Y_{}} + (1 - Y)\\log(1 - \\hat{Y_{}})] \\\\ & dZ^{[2]} = A^{[2]} - Y \\\\ & dW^{[2]} = \\frac{1}{m} dZ^{[2]} (A^{[1]})^{T} \\\\ & db^{[2]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[2]} \\\\ & dZ^{[1]} = dA^{[1]} [g^{[1]}(dZ^{1})]' = (W^{[2]})^{T}dZ^{[2]} [g^{[1]}(dZ^{1})]' \\\\ & dW^{[1]} = \\frac{1}{m} dZ^{[1]} X^{T} \\\\ & db^{[1]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[1]} \\end{aligned} \\begin{aligned} & L(\\hat{Y_{}}, Y) = -[Y \\log\\hat{Y_{}} + (1 - Y)\\log(1 - \\hat{Y_{}})] \\\\ & dZ^{[2]} = A^{[2]} - Y \\\\ & dW^{[2]} = \\frac{1}{m} dZ^{[2]} (A^{[1]})^{T} \\\\ & db^{[2]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[2]} \\\\ & dZ^{[1]} = dA^{[1]} [g^{[1]}(dZ^{1})]' = (W^{[2]})^{T}dZ^{[2]} [g^{[1]}(dZ^{1})]' \\\\ & dW^{[1]} = \\frac{1}{m} dZ^{[1]} X^{T} \\\\ & db^{[1]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[1]} \\end{aligned} \\bigstar \\bigstar \u8d85\u53c2\u6570\uff1a\u5b66\u4e60\u7387\uff0c\u8fed\u4ee3\u6570\u76ee\u3001\u9690\u5c42\u4e2a\u6570\u3001\u9690\u5c42\u5355\u5143\u6570\u3001\u6fc0\u6d3b\u51fd\u6570 1 2 3 4 5 6 7 A = np . random . randn ( 4 , 3 ) B = np . sum ( A , axis = 1 , keepdims = True ) # B.shape is (4, 1) dw2 = 1 / m * np . dot ( dZ2 , A1 . T ) # Backprop db2 = 1 / m * np . sum ( dZ2 , axis = 1 , keepdims = False ) dW1 = 1 / m * np . dot ( dZ1 , X . T ) db1 = 1 / m * np . sum ( dZ1 , axis = 1 , keepdims = False ) Jacobin \u00b6 \u8003\u8651\u4e00\u4e2a\u4ece\u5411\u91cf\u5230\u5411\u91cf\u7684\u6620\u5c04 g(x): (x_{1}, ..., x_{n}) \\rightarrow (g_{1}, ..., g_{m}) (x_{1}, ..., x_{n}) \\rightarrow (g_{1}, ..., g_{m}) f(g): (g_{1}, ..., g_{m}) \\rightarrow (f_{1}, ..., f_{k}) (g_{1}, ..., g_{m}) \\rightarrow (f_{1}, ..., f_{k}) this will be useful for RNN h(x) = f(g(x)): (x_{1}, ..., x_{n}) \\rightarrow (h_{1}, ..., h_{k}) = (f_{1}, ..., f_{k}) (x_{1}, ..., x_{n}) \\rightarrow (h_{1}, ..., h_{k}) = (f_{1}, ..., f_{k}) The matrix of partial derivatives \\frac{\\partial h_{i}}{\\partial x_{j}} \\frac{\\partial h_{i}}{\\partial x_{j}} is called the Jacobian \\begin{aligned} & J^{h} = \\begin{pmatrix} \\frac{\\partial h_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{1}}{\\partial x_{n}}\\\\ \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial h_{k}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{k}}{\\partial x_{n}} \\end{pmatrix} \\\\ & J_{i, j}^{h} = \\frac{\\partial h_{i}}{\\partial x_{j}} = \\sum_{l}\\frac{\\partial f_{i}}{\\partial g_{l}}\\frac{\\partial g_{l}}{\\partial x_{j}} = \\sum_{l}J_{i, l}^{f} \\cdot J_{l, j}^{g} \\\\ & J^{h} = J^{f} \\cdot J^{g} \\end{aligned} \\begin{aligned} & J^{h} = \\begin{pmatrix} \\frac{\\partial h_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{1}}{\\partial x_{n}}\\\\ \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial h_{k}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{k}}{\\partial x_{n}} \\end{pmatrix} \\\\ & J_{i, j}^{h} = \\frac{\\partial h_{i}}{\\partial x_{j}} = \\sum_{l}\\frac{\\partial f_{i}}{\\partial g_{l}}\\frac{\\partial g_{l}}{\\partial x_{j}} = \\sum_{l}J_{i, l}^{f} \\cdot J_{l, j}^{g} \\\\ & J^{h} = J^{f} \\cdot J^{g} \\end{aligned} \u5f20\u91cf\u5fae\u5206 \u00b6 \\begin{aligned} & \\begin{aligned} C &= AB \\\\ &= \\begin{pmatrix} a_{1, 1} & a_{1, 2}\\\\ a_{2, 1} & a_{2, 2} \\end{pmatrix} \\cdot \\begin{pmatrix} b_{1, 1} & b_{1, 2}\\\\ b_{2, 1} & b_{2, 2} \\end{pmatrix} \\\\ &= \\begin{pmatrix} a_{1, 1}b_{1, 1}+a_{1, 2}b_{2, 1} & a_{1, 1}b_{1, 2}+a_{1, 2}b_{2, 2}\\\\ a_{2, 1}b_{1, 1}+a_{2, 2}b_{2, 1} & a_{2, 1}b_{1, 2}+a_{2, 2}b_{2, 2} \\end{pmatrix} \\end{aligned} \\end{aligned} \\begin{aligned} & \\begin{aligned} C &= AB \\\\ &= \\begin{pmatrix} a_{1, 1} & a_{1, 2}\\\\ a_{2, 1} & a_{2, 2} \\end{pmatrix} \\cdot \\begin{pmatrix} b_{1, 1} & b_{1, 2}\\\\ b_{2, 1} & b_{2, 2} \\end{pmatrix} \\\\ &= \\begin{pmatrix} a_{1, 1}b_{1, 1}+a_{1, 2}b_{2, 1} & a_{1, 1}b_{1, 2}+a_{1, 2}b_{2, 2}\\\\ a_{2, 1}b_{1, 1}+a_{2, 2}b_{2, 1} & a_{2, 1}b_{1, 2}+a_{2, 2}b_{2, 2} \\end{pmatrix} \\end{aligned} \\end{aligned} \\begin{aligned} \\frac{\\partial C}{\\partial A} &= \\{ \\frac{\\partial c_{i, j}}{\\partial a_{k, l}} \\}_{i, j, k, l} \\\\ &= \\begin{pmatrix} \\frac{\\partial c_{1, 1}}{\\partial A} & \\frac{\\partial c_{1, 2}}{\\partial A}\\\\ \\frac{\\partial c_{2, 1}}{\\partial A} & \\frac{\\partial c_{2, 2}}{\\partial A} \\end{pmatrix} \\\\ &= \\begin{pmatrix} \\begin{bmatrix} b_{1, 1} & b_{2, 1}\\\\ 0 & 0 \\end{bmatrix} & \\begin{bmatrix} b_{1, 2} & b_{2, 2}\\\\ 0 & 0 \\end{bmatrix}\\\\ \\begin{bmatrix} 0 & 0\\\\ b_{1, 1} & b_{2, 1} \\end{bmatrix} & \\begin{bmatrix} 0 & 0\\\\ b_{1, 2} & b_{2, 2} \\end{bmatrix} \\end{pmatrix} \\end{aligned} \\begin{aligned} \\frac{\\partial C}{\\partial A} &= \\{ \\frac{\\partial c_{i, j}}{\\partial a_{k, l}} \\}_{i, j, k, l} \\\\ &= \\begin{pmatrix} \\frac{\\partial c_{1, 1}}{\\partial A} & \\frac{\\partial c_{1, 2}}{\\partial A}\\\\ \\frac{\\partial c_{2, 1}}{\\partial A} & \\frac{\\partial c_{2, 2}}{\\partial A} \\end{pmatrix} \\\\ &= \\begin{pmatrix} \\begin{bmatrix} b_{1, 1} & b_{2, 1}\\\\ 0 & 0 \\end{bmatrix} & \\begin{bmatrix} b_{1, 2} & b_{2, 2}\\\\ 0 & 0 \\end{bmatrix}\\\\ \\begin{bmatrix} 0 & 0\\\\ b_{1, 1} & b_{2, 1} \\end{bmatrix} & \\begin{bmatrix} 0 & 0\\\\ b_{1, 2} & b_{2, 2} \\end{bmatrix} \\end{pmatrix} \\end{aligned} \u4e00\u4e2a 3-d \u5f20\u91cf\u5bf9 4-d \u5f20\u91cf\u5fae\u5206\u7684\u7ef4\u5ea6\uff08dimensions\uff09\u662f 7\u3002 \u5411\u91cf\u5316 \u00b6 \u65e0\u8bba\u4f55\u65f6\uff0c\u907f\u514d\u663e\u793afor\u5faa\u73af \\text{z = np.dot(w, x)} \\text{z = np.dot(w, x)} \\bigstar \\bigstar Broadcasting \\begin{aligned} & (m, n) + R = (m, n) \\\\ & (m, n) + (1, n) = (m, n) \\\\ & (m, n) + (m, 1) = (m, n) \\end{aligned} \\begin{aligned} & (m, n) + R = (m, n) \\\\ & (m, n) + (1, n) = (m, n) \\\\ & (m, n) + (m, 1) = (m, n) \\end{aligned} \u4f8b\u5982 \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100 & 200 & 300 \\end{bmatrix} = \\begin{bmatrix} 101 & 202 & 303\\\\ 104 & 205 & 306 \\end{bmatrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100 & 200 & 300 \\end{bmatrix} = \\begin{bmatrix} 101 & 202 & 303\\\\ 104 & 205 & 306 \\end{bmatrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100\\\\ 200 \\end{bmatrix} = \\begin{bmatrix} 101 & 102 & 103\\\\ 104 & 205 & 206 \\end{bmatrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100\\\\ 200 \\end{bmatrix} = \\begin{bmatrix} 101 & 102 & 103\\\\ 104 & 205 & 206 \\end{bmatrix} Gradient checking \u00b6 \u5c06\u53c2\u6570\uff08 W^{[1]} W^{[1]} , b^{[1]} b^{[1]} , ..., W^{[L]} W^{[L]} , b^{[L]} b^{[L]} \uff09\u548c\u53c2\u6570\u7684\u5bfc\u6570\uff08 dW^{[1]} dW^{[1]} , db^{[1]} db^{[1]} , ..., dW^{[L]} dW^{[L]} , db^{[L]} db^{[L]} \uff09\u53d6\u51fa\u5e76\u5f62\u6210\u65b0\u7684\u5411\u91cf \\theta \\theta \u548c d\\theta d\\theta J(\\theta) = J(\\theta_{1}, \\theta_{2}, ..., \\theta_{n}) J(\\theta) = J(\\theta_{1}, \\theta_{2}, ..., \\theta_{n}) \u5bf9\u6bcf\u4e00\u4e2a\u53c2\u6570 \\theta_{i} \\theta_{i} \uff0c\u6211\u4eec\u68c0\u67e5 d\\theta_{i}^{\\text{approx}} = \\frac{J(\\theta_{1}, ..., \\theta_{i} + \\epsilon, ..., \\theta_{n})-J(\\theta_{1}, ..., \\theta_{i} - \\epsilon, ..., \\theta_{n})}{2\\epsilon} \\approx d\\theta_{i} d\\theta_{i}^{\\text{approx}} = \\frac{J(\\theta_{1}, ..., \\theta_{i} + \\epsilon, ..., \\theta_{n})-J(\\theta_{1}, ..., \\theta_{i} - \\epsilon, ..., \\theta_{n})}{2\\epsilon} \\approx d\\theta_{i} \u53e6\u4e00\u79cd\u5f62\u5f0f \\frac{\\left \\| d\\theta_{i}^{\\text{approx}} - d\\theta_{i} \\right \\|_{2}}{\\left \\| d\\theta_{i}^{\\text{approx}} \\right \\|_{2} + \\left \\| d\\theta_{i} \\right \\|_{2}} < 10^{-7} \\frac{\\left \\| d\\theta_{i}^{\\text{approx}} - d\\theta_{i} \\right \\|_{2}}{\\left \\| d\\theta_{i}^{\\text{approx}} \\right \\|_{2} + \\left \\| d\\theta_{i} \\right \\|_{2}} < 10^{-7} \\bigstar \\bigstar \u4ec5\u7528\u4f5c debug\uff0c\u4e0d\u7528\u5728\u8bad\u7ec3\u9636\u6bb5\u4f7f\u7528","title":"MLP"},{"location":"machine-learning/mlp/#_1","text":"\u795e\u7ecf\u7f51\u7edc\u8868\u793a \\bigstar \\bigstar X \u662f\u4e00\u4e2a\u77e9\u9635\uff0c\u6bcf\u4e00\u884c\u662f\u4e00\u6761\u6837\u672c \\bigstar \\bigstar a^{[2]} a^{[2]} \u4ee3\u8868\u7b2c\u4e8c\u5c42\u6fc0\u6d3b\u51fd\u6570\u540e\u7684\u5411\u91cf\uff0c a^{[2](12)} a^{[2](12)} \u4ee3\u8868\u7b2c\u4e8c\u5c42\u7b2c12\u4e2a\u8bad\u7ec3\u6837\u672c \\bigstar \\bigstar a_{4}^{[2]} a_{4}^{[2]} \u662f\u7b2c2\u5c42\u91cc\u7b2c4\u4e2a\u795e\u7ecf\u5143\u7684\u6fc0\u6d3b\u51fd\u6570\u503c \\bigstar \\bigstar \u5c42\u7684\u6570\u76ee\u7b49\u4e8en\u5c42\u9690\u5c42\u548c1\u5c42\u8f93\u51fa\u5c42","title":"\u57fa\u7840"},{"location":"machine-learning/mlp/#_2","text":"\u5411\u91cf\u5316\u8868\u793a\u5c42 l \\in [1, L] l \\in [1, L] \uff0c\u5728\u7b2c l^{th} l^{th} \u5c42\uff0c W^{[l]} W^{[l]} \u7684\u5c3a\u5bf8\u662f\uff08 n^{[l]} n^{[l]} , n^{[l-1]} n^{[l-1]} \uff09\uff0c b^{[l]} b^{[l]} \u7684\u5c3a\u5bf8\u662f\uff08 n^{[l]} n^{[l]} , 1\uff09\uff0c\u8fd9\u91cc n^{[l]} n^{[l]} \u662f l^{th} l^{th} \u5c42\u7684\u795e\u7ecf\u5143\u6570\u76ee\u3002l = 0 \u8868\u793a\u8f93\u5165\u5c42\u3002\u4f8b\u5982\uff1a W^{[1]} W^{[1]} \u7684\u5c3a\u5bf8\u662f (4, 3), b^{[1]} b^{[1]} \u662f (4, 1), W^{[2]} W^{[2]} \u662f (1, 4), b^{[2]} b^{[2]} \u662f (1, 1), Z^{[1]} Z^{[1]} \u662f (4, m)\u3002 \u5bf9\u5355\u4e00\u795e\u7ecf\u5143\u800c\u8a00 \\begin{aligned} & a_{1}^{[1]} = \\sigma(z_{1}^{[1]}) \\\\ & z_{1}^{[1]} = w_{1}^{[1]T} x + b_{1}^{[1]} \\\\ & x = \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} \\\\ & w_{1}^{[1]T} = \\begin{bmatrix} w_{1,1} & w_{1,2} & w_{1, 3} \\end{bmatrix} \\\\ & b_{1}^{[1]} = \\begin{bmatrix} R \\end{bmatrix} \\end{aligned} \\begin{aligned} & a_{1}^{[1]} = \\sigma(z_{1}^{[1]}) \\\\ & z_{1}^{[1]} = w_{1}^{[1]T} x + b_{1}^{[1]} \\\\ & x = \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} \\\\ & w_{1}^{[1]T} = \\begin{bmatrix} w_{1,1} & w_{1,2} & w_{1, 3} \\end{bmatrix} \\\\ & b_{1}^{[1]} = \\begin{bmatrix} R \\end{bmatrix} \\end{aligned} \u591a\u4e2a\u795e\u7ecf\u5143\u5982\u4e0b\uff1a \\begin{aligned} & \\begin{bmatrix} z_{1}^{[1]}\\\\ z_{2}^{[1]}\\\\ z_{3}^{[1]}\\\\ z_{4}^{[1]} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}x + b^{[1]} \\\\ & A^{[1]} = \\sigma(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]} A^{[1]} + b^{[2]} \\\\ & A^{[2]} = \\sigma(Z^{[2]}) \\end{aligned} \\begin{aligned} & \\begin{bmatrix} z_{1}^{[1]}\\\\ z_{2}^{[1]}\\\\ z_{3}^{[1]}\\\\ z_{4}^{[1]} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}\\\\ x_{2}\\\\ x_{3} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}x + b^{[1]} \\\\ & A^{[1]} = \\sigma(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]} A^{[1]} + b^{[2]} \\\\ & A^{[2]} = \\sigma(Z^{[2]}) \\end{aligned} \u6240\u4ee5\uff0c W^{[1]} W^{[1]} \u7684\u5c3a\u5bf8\u662f 4 \\times 3 4 \\times 3 \uff0c b^{[1]} b^{[1]} \u662f 4 \\times 1 4 \\times 1 (scalar)\uff1b W^{[2]} W^{[2]} \u662f 1 \\times 4 1 \\times 4 \uff0c b^{[2]} b^{[2]} \u662f 1 \\times 1 1 \\times 1 x \u4ee5\u5217\u5411\u91cf\u7684\u5f62\u5f0f\u8868\u793a\u4e00\u6761\u6837\u672c\uff0c\u6269\u5145\u5230 m \u6761\u6837\u672c\u540e\u3002 \\begin{aligned} & Z^{[l]} = W^{[l]} A^{[l-1]} + b^{[l]}, \\quad A^{[l]} = g^{[l]}(Z^{[l]}) \\\\ & X = \\begin{bmatrix} | & | & ... & |\\\\ x^{(1)} & x^{(2)} & ... & x^{(m)}\\\\ | & | & ... & | \\end{bmatrix}, \\quad x^{(i)} = \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} \\\\ & A^{[1]} = \\begin{bmatrix} | & | & ... & |\\\\ a^{[1](1)} & a^{[1](2)} & ... & a^{[1](m)}\\\\ | & | & ... & | \\end{bmatrix} \\\\ & a^{[1](i)} = \\sigma(z^{[1](i)}) \\\\ & z^{[1](i)} = \\begin{bmatrix} z_{1}^{[1](i)}\\\\ z_{2}^{[1](i)}\\\\ z_{3}^{[1](i)}\\\\ z_{4}^{[1](i)} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}X + b^{[1]} \\\\ & A^{[1]} = g^{[1]}(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]}A^{[1]} + b^{[2]} \\\\ & A^{[2]} = g^{[2]}(Z^{[2]}) = \\hat{Y_{}} \\end{aligned} \\begin{aligned} & Z^{[l]} = W^{[l]} A^{[l-1]} + b^{[l]}, \\quad A^{[l]} = g^{[l]}(Z^{[l]}) \\\\ & X = \\begin{bmatrix} | & | & ... & |\\\\ x^{(1)} & x^{(2)} & ... & x^{(m)}\\\\ | & | & ... & | \\end{bmatrix}, \\quad x^{(i)} = \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} \\\\ & A^{[1]} = \\begin{bmatrix} | & | & ... & |\\\\ a^{[1](1)} & a^{[1](2)} & ... & a^{[1](m)}\\\\ | & | & ... & | \\end{bmatrix} \\\\ & a^{[1](i)} = \\sigma(z^{[1](i)}) \\\\ & z^{[1](i)} = \\begin{bmatrix} z_{1}^{[1](i)}\\\\ z_{2}^{[1](i)}\\\\ z_{3}^{[1](i)}\\\\ z_{4}^{[1](i)} \\end{bmatrix} = \\begin{bmatrix} w_{1}^{[1]T}\\\\ w_{2}^{[1]T}\\\\ w_{3}^{[1]T}\\\\ w_{4}^{[1]T} \\end{bmatrix} \\begin{bmatrix} x_{1}^{(i)}\\\\ x_{2}^{(i)}\\\\ x_{3}^{(i)} \\end{bmatrix} + \\begin{bmatrix} b_{1}^{[1]}\\\\ b_{2}^{[1]}\\\\ b_{3}^{[1]}\\\\ b_{4}^{[1]} \\end{bmatrix} \\\\ & Z^{[1]} = W^{[1]}X + b^{[1]} \\\\ & A^{[1]} = g^{[1]}(Z^{[1]}) \\\\ & Z^{[2]} = W^{[2]}A^{[1]} + b^{[2]} \\\\ & A^{[2]} = g^{[2]}(Z^{[2]}) = \\hat{Y_{}} \\end{aligned}","title":"\u524d\u9988\u7f51\u7edc"},{"location":"machine-learning/mlp/#_3","text":"\\begin{aligned} & dA^{[l]} = (W^{[l+1]})^{T} dZ^{[l+1]} \\\\ & dZ^{[l]} = dA^{[l]} * [g^{[l]}(Z^{[l]})]' \\quad \\text{where * means element-wise multiplication} \\\\ & dW^{[l]} = \\frac{1}{m} dZ^{[l]} (A^{[l-1]})^{T} \\\\ & db^{[l]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[l]} \\end{aligned} \\begin{aligned} & dA^{[l]} = (W^{[l+1]})^{T} dZ^{[l+1]} \\\\ & dZ^{[l]} = dA^{[l]} * [g^{[l]}(Z^{[l]})]' \\quad \\text{where * means element-wise multiplication} \\\\ & dW^{[l]} = \\frac{1}{m} dZ^{[l]} (A^{[l-1]})^{T} \\\\ & db^{[l]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[l]} \\end{aligned} \\begin{aligned} & L(\\hat{Y_{}}, Y) = -[Y \\log\\hat{Y_{}} + (1 - Y)\\log(1 - \\hat{Y_{}})] \\\\ & dZ^{[2]} = A^{[2]} - Y \\\\ & dW^{[2]} = \\frac{1}{m} dZ^{[2]} (A^{[1]})^{T} \\\\ & db^{[2]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[2]} \\\\ & dZ^{[1]} = dA^{[1]} [g^{[1]}(dZ^{1})]' = (W^{[2]})^{T}dZ^{[2]} [g^{[1]}(dZ^{1})]' \\\\ & dW^{[1]} = \\frac{1}{m} dZ^{[1]} X^{T} \\\\ & db^{[1]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[1]} \\end{aligned} \\begin{aligned} & L(\\hat{Y_{}}, Y) = -[Y \\log\\hat{Y_{}} + (1 - Y)\\log(1 - \\hat{Y_{}})] \\\\ & dZ^{[2]} = A^{[2]} - Y \\\\ & dW^{[2]} = \\frac{1}{m} dZ^{[2]} (A^{[1]})^{T} \\\\ & db^{[2]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[2]} \\\\ & dZ^{[1]} = dA^{[1]} [g^{[1]}(dZ^{1})]' = (W^{[2]})^{T}dZ^{[2]} [g^{[1]}(dZ^{1})]' \\\\ & dW^{[1]} = \\frac{1}{m} dZ^{[1]} X^{T} \\\\ & db^{[1]} = \\frac{1}{m} \\sum_{i=1}^{m} dZ^{[1]} \\end{aligned} \\bigstar \\bigstar \u8d85\u53c2\u6570\uff1a\u5b66\u4e60\u7387\uff0c\u8fed\u4ee3\u6570\u76ee\u3001\u9690\u5c42\u4e2a\u6570\u3001\u9690\u5c42\u5355\u5143\u6570\u3001\u6fc0\u6d3b\u51fd\u6570 1 2 3 4 5 6 7 A = np . random . randn ( 4 , 3 ) B = np . sum ( A , axis = 1 , keepdims = True ) # B.shape is (4, 1) dw2 = 1 / m * np . dot ( dZ2 , A1 . T ) # Backprop db2 = 1 / m * np . sum ( dZ2 , axis = 1 , keepdims = False ) dW1 = 1 / m * np . dot ( dZ1 , X . T ) db1 = 1 / m * np . sum ( dZ1 , axis = 1 , keepdims = False )","title":"\u53cd\u5411\u4f20\u64ad"},{"location":"machine-learning/mlp/#jacobin","text":"\u8003\u8651\u4e00\u4e2a\u4ece\u5411\u91cf\u5230\u5411\u91cf\u7684\u6620\u5c04 g(x): (x_{1}, ..., x_{n}) \\rightarrow (g_{1}, ..., g_{m}) (x_{1}, ..., x_{n}) \\rightarrow (g_{1}, ..., g_{m}) f(g): (g_{1}, ..., g_{m}) \\rightarrow (f_{1}, ..., f_{k}) (g_{1}, ..., g_{m}) \\rightarrow (f_{1}, ..., f_{k}) this will be useful for RNN h(x) = f(g(x)): (x_{1}, ..., x_{n}) \\rightarrow (h_{1}, ..., h_{k}) = (f_{1}, ..., f_{k}) (x_{1}, ..., x_{n}) \\rightarrow (h_{1}, ..., h_{k}) = (f_{1}, ..., f_{k}) The matrix of partial derivatives \\frac{\\partial h_{i}}{\\partial x_{j}} \\frac{\\partial h_{i}}{\\partial x_{j}} is called the Jacobian \\begin{aligned} & J^{h} = \\begin{pmatrix} \\frac{\\partial h_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{1}}{\\partial x_{n}}\\\\ \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial h_{k}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{k}}{\\partial x_{n}} \\end{pmatrix} \\\\ & J_{i, j}^{h} = \\frac{\\partial h_{i}}{\\partial x_{j}} = \\sum_{l}\\frac{\\partial f_{i}}{\\partial g_{l}}\\frac{\\partial g_{l}}{\\partial x_{j}} = \\sum_{l}J_{i, l}^{f} \\cdot J_{l, j}^{g} \\\\ & J^{h} = J^{f} \\cdot J^{g} \\end{aligned} \\begin{aligned} & J^{h} = \\begin{pmatrix} \\frac{\\partial h_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{1}}{\\partial x_{n}}\\\\ \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial h_{k}}{\\partial x_{1}} & \\cdots & \\frac{\\partial h_{k}}{\\partial x_{n}} \\end{pmatrix} \\\\ & J_{i, j}^{h} = \\frac{\\partial h_{i}}{\\partial x_{j}} = \\sum_{l}\\frac{\\partial f_{i}}{\\partial g_{l}}\\frac{\\partial g_{l}}{\\partial x_{j}} = \\sum_{l}J_{i, l}^{f} \\cdot J_{l, j}^{g} \\\\ & J^{h} = J^{f} \\cdot J^{g} \\end{aligned}","title":"Jacobin"},{"location":"machine-learning/mlp/#_4","text":"\\begin{aligned} & \\begin{aligned} C &= AB \\\\ &= \\begin{pmatrix} a_{1, 1} & a_{1, 2}\\\\ a_{2, 1} & a_{2, 2} \\end{pmatrix} \\cdot \\begin{pmatrix} b_{1, 1} & b_{1, 2}\\\\ b_{2, 1} & b_{2, 2} \\end{pmatrix} \\\\ &= \\begin{pmatrix} a_{1, 1}b_{1, 1}+a_{1, 2}b_{2, 1} & a_{1, 1}b_{1, 2}+a_{1, 2}b_{2, 2}\\\\ a_{2, 1}b_{1, 1}+a_{2, 2}b_{2, 1} & a_{2, 1}b_{1, 2}+a_{2, 2}b_{2, 2} \\end{pmatrix} \\end{aligned} \\end{aligned} \\begin{aligned} & \\begin{aligned} C &= AB \\\\ &= \\begin{pmatrix} a_{1, 1} & a_{1, 2}\\\\ a_{2, 1} & a_{2, 2} \\end{pmatrix} \\cdot \\begin{pmatrix} b_{1, 1} & b_{1, 2}\\\\ b_{2, 1} & b_{2, 2} \\end{pmatrix} \\\\ &= \\begin{pmatrix} a_{1, 1}b_{1, 1}+a_{1, 2}b_{2, 1} & a_{1, 1}b_{1, 2}+a_{1, 2}b_{2, 2}\\\\ a_{2, 1}b_{1, 1}+a_{2, 2}b_{2, 1} & a_{2, 1}b_{1, 2}+a_{2, 2}b_{2, 2} \\end{pmatrix} \\end{aligned} \\end{aligned} \\begin{aligned} \\frac{\\partial C}{\\partial A} &= \\{ \\frac{\\partial c_{i, j}}{\\partial a_{k, l}} \\}_{i, j, k, l} \\\\ &= \\begin{pmatrix} \\frac{\\partial c_{1, 1}}{\\partial A} & \\frac{\\partial c_{1, 2}}{\\partial A}\\\\ \\frac{\\partial c_{2, 1}}{\\partial A} & \\frac{\\partial c_{2, 2}}{\\partial A} \\end{pmatrix} \\\\ &= \\begin{pmatrix} \\begin{bmatrix} b_{1, 1} & b_{2, 1}\\\\ 0 & 0 \\end{bmatrix} & \\begin{bmatrix} b_{1, 2} & b_{2, 2}\\\\ 0 & 0 \\end{bmatrix}\\\\ \\begin{bmatrix} 0 & 0\\\\ b_{1, 1} & b_{2, 1} \\end{bmatrix} & \\begin{bmatrix} 0 & 0\\\\ b_{1, 2} & b_{2, 2} \\end{bmatrix} \\end{pmatrix} \\end{aligned} \\begin{aligned} \\frac{\\partial C}{\\partial A} &= \\{ \\frac{\\partial c_{i, j}}{\\partial a_{k, l}} \\}_{i, j, k, l} \\\\ &= \\begin{pmatrix} \\frac{\\partial c_{1, 1}}{\\partial A} & \\frac{\\partial c_{1, 2}}{\\partial A}\\\\ \\frac{\\partial c_{2, 1}}{\\partial A} & \\frac{\\partial c_{2, 2}}{\\partial A} \\end{pmatrix} \\\\ &= \\begin{pmatrix} \\begin{bmatrix} b_{1, 1} & b_{2, 1}\\\\ 0 & 0 \\end{bmatrix} & \\begin{bmatrix} b_{1, 2} & b_{2, 2}\\\\ 0 & 0 \\end{bmatrix}\\\\ \\begin{bmatrix} 0 & 0\\\\ b_{1, 1} & b_{2, 1} \\end{bmatrix} & \\begin{bmatrix} 0 & 0\\\\ b_{1, 2} & b_{2, 2} \\end{bmatrix} \\end{pmatrix} \\end{aligned} \u4e00\u4e2a 3-d \u5f20\u91cf\u5bf9 4-d \u5f20\u91cf\u5fae\u5206\u7684\u7ef4\u5ea6\uff08dimensions\uff09\u662f 7\u3002","title":"\u5f20\u91cf\u5fae\u5206"},{"location":"machine-learning/mlp/#_5","text":"\u65e0\u8bba\u4f55\u65f6\uff0c\u907f\u514d\u663e\u793afor\u5faa\u73af \\text{z = np.dot(w, x)} \\text{z = np.dot(w, x)} \\bigstar \\bigstar Broadcasting \\begin{aligned} & (m, n) + R = (m, n) \\\\ & (m, n) + (1, n) = (m, n) \\\\ & (m, n) + (m, 1) = (m, n) \\end{aligned} \\begin{aligned} & (m, n) + R = (m, n) \\\\ & (m, n) + (1, n) = (m, n) \\\\ & (m, n) + (m, 1) = (m, n) \\end{aligned} \u4f8b\u5982 \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100 & 200 & 300 \\end{bmatrix} = \\begin{bmatrix} 101 & 202 & 303\\\\ 104 & 205 & 306 \\end{bmatrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100 & 200 & 300 \\end{bmatrix} = \\begin{bmatrix} 101 & 202 & 303\\\\ 104 & 205 & 306 \\end{bmatrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100\\\\ 200 \\end{bmatrix} = \\begin{bmatrix} 101 & 102 & 103\\\\ 104 & 205 & 206 \\end{bmatrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{bmatrix} + \\begin{bmatrix} 100\\\\ 200 \\end{bmatrix} = \\begin{bmatrix} 101 & 102 & 103\\\\ 104 & 205 & 206 \\end{bmatrix}","title":"\u5411\u91cf\u5316"},{"location":"machine-learning/mlp/#gradient-checking","text":"\u5c06\u53c2\u6570\uff08 W^{[1]} W^{[1]} , b^{[1]} b^{[1]} , ..., W^{[L]} W^{[L]} , b^{[L]} b^{[L]} \uff09\u548c\u53c2\u6570\u7684\u5bfc\u6570\uff08 dW^{[1]} dW^{[1]} , db^{[1]} db^{[1]} , ..., dW^{[L]} dW^{[L]} , db^{[L]} db^{[L]} \uff09\u53d6\u51fa\u5e76\u5f62\u6210\u65b0\u7684\u5411\u91cf \\theta \\theta \u548c d\\theta d\\theta J(\\theta) = J(\\theta_{1}, \\theta_{2}, ..., \\theta_{n}) J(\\theta) = J(\\theta_{1}, \\theta_{2}, ..., \\theta_{n}) \u5bf9\u6bcf\u4e00\u4e2a\u53c2\u6570 \\theta_{i} \\theta_{i} \uff0c\u6211\u4eec\u68c0\u67e5 d\\theta_{i}^{\\text{approx}} = \\frac{J(\\theta_{1}, ..., \\theta_{i} + \\epsilon, ..., \\theta_{n})-J(\\theta_{1}, ..., \\theta_{i} - \\epsilon, ..., \\theta_{n})}{2\\epsilon} \\approx d\\theta_{i} d\\theta_{i}^{\\text{approx}} = \\frac{J(\\theta_{1}, ..., \\theta_{i} + \\epsilon, ..., \\theta_{n})-J(\\theta_{1}, ..., \\theta_{i} - \\epsilon, ..., \\theta_{n})}{2\\epsilon} \\approx d\\theta_{i} \u53e6\u4e00\u79cd\u5f62\u5f0f \\frac{\\left \\| d\\theta_{i}^{\\text{approx}} - d\\theta_{i} \\right \\|_{2}}{\\left \\| d\\theta_{i}^{\\text{approx}} \\right \\|_{2} + \\left \\| d\\theta_{i} \\right \\|_{2}} < 10^{-7} \\frac{\\left \\| d\\theta_{i}^{\\text{approx}} - d\\theta_{i} \\right \\|_{2}}{\\left \\| d\\theta_{i}^{\\text{approx}} \\right \\|_{2} + \\left \\| d\\theta_{i} \\right \\|_{2}} < 10^{-7} \\bigstar \\bigstar \u4ec5\u7528\u4f5c debug\uff0c\u4e0d\u7528\u5728\u8bad\u7ec3\u9636\u6bb5\u4f7f\u7528","title":"Gradient checking"},{"location":"machine-learning/normalization/","text":"Batch Normalization \u00b6 \\bigstar \\bigstar BN \u4fee\u6b63\u8f93\u5165\u7684\u504f\u79fb\uff08internal covariate shift\uff09 \\bigstar \\bigstar BN \u5728\u6fc0\u6d3b\u51fd\u6570\u4e4b\u524d\u63a7\u5236\u8f93\u51fa\u7684\u5747\u503c\u548c\u65b9\u5dee \\bigstar \\bigstar BN \u8d77\u5230\u6b63\u5219\u5316\u4f5c\u7528\u7684\u539f\u56e0\u662f\uff0c\u6bcf\u4e00\u6279\u6b21\u7684\u6570\u636e\u6839\u636e\u5747\u503c\u548c\u65b9\u5dee\u88ab\u7f29\u653e\uff0c\u8fd9\u76f8\u5f53\u4e8e\u7ed9 Z^{[l]} Z^{[l]} \u589e\u52a0\u4e86\u566a\u97f3\u3002 h_{i} = \\gamma_{i} \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} + \\beta_{i}, \\quad \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} \\in \\mathcal{N}(0,1) h_{i} = \\gamma_{i} \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} + \\beta_{i}, \\quad \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} \\in \\mathcal{N}(0,1) \\mu_{i} \\mu_{i} \u548c \\sigma^{2} \\sigma^{2} \u4ece\u5f53\u524d\u6279\u6b21\u7684\u6570\u636e\u83b7\u5f97\u3002\u6d4b\u8bd5\u9636\u6bb5\u4f7f\u7528\u7684\u5747\u503c\u548c\u65b9\u5dee\u662f\u8bad\u7ec3\u9636\u6bb5\u7684\u6307\u6570\u6ed1\u52a8\u5e73\u5747\u3002\u5f52\u4e00\u5316\u8f93\u5165\u6709\u5229\u4e8e\u52a0\u901f\u5b66\u4e60\uff0c\u4f8b\u5982\uff0c\u5f52\u4e00\u5316 a^{[2]} a^{[2]} \u53ef\u4ee5\u4f7f w^{[3]} w^{[3]} , b^{[3]} b^{[3]} \u66f4\u5feb\u6536\u655b\u3002 \\begin{aligned} & \\mu = \\frac{1}{m} \\sum_{i}^{m} Z^{[l](i)}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (Z^{[l](i)} - \\mu)^{2} \\\\ & Z_{\\text{norm}}^{(i)} = \\frac{Z^{[l](i)} - \\mu}{\\sqrt{\\sigma^{2} + \\epsilon}} \\end{aligned} \\begin{aligned} & \\mu = \\frac{1}{m} \\sum_{i}^{m} Z^{[l](i)}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (Z^{[l](i)} - \\mu)^{2} \\\\ & Z_{\\text{norm}}^{(i)} = \\frac{Z^{[l](i)} - \\mu}{\\sqrt{\\sigma^{2} + \\epsilon}} \\end{aligned} \u4f46\u662f\uff0c\u9690\u5c42\u5355\u5143\u5e76\u4e0d\u603b\u662f\u6b63\u6001\u5206\u5e03\uff0c \\gamma_{i} \\gamma_{i} \u548c \\beta_{i} \\beta_{i} \u662f\u5b66\u4e60\u7684\u53c2\u6570\uff0c\u8d1f\u8d23\u5bf9\u77eb\u6b63\u6bcf\u4e00\u5c42\u7684\u8f93\u5165\u5206\u5e03\u3002 \\widetilde{Z}^{[l](i)} = \\gamma Z_{\\text{norm}}^{[l](i)} + \\beta \\widetilde{Z}^{[l](i)} = \\gamma Z_{\\text{norm}}^{[l](i)} + \\beta \\begin{aligned} & 0 < \\alpha < 1 \\\\ & \\mu_{i} = \\alpha \\cdot \\text{mean}_{batch} + (1-\\alpha)\\mu_{i} \\\\ & \\sigma_{i}^{2} = \\alpha \\cdot \\text{variance}_{batch} + (1-\\alpha)\\sigma_{i}^{2} \\end{aligned} \\begin{aligned} & 0 < \\alpha < 1 \\\\ & \\mu_{i} = \\alpha \\cdot \\text{mean}_{batch} + (1-\\alpha)\\mu_{i} \\\\ & \\sigma_{i}^{2} = \\alpha \\cdot \\text{variance}_{batch} + (1-\\alpha)\\sigma_{i}^{2} \\end{aligned} \u53cd\u5411\u4f20\u64ad \\gamma^{[l]} = \\gamma^{[l]} - \\alpha d\\gamma^{[l]}, \\quad \\beta^{[l]} = \\beta^{[l]} - \\alpha d \\beta^{[l]} \\gamma^{[l]} = \\gamma^{[l]} - \\alpha d\\gamma^{[l]}, \\quad \\beta^{[l]} = \\beta^{[l]} - \\alpha d \\beta^{[l]} \u5728\u795e\u7ecf\u7f51\u7edc\u52a0 BN \u5c42 Layer Normalization \u00b6 LN \u7c7b\u4f3c\u4e8e BN \u90fd\u662f\u5bf9\u8f93\u5165\u6570\u636e\u505a\u5f52\u4e00\u5316\u64cd\u4f5c\uff0c\u4e0d\u540c\u70b9\u5728\u4e8e\uff0cBN \u662f\u5bf9\u540c\u4e00\u7279\u5f81\u4e0b\u7684\u4e00\u6279\u6570\u636e\uff0c\u800c LN \u662f\u540c\u4e00\u6761\u6570\u636e\u4e0b\u4e0d\u540c\u7279\u5f81\u505a\u5f52\u4e00\u5316\u3002 Normalizing inputs \u00b6 \u5f52\u4e00\u5316\u8f93\u5165\u6709\u5229\u4e8e\u68af\u5ea6\u4e0b\u964d\uff0c\u635f\u5931\u51fd\u6570\u66f4\u5feb\u6536\u655b \\begin{aligned} & X = \\frac{X - \\mu}{\\sigma} \\\\ & \\mu = \\frac{1}{m} \\sum_{i=1}^{m} x^{i}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (x^{i} - \\mu)^{2} \\end{aligned} \\begin{aligned} & X = \\frac{X - \\mu}{\\sigma} \\\\ & \\mu = \\frac{1}{m} \\sum_{i=1}^{m} x^{i}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (x^{i} - \\mu)^{2} \\end{aligned} \u5047\u8bbe\u8f93\u5165\u7684\u662f\u4e00\u5f20\u56fe\u7247\uff0c\u50cf\u7d20\u503c\u5f52\u4e00\u5316\u540e x_{norm} = \\frac{x}{255} - 0.5 x_{norm} = \\frac{x}{255} - 0.5","title":"\u5f52\u4e00\u5316"},{"location":"machine-learning/normalization/#batch-normalization","text":"\\bigstar \\bigstar BN \u4fee\u6b63\u8f93\u5165\u7684\u504f\u79fb\uff08internal covariate shift\uff09 \\bigstar \\bigstar BN \u5728\u6fc0\u6d3b\u51fd\u6570\u4e4b\u524d\u63a7\u5236\u8f93\u51fa\u7684\u5747\u503c\u548c\u65b9\u5dee \\bigstar \\bigstar BN \u8d77\u5230\u6b63\u5219\u5316\u4f5c\u7528\u7684\u539f\u56e0\u662f\uff0c\u6bcf\u4e00\u6279\u6b21\u7684\u6570\u636e\u6839\u636e\u5747\u503c\u548c\u65b9\u5dee\u88ab\u7f29\u653e\uff0c\u8fd9\u76f8\u5f53\u4e8e\u7ed9 Z^{[l]} Z^{[l]} \u589e\u52a0\u4e86\u566a\u97f3\u3002 h_{i} = \\gamma_{i} \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} + \\beta_{i}, \\quad \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} \\in \\mathcal{N}(0,1) h_{i} = \\gamma_{i} \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} + \\beta_{i}, \\quad \\frac{h_{i}-\\mu_{i}}{\\sqrt{\\sigma^{2}}} \\in \\mathcal{N}(0,1) \\mu_{i} \\mu_{i} \u548c \\sigma^{2} \\sigma^{2} \u4ece\u5f53\u524d\u6279\u6b21\u7684\u6570\u636e\u83b7\u5f97\u3002\u6d4b\u8bd5\u9636\u6bb5\u4f7f\u7528\u7684\u5747\u503c\u548c\u65b9\u5dee\u662f\u8bad\u7ec3\u9636\u6bb5\u7684\u6307\u6570\u6ed1\u52a8\u5e73\u5747\u3002\u5f52\u4e00\u5316\u8f93\u5165\u6709\u5229\u4e8e\u52a0\u901f\u5b66\u4e60\uff0c\u4f8b\u5982\uff0c\u5f52\u4e00\u5316 a^{[2]} a^{[2]} \u53ef\u4ee5\u4f7f w^{[3]} w^{[3]} , b^{[3]} b^{[3]} \u66f4\u5feb\u6536\u655b\u3002 \\begin{aligned} & \\mu = \\frac{1}{m} \\sum_{i}^{m} Z^{[l](i)}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (Z^{[l](i)} - \\mu)^{2} \\\\ & Z_{\\text{norm}}^{(i)} = \\frac{Z^{[l](i)} - \\mu}{\\sqrt{\\sigma^{2} + \\epsilon}} \\end{aligned} \\begin{aligned} & \\mu = \\frac{1}{m} \\sum_{i}^{m} Z^{[l](i)}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (Z^{[l](i)} - \\mu)^{2} \\\\ & Z_{\\text{norm}}^{(i)} = \\frac{Z^{[l](i)} - \\mu}{\\sqrt{\\sigma^{2} + \\epsilon}} \\end{aligned} \u4f46\u662f\uff0c\u9690\u5c42\u5355\u5143\u5e76\u4e0d\u603b\u662f\u6b63\u6001\u5206\u5e03\uff0c \\gamma_{i} \\gamma_{i} \u548c \\beta_{i} \\beta_{i} \u662f\u5b66\u4e60\u7684\u53c2\u6570\uff0c\u8d1f\u8d23\u5bf9\u77eb\u6b63\u6bcf\u4e00\u5c42\u7684\u8f93\u5165\u5206\u5e03\u3002 \\widetilde{Z}^{[l](i)} = \\gamma Z_{\\text{norm}}^{[l](i)} + \\beta \\widetilde{Z}^{[l](i)} = \\gamma Z_{\\text{norm}}^{[l](i)} + \\beta \\begin{aligned} & 0 < \\alpha < 1 \\\\ & \\mu_{i} = \\alpha \\cdot \\text{mean}_{batch} + (1-\\alpha)\\mu_{i} \\\\ & \\sigma_{i}^{2} = \\alpha \\cdot \\text{variance}_{batch} + (1-\\alpha)\\sigma_{i}^{2} \\end{aligned} \\begin{aligned} & 0 < \\alpha < 1 \\\\ & \\mu_{i} = \\alpha \\cdot \\text{mean}_{batch} + (1-\\alpha)\\mu_{i} \\\\ & \\sigma_{i}^{2} = \\alpha \\cdot \\text{variance}_{batch} + (1-\\alpha)\\sigma_{i}^{2} \\end{aligned} \u53cd\u5411\u4f20\u64ad \\gamma^{[l]} = \\gamma^{[l]} - \\alpha d\\gamma^{[l]}, \\quad \\beta^{[l]} = \\beta^{[l]} - \\alpha d \\beta^{[l]} \\gamma^{[l]} = \\gamma^{[l]} - \\alpha d\\gamma^{[l]}, \\quad \\beta^{[l]} = \\beta^{[l]} - \\alpha d \\beta^{[l]} \u5728\u795e\u7ecf\u7f51\u7edc\u52a0 BN \u5c42","title":"Batch Normalization"},{"location":"machine-learning/normalization/#layer-normalization","text":"LN \u7c7b\u4f3c\u4e8e BN \u90fd\u662f\u5bf9\u8f93\u5165\u6570\u636e\u505a\u5f52\u4e00\u5316\u64cd\u4f5c\uff0c\u4e0d\u540c\u70b9\u5728\u4e8e\uff0cBN \u662f\u5bf9\u540c\u4e00\u7279\u5f81\u4e0b\u7684\u4e00\u6279\u6570\u636e\uff0c\u800c LN \u662f\u540c\u4e00\u6761\u6570\u636e\u4e0b\u4e0d\u540c\u7279\u5f81\u505a\u5f52\u4e00\u5316\u3002","title":"Layer Normalization"},{"location":"machine-learning/normalization/#normalizing-inputs","text":"\u5f52\u4e00\u5316\u8f93\u5165\u6709\u5229\u4e8e\u68af\u5ea6\u4e0b\u964d\uff0c\u635f\u5931\u51fd\u6570\u66f4\u5feb\u6536\u655b \\begin{aligned} & X = \\frac{X - \\mu}{\\sigma} \\\\ & \\mu = \\frac{1}{m} \\sum_{i=1}^{m} x^{i}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (x^{i} - \\mu)^{2} \\end{aligned} \\begin{aligned} & X = \\frac{X - \\mu}{\\sigma} \\\\ & \\mu = \\frac{1}{m} \\sum_{i=1}^{m} x^{i}, \\quad \\sigma^{2} = \\frac{1}{m} \\sum_{i=1}^{m} (x^{i} - \\mu)^{2} \\end{aligned} \u5047\u8bbe\u8f93\u5165\u7684\u662f\u4e00\u5f20\u56fe\u7247\uff0c\u50cf\u7d20\u503c\u5f52\u4e00\u5316\u540e x_{norm} = \\frac{x}{255} - 0.5 x_{norm} = \\frac{x}{255} - 0.5","title":"Normalizing inputs"},{"location":"machine-learning/optimization/","text":"\u68af\u5ea6\u4e0b\u964d \u00b6 \u4f18\u5316\u95ee\u9898\uff1a L(w)\\rightarrow \\min_{w} L(w)\\rightarrow \\min_{w} \uff0c\u521d\u59cb\u5316\u53c2\u6570\uff1a w^{0} w^{0} \u3002\u68af\u5ea6\u5411\u91cf\uff1a \\nabla L(w^{0})=(\\frac{\\partial L(w^{0})}{\\partial w_{1}}, \\frac{\\partial L(w^{0})}{\\partial w_{2}}, ..., \\frac{\\partial L(w^{0})}{\\partial w_{n}}) \\nabla L(w^{0})=(\\frac{\\partial L(w^{0})}{\\partial w_{1}}, \\frac{\\partial L(w^{0})}{\\partial w_{2}}, ..., \\frac{\\partial L(w^{0})}{\\partial w_{n}}) \u53c2\u6570\u66f4\u65b0 w^{t+1} = w^{t} - \\eta_{t}\\nabla L(w^{t}) w^{t+1} = w^{t} - \\eta_{t}\\nabla L(w^{t}) \u6536\u655b\u65f6\u505c\u6b62\u66f4\u65b0\uff1a \\left \\| w^{t+1}-w^{t} \\right \\| < \\epsilon \\left \\| w^{t+1}-w^{t} \\right \\| < \\epsilon \u68af\u5ea6\u4e0b\u964d\u4e00\u6b21\u8ba1\u7b97\u5168\u90e8\u7684\u6837\u672c\uff0c\u4f46\u5185\u5b58\u6709\u4e00\u5b9a\u5141\u8bb8\uff0c\u8fd9\u65f6\u4f7f\u7528 \u968f\u673a\u68af\u5ea6\u4e0b\u964d\uff08SGD\uff09 \u66f4\u65b0\u3002 L(w) = \\sum_{i=1}^{n}L(w; x_{i}, y_{i}) \\rightarrow \\min_{w} L(w) = \\sum_{i=1}^{n}L(w; x_{i}, y_{i}) \\rightarrow \\min_{w} i_{1}, i_{2}, ..., i_{m} i_{1}, i_{2}, ..., i_{m} = random indice between 1 ~ n g_{t} = \\frac{1}{m}\\sum_{j=1}^{m}\\nabla L(w^{t};x_{i_{j}},y_{i_{j}}) g_{t} = \\frac{1}{m}\\sum_{j=1}^{m}\\nabla L(w^{t};x_{i_{j}},y_{i_{j}}) w^{t+1} = w^{t} - \\eta_{t}g_{t} w^{t+1} = w^{t} - \\eta_{t}g_{t} if \\left\\| w^{t+1}-w^{t} \\right\\| \\leq \\epsilon \\left\\| w^{t+1}-w^{t} \\right\\| \\leq \\epsilon , finish \u6307\u6570\u52a0\u6743\u5e73\u5747 \u00b6 \u6307\u6570\u52a0\u6743\u5e73\u5747\uff08Exponentially Weighted Averages\uff09\u662f\u4e00\u79cd\u6570\u636e\u5e73\u6ed1\u7684\u65b9\u6cd5\u3002\u516c\u5f0f\u5982\u4e0b\uff1a \\begin{aligned} V_{t} &= \\beta V_{t-1} + (1 - \\beta) \\theta_{t} \\\\ &= \\beta^{t} V_{0} + \\sum_{k = 1}^{t} \\beta^{t - k} (1 - \\beta) \\theta_{k} \\end{aligned} \\begin{aligned} V_{t} &= \\beta V_{t-1} + (1 - \\beta) \\theta_{t} \\\\ &= \\beta^{t} V_{0} + \\sum_{k = 1}^{t} \\beta^{t - k} (1 - \\beta) \\theta_{k} \\end{aligned} \u4f8b\u5982\uff0c\u67d0\u5730\u7684\u6e29\u5ea6\u53d8\u5316 \\begin{aligned} & \\theta_{1} = 40^{\\circ}\\text{F} \\\\ & \\theta_{2} = 49^{\\circ}\\text{F} \\\\ & \\theta_{3} = 45^{\\circ}\\text{F} \\\\ & \\vdots\\\\ & \\theta_{180} = 60^{\\circ}\\text{F} \\\\ & \\theta_{181} = 56^{\\circ}\\text{F} \\\\ & \\vdots \\end{aligned} \\begin{aligned} & \\theta_{1} = 40^{\\circ}\\text{F} \\\\ & \\theta_{2} = 49^{\\circ}\\text{F} \\\\ & \\theta_{3} = 45^{\\circ}\\text{F} \\\\ & \\vdots\\\\ & \\theta_{180} = 60^{\\circ}\\text{F} \\\\ & \\theta_{181} = 56^{\\circ}\\text{F} \\\\ & \\vdots \\end{aligned} \u6211\u4eec\u53ef\u4ee5\u8ba1\u7b97\u8fd9\u4e00\u6bb5\u65f6\u95f4\u7684\u6ed1\u52a8\u5e73\u5747\u503c\uff0c\u7528\u53c2\u6570 \\beta \\beta = 0.9 \\begin{aligned} & V_{0} = 0 \\\\ & V_{1} = \\beta V_{0} + (1 - \\beta) \\theta_{1} = 0.9 \\cdot 0 + 0.1 \\cdot 40 = 4 \\\\ & V_{2} = \\beta V_{1} + (1 - \\beta) \\theta_{2} = 0.9 \\cdot 4 + 0.1 \\cdot 49 = 8.5 \\\\ & V_{3} = \\beta V_{2} + (1 - \\beta) \\theta_{3} = 0.9 \\cdot 8.5 + 0.1 \\cdot 45 = 12.15 \\\\ & \\vdots \\end{aligned} \\begin{aligned} & V_{0} = 0 \\\\ & V_{1} = \\beta V_{0} + (1 - \\beta) \\theta_{1} = 0.9 \\cdot 0 + 0.1 \\cdot 40 = 4 \\\\ & V_{2} = \\beta V_{1} + (1 - \\beta) \\theta_{2} = 0.9 \\cdot 4 + 0.1 \\cdot 49 = 8.5 \\\\ & V_{3} = \\beta V_{2} + (1 - \\beta) \\theta_{3} = 0.9 \\cdot 8.5 + 0.1 \\cdot 45 = 12.15 \\\\ & \\vdots \\end{aligned} V_{t} V_{t} \u662f \\frac{1}{1 - \\beta} \\frac{1}{1 - \\beta} \u5929\u5185\u7684\u6ed1\u52a8\u5e73\u5747\u503c\uff0c\u4f8b\u5982\uff0c \\beta \\beta = 0.9\uff0c \\frac{1}{1 - \\beta} = \\frac{1}{1 - 0.98} = 50 \\frac{1}{1 - \\beta} = \\frac{1}{1 - 0.98} = 50 \u3002 \u5982\u679c\u589e\u5927 \\beta \\beta \uff0c\u6ed1\u52a8\u5e73\u5747\u503c\u66f2\u7ebf\u5411\u53f3\u504f\u79fb\uff1b\u51cf\u5c0f \\beta \\beta \uff0c\u66f2\u7ebf\u5c06\u4f1a\u66f4\u52a0\u9707\u8361\u3002 \u56e0\u4e3a\u5728\u771f\u5b9e\u503c\u548c\u6ed1\u52a8\u5e73\u5747\u503c\u4e4b\u95f4\u5b58\u5728\u504f\u5dee\uff0c\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u4fee\u6b63 \\frac{V_{t}}{1 - \\beta^{t}} \\frac{V_{t}}{1 - \\beta^{t}} Momentum \u00b6 \\bigstar \\bigstar \u52a8\u91cf\u6cd5\u7528\u6765\u6d88\u9664\u9707\u8361 \\bigstar \\bigstar \\beta \\beta \u901a\u5e38\u662f 0.9. \\bigstar \\bigstar \u5728\u6bcf\u4e00\u4e2amini-batch\u4e0b\uff0c\u6211\u4eec\u8ba1\u7b97 dW \u548c db\uff0c\u4e4b\u540e\u8ba1\u7b97\u6307\u6570\u6ed1\u52a8\u5e73\u5747\uff0c\u5e76\u66f4\u65b0 W \u548c b\u3002 \\begin{aligned} & V_{dW} = \\beta V_{dW} + (1 - \\beta) dW \\\\ & V_{db} = \\beta V_{db} + (1 - \\beta) db \\\\ & W = W - \\alpha V_{dW} \\\\ & b = b - \\alpha V_{db} \\end{aligned} \\begin{aligned} & V_{dW} = \\beta V_{dW} + (1 - \\beta) dW \\\\ & V_{db} = \\beta V_{db} + (1 - \\beta) db \\\\ & W = W - \\alpha V_{dW} \\\\ & b = b - \\alpha V_{db} \\end{aligned} RMSProp \u00b6 \\bigstar \\bigstar RMSprop: Root Mean Square Propogation \\begin{aligned} & S_{dW} = \\beta S_{dW} + (1 - \\beta) (dW)^{2} \\quad \\text{where } (dW)^{2} \\text{ are element-wise square} \\\\ & S_{db} = \\beta S_{db} + (1 - \\beta) (db)^{2} \\quad \\text{where } (db)^{2} \\text{ are element-wise square} \\\\ & W = W - \\alpha \\frac{dW}{\\sqrt{S_{dW}} + \\epsilon} \\\\ & b = b - \\alpha \\frac{db}{\\sqrt{S_{db}} + \\epsilon} \\end{aligned} \\begin{aligned} & S_{dW} = \\beta S_{dW} + (1 - \\beta) (dW)^{2} \\quad \\text{where } (dW)^{2} \\text{ are element-wise square} \\\\ & S_{db} = \\beta S_{db} + (1 - \\beta) (db)^{2} \\quad \\text{where } (db)^{2} \\text{ are element-wise square} \\\\ & W = W - \\alpha \\frac{dW}{\\sqrt{S_{dW}} + \\epsilon} \\\\ & b = b - \\alpha \\frac{db}{\\sqrt{S_{db}} + \\epsilon} \\end{aligned} Adam \u00b6 \\bigstar \\bigstar Adam \u662f Momentum \u548c RMSprop \u7684\u7ed3\u5408 \\bigstar \\bigstar \\beta_{1} \\beta_{1} \u662f 0.9\uff0c \\beta_{2} \\beta_{2} \u53d6 0.999\uff0c \\epsilon \\epsilon \u53d6 10^{-8} 10^{-8} \\begin{aligned} & V_{dW} = 0, \\quad S_{dW} = 0, \\quad V_{db} = 0, \\quad S_{db} = 0 \\\\ & V_{dW} = \\beta_{1} V_{dW} + (1 - \\beta_{1}) dW, \\quad V_{db} = \\beta_{1} V_{db} + (1 - \\beta_{1}) db \\\\ & S_{dW} = \\beta_{2} S_{dW} + (1 - \\beta_{2}) (dW)^{2}, \\quad S_{db} = \\beta_{2} S_{db} + (1 - \\beta_{2}) (db)^{2} \\\\ & V_{dW}^{\\text{corrected}} = \\frac{V_{dW}}{1 - \\beta_{1}^{t}}, \\quad V_{db}^{\\text{corrected}} = \\frac{V_{db}}{1 - \\beta_{1}^{t}} \\\\ & S_{dW}^{\\text{corrected}} = \\frac{S_{dW}}{1 - \\beta_{2}^{t}}, \\quad S_{db}^{\\text{corrected}} = \\frac{S_{db}}{1 - \\beta_{2}^{t}} \\\\ & W = W - \\alpha \\frac{V_{dW}^{\\text{corrected}}}{\\sqrt{S_{dW}^{\\text{corrected}}}+\\epsilon}, \\quad b = b - \\alpha \\frac{V_{db}^{\\text{corrected}}}{\\sqrt{S_{db}^{\\text{corrected}}}+\\epsilon} \\end{aligned} \\begin{aligned} & V_{dW} = 0, \\quad S_{dW} = 0, \\quad V_{db} = 0, \\quad S_{db} = 0 \\\\ & V_{dW} = \\beta_{1} V_{dW} + (1 - \\beta_{1}) dW, \\quad V_{db} = \\beta_{1} V_{db} + (1 - \\beta_{1}) db \\\\ & S_{dW} = \\beta_{2} S_{dW} + (1 - \\beta_{2}) (dW)^{2}, \\quad S_{db} = \\beta_{2} S_{db} + (1 - \\beta_{2}) (db)^{2} \\\\ & V_{dW}^{\\text{corrected}} = \\frac{V_{dW}}{1 - \\beta_{1}^{t}}, \\quad V_{db}^{\\text{corrected}} = \\frac{V_{db}}{1 - \\beta_{1}^{t}} \\\\ & S_{dW}^{\\text{corrected}} = \\frac{S_{dW}}{1 - \\beta_{2}^{t}}, \\quad S_{db}^{\\text{corrected}} = \\frac{S_{db}}{1 - \\beta_{2}^{t}} \\\\ & W = W - \\alpha \\frac{V_{dW}^{\\text{corrected}}}{\\sqrt{S_{dW}^{\\text{corrected}}}+\\epsilon}, \\quad b = b - \\alpha \\frac{V_{db}^{\\text{corrected}}}{\\sqrt{S_{db}^{\\text{corrected}}}+\\epsilon} \\end{aligned} \u5b66\u4e60\u7387\u8870\u51cf \u00b6 \\begin{aligned} & \\alpha = \\frac{\\alpha_{0}}{ 1 + \\text{DecayRate} * \\text{EpochNumber}} \\\\ & \\alpha =\\alpha_{0}\\cdot \\text{DecayRate}^{\\text{EpochNumber}} \\\\ & \\alpha = \\frac{k}{\\sqrt{\\text{EpochNumber}}} \\cdot \\alpha_{0} \\end{aligned} \\begin{aligned} & \\alpha = \\frac{\\alpha_{0}}{ 1 + \\text{DecayRate} * \\text{EpochNumber}} \\\\ & \\alpha =\\alpha_{0}\\cdot \\text{DecayRate}^{\\text{EpochNumber}} \\\\ & \\alpha = \\frac{k}{\\sqrt{\\text{EpochNumber}}} \\cdot \\alpha_{0} \\end{aligned}","title":"\u4f18\u5316"},{"location":"machine-learning/optimization/#_1","text":"\u4f18\u5316\u95ee\u9898\uff1a L(w)\\rightarrow \\min_{w} L(w)\\rightarrow \\min_{w} \uff0c\u521d\u59cb\u5316\u53c2\u6570\uff1a w^{0} w^{0} \u3002\u68af\u5ea6\u5411\u91cf\uff1a \\nabla L(w^{0})=(\\frac{\\partial L(w^{0})}{\\partial w_{1}}, \\frac{\\partial L(w^{0})}{\\partial w_{2}}, ..., \\frac{\\partial L(w^{0})}{\\partial w_{n}}) \\nabla L(w^{0})=(\\frac{\\partial L(w^{0})}{\\partial w_{1}}, \\frac{\\partial L(w^{0})}{\\partial w_{2}}, ..., \\frac{\\partial L(w^{0})}{\\partial w_{n}}) \u53c2\u6570\u66f4\u65b0 w^{t+1} = w^{t} - \\eta_{t}\\nabla L(w^{t}) w^{t+1} = w^{t} - \\eta_{t}\\nabla L(w^{t}) \u6536\u655b\u65f6\u505c\u6b62\u66f4\u65b0\uff1a \\left \\| w^{t+1}-w^{t} \\right \\| < \\epsilon \\left \\| w^{t+1}-w^{t} \\right \\| < \\epsilon \u68af\u5ea6\u4e0b\u964d\u4e00\u6b21\u8ba1\u7b97\u5168\u90e8\u7684\u6837\u672c\uff0c\u4f46\u5185\u5b58\u6709\u4e00\u5b9a\u5141\u8bb8\uff0c\u8fd9\u65f6\u4f7f\u7528 \u968f\u673a\u68af\u5ea6\u4e0b\u964d\uff08SGD\uff09 \u66f4\u65b0\u3002 L(w) = \\sum_{i=1}^{n}L(w; x_{i}, y_{i}) \\rightarrow \\min_{w} L(w) = \\sum_{i=1}^{n}L(w; x_{i}, y_{i}) \\rightarrow \\min_{w} i_{1}, i_{2}, ..., i_{m} i_{1}, i_{2}, ..., i_{m} = random indice between 1 ~ n g_{t} = \\frac{1}{m}\\sum_{j=1}^{m}\\nabla L(w^{t};x_{i_{j}},y_{i_{j}}) g_{t} = \\frac{1}{m}\\sum_{j=1}^{m}\\nabla L(w^{t};x_{i_{j}},y_{i_{j}}) w^{t+1} = w^{t} - \\eta_{t}g_{t} w^{t+1} = w^{t} - \\eta_{t}g_{t} if \\left\\| w^{t+1}-w^{t} \\right\\| \\leq \\epsilon \\left\\| w^{t+1}-w^{t} \\right\\| \\leq \\epsilon , finish","title":"\u68af\u5ea6\u4e0b\u964d"},{"location":"machine-learning/optimization/#_2","text":"\u6307\u6570\u52a0\u6743\u5e73\u5747\uff08Exponentially Weighted Averages\uff09\u662f\u4e00\u79cd\u6570\u636e\u5e73\u6ed1\u7684\u65b9\u6cd5\u3002\u516c\u5f0f\u5982\u4e0b\uff1a \\begin{aligned} V_{t} &= \\beta V_{t-1} + (1 - \\beta) \\theta_{t} \\\\ &= \\beta^{t} V_{0} + \\sum_{k = 1}^{t} \\beta^{t - k} (1 - \\beta) \\theta_{k} \\end{aligned} \\begin{aligned} V_{t} &= \\beta V_{t-1} + (1 - \\beta) \\theta_{t} \\\\ &= \\beta^{t} V_{0} + \\sum_{k = 1}^{t} \\beta^{t - k} (1 - \\beta) \\theta_{k} \\end{aligned} \u4f8b\u5982\uff0c\u67d0\u5730\u7684\u6e29\u5ea6\u53d8\u5316 \\begin{aligned} & \\theta_{1} = 40^{\\circ}\\text{F} \\\\ & \\theta_{2} = 49^{\\circ}\\text{F} \\\\ & \\theta_{3} = 45^{\\circ}\\text{F} \\\\ & \\vdots\\\\ & \\theta_{180} = 60^{\\circ}\\text{F} \\\\ & \\theta_{181} = 56^{\\circ}\\text{F} \\\\ & \\vdots \\end{aligned} \\begin{aligned} & \\theta_{1} = 40^{\\circ}\\text{F} \\\\ & \\theta_{2} = 49^{\\circ}\\text{F} \\\\ & \\theta_{3} = 45^{\\circ}\\text{F} \\\\ & \\vdots\\\\ & \\theta_{180} = 60^{\\circ}\\text{F} \\\\ & \\theta_{181} = 56^{\\circ}\\text{F} \\\\ & \\vdots \\end{aligned} \u6211\u4eec\u53ef\u4ee5\u8ba1\u7b97\u8fd9\u4e00\u6bb5\u65f6\u95f4\u7684\u6ed1\u52a8\u5e73\u5747\u503c\uff0c\u7528\u53c2\u6570 \\beta \\beta = 0.9 \\begin{aligned} & V_{0} = 0 \\\\ & V_{1} = \\beta V_{0} + (1 - \\beta) \\theta_{1} = 0.9 \\cdot 0 + 0.1 \\cdot 40 = 4 \\\\ & V_{2} = \\beta V_{1} + (1 - \\beta) \\theta_{2} = 0.9 \\cdot 4 + 0.1 \\cdot 49 = 8.5 \\\\ & V_{3} = \\beta V_{2} + (1 - \\beta) \\theta_{3} = 0.9 \\cdot 8.5 + 0.1 \\cdot 45 = 12.15 \\\\ & \\vdots \\end{aligned} \\begin{aligned} & V_{0} = 0 \\\\ & V_{1} = \\beta V_{0} + (1 - \\beta) \\theta_{1} = 0.9 \\cdot 0 + 0.1 \\cdot 40 = 4 \\\\ & V_{2} = \\beta V_{1} + (1 - \\beta) \\theta_{2} = 0.9 \\cdot 4 + 0.1 \\cdot 49 = 8.5 \\\\ & V_{3} = \\beta V_{2} + (1 - \\beta) \\theta_{3} = 0.9 \\cdot 8.5 + 0.1 \\cdot 45 = 12.15 \\\\ & \\vdots \\end{aligned} V_{t} V_{t} \u662f \\frac{1}{1 - \\beta} \\frac{1}{1 - \\beta} \u5929\u5185\u7684\u6ed1\u52a8\u5e73\u5747\u503c\uff0c\u4f8b\u5982\uff0c \\beta \\beta = 0.9\uff0c \\frac{1}{1 - \\beta} = \\frac{1}{1 - 0.98} = 50 \\frac{1}{1 - \\beta} = \\frac{1}{1 - 0.98} = 50 \u3002 \u5982\u679c\u589e\u5927 \\beta \\beta \uff0c\u6ed1\u52a8\u5e73\u5747\u503c\u66f2\u7ebf\u5411\u53f3\u504f\u79fb\uff1b\u51cf\u5c0f \\beta \\beta \uff0c\u66f2\u7ebf\u5c06\u4f1a\u66f4\u52a0\u9707\u8361\u3002 \u56e0\u4e3a\u5728\u771f\u5b9e\u503c\u548c\u6ed1\u52a8\u5e73\u5747\u503c\u4e4b\u95f4\u5b58\u5728\u504f\u5dee\uff0c\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u4fee\u6b63 \\frac{V_{t}}{1 - \\beta^{t}} \\frac{V_{t}}{1 - \\beta^{t}}","title":"\u6307\u6570\u52a0\u6743\u5e73\u5747"},{"location":"machine-learning/optimization/#momentum","text":"\\bigstar \\bigstar \u52a8\u91cf\u6cd5\u7528\u6765\u6d88\u9664\u9707\u8361 \\bigstar \\bigstar \\beta \\beta \u901a\u5e38\u662f 0.9. \\bigstar \\bigstar \u5728\u6bcf\u4e00\u4e2amini-batch\u4e0b\uff0c\u6211\u4eec\u8ba1\u7b97 dW \u548c db\uff0c\u4e4b\u540e\u8ba1\u7b97\u6307\u6570\u6ed1\u52a8\u5e73\u5747\uff0c\u5e76\u66f4\u65b0 W \u548c b\u3002 \\begin{aligned} & V_{dW} = \\beta V_{dW} + (1 - \\beta) dW \\\\ & V_{db} = \\beta V_{db} + (1 - \\beta) db \\\\ & W = W - \\alpha V_{dW} \\\\ & b = b - \\alpha V_{db} \\end{aligned} \\begin{aligned} & V_{dW} = \\beta V_{dW} + (1 - \\beta) dW \\\\ & V_{db} = \\beta V_{db} + (1 - \\beta) db \\\\ & W = W - \\alpha V_{dW} \\\\ & b = b - \\alpha V_{db} \\end{aligned}","title":"Momentum"},{"location":"machine-learning/optimization/#rmsprop","text":"\\bigstar \\bigstar RMSprop: Root Mean Square Propogation \\begin{aligned} & S_{dW} = \\beta S_{dW} + (1 - \\beta) (dW)^{2} \\quad \\text{where } (dW)^{2} \\text{ are element-wise square} \\\\ & S_{db} = \\beta S_{db} + (1 - \\beta) (db)^{2} \\quad \\text{where } (db)^{2} \\text{ are element-wise square} \\\\ & W = W - \\alpha \\frac{dW}{\\sqrt{S_{dW}} + \\epsilon} \\\\ & b = b - \\alpha \\frac{db}{\\sqrt{S_{db}} + \\epsilon} \\end{aligned} \\begin{aligned} & S_{dW} = \\beta S_{dW} + (1 - \\beta) (dW)^{2} \\quad \\text{where } (dW)^{2} \\text{ are element-wise square} \\\\ & S_{db} = \\beta S_{db} + (1 - \\beta) (db)^{2} \\quad \\text{where } (db)^{2} \\text{ are element-wise square} \\\\ & W = W - \\alpha \\frac{dW}{\\sqrt{S_{dW}} + \\epsilon} \\\\ & b = b - \\alpha \\frac{db}{\\sqrt{S_{db}} + \\epsilon} \\end{aligned}","title":"RMSProp"},{"location":"machine-learning/optimization/#adam","text":"\\bigstar \\bigstar Adam \u662f Momentum \u548c RMSprop \u7684\u7ed3\u5408 \\bigstar \\bigstar \\beta_{1} \\beta_{1} \u662f 0.9\uff0c \\beta_{2} \\beta_{2} \u53d6 0.999\uff0c \\epsilon \\epsilon \u53d6 10^{-8} 10^{-8} \\begin{aligned} & V_{dW} = 0, \\quad S_{dW} = 0, \\quad V_{db} = 0, \\quad S_{db} = 0 \\\\ & V_{dW} = \\beta_{1} V_{dW} + (1 - \\beta_{1}) dW, \\quad V_{db} = \\beta_{1} V_{db} + (1 - \\beta_{1}) db \\\\ & S_{dW} = \\beta_{2} S_{dW} + (1 - \\beta_{2}) (dW)^{2}, \\quad S_{db} = \\beta_{2} S_{db} + (1 - \\beta_{2}) (db)^{2} \\\\ & V_{dW}^{\\text{corrected}} = \\frac{V_{dW}}{1 - \\beta_{1}^{t}}, \\quad V_{db}^{\\text{corrected}} = \\frac{V_{db}}{1 - \\beta_{1}^{t}} \\\\ & S_{dW}^{\\text{corrected}} = \\frac{S_{dW}}{1 - \\beta_{2}^{t}}, \\quad S_{db}^{\\text{corrected}} = \\frac{S_{db}}{1 - \\beta_{2}^{t}} \\\\ & W = W - \\alpha \\frac{V_{dW}^{\\text{corrected}}}{\\sqrt{S_{dW}^{\\text{corrected}}}+\\epsilon}, \\quad b = b - \\alpha \\frac{V_{db}^{\\text{corrected}}}{\\sqrt{S_{db}^{\\text{corrected}}}+\\epsilon} \\end{aligned} \\begin{aligned} & V_{dW} = 0, \\quad S_{dW} = 0, \\quad V_{db} = 0, \\quad S_{db} = 0 \\\\ & V_{dW} = \\beta_{1} V_{dW} + (1 - \\beta_{1}) dW, \\quad V_{db} = \\beta_{1} V_{db} + (1 - \\beta_{1}) db \\\\ & S_{dW} = \\beta_{2} S_{dW} + (1 - \\beta_{2}) (dW)^{2}, \\quad S_{db} = \\beta_{2} S_{db} + (1 - \\beta_{2}) (db)^{2} \\\\ & V_{dW}^{\\text{corrected}} = \\frac{V_{dW}}{1 - \\beta_{1}^{t}}, \\quad V_{db}^{\\text{corrected}} = \\frac{V_{db}}{1 - \\beta_{1}^{t}} \\\\ & S_{dW}^{\\text{corrected}} = \\frac{S_{dW}}{1 - \\beta_{2}^{t}}, \\quad S_{db}^{\\text{corrected}} = \\frac{S_{db}}{1 - \\beta_{2}^{t}} \\\\ & W = W - \\alpha \\frac{V_{dW}^{\\text{corrected}}}{\\sqrt{S_{dW}^{\\text{corrected}}}+\\epsilon}, \\quad b = b - \\alpha \\frac{V_{db}^{\\text{corrected}}}{\\sqrt{S_{db}^{\\text{corrected}}}+\\epsilon} \\end{aligned}","title":"Adam"},{"location":"machine-learning/optimization/#_3","text":"\\begin{aligned} & \\alpha = \\frac{\\alpha_{0}}{ 1 + \\text{DecayRate} * \\text{EpochNumber}} \\\\ & \\alpha =\\alpha_{0}\\cdot \\text{DecayRate}^{\\text{EpochNumber}} \\\\ & \\alpha = \\frac{k}{\\sqrt{\\text{EpochNumber}}} \\cdot \\alpha_{0} \\end{aligned} \\begin{aligned} & \\alpha = \\frac{\\alpha_{0}}{ 1 + \\text{DecayRate} * \\text{EpochNumber}} \\\\ & \\alpha =\\alpha_{0}\\cdot \\text{DecayRate}^{\\text{EpochNumber}} \\\\ & \\alpha = \\frac{k}{\\sqrt{\\text{EpochNumber}}} \\cdot \\alpha_{0} \\end{aligned}","title":"\u5b66\u4e60\u7387\u8870\u51cf"},{"location":"machine-learning/perceptron/","text":"\u5b9a\u4e49 \u00b6 \u611f\u77e5\u673a\u662f\u4e00\u79cd\u5206\u7c7b\u6a21\u578b\u3002\u8f93\u5165\u7a7a\u95f4\u662f X = \\{x_{1}, x_{2}, ..., x_{n}\\} X = \\{x_{1}, x_{2}, ..., x_{n}\\} \uff0c\u8f93\u51fa\u7a7a\u95f4\u662f Y = \\{+1 , -1\\} Y = \\{+1 , -1\\} \u3002 \u5224\u522b\u51fd\u6570 \\begin{aligned} f(x_{i}) &= \\text{sign}(w \\cdot x_{i} + b) \\\\ &= \\begin{cases} 1, \\quad w \\cdot x_{i} + b \\geq 0 \\\\ -1, \\quad \\text{else} \\end{cases} \\end{aligned} \\begin{aligned} f(x_{i}) &= \\text{sign}(w \\cdot x_{i} + b) \\\\ &= \\begin{cases} 1, \\quad w \\cdot x_{i} + b \\geq 0 \\\\ -1, \\quad \\text{else} \\end{cases} \\end{aligned} W \\cdot X W \\cdot X \u4ee3\u8868\u7684\u662f\u70b9\u4e58 \u7b97\u6cd5 \u00b6 \u6570\u636e\u96c6 T = \\{(x_{1}, y_{1}), (x_{2}, y_{2}), ..., (x_{n}, y_{n})\\} \\{(x_{1}, y_{1}), (x_{2}, y_{2}), ..., (x_{n}, y_{n})\\} \uff0c\u5047\u8bbe\u4e00\u4e2a\u6570\u636e\u70b9 ( x_{i} x_{i} , y_{i} y_{i} ) \u88ab\u8bef\u5206\u7c7b\u4e86\u3002\u53ef\u4ee5\u7528\u5982\u4e0b\u65b9\u6cd5\u8868\u793a\uff1a y_{i} \\times f(x_{i}) = y_{i} \\times \\text{sign}(x_{i}) = -1 y_{i} \\times f(x_{i}) = y_{i} \\times \\text{sign}(x_{i}) = -1 \u6240\u6709\u88ab\u8bef\u5206\u7c7b\u7684\u70b9\u6784\u6210\u96c6\u5408 M\uff0c\u635f\u5931\u51fd\u6570\u4e3a L(w, b) = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i}(w \\cdot x_{i} + b) L(w, b) = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i}(w \\cdot x_{i} + b) \u53c2\u6570\u68af\u5ea6 \\begin{aligned} & \\frac{\\partial L(w, b)}{\\partial w} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} x_{i} \\\\ & \\frac{\\partial L(w, b)}{\\partial b} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} \\end{aligned} \\begin{aligned} & \\frac{\\partial L(w, b)}{\\partial w} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} x_{i} \\\\ & \\frac{\\partial L(w, b)}{\\partial b} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} \\end{aligned} \u53cd\u5411\u4f20\u64ad\uff0c\u5b66\u4e60\u7387 \\eta \\in (0, 1] \\eta \\in (0, 1] \\begin{matrix} & & \\begin{aligned} & w := w - \\eta \\frac{\\partial L(w, b)}{\\partial w} \\\\ & b := b - \\eta \\frac{\\partial L(w, b)}{\\partial b} \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w - \\eta (-y_{i} x_{i}) \\\\ & b := b - \\eta (-y_{i}) \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w + \\eta y_{i} x_{i} \\\\ & b := b + \\eta y_{i} \\end{aligned} & & \\end{matrix} \\begin{matrix} & & \\begin{aligned} & w := w - \\eta \\frac{\\partial L(w, b)}{\\partial w} \\\\ & b := b - \\eta \\frac{\\partial L(w, b)}{\\partial b} \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w - \\eta (-y_{i} x_{i}) \\\\ & b := b - \\eta (-y_{i}) \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w + \\eta y_{i} x_{i} \\\\ & b := b + \\eta y_{i} \\end{aligned} & & \\end{matrix} \u4f2a\u4ee3\u7801 1 2 3 4 5 6 7 8 9 Input: dataset T = $ \\{ ( x_ { 1 } , y_ { 1 }) , ( x_ { 2 } , y_ { 2 }) , ..., ( x_ { n } , y_ { n }) \\} $ Output: $w ^ { * } $, $b ^ { * } $ Initialise w, b with 0 While True do : Calculate misclassified set M If $M = \\v arnothing$: break Pick up one point form M, update w, b return w, b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import numpy as np def sign ( x ): res = x . copy () idx = x >= 0 res [:] = - 1 res [ idx ] = 1 return res def Perception ( T , eta = 0.1 ): X = T [:, : - 1 ] Y = T [:, - 1 ] n , m = X . shape w = np . zeros ( m ) b = 0 while True : y_hat = sign ( np . dot ( X , w ) + b ) M = np . nonzero ( Y != y_hat )[ 0 ] if len ( M ) == 0 : break pickedUp = np . random . choice ( M , 1 ) w = w + eta * Y [ pickedUp ] * X [ pickedUp , :][ 0 ] b = b + eta * Y [ pickedUp ] return w , b T = [[ 3 , 3 , 1 ], [ 4 , 3 , 1 ], [ 1 , 1 , - 1 ]] T = np . array ( T ) w , b = Perception ( T ) Novikoff\u5b9a\u7406 \u5047\u8bbe\u6570\u636e\u96c6 T \u662f\u7ebf\u5f62\u53ef\u5206\u7684\uff0c \uff081\uff09\u5b58\u5728\u4e00\u4e2a\u8d85\u5e73\u9762 w^{*} \\cdot x + b^{*} = 0 w^{*} \\cdot x + b^{*} = 0 \uff0c\u4f7f\u5f97\u6b63\u786e\u533a\u5206\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\uff0c\u5373\u5bf9\u6240\u6709\u7684\u5b9e\u4f8b (x_{i}, y_{i}), i = 1, 2, ..., n (x_{i}, y_{i}), i = 1, 2, ..., n \uff0c\u5b58\u5728 \\gamma > 0 \\gamma > 0 \u4f7f\u5f97 y_{i} (w^{*} \\cdot x_{i} + b^{*}) \\geq \\gamma y_{i} (w^{*} \\cdot x_{i} + b^{*}) \\geq \\gamma \uff082\uff09 (ii) \u4ee4 R = \\max_{i = 1, 2, ..., n} \\left \\| x_{i} \\right \\| R = \\max_{i = 1, 2, ..., n} \\left \\| x_{i} \\right \\| , \u8bef\u5206\u7c7b\u7684\u4e2a\u6570 k \u6ee1\u8db3 k \\leq (\\frac{R}{\\gamma})^{2} k \\leq (\\frac{R}{\\gamma})^{2} \u8bc1\u660e 1\uff09\u4efb\u610f\u4e00\u4e2a\u5b9e\u4f8b x_{i} x_{i} \u80fd\u591f\u88ab\u6b63\u786e\u5206\u7c7b\uff0c\u5fc5\u987b\u6ee1\u8db3 y_{i} (w^{*} \\cdot x + b^{*}) > 0 y_{i} (w^{*} \\cdot x + b^{*}) > 0 \u56e0\u6b64\uff0c\u6211\u4eec\u603b\u80fd\u627e\u5230\u4e00\u4e2a \\gamma \\gamma \u6ee1\u8db3\uff081\uff09 \\gamma = \\min_{i = 1, 2, ..., n} y_{i} (w^{*} \\cdot x_{i} + b^{*}) \\gamma = \\min_{i = 1, 2, ..., n} y_{i} (w^{*} \\cdot x_{i} + b^{*}) 2\uff09\u5047\u8bbe\u5728\u7b2ck\u6b21\u8fed\u4ee3\u91cc\uff0c\u6211\u4eec\u7684\u53c2\u6570\u66f4\u65b0\u8fc7\u7a0b\u5982\u4e0b W_{k} = \\begin{bmatrix} w_{k} \\\\ b_{k} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} + \\eta y_{i} x_{i} \\\\ b_{k-1} + \\eta y_{i} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} \\\\ b_{k-1} \\end{bmatrix} + \\eta y_{i} \\begin{bmatrix} x_{i} \\\\ 1 \\end{bmatrix} W_{k} = \\begin{bmatrix} w_{k} \\\\ b_{k} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} + \\eta y_{i} x_{i} \\\\ b_{k-1} + \\eta y_{i} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} \\\\ b_{k-1} \\end{bmatrix} + \\eta y_{i} \\begin{bmatrix} x_{i} \\\\ 1 \\end{bmatrix} \u4e24\u4e2a\u4e0d\u7b49\u5f0f \\begin{aligned} & \\begin{aligned} w_{k} \\cdot w^{*} & = (w_{k} + \\eta y_{i} x_{i}) \\cdot w^{*} \\\\ & \\geq w_{k-1} \\cdot w^{*} + \\eta \\gamma \\\\ & \\geq w_{k-2} \\cdot w^{*} + 2 \\eta \\gamma \\\\ & \\geq k \\eta \\gamma \\end{aligned} \\\\ & \\begin{aligned} \\left \\| w_{k} \\right \\|^{2} & = (w_{k-1} + \\eta y_{i} x_{i})^{2} \\\\ & = \\left \\| w_{k-1} \\right \\|^{2} + 2 w_{k-1} \\eta y_{i} x_{i} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} R^{2} \\\\ & \\leq k \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq k \\eta^{2} R^{2} \\end{aligned} \\end{aligned} \\begin{aligned} & \\begin{aligned} w_{k} \\cdot w^{*} & = (w_{k} + \\eta y_{i} x_{i}) \\cdot w^{*} \\\\ & \\geq w_{k-1} \\cdot w^{*} + \\eta \\gamma \\\\ & \\geq w_{k-2} \\cdot w^{*} + 2 \\eta \\gamma \\\\ & \\geq k \\eta \\gamma \\end{aligned} \\\\ & \\begin{aligned} \\left \\| w_{k} \\right \\|^{2} & = (w_{k-1} + \\eta y_{i} x_{i})^{2} \\\\ & = \\left \\| w_{k-1} \\right \\|^{2} + 2 w_{k-1} \\eta y_{i} x_{i} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} R^{2} \\\\ & \\leq k \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq k \\eta^{2} R^{2} \\end{aligned} \\end{aligned} \\begin{matrix} & k \\eta \\gamma \\leq w^{k} \\cdot w^{k} \\leq \\left \\| w_{k} \\right \\| \\left \\| w^{*} \\right \\| \\leq \\sqrt{k} \\eta R & \\\\ & \\Downarrow & \\\\ & k \\leq (\\frac{R}{\\gamma})^{2} & \\end{matrix} \\begin{matrix} & k \\eta \\gamma \\leq w^{k} \\cdot w^{k} \\leq \\left \\| w_{k} \\right \\| \\left \\| w^{*} \\right \\| \\leq \\sqrt{k} \\eta R & \\\\ & \\Downarrow & \\\\ & k \\leq (\\frac{R}{\\gamma})^{2} & \\end{matrix} \u8bc4\u4ef7 \u00b6 \u4f18\u70b9 \uff1a\u5bb9\u6613\u5b9e\u73b0 \u7f3a\u70b9 \uff1a\u4e0d\u80fd\u5904\u7406\u975e\u7ebf\u6027\u5206\u88c2\u95ee\u9898\uff0c\u5982\u5f02\u6216XOR","title":"\u611f\u77e5\u673a"},{"location":"machine-learning/perceptron/#_1","text":"\u611f\u77e5\u673a\u662f\u4e00\u79cd\u5206\u7c7b\u6a21\u578b\u3002\u8f93\u5165\u7a7a\u95f4\u662f X = \\{x_{1}, x_{2}, ..., x_{n}\\} X = \\{x_{1}, x_{2}, ..., x_{n}\\} \uff0c\u8f93\u51fa\u7a7a\u95f4\u662f Y = \\{+1 , -1\\} Y = \\{+1 , -1\\} \u3002 \u5224\u522b\u51fd\u6570 \\begin{aligned} f(x_{i}) &= \\text{sign}(w \\cdot x_{i} + b) \\\\ &= \\begin{cases} 1, \\quad w \\cdot x_{i} + b \\geq 0 \\\\ -1, \\quad \\text{else} \\end{cases} \\end{aligned} \\begin{aligned} f(x_{i}) &= \\text{sign}(w \\cdot x_{i} + b) \\\\ &= \\begin{cases} 1, \\quad w \\cdot x_{i} + b \\geq 0 \\\\ -1, \\quad \\text{else} \\end{cases} \\end{aligned} W \\cdot X W \\cdot X \u4ee3\u8868\u7684\u662f\u70b9\u4e58","title":"\u5b9a\u4e49"},{"location":"machine-learning/perceptron/#_2","text":"\u6570\u636e\u96c6 T = \\{(x_{1}, y_{1}), (x_{2}, y_{2}), ..., (x_{n}, y_{n})\\} \\{(x_{1}, y_{1}), (x_{2}, y_{2}), ..., (x_{n}, y_{n})\\} \uff0c\u5047\u8bbe\u4e00\u4e2a\u6570\u636e\u70b9 ( x_{i} x_{i} , y_{i} y_{i} ) \u88ab\u8bef\u5206\u7c7b\u4e86\u3002\u53ef\u4ee5\u7528\u5982\u4e0b\u65b9\u6cd5\u8868\u793a\uff1a y_{i} \\times f(x_{i}) = y_{i} \\times \\text{sign}(x_{i}) = -1 y_{i} \\times f(x_{i}) = y_{i} \\times \\text{sign}(x_{i}) = -1 \u6240\u6709\u88ab\u8bef\u5206\u7c7b\u7684\u70b9\u6784\u6210\u96c6\u5408 M\uff0c\u635f\u5931\u51fd\u6570\u4e3a L(w, b) = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i}(w \\cdot x_{i} + b) L(w, b) = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i}(w \\cdot x_{i} + b) \u53c2\u6570\u68af\u5ea6 \\begin{aligned} & \\frac{\\partial L(w, b)}{\\partial w} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} x_{i} \\\\ & \\frac{\\partial L(w, b)}{\\partial b} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} \\end{aligned} \\begin{aligned} & \\frac{\\partial L(w, b)}{\\partial w} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} x_{i} \\\\ & \\frac{\\partial L(w, b)}{\\partial b} = -\\sum_{(x_{i}, y_{i}) \\in M} y_{i} \\end{aligned} \u53cd\u5411\u4f20\u64ad\uff0c\u5b66\u4e60\u7387 \\eta \\in (0, 1] \\eta \\in (0, 1] \\begin{matrix} & & \\begin{aligned} & w := w - \\eta \\frac{\\partial L(w, b)}{\\partial w} \\\\ & b := b - \\eta \\frac{\\partial L(w, b)}{\\partial b} \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w - \\eta (-y_{i} x_{i}) \\\\ & b := b - \\eta (-y_{i}) \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w + \\eta y_{i} x_{i} \\\\ & b := b + \\eta y_{i} \\end{aligned} & & \\end{matrix} \\begin{matrix} & & \\begin{aligned} & w := w - \\eta \\frac{\\partial L(w, b)}{\\partial w} \\\\ & b := b - \\eta \\frac{\\partial L(w, b)}{\\partial b} \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w - \\eta (-y_{i} x_{i}) \\\\ & b := b - \\eta (-y_{i}) \\end{aligned} & & \\\\ & & \\Downarrow & & \\\\ & & \\begin{aligned} & w := w + \\eta y_{i} x_{i} \\\\ & b := b + \\eta y_{i} \\end{aligned} & & \\end{matrix} \u4f2a\u4ee3\u7801 1 2 3 4 5 6 7 8 9 Input: dataset T = $ \\{ ( x_ { 1 } , y_ { 1 }) , ( x_ { 2 } , y_ { 2 }) , ..., ( x_ { n } , y_ { n }) \\} $ Output: $w ^ { * } $, $b ^ { * } $ Initialise w, b with 0 While True do : Calculate misclassified set M If $M = \\v arnothing$: break Pick up one point form M, update w, b return w, b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import numpy as np def sign ( x ): res = x . copy () idx = x >= 0 res [:] = - 1 res [ idx ] = 1 return res def Perception ( T , eta = 0.1 ): X = T [:, : - 1 ] Y = T [:, - 1 ] n , m = X . shape w = np . zeros ( m ) b = 0 while True : y_hat = sign ( np . dot ( X , w ) + b ) M = np . nonzero ( Y != y_hat )[ 0 ] if len ( M ) == 0 : break pickedUp = np . random . choice ( M , 1 ) w = w + eta * Y [ pickedUp ] * X [ pickedUp , :][ 0 ] b = b + eta * Y [ pickedUp ] return w , b T = [[ 3 , 3 , 1 ], [ 4 , 3 , 1 ], [ 1 , 1 , - 1 ]] T = np . array ( T ) w , b = Perception ( T ) Novikoff\u5b9a\u7406 \u5047\u8bbe\u6570\u636e\u96c6 T \u662f\u7ebf\u5f62\u53ef\u5206\u7684\uff0c \uff081\uff09\u5b58\u5728\u4e00\u4e2a\u8d85\u5e73\u9762 w^{*} \\cdot x + b^{*} = 0 w^{*} \\cdot x + b^{*} = 0 \uff0c\u4f7f\u5f97\u6b63\u786e\u533a\u5206\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\uff0c\u5373\u5bf9\u6240\u6709\u7684\u5b9e\u4f8b (x_{i}, y_{i}), i = 1, 2, ..., n (x_{i}, y_{i}), i = 1, 2, ..., n \uff0c\u5b58\u5728 \\gamma > 0 \\gamma > 0 \u4f7f\u5f97 y_{i} (w^{*} \\cdot x_{i} + b^{*}) \\geq \\gamma y_{i} (w^{*} \\cdot x_{i} + b^{*}) \\geq \\gamma \uff082\uff09 (ii) \u4ee4 R = \\max_{i = 1, 2, ..., n} \\left \\| x_{i} \\right \\| R = \\max_{i = 1, 2, ..., n} \\left \\| x_{i} \\right \\| , \u8bef\u5206\u7c7b\u7684\u4e2a\u6570 k \u6ee1\u8db3 k \\leq (\\frac{R}{\\gamma})^{2} k \\leq (\\frac{R}{\\gamma})^{2} \u8bc1\u660e 1\uff09\u4efb\u610f\u4e00\u4e2a\u5b9e\u4f8b x_{i} x_{i} \u80fd\u591f\u88ab\u6b63\u786e\u5206\u7c7b\uff0c\u5fc5\u987b\u6ee1\u8db3 y_{i} (w^{*} \\cdot x + b^{*}) > 0 y_{i} (w^{*} \\cdot x + b^{*}) > 0 \u56e0\u6b64\uff0c\u6211\u4eec\u603b\u80fd\u627e\u5230\u4e00\u4e2a \\gamma \\gamma \u6ee1\u8db3\uff081\uff09 \\gamma = \\min_{i = 1, 2, ..., n} y_{i} (w^{*} \\cdot x_{i} + b^{*}) \\gamma = \\min_{i = 1, 2, ..., n} y_{i} (w^{*} \\cdot x_{i} + b^{*}) 2\uff09\u5047\u8bbe\u5728\u7b2ck\u6b21\u8fed\u4ee3\u91cc\uff0c\u6211\u4eec\u7684\u53c2\u6570\u66f4\u65b0\u8fc7\u7a0b\u5982\u4e0b W_{k} = \\begin{bmatrix} w_{k} \\\\ b_{k} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} + \\eta y_{i} x_{i} \\\\ b_{k-1} + \\eta y_{i} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} \\\\ b_{k-1} \\end{bmatrix} + \\eta y_{i} \\begin{bmatrix} x_{i} \\\\ 1 \\end{bmatrix} W_{k} = \\begin{bmatrix} w_{k} \\\\ b_{k} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} + \\eta y_{i} x_{i} \\\\ b_{k-1} + \\eta y_{i} \\end{bmatrix} = \\begin{bmatrix} w_{k-1} \\\\ b_{k-1} \\end{bmatrix} + \\eta y_{i} \\begin{bmatrix} x_{i} \\\\ 1 \\end{bmatrix} \u4e24\u4e2a\u4e0d\u7b49\u5f0f \\begin{aligned} & \\begin{aligned} w_{k} \\cdot w^{*} & = (w_{k} + \\eta y_{i} x_{i}) \\cdot w^{*} \\\\ & \\geq w_{k-1} \\cdot w^{*} + \\eta \\gamma \\\\ & \\geq w_{k-2} \\cdot w^{*} + 2 \\eta \\gamma \\\\ & \\geq k \\eta \\gamma \\end{aligned} \\\\ & \\begin{aligned} \\left \\| w_{k} \\right \\|^{2} & = (w_{k-1} + \\eta y_{i} x_{i})^{2} \\\\ & = \\left \\| w_{k-1} \\right \\|^{2} + 2 w_{k-1} \\eta y_{i} x_{i} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} R^{2} \\\\ & \\leq k \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq k \\eta^{2} R^{2} \\end{aligned} \\end{aligned} \\begin{aligned} & \\begin{aligned} w_{k} \\cdot w^{*} & = (w_{k} + \\eta y_{i} x_{i}) \\cdot w^{*} \\\\ & \\geq w_{k-1} \\cdot w^{*} + \\eta \\gamma \\\\ & \\geq w_{k-2} \\cdot w^{*} + 2 \\eta \\gamma \\\\ & \\geq k \\eta \\gamma \\end{aligned} \\\\ & \\begin{aligned} \\left \\| w_{k} \\right \\|^{2} & = (w_{k-1} + \\eta y_{i} x_{i})^{2} \\\\ & = \\left \\| w_{k-1} \\right \\|^{2} + 2 w_{k-1} \\eta y_{i} x_{i} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq \\left \\| w_{k-1} \\right \\|^{2} + \\eta^{2} R^{2} \\\\ & \\leq k \\eta^{2} \\left \\| x_{i} \\right \\|^{2} \\\\ & \\leq k \\eta^{2} R^{2} \\end{aligned} \\end{aligned} \\begin{matrix} & k \\eta \\gamma \\leq w^{k} \\cdot w^{k} \\leq \\left \\| w_{k} \\right \\| \\left \\| w^{*} \\right \\| \\leq \\sqrt{k} \\eta R & \\\\ & \\Downarrow & \\\\ & k \\leq (\\frac{R}{\\gamma})^{2} & \\end{matrix} \\begin{matrix} & k \\eta \\gamma \\leq w^{k} \\cdot w^{k} \\leq \\left \\| w_{k} \\right \\| \\left \\| w^{*} \\right \\| \\leq \\sqrt{k} \\eta R & \\\\ & \\Downarrow & \\\\ & k \\leq (\\frac{R}{\\gamma})^{2} & \\end{matrix}","title":"\u7b97\u6cd5"},{"location":"machine-learning/perceptron/#_3","text":"\u4f18\u70b9 \uff1a\u5bb9\u6613\u5b9e\u73b0 \u7f3a\u70b9 \uff1a\u4e0d\u80fd\u5904\u7406\u975e\u7ebf\u6027\u5206\u88c2\u95ee\u9898\uff0c\u5982\u5f02\u6216XOR","title":"\u8bc4\u4ef7"},{"location":"machine-learning/pgm/","text":"\u57fa\u7840 \u00b6","title":"\u6982\u7387\u56fe"},{"location":"machine-learning/pgm/#_1","text":"","title":"\u57fa\u7840"},{"location":"machine-learning/regularization/","text":"\u7528\u9014 \u00b6 \u6b63\u5219\u5316\uff08Regularization\uff09\u662f\u9632\u6b62\u8fc7\u62df\u5408\u7684\u65b9\u6cd5\u4e4b\u4e00\u3002\u5982\u679c\u4e00\u4e2a\u6a21\u578b\u7684\u53c2\u6570\u8f83\u5927\u7684\u8bdd\uff0c\u4f1a\u5f15\u8d77\u6a21\u578b\u8fc7\u62df\u5408\uff0c\u6b63\u5219\u5316\u9a71\u4f7f\u6a21\u578b\u53c2\u6570\u53d8\u5c0f\u751a\u81f3\u6210\u4e3a0\u3002 J(w, b) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\lambda R(w), \\quad \\text{where } R(w) \\text{ is a regularizor} J(w, b) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\lambda R(w), \\quad \\text{where } R(w) \\text{ is a regularizor} L1 norm \u00b6 \\bigstar \\bigstar \u8ba9\u53c2\u6570 w \u53d8\u7684\u7cfb\u6570\uff0c\u67d0\u4e9b\u503c\u53d8\u4e3a 0 \\bigstar \\bigstar \u4e0d\u80fd\u5fae\u5206 \\begin{aligned} L_{reg}(w) &= L(w) + \\lambda \\left \\| w \\right \\|_{1} \\\\ &= L(w) + \\frac{\\lambda}{2m} \\sum_{j=1}^{m} \\left | w_{j} \\right | \\\\ &\\rightarrow \\min_{w} \\end{aligned} \\begin{aligned} L_{reg}(w) &= L(w) + \\lambda \\left \\| w \\right \\|_{1} \\\\ &= L(w) + \\frac{\\lambda}{2m} \\sum_{j=1}^{m} \\left | w_{j} \\right | \\\\ &\\rightarrow \\min_{w} \\end{aligned} L2 norm \u00b6 \\bigstar \\bigstar \u9a71\u4f7f\u53c2\u6570\u9760\u8fd1 0 \\bigstar \\bigstar \u56e0\u4e3a\u53ef\u5fae\u5206\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u68af\u5ea6\u4e0b\u964d\u6765\u4f18\u5316 \\bigstar \\bigstar \u589e\u5927\u6b63\u5219\u7cfb\u6570\uff0c\u5bfc\u81f4\u53c2\u6570\u8d8a\u9760\u8fd1 0 \\frac{\\lambda}{2m} \\left \\| w \\right \\|_{2}^{2} = \\frac{\\lambda}{2m} \\sum_{j = 1}^{m} w_{j}^{2} = \\frac{\\lambda}{2m} w^{T}w \\frac{\\lambda}{2m} \\left \\| w \\right \\|_{2}^{2} = \\frac{\\lambda}{2m} \\sum_{j = 1}^{m} w_{j}^{2} = \\frac{\\lambda}{2m} w^{T}w Frobenius norm \u00b6 \\begin{aligned} & J(W^{[1]}, b^{[1]}, ..., W^{[L]}, b^{[L]}) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\frac{\\lambda}{2m} \\sum_{l=1}^{L} \\left \\| W^{[l]} \\right \\|_{F}^{2} \\\\ & \\left \\| W^{[l]} \\right \\|_{F}^{2} = \\sum_{i=1}^{n^{l}} \\sum_{j=1}^{n^{l-1}} (W_{ij}^{[l]})^{2} \\end{aligned} \\begin{aligned} & J(W^{[1]}, b^{[1]}, ..., W^{[L]}, b^{[L]}) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\frac{\\lambda}{2m} \\sum_{l=1}^{L} \\left \\| W^{[l]} \\right \\|_{F}^{2} \\\\ & \\left \\| W^{[l]} \\right \\|_{F}^{2} = \\sum_{i=1}^{n^{l}} \\sum_{j=1}^{n^{l-1}} (W_{ij}^{[l]})^{2} \\end{aligned} Dropout \u00b6 \\bigstar \\bigstar \u6309\u4e00\u5b9a\u7684\u6982\u7387 p \u4fdd\u6301\u795e\u7ecf\u5143\u6d3b\u8dc3\uff0cp = 0.8 \u610f\u5473\u7740\u8fde\u63a5 2 \u4e2a\u795e\u7ecf\u5143\u7684\u8fb9\u6709 20% \u7684\u6982\u7387\u88ab\u79fb\u9664\u3002\u589e\u5927 p \u4f1a\u51cf\u5f31\u6b63\u5219\u4f5c\u7528\u3002 \\bigstar \\bigstar Inverted dropout \\bigstar \\bigstar \u6d4b\u8bd5\u96c6\u4e0a\u4e0d\u4f7f\u7528 1 2 3 d3 = np . random . rand ( a3 . shape [ 0 ], a3 . shape [ 1 ]) < keep_prob a3 = np . multiply ( a3 , d3 ) # a3 = a3 * d3 a3 = a3 / keep_prob","title":"\u6b63\u5219\u5316"},{"location":"machine-learning/regularization/#_1","text":"\u6b63\u5219\u5316\uff08Regularization\uff09\u662f\u9632\u6b62\u8fc7\u62df\u5408\u7684\u65b9\u6cd5\u4e4b\u4e00\u3002\u5982\u679c\u4e00\u4e2a\u6a21\u578b\u7684\u53c2\u6570\u8f83\u5927\u7684\u8bdd\uff0c\u4f1a\u5f15\u8d77\u6a21\u578b\u8fc7\u62df\u5408\uff0c\u6b63\u5219\u5316\u9a71\u4f7f\u6a21\u578b\u53c2\u6570\u53d8\u5c0f\u751a\u81f3\u6210\u4e3a0\u3002 J(w, b) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\lambda R(w), \\quad \\text{where } R(w) \\text{ is a regularizor} J(w, b) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\lambda R(w), \\quad \\text{where } R(w) \\text{ is a regularizor}","title":"\u7528\u9014"},{"location":"machine-learning/regularization/#l1-norm","text":"\\bigstar \\bigstar \u8ba9\u53c2\u6570 w \u53d8\u7684\u7cfb\u6570\uff0c\u67d0\u4e9b\u503c\u53d8\u4e3a 0 \\bigstar \\bigstar \u4e0d\u80fd\u5fae\u5206 \\begin{aligned} L_{reg}(w) &= L(w) + \\lambda \\left \\| w \\right \\|_{1} \\\\ &= L(w) + \\frac{\\lambda}{2m} \\sum_{j=1}^{m} \\left | w_{j} \\right | \\\\ &\\rightarrow \\min_{w} \\end{aligned} \\begin{aligned} L_{reg}(w) &= L(w) + \\lambda \\left \\| w \\right \\|_{1} \\\\ &= L(w) + \\frac{\\lambda}{2m} \\sum_{j=1}^{m} \\left | w_{j} \\right | \\\\ &\\rightarrow \\min_{w} \\end{aligned}","title":"L1 norm"},{"location":"machine-learning/regularization/#l2-norm","text":"\\bigstar \\bigstar \u9a71\u4f7f\u53c2\u6570\u9760\u8fd1 0 \\bigstar \\bigstar \u56e0\u4e3a\u53ef\u5fae\u5206\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u68af\u5ea6\u4e0b\u964d\u6765\u4f18\u5316 \\bigstar \\bigstar \u589e\u5927\u6b63\u5219\u7cfb\u6570\uff0c\u5bfc\u81f4\u53c2\u6570\u8d8a\u9760\u8fd1 0 \\frac{\\lambda}{2m} \\left \\| w \\right \\|_{2}^{2} = \\frac{\\lambda}{2m} \\sum_{j = 1}^{m} w_{j}^{2} = \\frac{\\lambda}{2m} w^{T}w \\frac{\\lambda}{2m} \\left \\| w \\right \\|_{2}^{2} = \\frac{\\lambda}{2m} \\sum_{j = 1}^{m} w_{j}^{2} = \\frac{\\lambda}{2m} w^{T}w","title":"L2 norm"},{"location":"machine-learning/regularization/#frobenius-norm","text":"\\begin{aligned} & J(W^{[1]}, b^{[1]}, ..., W^{[L]}, b^{[L]}) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\frac{\\lambda}{2m} \\sum_{l=1}^{L} \\left \\| W^{[l]} \\right \\|_{F}^{2} \\\\ & \\left \\| W^{[l]} \\right \\|_{F}^{2} = \\sum_{i=1}^{n^{l}} \\sum_{j=1}^{n^{l-1}} (W_{ij}^{[l]})^{2} \\end{aligned} \\begin{aligned} & J(W^{[1]}, b^{[1]}, ..., W^{[L]}, b^{[L]}) = \\frac{1}{m} \\sum_{i=1}^{m} L(\\hat{y^{i}}, y^{i}) + \\frac{\\lambda}{2m} \\sum_{l=1}^{L} \\left \\| W^{[l]} \\right \\|_{F}^{2} \\\\ & \\left \\| W^{[l]} \\right \\|_{F}^{2} = \\sum_{i=1}^{n^{l}} \\sum_{j=1}^{n^{l-1}} (W_{ij}^{[l]})^{2} \\end{aligned}","title":"Frobenius norm"},{"location":"machine-learning/regularization/#dropout","text":"\\bigstar \\bigstar \u6309\u4e00\u5b9a\u7684\u6982\u7387 p \u4fdd\u6301\u795e\u7ecf\u5143\u6d3b\u8dc3\uff0cp = 0.8 \u610f\u5473\u7740\u8fde\u63a5 2 \u4e2a\u795e\u7ecf\u5143\u7684\u8fb9\u6709 20% \u7684\u6982\u7387\u88ab\u79fb\u9664\u3002\u589e\u5927 p \u4f1a\u51cf\u5f31\u6b63\u5219\u4f5c\u7528\u3002 \\bigstar \\bigstar Inverted dropout \\bigstar \\bigstar \u6d4b\u8bd5\u96c6\u4e0a\u4e0d\u4f7f\u7528 1 2 3 d3 = np . random . rand ( a3 . shape [ 0 ], a3 . shape [ 1 ]) < keep_prob a3 = np . multiply ( a3 , d3 ) # a3 = a3 * d3 a3 = a3 / keep_prob","title":"Dropout"},{"location":"machine-learning/roc/","text":"\u7b80\u4ecb \u00b6 \u63a5\u6536\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7dda\uff08receiver operating characteristic curve\uff0c\u7b80\u79f0ROC\uff09\u662f\u4e00\u79cd\u9009\u62e9\u6700\u4f73\u6a21\u578b\u7684\u5750\u6807\u56fe\u5f0f\u5206\u6790\u5de5\u5177\u3002 \u672f\u8bed \u00b6 \u9633\u6027 P\uff08positive\uff09 \u9634\u6027 N \uff08negative\uff09 \u771f\u9633\u6027 TP \uff08true positive\uff09 \u771f\u9634\u6027 TN \uff08true negative\uff09 \u5047\u9633\u6027 FP \uff08false positive\uff09 \u5047\u9634\u6027 FN \uff08false negative\uff09 \u7cbe\u786e\u5ea6 \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \u53ec\u56de\u7387/\u771f\u9633\u6027\u7387 \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \u5047\u9633\u6027\u7387 \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \u51c6\u786e\u5ea6 \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} P N T TP FN F FP TN AUC \u00b6 AUC \u5168\u79f0\u662f area under curve \uff0c\u6307\u7684\u662f\u63a5\u53d7\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7ebf\u4e0b\u7684\u9762\u79ef\u3002 \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix} \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix} \u7269\u7406\u542b\u4e49 \u00b6 \u4efb\u610f\u53d6\u4e00\u4e2a\u6b63\u6837\u672c\u548c\u4e00\u4e2a\u8d1f\u6837\u672c\u7ec4\u6210\u4e00\u4e2a\u6837\u672c\u5bf9 (p_{i}, n_{i}) (p_{i}, n_{i}) \uff0c\u4f7f\u7528\u8bad\u7ec3\u597d\u7684\u6a21\u578b\u5bf9\u8fd9\u4e00\u5bf9\u968f\u673a\u6837\u672c\u8fdb\u884c\u9884\u6d4b\uff0c\u5224\u65ad \u6b63\u6837\u672c p_{i} p_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{1} p_{1} \uff0c\u5224\u65ad\u8d1f\u6837\u672c n_{i} n_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{0} p_{0} \uff0cauc \u7684\u5927\u5c0f\u5373\u4e3a p_{1} p_{1} \u5927\u4e8e p_{0} p_{0} \u7684\u6982\u7387 \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \u5047\u8bbe\u6211\u4eec\u7684\u5206\u7c7b\u5668\u662f\u4e00\u4e2a\u968f\u673a\u5206\u7c7b\u5668\uff0c\u5bf9\u6b63\u8d1f\u6837\u672c\u7684\u5212\u5206\u6982\u7387\u662f\u4e00\u6837\u7684\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5206\u7c7b\u5668\u7684 AUC \u5c31\u662f0.5\u3002 AUC \u4e0d\u53d7\u5212\u5206\u6b63\u8d1f\u6837\u672c\u7684\u9608\u503c\u5f71\u54cd\uff0c\u4e5f\u4e0d\u53d7\u6b63\u8d1f\u6837\u672c\u7684\u4e0d\u5747\u5f71\u54cd\uff0c\u4f46\u662f\u53ea\u9002\u5408\u4e8c\u5206\u7c7b\u7684\u95ee\u9898\u3002 \u8ba1\u7b97\u65b9\u6cd5 \u00b6 \u300c\u6b63\u8d1f\u6837\u672c\u5bf9\u300d \u6211\u4eec\u53ef\u4ee5\u6839\u636eAUC\u7684\u7269\u7406\u542b\u4e49\u6c42\u89e3\uff0c\u7a77\u4e3e\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\u5bf9\uff0c\u7136\u540e\u8ba1\u7b97\u6b63\u6837\u672c\u7684\u9884\u6d4b\u503c\u5927\u4e8e\u8d1f\u6837\u672c\u9884\u6d4b\u503c\u7684\u6982\u7387\u3002 \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 double auc1 ( vector < double > predict , vector < int > label ) { int n = ( int ) predict . size (); int n1 = 0 , n0 = 0 ; double I = 0.0 ; vector < double > p1 , p0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( label [ i ]) { p1 . emplace_back ( predict [ i ]); n1 ++ ; } else { p0 . emplace_back ( predict [ i ]); n0 ++ ; } } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < n0 ; j ++ ) { if ( p1 [ i ] > p0 [ j ]) { I += 1 ; } else if ( p1 [ i ] == p0 [ j ]) { I += 0.5 ; } } } return I / ( n1 * n0 ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n_{1} n_{0}) O(n_{1} n_{0}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n_{1} + n_{0}) O(n_{1} + n_{0}) \uff0c\u5176\u4e2d n_{1} n_{1} \u548c n_{0} n_{0} \u5206\u522b\u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee \u300c\u6392\u5e8f\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u5c06\u9884\u6d4b\u503c\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u6392\u5217\uff0c\u53ef\u4f7f\u7528\u5982\u4e0b\u516c\u5f0f \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \u6211\u4eec\u53ea\u9700\u8981\u8ba1\u7b97\u6b63\u6837\u672c\u5728\u6392\u5e8f\u540e\u7684\u5217\u8868\u91cc\u9762\u7684\u5e8f\u53f7\uff08\u79e9\uff09\uff0c\u4ece 1 \u5f00\u59cb\u3002\u5982\u679c\u51fa\u73b0\u6b63\u8d1f\u6837\u672c\u5177\u6709\u76f8\u540c\u7684\u9884\u6d4b\u5206\u503c\uff0c\u90a3\u4e48\u9700\u8981\u6c42\u8fd9\u4e9b\u6b63\u8d1f\u6837\u672c\u7684\u5e73\u5747\u79e9\u4e58\u4ee5\u540c\u5206\u503c\u4e2d\u6b63\u6837\u672c\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 double auc2 ( vector < double > predict , vector < int > label ) { vector < pair < double , int >> data ; int n = ( int ) predict . size (); for ( int i = 0 ; i < n ; i ++ ) { data . emplace_back ( pair < double , int > { predict [ i ], label [ i ]}); } sort ( data . begin (), data . end (), []( const pair < double , int > & x , pair < double , int > & y ) { return x . first < y . first || ( x . first == y . first && x . second > y . second ); }); int row = 0 , rankPos = 0 , rankNeg = 0 , numPos = 0 , numNeg = 0 , totPosSam = 0 ; double cnt = 0 ; double lastScore = - 0.1 ; // \u6700\u540e\u6dfb\u52a0\u4e00\u4e2a\u6570\u5bf9\u6807\u5fd7\u7ed3\u675f\uff0c\u4e0d\u53c2\u4e0e\u8ba1\u7b97 data . emplace_back ( pair < double , int > { - 0.1 , - 1 }); for ( auto d : data ) { row ++ ; if ( lastScore != d . first && row > 1 ) { lastScore = d . first ; cnt += double ( rankPos + rankNeg ) / ( numPos + numNeg ) * numPos ; rankPos = rankNeg = numPos = numNeg = 0 ; } if ( d . second == 1 ) { rankPos += row ; numPos ++ ; totPosSam ++ ; } else { rankNeg += row ; numNeg ++ ; } } return ( cnt - totPosSam * ( totPosSam + 1 ) / 2.0 ) / ( totPosSam * ( n - totPosSam )); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c \u300c\u5206\u6876\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u6982\u7387\u7684\u8303\u56f4\u662f [0, 1]\uff0c\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528\u5206\u6876\u65b9\u6cd5\u7edf\u8ba1\u6bcf\u4e00\u4e2a\u6837\u672c\u9884\u6d4b\u503c\u843d\u5728\u54ea\u4e2a\u6876\u5185\uff08\u533a\u95f4\uff09\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a hist \u7528\u6765\u7edf\u8ba1\u9884\u6d4b\u503c\u843d\u5728\u67d0\u4e2a\u6876\u5185\u7684\u4e2a\u6570\u3002\u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6982\u7387\u5bf9\uff0c\u5047\u8bbe\u9884\u6d4b\u503c\u4e3a 0.8 \u7684\u6b63\u6837\u672c\u6709 10 \u4e2a\uff0c\u90a3\u4e48\u4f4e\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u603b\u6570\u4e58\u4ee5 10 \u5373\u4e3a\u8fd9\u4e00\u9884\u6d4b\u503c\u7684\u6982\u7387\u5bf9\uff0c\u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u5e94\u8be5\u8ba1\u7b97\u9884\u6d4b\u503c\u7b49\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u6570\uff0c\u5047\u8bbe\u4e3a 8\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6b64\u65f6\u6b63\u8d1f\u6837\u672c\u6982\u7387\u76f8\u7b49\uff0c\u9700\u8981\u53d6\u4e00\u534a\uff0c\u5373 8 * 10 / 2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 double auc3 ( vector < double > predict , vector < int > label , int bins = 100 ) { // \u65f6\u95f4\u590d\u6742\u5ea6O(n) int cnt_pos = 0 , cnt_neg = 0 ; int n = ( int ) predict . size (); vector < int > pos_hist ( bins , 0 ), neg_hist ( bins , 0 ); double width = 1.0 / bins ; for ( int i = 0 ; i < n ; i ++ ) { int nth_bin = ( int )( predict [ i ] / width ); if ( label [ i ]) { cnt_pos ++ ; pos_hist [ nth_bin ] ++ ; } else { cnt_neg ++ ; neg_hist [ nth_bin ] ++ ; } } int accumulated_negative = 0 , satisfied_pair = 0 ; for ( int i = 0 ; i < bins ; i ++ ) { satisfied_pair += pos_hist [ i ] * accumulated_negative + pos_hist [ i ] * neg_hist [ i ] * 0.5 ; accumulated_negative += neg_hist [ i ]; } return satisfied_pair / double ( cnt_pos * cnt_neg ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c","title":"ROC"},{"location":"machine-learning/roc/#_1","text":"\u63a5\u6536\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7dda\uff08receiver operating characteristic curve\uff0c\u7b80\u79f0ROC\uff09\u662f\u4e00\u79cd\u9009\u62e9\u6700\u4f73\u6a21\u578b\u7684\u5750\u6807\u56fe\u5f0f\u5206\u6790\u5de5\u5177\u3002","title":"\u7b80\u4ecb"},{"location":"machine-learning/roc/#_2","text":"\u9633\u6027 P\uff08positive\uff09 \u9634\u6027 N \uff08negative\uff09 \u771f\u9633\u6027 TP \uff08true positive\uff09 \u771f\u9634\u6027 TN \uff08true negative\uff09 \u5047\u9633\u6027 FP \uff08false positive\uff09 \u5047\u9634\u6027 FN \uff08false negative\uff09 \u7cbe\u786e\u5ea6 \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \u53ec\u56de\u7387/\u771f\u9633\u6027\u7387 \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \u5047\u9633\u6027\u7387 \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \u51c6\u786e\u5ea6 \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} P N T TP FN F FP TN","title":"\u672f\u8bed"},{"location":"machine-learning/roc/#auc","text":"AUC \u5168\u79f0\u662f area under curve \uff0c\u6307\u7684\u662f\u63a5\u53d7\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7ebf\u4e0b\u7684\u9762\u79ef\u3002 \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix} \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix}","title":"AUC"},{"location":"machine-learning/roc/#_3","text":"\u4efb\u610f\u53d6\u4e00\u4e2a\u6b63\u6837\u672c\u548c\u4e00\u4e2a\u8d1f\u6837\u672c\u7ec4\u6210\u4e00\u4e2a\u6837\u672c\u5bf9 (p_{i}, n_{i}) (p_{i}, n_{i}) \uff0c\u4f7f\u7528\u8bad\u7ec3\u597d\u7684\u6a21\u578b\u5bf9\u8fd9\u4e00\u5bf9\u968f\u673a\u6837\u672c\u8fdb\u884c\u9884\u6d4b\uff0c\u5224\u65ad \u6b63\u6837\u672c p_{i} p_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{1} p_{1} \uff0c\u5224\u65ad\u8d1f\u6837\u672c n_{i} n_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{0} p_{0} \uff0cauc \u7684\u5927\u5c0f\u5373\u4e3a p_{1} p_{1} \u5927\u4e8e p_{0} p_{0} \u7684\u6982\u7387 \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \u5047\u8bbe\u6211\u4eec\u7684\u5206\u7c7b\u5668\u662f\u4e00\u4e2a\u968f\u673a\u5206\u7c7b\u5668\uff0c\u5bf9\u6b63\u8d1f\u6837\u672c\u7684\u5212\u5206\u6982\u7387\u662f\u4e00\u6837\u7684\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5206\u7c7b\u5668\u7684 AUC \u5c31\u662f0.5\u3002 AUC \u4e0d\u53d7\u5212\u5206\u6b63\u8d1f\u6837\u672c\u7684\u9608\u503c\u5f71\u54cd\uff0c\u4e5f\u4e0d\u53d7\u6b63\u8d1f\u6837\u672c\u7684\u4e0d\u5747\u5f71\u54cd\uff0c\u4f46\u662f\u53ea\u9002\u5408\u4e8c\u5206\u7c7b\u7684\u95ee\u9898\u3002","title":"\u7269\u7406\u542b\u4e49"},{"location":"machine-learning/roc/#_4","text":"\u300c\u6b63\u8d1f\u6837\u672c\u5bf9\u300d \u6211\u4eec\u53ef\u4ee5\u6839\u636eAUC\u7684\u7269\u7406\u542b\u4e49\u6c42\u89e3\uff0c\u7a77\u4e3e\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\u5bf9\uff0c\u7136\u540e\u8ba1\u7b97\u6b63\u6837\u672c\u7684\u9884\u6d4b\u503c\u5927\u4e8e\u8d1f\u6837\u672c\u9884\u6d4b\u503c\u7684\u6982\u7387\u3002 \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 double auc1 ( vector < double > predict , vector < int > label ) { int n = ( int ) predict . size (); int n1 = 0 , n0 = 0 ; double I = 0.0 ; vector < double > p1 , p0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( label [ i ]) { p1 . emplace_back ( predict [ i ]); n1 ++ ; } else { p0 . emplace_back ( predict [ i ]); n0 ++ ; } } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < n0 ; j ++ ) { if ( p1 [ i ] > p0 [ j ]) { I += 1 ; } else if ( p1 [ i ] == p0 [ j ]) { I += 0.5 ; } } } return I / ( n1 * n0 ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n_{1} n_{0}) O(n_{1} n_{0}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n_{1} + n_{0}) O(n_{1} + n_{0}) \uff0c\u5176\u4e2d n_{1} n_{1} \u548c n_{0} n_{0} \u5206\u522b\u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee \u300c\u6392\u5e8f\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u5c06\u9884\u6d4b\u503c\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u6392\u5217\uff0c\u53ef\u4f7f\u7528\u5982\u4e0b\u516c\u5f0f \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \u6211\u4eec\u53ea\u9700\u8981\u8ba1\u7b97\u6b63\u6837\u672c\u5728\u6392\u5e8f\u540e\u7684\u5217\u8868\u91cc\u9762\u7684\u5e8f\u53f7\uff08\u79e9\uff09\uff0c\u4ece 1 \u5f00\u59cb\u3002\u5982\u679c\u51fa\u73b0\u6b63\u8d1f\u6837\u672c\u5177\u6709\u76f8\u540c\u7684\u9884\u6d4b\u5206\u503c\uff0c\u90a3\u4e48\u9700\u8981\u6c42\u8fd9\u4e9b\u6b63\u8d1f\u6837\u672c\u7684\u5e73\u5747\u79e9\u4e58\u4ee5\u540c\u5206\u503c\u4e2d\u6b63\u6837\u672c\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 double auc2 ( vector < double > predict , vector < int > label ) { vector < pair < double , int >> data ; int n = ( int ) predict . size (); for ( int i = 0 ; i < n ; i ++ ) { data . emplace_back ( pair < double , int > { predict [ i ], label [ i ]}); } sort ( data . begin (), data . end (), []( const pair < double , int > & x , pair < double , int > & y ) { return x . first < y . first || ( x . first == y . first && x . second > y . second ); }); int row = 0 , rankPos = 0 , rankNeg = 0 , numPos = 0 , numNeg = 0 , totPosSam = 0 ; double cnt = 0 ; double lastScore = - 0.1 ; // \u6700\u540e\u6dfb\u52a0\u4e00\u4e2a\u6570\u5bf9\u6807\u5fd7\u7ed3\u675f\uff0c\u4e0d\u53c2\u4e0e\u8ba1\u7b97 data . emplace_back ( pair < double , int > { - 0.1 , - 1 }); for ( auto d : data ) { row ++ ; if ( lastScore != d . first && row > 1 ) { lastScore = d . first ; cnt += double ( rankPos + rankNeg ) / ( numPos + numNeg ) * numPos ; rankPos = rankNeg = numPos = numNeg = 0 ; } if ( d . second == 1 ) { rankPos += row ; numPos ++ ; totPosSam ++ ; } else { rankNeg += row ; numNeg ++ ; } } return ( cnt - totPosSam * ( totPosSam + 1 ) / 2.0 ) / ( totPosSam * ( n - totPosSam )); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c \u300c\u5206\u6876\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u6982\u7387\u7684\u8303\u56f4\u662f [0, 1]\uff0c\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528\u5206\u6876\u65b9\u6cd5\u7edf\u8ba1\u6bcf\u4e00\u4e2a\u6837\u672c\u9884\u6d4b\u503c\u843d\u5728\u54ea\u4e2a\u6876\u5185\uff08\u533a\u95f4\uff09\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a hist \u7528\u6765\u7edf\u8ba1\u9884\u6d4b\u503c\u843d\u5728\u67d0\u4e2a\u6876\u5185\u7684\u4e2a\u6570\u3002\u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6982\u7387\u5bf9\uff0c\u5047\u8bbe\u9884\u6d4b\u503c\u4e3a 0.8 \u7684\u6b63\u6837\u672c\u6709 10 \u4e2a\uff0c\u90a3\u4e48\u4f4e\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u603b\u6570\u4e58\u4ee5 10 \u5373\u4e3a\u8fd9\u4e00\u9884\u6d4b\u503c\u7684\u6982\u7387\u5bf9\uff0c\u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u5e94\u8be5\u8ba1\u7b97\u9884\u6d4b\u503c\u7b49\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u6570\uff0c\u5047\u8bbe\u4e3a 8\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6b64\u65f6\u6b63\u8d1f\u6837\u672c\u6982\u7387\u76f8\u7b49\uff0c\u9700\u8981\u53d6\u4e00\u534a\uff0c\u5373 8 * 10 / 2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 double auc3 ( vector < double > predict , vector < int > label , int bins = 100 ) { // \u65f6\u95f4\u590d\u6742\u5ea6O(n) int cnt_pos = 0 , cnt_neg = 0 ; int n = ( int ) predict . size (); vector < int > pos_hist ( bins , 0 ), neg_hist ( bins , 0 ); double width = 1.0 / bins ; for ( int i = 0 ; i < n ; i ++ ) { int nth_bin = ( int )( predict [ i ] / width ); if ( label [ i ]) { cnt_pos ++ ; pos_hist [ nth_bin ] ++ ; } else { cnt_neg ++ ; neg_hist [ nth_bin ] ++ ; } } int accumulated_negative = 0 , satisfied_pair = 0 ; for ( int i = 0 ; i < bins ; i ++ ) { satisfied_pair += pos_hist [ i ] * accumulated_negative + pos_hist [ i ] * neg_hist [ i ] * 0.5 ; accumulated_negative += neg_hist [ i ]; } return satisfied_pair / double ( cnt_pos * cnt_neg ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c","title":"\u8ba1\u7b97\u65b9\u6cd5"},{"location":"machine-learning/svm/","text":"\u7b80\u4ecb \u00b6 SVM \u5168\u79f0\u662f\u652f\u6301\u5411\u91cf\u673a\uff08support vector machine\uff09\uff0c\u662f\u4e00\u79cd\u5206\u7c7b\u7684\u7b97\u6cd5\uff0c\u53ef\u4ee5\u5904\u7406\u7ebf\u5f62\u5206\u7c7b\uff0c\u4e5f\u53ef\u4ee5\u5904\u7406\u975e\u7ebf\u6027\u5206\u7c7b\u3002 \u539f\u7406 \u00b6 \u8003\u8651\u4e00\u7ec4\u6570\u636e\u96c6\u5408 T = \\{ (x_{1}, y_{1}), (x_{2}, y_{2}), \\cdots, (x_{N}, y_{N}) \\} T = \\{ (x_{1}, y_{1}), (x_{2}, y_{2}), \\cdots, (x_{N}, y_{N}) \\} \u8fd9\u91cc x_{i} \\in R^{n}, y_{i} \\in \\{ +1, -1 \\}, i = 1, 2, ..., N x_{i} \\in R^{n}, y_{i} \\in \\{ +1, -1 \\}, i = 1, 2, ..., N \u7ebf\u5f62 \u00b6 \u5982\u679c\u6211\u4eec\u80fd\u627e\u5230\u4e00\u4e2a\u8d85\u5e73\u9762\uff0c\u7528\u6765\u5206\u9694\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\uff0c\u5c31\u53ef\u4ee5\u6210\u4e3a\u7ebf\u5f62SVM\u3002 w^{*}x + b^{*} = 0 w^{*}x + b^{*} = 0 f(x) = \\text{sign}(w^{*}x + b^{*}) f(x) = \\text{sign}(w^{*}x + b^{*}) \u51fd\u6570\u95f4\u9694\uff08Functional margin\uff09 \u6307\u7684\u662f\u6240\u6709\u6837\u672c\u70b9\u4e0e\u8d85\u5e73\u9762\u7684\u8ddd\u79bb\u4e2d\u6700\u5c0f\u503c \\begin{aligned} & \\hat{\\gamma_{}} = \\min_{i=1, 2, \\cdots, N} \\hat{\\gamma_{i}} \\\\ & \\hat{\\gamma_{i}} = y_{i}(wx_{i}+b) \\end{aligned} \\begin{aligned} & \\hat{\\gamma_{}} = \\min_{i=1, 2, \\cdots, N} \\hat{\\gamma_{i}} \\\\ & \\hat{\\gamma_{i}} = y_{i}(wx_{i}+b) \\end{aligned} \u51e0\u4f55\u95f4\u9694\uff08Geometric margin\uff09 \u6307\u7684\u662f\u5355\u4f4d\u51fd\u6570\u95f4\u9694\uff0c\u5373 \\left \\| w \\right \\| = 1 \\left \\| w \\right \\| = 1 \u3002 \\begin{aligned} & \\gamma = \\min_{i=1, 2, \\cdots, N} \\gamma_{i} \\\\ & \\gamma_{i} = y_{i}(\\frac{w}{\\left \\| w \\right \\|}x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\end{aligned} \\begin{aligned} & \\gamma = \\min_{i=1, 2, \\cdots, N} \\gamma_{i} \\\\ & \\gamma_{i} = y_{i}(\\frac{w}{\\left \\| w \\right \\|}x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\end{aligned} \u51fd\u6570\u95f4\u9694\u548c\u51e0\u4f55\u95f4\u9694\u7684\u5173\u7cfb\u5982\u4e0b \\begin{aligned} & \\gamma_{i} = \\frac{\\hat{\\gamma_{i}}}{\\left \\| w \\right \\|} \\\\ & \\gamma = \\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\end{aligned} \\begin{aligned} & \\gamma_{i} = \\frac{\\hat{\\gamma_{i}}}{\\left \\| w \\right \\|} \\\\ & \\gamma = \\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\end{aligned} \u4f8b\u5982\u5728\u4e00\u4e2a2\u7ef4\u5e73\u9762\u91cc\uff0c\u8d85\u5e73\u9762 x_{1} + x_{2} = 0 x_{1} + x_{2} = 0 \u5b9e\u9645\u4e0a\u662f\u4e00\u6761\u7ebf\u3002\u5047\u8bbe\u6709\u4e00\u4e2a\u8d1f\u6837\u672c (2, 1)\uff0c\u90a3\u4e48\u95f4\u9694\u548c\u8ddd\u79bb\u5206\u522b\u5982\u4e0b \\begin{aligned} & w = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\ & \\frac{w}{\\left \\| w \\right \\|} = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\end{bmatrix}, \\quad b = 0 \\\\ & x = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} \\\\ & \\text{Functional margin is } y(w^{T}x + b) = -3 \\\\ & \\text{Geometric margin is } y(\\frac{w^{T} x + b}{\\left \\| w \\right \\|}) = -\\frac{3\\sqrt{2}}{2} \\end{aligned} \\begin{aligned} & w = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\ & \\frac{w}{\\left \\| w \\right \\|} = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\end{bmatrix}, \\quad b = 0 \\\\ & x = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} \\\\ & \\text{Functional margin is } y(w^{T}x + b) = -3 \\\\ & \\text{Geometric margin is } y(\\frac{w^{T} x + b}{\\left \\| w \\right \\|}) = -\\frac{3\\sqrt{2}}{2} \\end{aligned} SVM \u505a\u7684\u4e8b\u60c5\u5c31\u662f\u6700\u5927\u5316\u51e0\u4f55\u95f4\u9694\u3002 \\begin{aligned} & \\max_{w, b} \\gamma \\\\ & \\text{s.t.} \\quad y_{i}(\\frac{w}{\\left \\| w \\right \\|} \\cdot x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\geq \\gamma, \\quad i = 1, 2, \\cdots, N \\end{aligned} \\begin{aligned} & \\max_{w, b} \\gamma \\\\ & \\text{s.t.} \\quad y_{i}(\\frac{w}{\\left \\| w \\right \\|} \\cdot x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\geq \\gamma, \\quad i = 1, 2, \\cdots, N \\end{aligned} \u5f15\u5165\u51e0\u4f55\u95f4\u9694\u4e0e\u51fd\u6570\u95f4\u9694\u7684\u5173\u7cfb \\begin{cases} \\max_{w, b}\\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\\\ \\text{s.t.} \\quad y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma_{}}, \\quad i = 1, 2, \\cdots, N \\end{cases} \\begin{cases} \\max_{w, b}\\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\\\ \\text{s.t.} \\quad y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma_{}}, \\quad i = 1, 2, \\cdots, N \\end{cases} \u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u4ee4 \\hat{\\gamma} = 1 \\hat{\\gamma} = 1 \uff0c\u56e0\u4e3a\u8fd9\u4e0d\u4f1a\u5f71\u54cd\u6700\u540e\u7684\u89e3\u3002 y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma} \\Leftrightarrow y_{i}(\\lambda w \\cdot x_{i} + \\lambda b) \\geq \\lambda \\hat{\\gamma} y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma} \\Leftrightarrow y_{i}(\\lambda w \\cdot x_{i} + \\lambda b) \\geq \\lambda \\hat{\\gamma} \\max_{w, b}\\frac{1}{\\left \\| w \\right \\|} \\Leftrightarrow \\min_{w, b}\\frac{1}{2}\\left \\| w \\right \\|^{2} \\max_{w, b}\\frac{1}{\\left \\| w \\right \\|} \\Leftrightarrow \\min_{w, b}\\frac{1}{2}\\left \\| w \\right \\|^{2} \\begin{cases} \\min_{w, b} \\frac{1}{2} \\left \\| w \\right \\|^{2} & \\quad \\text{(1)}\\\\ \\text{s.t.} \\quad y_{i} (w \\cdot x_{i} + b) -1 \\geq 0, \\quad i = 1, 2, \\cdots, N & \\quad \\text{(2)} \\end{cases} \\begin{cases} \\min_{w, b} \\frac{1}{2} \\left \\| w \\right \\|^{2} & \\quad \\text{(1)}\\\\ \\text{s.t.} \\quad y_{i} (w \\cdot x_{i} + b) -1 \\geq 0, \\quad i = 1, 2, \\cdots, N & \\quad \\text{(2)} \\end{cases} \u8fd9\u662f\u4e00\u4e2a\u51f8\u4f18\u5316\u95ee\u9898\uff0c\u6700\u4f18\u89e3 w^{*}, b^{*} w^{*}, b^{*} \u4ee3\u8868\u4e00\u4e2a\u8d85\u5e73\u9762\u3002\u5982\u679c\u6570\u636e\u96c6\u662f\u7ebf\u5f62\u53ef\u5206\uff0c\u90a3\u4e48\u8d85\u5e73\u9762\u662f\u552f\u4e00\u7684\u3002\u8bc1\u660e\u5982\u4e0b\uff1a \u5b58\u5728\u6027 \uff1a\u6211\u4eec\u603b\u53ef\u4ee5\u627e\u5230\u4e00\u4e2a \\left \\| w \\right \\|^{2} \\left \\| w \\right \\|^{2} \uff0c\u5176\u6709\u4e00\u4e2a\u4e0b\u754c\u3002 \u552f\u4e00\u6027 \uff1a\u5047\u8bbe\u6211\u4eec\u6709\u4e24\u4e2a\u6700\u4f18\u89e3\uff08 w_{1}^{*} w_{1}^{*} , b_{1}^{*} b_{1}^{*} \uff09\u548c\uff08 w_{2}^{*} w_{2}^{*} , b_{2}^{*} b_{2}^{*} \uff09 \\begin{aligned} & \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\|^{2} = \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\|^{2} \\rightarrow \\left \\| w_{1} \\right \\| = \\left \\| w_{2} \\right \\| = c, \\quad c \\text{ is a some scalar value} \\\\ \\because \\quad & (w = \\frac{w_{1}^{*} + w_{2}^{*}}{2}, \\quad b = \\frac{b_{1}^{*} + b_{2}^{*}}{2}) \\text{ is also a feasible solution} \\\\ \\therefore \\quad & c \\leq \\left \\| w \\right \\| = \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| = c \\\\ \\therefore \\quad & \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & w_{1}^{*} = \\lambda w_{2}^{*} \\text{ (parallel)} \\\\ \\because \\quad & \\left \\| w_{1}^{*} \\right \\| = \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & \\left \\| \\lambda \\right \\| = 1 \\end{aligned} \\begin{aligned} & \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\|^{2} = \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\|^{2} \\rightarrow \\left \\| w_{1} \\right \\| = \\left \\| w_{2} \\right \\| = c, \\quad c \\text{ is a some scalar value} \\\\ \\because \\quad & (w = \\frac{w_{1}^{*} + w_{2}^{*}}{2}, \\quad b = \\frac{b_{1}^{*} + b_{2}^{*}}{2}) \\text{ is also a feasible solution} \\\\ \\therefore \\quad & c \\leq \\left \\| w \\right \\| = \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| = c \\\\ \\therefore \\quad & \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & w_{1}^{*} = \\lambda w_{2}^{*} \\text{ (parallel)} \\\\ \\because \\quad & \\left \\| w_{1}^{*} \\right \\| = \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & \\left \\| \\lambda \\right \\| = 1 \\end{aligned} \\lambda \\lambda = -1, w = \\overrightarrow{\\mathbf{0}} w = \\overrightarrow{\\mathbf{0}} \u662f\u4e0d\u53ef\u80fd\u7684\uff0c\u56e0\u4e3a \\left \\| w \\right \\| = 0 \\left \\| w \\right \\| = 0 \u4e0d\u662f\u4e00\u4e2a (1) \\sim (2) (1) \\sim (2) \u7684\u53ef\u884c\u89e3\uff0c\u56e0\u6b64\uff0c \\lambda \\lambda = 1\uff0c\u8fdb\u800c w_{1}^{*} = w_{2}^{*} w_{1}^{*} = w_{2}^{*} \u8bc1\u660e b_{1}^{*} = b_{2}^{*} b_{1}^{*} = b_{2}^{*} \\begin{aligned} & \\quad \\text{consider a positve and a negative instance } x_{1}^{+}, x_{1}^{-} \\in w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ & \\quad \\text{another positve negative instance } x_{2}^{+}, x_{2}^{-} \\in w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} w^{*} \\cdot x_{1}^{+} + b_{1}^{*} = 1 \\\\ w^{*} \\cdot x_{1}^{-} + b_{1}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{1}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{1}^{+} + w^{*} \\cdot x_{1}^{-}) \\\\ & \\quad \\begin{cases} w^{*} \\cdot x_{2}^{+} + b_{2}^{*} = 1 \\\\ w^{*} \\cdot x_{2}^{-} + b_{2}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{2}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{2}^{+} + w^{*} \\cdot x_{2}^{-}) \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] \\\\ \\because & \\quad \\text{instances } x_{1}^{+}, x_{1}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\text{ and} \\\\ & \\quad \\text{instance } x_{2}^{+}, x_{2}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} (+1) (w^{*} \\cdot x_{2}^{+} + b_{1}^{*}) \\geq 1 = w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\\\ (+1) (w^{*} \\cdot x_{1}^{+} + b_{2}^{*}) \\geq 1 = w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\\\ & \\quad \\begin{cases} (-1) (w^{*} \\cdot x_{2}^{-} + b_{1}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{1}^{-} + b_{1}^{*}) \\\\ (-1) (w^{*} \\cdot x_{1}^{-} + b_{2}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{2}^{-} + b_{2}^{*}) \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{1}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{2}^{-} + b_{2}^{*} \\\\ \\therefore & \\quad \\begin{cases} x_{1}^{+} = x_{2}^{+} \\\\ x_{1}^{-} = x_{2}^{-} \\end{cases} \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] = 0 \\\\ \\end{aligned} \\begin{aligned} & \\quad \\text{consider a positve and a negative instance } x_{1}^{+}, x_{1}^{-} \\in w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ & \\quad \\text{another positve negative instance } x_{2}^{+}, x_{2}^{-} \\in w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} w^{*} \\cdot x_{1}^{+} + b_{1}^{*} = 1 \\\\ w^{*} \\cdot x_{1}^{-} + b_{1}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{1}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{1}^{+} + w^{*} \\cdot x_{1}^{-}) \\\\ & \\quad \\begin{cases} w^{*} \\cdot x_{2}^{+} + b_{2}^{*} = 1 \\\\ w^{*} \\cdot x_{2}^{-} + b_{2}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{2}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{2}^{+} + w^{*} \\cdot x_{2}^{-}) \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] \\\\ \\because & \\quad \\text{instances } x_{1}^{+}, x_{1}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\text{ and} \\\\ & \\quad \\text{instance } x_{2}^{+}, x_{2}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} (+1) (w^{*} \\cdot x_{2}^{+} + b_{1}^{*}) \\geq 1 = w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\\\ (+1) (w^{*} \\cdot x_{1}^{+} + b_{2}^{*}) \\geq 1 = w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\\\ & \\quad \\begin{cases} (-1) (w^{*} \\cdot x_{2}^{-} + b_{1}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{1}^{-} + b_{1}^{*}) \\\\ (-1) (w^{*} \\cdot x_{1}^{-} + b_{2}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{2}^{-} + b_{2}^{*}) \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{1}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{2}^{-} + b_{2}^{*} \\\\ \\therefore & \\quad \\begin{cases} x_{1}^{+} = x_{2}^{+} \\\\ x_{1}^{-} = x_{2}^{-} \\end{cases} \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] = 0 \\\\ \\end{aligned} \u7efc\u4e0a\uff0c\u6700\u4f18\u89e3\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u652f\u6301\u5411\u91cf \uff08support vector\uff09\u6307\u7684\u662f\u51b3\u5b9a\u8d85\u5e73\u7684\u90a3\u4e9b\u5b9e\u4f8b\uff08\u5373\u6709\u6b63\u6837\u672c\u4e5f\u6709\u8d1f\u6837\u672c\uff09\u3002 (y_{i}) (w^{*} \\cdot x_{i} + b^{*}) = 1 (y_{i}) (w^{*} \\cdot x_{i} + b^{*}) = 1 \u56e0\u6b64\u6211\u4eec\u6709\u4e24\u4e2a\u5e73\u884c\u8d85\u5e73\u9762 H^{+} H^{+} \u548c H^{-} H^{-} \\begin{cases} H^{+}: \\quad w^{*} \\cdot x^{+} + b^{*} = 1 \\\\ H^{-}: \\quad w^{*} \\cdot x^{-} + b^{*} = -1 \\end{cases} \\begin{cases} H^{+}: \\quad w^{*} \\cdot x^{+} + b^{*} = 1 \\\\ H^{-}: \\quad w^{*} \\cdot x^{-} + b^{*} = -1 \\end{cases} \u95f4\u9694 \uff08Margin\uff09\u6307\u7684\u662f H^{+} H^{+} \u548c H^{-} H^{-} \u4e4b\u95f4\u7684\u8ddd\u79bb d_{H^{+}, H^{-}} = \\frac{\\left | (b^{*} - 1) - (b^{*} + 1) \\right |}{\\left | w^{*} \\right |} = \\frac{2}{\\left | w^{*} \\right |} d_{H^{+}, H^{-}} = \\frac{\\left | (b^{*} - 1) - (b^{*} + 1) \\right |}{\\left | w^{*} \\right |} = \\frac{2}{\\left | w^{*} \\right |} \u975e\u7ebf\u5f62SVM \u00b6 SMO \u00b6","title":"\u652f\u6301\u5411\u91cf\u673a"},{"location":"machine-learning/svm/#_1","text":"SVM \u5168\u79f0\u662f\u652f\u6301\u5411\u91cf\u673a\uff08support vector machine\uff09\uff0c\u662f\u4e00\u79cd\u5206\u7c7b\u7684\u7b97\u6cd5\uff0c\u53ef\u4ee5\u5904\u7406\u7ebf\u5f62\u5206\u7c7b\uff0c\u4e5f\u53ef\u4ee5\u5904\u7406\u975e\u7ebf\u6027\u5206\u7c7b\u3002","title":"\u7b80\u4ecb"},{"location":"machine-learning/svm/#_2","text":"\u8003\u8651\u4e00\u7ec4\u6570\u636e\u96c6\u5408 T = \\{ (x_{1}, y_{1}), (x_{2}, y_{2}), \\cdots, (x_{N}, y_{N}) \\} T = \\{ (x_{1}, y_{1}), (x_{2}, y_{2}), \\cdots, (x_{N}, y_{N}) \\} \u8fd9\u91cc x_{i} \\in R^{n}, y_{i} \\in \\{ +1, -1 \\}, i = 1, 2, ..., N x_{i} \\in R^{n}, y_{i} \\in \\{ +1, -1 \\}, i = 1, 2, ..., N","title":"\u539f\u7406"},{"location":"machine-learning/svm/#_3","text":"\u5982\u679c\u6211\u4eec\u80fd\u627e\u5230\u4e00\u4e2a\u8d85\u5e73\u9762\uff0c\u7528\u6765\u5206\u9694\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\uff0c\u5c31\u53ef\u4ee5\u6210\u4e3a\u7ebf\u5f62SVM\u3002 w^{*}x + b^{*} = 0 w^{*}x + b^{*} = 0 f(x) = \\text{sign}(w^{*}x + b^{*}) f(x) = \\text{sign}(w^{*}x + b^{*}) \u51fd\u6570\u95f4\u9694\uff08Functional margin\uff09 \u6307\u7684\u662f\u6240\u6709\u6837\u672c\u70b9\u4e0e\u8d85\u5e73\u9762\u7684\u8ddd\u79bb\u4e2d\u6700\u5c0f\u503c \\begin{aligned} & \\hat{\\gamma_{}} = \\min_{i=1, 2, \\cdots, N} \\hat{\\gamma_{i}} \\\\ & \\hat{\\gamma_{i}} = y_{i}(wx_{i}+b) \\end{aligned} \\begin{aligned} & \\hat{\\gamma_{}} = \\min_{i=1, 2, \\cdots, N} \\hat{\\gamma_{i}} \\\\ & \\hat{\\gamma_{i}} = y_{i}(wx_{i}+b) \\end{aligned} \u51e0\u4f55\u95f4\u9694\uff08Geometric margin\uff09 \u6307\u7684\u662f\u5355\u4f4d\u51fd\u6570\u95f4\u9694\uff0c\u5373 \\left \\| w \\right \\| = 1 \\left \\| w \\right \\| = 1 \u3002 \\begin{aligned} & \\gamma = \\min_{i=1, 2, \\cdots, N} \\gamma_{i} \\\\ & \\gamma_{i} = y_{i}(\\frac{w}{\\left \\| w \\right \\|}x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\end{aligned} \\begin{aligned} & \\gamma = \\min_{i=1, 2, \\cdots, N} \\gamma_{i} \\\\ & \\gamma_{i} = y_{i}(\\frac{w}{\\left \\| w \\right \\|}x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\end{aligned} \u51fd\u6570\u95f4\u9694\u548c\u51e0\u4f55\u95f4\u9694\u7684\u5173\u7cfb\u5982\u4e0b \\begin{aligned} & \\gamma_{i} = \\frac{\\hat{\\gamma_{i}}}{\\left \\| w \\right \\|} \\\\ & \\gamma = \\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\end{aligned} \\begin{aligned} & \\gamma_{i} = \\frac{\\hat{\\gamma_{i}}}{\\left \\| w \\right \\|} \\\\ & \\gamma = \\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\end{aligned} \u4f8b\u5982\u5728\u4e00\u4e2a2\u7ef4\u5e73\u9762\u91cc\uff0c\u8d85\u5e73\u9762 x_{1} + x_{2} = 0 x_{1} + x_{2} = 0 \u5b9e\u9645\u4e0a\u662f\u4e00\u6761\u7ebf\u3002\u5047\u8bbe\u6709\u4e00\u4e2a\u8d1f\u6837\u672c (2, 1)\uff0c\u90a3\u4e48\u95f4\u9694\u548c\u8ddd\u79bb\u5206\u522b\u5982\u4e0b \\begin{aligned} & w = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\ & \\frac{w}{\\left \\| w \\right \\|} = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\end{bmatrix}, \\quad b = 0 \\\\ & x = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} \\\\ & \\text{Functional margin is } y(w^{T}x + b) = -3 \\\\ & \\text{Geometric margin is } y(\\frac{w^{T} x + b}{\\left \\| w \\right \\|}) = -\\frac{3\\sqrt{2}}{2} \\end{aligned} \\begin{aligned} & w = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\ & \\frac{w}{\\left \\| w \\right \\|} = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\end{bmatrix}, \\quad b = 0 \\\\ & x = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} \\\\ & \\text{Functional margin is } y(w^{T}x + b) = -3 \\\\ & \\text{Geometric margin is } y(\\frac{w^{T} x + b}{\\left \\| w \\right \\|}) = -\\frac{3\\sqrt{2}}{2} \\end{aligned} SVM \u505a\u7684\u4e8b\u60c5\u5c31\u662f\u6700\u5927\u5316\u51e0\u4f55\u95f4\u9694\u3002 \\begin{aligned} & \\max_{w, b} \\gamma \\\\ & \\text{s.t.} \\quad y_{i}(\\frac{w}{\\left \\| w \\right \\|} \\cdot x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\geq \\gamma, \\quad i = 1, 2, \\cdots, N \\end{aligned} \\begin{aligned} & \\max_{w, b} \\gamma \\\\ & \\text{s.t.} \\quad y_{i}(\\frac{w}{\\left \\| w \\right \\|} \\cdot x_{i} + \\frac{b}{\\left \\| w \\right \\|}) \\geq \\gamma, \\quad i = 1, 2, \\cdots, N \\end{aligned} \u5f15\u5165\u51e0\u4f55\u95f4\u9694\u4e0e\u51fd\u6570\u95f4\u9694\u7684\u5173\u7cfb \\begin{cases} \\max_{w, b}\\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\\\ \\text{s.t.} \\quad y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma_{}}, \\quad i = 1, 2, \\cdots, N \\end{cases} \\begin{cases} \\max_{w, b}\\frac{\\hat{\\gamma_{}}}{\\left \\| w \\right \\|} \\\\ \\text{s.t.} \\quad y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma_{}}, \\quad i = 1, 2, \\cdots, N \\end{cases} \u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u4ee4 \\hat{\\gamma} = 1 \\hat{\\gamma} = 1 \uff0c\u56e0\u4e3a\u8fd9\u4e0d\u4f1a\u5f71\u54cd\u6700\u540e\u7684\u89e3\u3002 y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma} \\Leftrightarrow y_{i}(\\lambda w \\cdot x_{i} + \\lambda b) \\geq \\lambda \\hat{\\gamma} y_{i}(w \\cdot x_{i}+b) \\geq \\hat{\\gamma} \\Leftrightarrow y_{i}(\\lambda w \\cdot x_{i} + \\lambda b) \\geq \\lambda \\hat{\\gamma} \\max_{w, b}\\frac{1}{\\left \\| w \\right \\|} \\Leftrightarrow \\min_{w, b}\\frac{1}{2}\\left \\| w \\right \\|^{2} \\max_{w, b}\\frac{1}{\\left \\| w \\right \\|} \\Leftrightarrow \\min_{w, b}\\frac{1}{2}\\left \\| w \\right \\|^{2} \\begin{cases} \\min_{w, b} \\frac{1}{2} \\left \\| w \\right \\|^{2} & \\quad \\text{(1)}\\\\ \\text{s.t.} \\quad y_{i} (w \\cdot x_{i} + b) -1 \\geq 0, \\quad i = 1, 2, \\cdots, N & \\quad \\text{(2)} \\end{cases} \\begin{cases} \\min_{w, b} \\frac{1}{2} \\left \\| w \\right \\|^{2} & \\quad \\text{(1)}\\\\ \\text{s.t.} \\quad y_{i} (w \\cdot x_{i} + b) -1 \\geq 0, \\quad i = 1, 2, \\cdots, N & \\quad \\text{(2)} \\end{cases} \u8fd9\u662f\u4e00\u4e2a\u51f8\u4f18\u5316\u95ee\u9898\uff0c\u6700\u4f18\u89e3 w^{*}, b^{*} w^{*}, b^{*} \u4ee3\u8868\u4e00\u4e2a\u8d85\u5e73\u9762\u3002\u5982\u679c\u6570\u636e\u96c6\u662f\u7ebf\u5f62\u53ef\u5206\uff0c\u90a3\u4e48\u8d85\u5e73\u9762\u662f\u552f\u4e00\u7684\u3002\u8bc1\u660e\u5982\u4e0b\uff1a \u5b58\u5728\u6027 \uff1a\u6211\u4eec\u603b\u53ef\u4ee5\u627e\u5230\u4e00\u4e2a \\left \\| w \\right \\|^{2} \\left \\| w \\right \\|^{2} \uff0c\u5176\u6709\u4e00\u4e2a\u4e0b\u754c\u3002 \u552f\u4e00\u6027 \uff1a\u5047\u8bbe\u6211\u4eec\u6709\u4e24\u4e2a\u6700\u4f18\u89e3\uff08 w_{1}^{*} w_{1}^{*} , b_{1}^{*} b_{1}^{*} \uff09\u548c\uff08 w_{2}^{*} w_{2}^{*} , b_{2}^{*} b_{2}^{*} \uff09 \\begin{aligned} & \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\|^{2} = \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\|^{2} \\rightarrow \\left \\| w_{1} \\right \\| = \\left \\| w_{2} \\right \\| = c, \\quad c \\text{ is a some scalar value} \\\\ \\because \\quad & (w = \\frac{w_{1}^{*} + w_{2}^{*}}{2}, \\quad b = \\frac{b_{1}^{*} + b_{2}^{*}}{2}) \\text{ is also a feasible solution} \\\\ \\therefore \\quad & c \\leq \\left \\| w \\right \\| = \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| = c \\\\ \\therefore \\quad & \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & w_{1}^{*} = \\lambda w_{2}^{*} \\text{ (parallel)} \\\\ \\because \\quad & \\left \\| w_{1}^{*} \\right \\| = \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & \\left \\| \\lambda \\right \\| = 1 \\end{aligned} \\begin{aligned} & \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\|^{2} = \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\|^{2} \\rightarrow \\left \\| w_{1} \\right \\| = \\left \\| w_{2} \\right \\| = c, \\quad c \\text{ is a some scalar value} \\\\ \\because \\quad & (w = \\frac{w_{1}^{*} + w_{2}^{*}}{2}, \\quad b = \\frac{b_{1}^{*} + b_{2}^{*}}{2}) \\text{ is also a feasible solution} \\\\ \\therefore \\quad & c \\leq \\left \\| w \\right \\| = \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| = c \\\\ \\therefore \\quad & \\left \\| \\frac{w_{1}^{*} + w_{2}^{*}}{2} \\right \\| \\leq \\frac{1}{2} \\left \\| w_{1}^{*} \\right \\| + \\frac{1}{2} \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & w_{1}^{*} = \\lambda w_{2}^{*} \\text{ (parallel)} \\\\ \\because \\quad & \\left \\| w_{1}^{*} \\right \\| = \\left \\| w_{2}^{*} \\right \\| \\\\ \\therefore \\quad & \\left \\| \\lambda \\right \\| = 1 \\end{aligned} \\lambda \\lambda = -1, w = \\overrightarrow{\\mathbf{0}} w = \\overrightarrow{\\mathbf{0}} \u662f\u4e0d\u53ef\u80fd\u7684\uff0c\u56e0\u4e3a \\left \\| w \\right \\| = 0 \\left \\| w \\right \\| = 0 \u4e0d\u662f\u4e00\u4e2a (1) \\sim (2) (1) \\sim (2) \u7684\u53ef\u884c\u89e3\uff0c\u56e0\u6b64\uff0c \\lambda \\lambda = 1\uff0c\u8fdb\u800c w_{1}^{*} = w_{2}^{*} w_{1}^{*} = w_{2}^{*} \u8bc1\u660e b_{1}^{*} = b_{2}^{*} b_{1}^{*} = b_{2}^{*} \\begin{aligned} & \\quad \\text{consider a positve and a negative instance } x_{1}^{+}, x_{1}^{-} \\in w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ & \\quad \\text{another positve negative instance } x_{2}^{+}, x_{2}^{-} \\in w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} w^{*} \\cdot x_{1}^{+} + b_{1}^{*} = 1 \\\\ w^{*} \\cdot x_{1}^{-} + b_{1}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{1}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{1}^{+} + w^{*} \\cdot x_{1}^{-}) \\\\ & \\quad \\begin{cases} w^{*} \\cdot x_{2}^{+} + b_{2}^{*} = 1 \\\\ w^{*} \\cdot x_{2}^{-} + b_{2}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{2}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{2}^{+} + w^{*} \\cdot x_{2}^{-}) \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] \\\\ \\because & \\quad \\text{instances } x_{1}^{+}, x_{1}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\text{ and} \\\\ & \\quad \\text{instance } x_{2}^{+}, x_{2}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} (+1) (w^{*} \\cdot x_{2}^{+} + b_{1}^{*}) \\geq 1 = w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\\\ (+1) (w^{*} \\cdot x_{1}^{+} + b_{2}^{*}) \\geq 1 = w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\\\ & \\quad \\begin{cases} (-1) (w^{*} \\cdot x_{2}^{-} + b_{1}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{1}^{-} + b_{1}^{*}) \\\\ (-1) (w^{*} \\cdot x_{1}^{-} + b_{2}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{2}^{-} + b_{2}^{*}) \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{1}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{2}^{-} + b_{2}^{*} \\\\ \\therefore & \\quad \\begin{cases} x_{1}^{+} = x_{2}^{+} \\\\ x_{1}^{-} = x_{2}^{-} \\end{cases} \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] = 0 \\\\ \\end{aligned} \\begin{aligned} & \\quad \\text{consider a positve and a negative instance } x_{1}^{+}, x_{1}^{-} \\in w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ & \\quad \\text{another positve negative instance } x_{2}^{+}, x_{2}^{-} \\in w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} w^{*} \\cdot x_{1}^{+} + b_{1}^{*} = 1 \\\\ w^{*} \\cdot x_{1}^{-} + b_{1}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{1}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{1}^{+} + w^{*} \\cdot x_{1}^{-}) \\\\ & \\quad \\begin{cases} w^{*} \\cdot x_{2}^{+} + b_{2}^{*} = 1 \\\\ w^{*} \\cdot x_{2}^{-} + b_{2}^{*} = -1 \\\\ \\end{cases} \\rightarrow b_{2}^{*} = -\\frac{1}{2} (w^{*} \\cdot x_{2}^{+} + w^{*} \\cdot x_{2}^{-}) \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] \\\\ \\because & \\quad \\text{instances } x_{1}^{+}, x_{1}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{2}^{*} = \\overrightarrow{\\mathbf{0}} \\text{ and} \\\\ & \\quad \\text{instance } x_{2}^{+}, x_{2}^{-} \\text{ also satisfies hyperplane } w^{*} + b_{1}^{*} = \\overrightarrow{\\mathbf{0}} \\\\ \\therefore & \\quad \\begin{cases} (+1) (w^{*} \\cdot x_{2}^{+} + b_{1}^{*}) \\geq 1 = w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\\\ (+1) (w^{*} \\cdot x_{1}^{+} + b_{2}^{*}) \\geq 1 = w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{1}^{+} + b_{1}^{*} \\geq w^{*} \\cdot x_{2}^{+} + b_{2}^{*} \\\\ & \\quad \\begin{cases} (-1) (w^{*} \\cdot x_{2}^{-} + b_{1}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{1}^{-} + b_{1}^{*}) \\\\ (-1) (w^{*} \\cdot x_{1}^{-} + b_{2}^{*}) \\geq 1 = (-1) (w^{*} \\cdot x_{2}^{-} + b_{2}^{*}) \\end{cases} \\\\ & \\quad \\rightarrow w^{*} \\cdot x_{2}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{1}^{-} + b_{1}^{*} \\leq w^{*} \\cdot x_{2}^{-} + b_{2}^{*} \\\\ \\therefore & \\quad \\begin{cases} x_{1}^{+} = x_{2}^{+} \\\\ x_{1}^{-} = x_{2}^{-} \\end{cases} \\\\ \\therefore & \\quad b_{1}^{*} - b_{2}^{*} = -\\frac{1}{2} [w^{*} (x_{1}^{+} - x_{2}^{+}) + w^{*} (x_{1}^{-} - x_{2}^{-})] = 0 \\\\ \\end{aligned} \u7efc\u4e0a\uff0c\u6700\u4f18\u89e3\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u652f\u6301\u5411\u91cf \uff08support vector\uff09\u6307\u7684\u662f\u51b3\u5b9a\u8d85\u5e73\u7684\u90a3\u4e9b\u5b9e\u4f8b\uff08\u5373\u6709\u6b63\u6837\u672c\u4e5f\u6709\u8d1f\u6837\u672c\uff09\u3002 (y_{i}) (w^{*} \\cdot x_{i} + b^{*}) = 1 (y_{i}) (w^{*} \\cdot x_{i} + b^{*}) = 1 \u56e0\u6b64\u6211\u4eec\u6709\u4e24\u4e2a\u5e73\u884c\u8d85\u5e73\u9762 H^{+} H^{+} \u548c H^{-} H^{-} \\begin{cases} H^{+}: \\quad w^{*} \\cdot x^{+} + b^{*} = 1 \\\\ H^{-}: \\quad w^{*} \\cdot x^{-} + b^{*} = -1 \\end{cases} \\begin{cases} H^{+}: \\quad w^{*} \\cdot x^{+} + b^{*} = 1 \\\\ H^{-}: \\quad w^{*} \\cdot x^{-} + b^{*} = -1 \\end{cases} \u95f4\u9694 \uff08Margin\uff09\u6307\u7684\u662f H^{+} H^{+} \u548c H^{-} H^{-} \u4e4b\u95f4\u7684\u8ddd\u79bb d_{H^{+}, H^{-}} = \\frac{\\left | (b^{*} - 1) - (b^{*} + 1) \\right |}{\\left | w^{*} \\right |} = \\frac{2}{\\left | w^{*} \\right |} d_{H^{+}, H^{-}} = \\frac{\\left | (b^{*} - 1) - (b^{*} + 1) \\right |}{\\left | w^{*} \\right |} = \\frac{2}{\\left | w^{*} \\right |}","title":"\u7ebf\u5f62"},{"location":"machine-learning/svm/#svm","text":"","title":"\u975e\u7ebf\u5f62SVM"},{"location":"machine-learning/svm/#smo","text":"","title":"SMO"},{"location":"math/graph/","text":"\u57fa\u7840 \u00b6 \u6709\u5411\u56fe & \u65e0\u5411\u56fe \u00b6 \u6700\u5c0f\u751f\u6210\u6811 \u00b6 \u6700\u77ed\u8def\u5f84 \u00b6 \u5404\u79cd\u7b97\u6cd5\u5bf9\u6bd4 \u7b97\u6cd5 \u590d\u6742\u5ea6 \u6e90 \u7a00\u758f/\u7a20\u5bc6\u56fe \u4f18\u52bf \u52a3\u52bf Floyd O(V^{3}) O(V^{3}) \u591a\u6e90 \u7a20\u5bc6 \u5b9e\u73b0\u7b80\u5355 \u4e0d\u9002\u7528\u4e8e\u5927\u6570\u636e\u96c6 Heap-Dijkstra O(V\\log V) O(V\\log V) \u5355\u6e90 \u7a20\u5bc6 \u7a33\u5b9a \u4e0d\u9002\u7528\u4e8e\u8d1f\u6743\u91cd\u56fe Bellman-Ford VE VE \u5355\u6e90 \u7a00\u758f \u9002\u7528\u4e8e\u8d1f\u6743\u91cd\u56fe \u8d1f\u6743\u91cd\u6210\u73af\u56fe SPFA kE (k mean is 2) -- -- -- -- Bellman-Ford \u00b6 Dijkstra \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 int Dijkstra ( int ** mat , int n , int b , int e ) { int * dist = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = - 1 ; } bool * V = new bool [ n ]{}; V [ b ] = true ; dist [ b ] = 0 ; int curNode = b ; int num = 0 ; while ( num < n ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ curNode ][ j ] && ! V [ j ]) { if ( dist [ j ] == - 1 ) { dist [ j ] = dist [ curNode ] + mat [ curNode ][ j ]; } else if ( dist [ curNode ] + mat [ curNode ][ j ] < dist [ j ]) { dist [ j ] = dist [ curNode ] + mat [ curNode ][ j ]; } } } int min = ( 1ll << 31 ) - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( dist [ j ] != - 1 && ! V [ j ] && dist [ j ] < min ) { min = dist [ j ]; curNode = j ; } } V [ curNode ] = true ; num ++ ; } int res = dist [ e ]; delete [] dist ; delete [] V ; return res ; } void ShortPath () { int n = 4 ; int ** mat = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { mat [ i ] = new int [ n ]{}; } mat [ 1 - 1 ][ 2 - 1 ] = mat [ 2 - 1 ][ 1 - 1 ] = 5 ; mat [ 1 - 1 ][ 3 - 1 ] = mat [ 3 - 1 ][ 1 - 1 ] = 6 ; mat [ 2 - 1 ][ 4 - 1 ] = mat [ 4 - 1 ][ 2 - 1 ] = 8 ; mat [ 3 - 1 ][ 4 - 1 ] = mat [ 4 - 1 ][ 3 - 1 ] = 6 ; int b = 1 , e = 3 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( Dijkstra ( mat , n , i , j ) != Floyd ( mat , n , i , j )) { cout << i << ' ' << j << endl ; } } } cout << Dijkstra ( mat , n , b , e ) << endl ; cout << Floyd ( mat , n , b , e ) << endl ; for ( int i = 0 ; i < n ; i ++ ) { delete [] mat [ i ]; } delete [] mat ; } Floyd \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int Floyd ( int ** mat , int n , int b , int e ) { int INF = ( 1ll << 31 ) - 1 ; int ** dist = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = new int [ n ]{}; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { continue ; } if ( mat [ i ][ j ] == 0 ) { dist [ i ][ j ] = INF ; } else { dist [ i ][ j ] = mat [ i ][ j ]; } } } for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dist [ i ][ k ] == INF || dist [ k ][ j ] == INF ) { continue ; } if ( dist [ i ][ j ] == INF ) { dist [ i ][ j ] = dist [ i ][ k ] + dist [ k ][ j ]; } else if ( dist [ i ][ j ] > dist [ i ][ k ] + dist [ k ][ j ]) { dist [ i ][ j ] = dist [ i ][ k ] + dist [ k ][ j ]; } } } } int res = dist [ b ][ e ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dist [ i ]; } delete [] dist ; return res ; } A* \u00b6","title":"\u56fe\u8bba"},{"location":"math/graph/#_1","text":"","title":"\u57fa\u7840"},{"location":"math/graph/#_2","text":"","title":"\u6709\u5411\u56fe &amp; \u65e0\u5411\u56fe"},{"location":"math/graph/#_3","text":"","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"math/graph/#_4","text":"\u5404\u79cd\u7b97\u6cd5\u5bf9\u6bd4 \u7b97\u6cd5 \u590d\u6742\u5ea6 \u6e90 \u7a00\u758f/\u7a20\u5bc6\u56fe \u4f18\u52bf \u52a3\u52bf Floyd O(V^{3}) O(V^{3}) \u591a\u6e90 \u7a20\u5bc6 \u5b9e\u73b0\u7b80\u5355 \u4e0d\u9002\u7528\u4e8e\u5927\u6570\u636e\u96c6 Heap-Dijkstra O(V\\log V) O(V\\log V) \u5355\u6e90 \u7a20\u5bc6 \u7a33\u5b9a \u4e0d\u9002\u7528\u4e8e\u8d1f\u6743\u91cd\u56fe Bellman-Ford VE VE \u5355\u6e90 \u7a00\u758f \u9002\u7528\u4e8e\u8d1f\u6743\u91cd\u56fe \u8d1f\u6743\u91cd\u6210\u73af\u56fe SPFA kE (k mean is 2) -- -- -- --","title":"\u6700\u77ed\u8def\u5f84"},{"location":"math/graph/#bellman-ford","text":"","title":"Bellman-Ford"},{"location":"math/graph/#dijkstra","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 int Dijkstra ( int ** mat , int n , int b , int e ) { int * dist = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = - 1 ; } bool * V = new bool [ n ]{}; V [ b ] = true ; dist [ b ] = 0 ; int curNode = b ; int num = 0 ; while ( num < n ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ curNode ][ j ] && ! V [ j ]) { if ( dist [ j ] == - 1 ) { dist [ j ] = dist [ curNode ] + mat [ curNode ][ j ]; } else if ( dist [ curNode ] + mat [ curNode ][ j ] < dist [ j ]) { dist [ j ] = dist [ curNode ] + mat [ curNode ][ j ]; } } } int min = ( 1ll << 31 ) - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( dist [ j ] != - 1 && ! V [ j ] && dist [ j ] < min ) { min = dist [ j ]; curNode = j ; } } V [ curNode ] = true ; num ++ ; } int res = dist [ e ]; delete [] dist ; delete [] V ; return res ; } void ShortPath () { int n = 4 ; int ** mat = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { mat [ i ] = new int [ n ]{}; } mat [ 1 - 1 ][ 2 - 1 ] = mat [ 2 - 1 ][ 1 - 1 ] = 5 ; mat [ 1 - 1 ][ 3 - 1 ] = mat [ 3 - 1 ][ 1 - 1 ] = 6 ; mat [ 2 - 1 ][ 4 - 1 ] = mat [ 4 - 1 ][ 2 - 1 ] = 8 ; mat [ 3 - 1 ][ 4 - 1 ] = mat [ 4 - 1 ][ 3 - 1 ] = 6 ; int b = 1 , e = 3 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( Dijkstra ( mat , n , i , j ) != Floyd ( mat , n , i , j )) { cout << i << ' ' << j << endl ; } } } cout << Dijkstra ( mat , n , b , e ) << endl ; cout << Floyd ( mat , n , b , e ) << endl ; for ( int i = 0 ; i < n ; i ++ ) { delete [] mat [ i ]; } delete [] mat ; }","title":"Dijkstra"},{"location":"math/graph/#floyd","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int Floyd ( int ** mat , int n , int b , int e ) { int INF = ( 1ll << 31 ) - 1 ; int ** dist = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = new int [ n ]{}; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { continue ; } if ( mat [ i ][ j ] == 0 ) { dist [ i ][ j ] = INF ; } else { dist [ i ][ j ] = mat [ i ][ j ]; } } } for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dist [ i ][ k ] == INF || dist [ k ][ j ] == INF ) { continue ; } if ( dist [ i ][ j ] == INF ) { dist [ i ][ j ] = dist [ i ][ k ] + dist [ k ][ j ]; } else if ( dist [ i ][ j ] > dist [ i ][ k ] + dist [ k ][ j ]) { dist [ i ][ j ] = dist [ i ][ k ] + dist [ k ][ j ]; } } } } int res = dist [ b ][ e ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dist [ i ]; } delete [] dist ; return res ; }","title":"Floyd"},{"location":"math/graph/#a","text":"","title":"A*"},{"location":"math/linear-algebra/","text":"\u57fa\u7840 \u00b6","title":"\u7ebf\u6027\u4ee3\u6570"},{"location":"math/linear-algebra/#_1","text":"","title":"\u57fa\u7840"},{"location":"math/prob-stat/","text":"\u6982\u7387 \u00b6 \u8054\u5408\u6982\u7387 Joint probability \u00b6 \\begin{aligned} P(X = x \\text{ and } Y = y) &= P(X = x \\mid Y = y) P(y = y) \\\\ &= P(Y = y \\mid X = x) P(X = x) \\end{aligned} \\begin{aligned} P(X = x \\text{ and } Y = y) &= P(X = x \\mid Y = y) P(y = y) \\\\ &= P(Y = y \\mid X = x) P(X = x) \\end{aligned} \u6ee1\u8db3 \\begin{aligned} & \\sum_{x} \\sum_{y} P(X = x \\text{ and } Y = y) = 1 \\\\ & \\int_{x} \\int_{y} f_{X, Y} (x, y) dy dx = 1 \\end{aligned} \\begin{aligned} & \\sum_{x} \\sum_{y} P(X = x \\text{ and } Y = y) = 1 \\\\ & \\int_{x} \\int_{y} f_{X, Y} (x, y) dy dx = 1 \\end{aligned} \u8fb9\u9645\u6982\u7387 Marginal Probability \u00b6 \\begin{aligned} & P(X = x) = \\sum_{Y} P(X = a, Y = b) \\\\ & P(Y = b) = \\sum_{X} P(X = a, Y = b) \\end{aligned} \\begin{aligned} & P(X = x) = \\sum_{Y} P(X = a, Y = b) \\\\ & P(Y = b) = \\sum_{X} P(X = a, Y = b) \\end{aligned} \u6761\u4ef6\u6982\u7387 Conditional probability \u00b6 \\begin{aligned} & \\sum_{x} P(X = a \\mid Y = b) = 1 \\\\ & P(X = a \\mid Y = b) = \\frac{P(X = a, Y = b)}{P(Y = b)} \\end{aligned} \\begin{aligned} & \\sum_{x} P(X = a \\mid Y = b) = 1 \\\\ & P(X = a \\mid Y = b) = \\frac{P(X = a, Y = b)}{P(Y = b)} \\end{aligned} \u671f\u671b Expect \u00b6 \\begin{aligned} & \\text{E}(X, Y) = \\sum_{i} x_{i} p(x_{i}), \\quad i = 1, 2, \\cdots, n \\\\ & \\text{E}[f] = \\sum_{i} f(x_{i}) p(x_{i}, y_{i}), \\quad i = 1, 2, \\cdots n \\end{aligned} \\begin{aligned} & \\text{E}(X, Y) = \\sum_{i} x_{i} p(x_{i}), \\quad i = 1, 2, \\cdots, n \\\\ & \\text{E}[f] = \\sum_{i} f(x_{i}) p(x_{i}, y_{i}), \\quad i = 1, 2, \\cdots n \\end{aligned} \u65b9\u5dee Variance \u00b6 \\text{Var}(f(x)) = \\text{E}[(f(x) - \\text{E}[f(x)])^{2}] \\text{Var}(f(x)) = \\text{E}[(f(x) - \\text{E}[f(x)])^{2}] \u4e24\u4e2a\u72ec\u7acb\u7684\u6807\u51c6\u6b63\u6001\u5206\u5e03 X \\sim (0, 1) X \\sim (0, 1) Y \\sim (0, 1) Y \\sim (0, 1) \uff0c\u4e24\u8005\u7684\u4e58\u79ef\u4e5f\u662f\u670d\u4ece\u6807\u51c6\u6b63\u6001\u5206\u5e03 E[XY] = E[x] * E[Y] = 0 * 0 = 0 E[XY] = E[x] * E[Y] = 0 * 0 = 0 \\begin{aligned} D[XY] &= E[(XY)^{2}] - (E[XY])^{2} \\\\ &= E[X^{2}Y^{2}] - (E[X]E[Y])^{2} \\\\ &= E[X^{2}]E[Y^{2}] - (E[X])^{2}(E[Y])^{2} \\\\ &= (E[X^{2}] - (E[X])^{2})(E[Y^{2}] - (E[Y])^{2}) - 0 \\\\ &= D[X]D[Y] \\\\ &= 1 \\end{aligned} \\begin{aligned} D[XY] &= E[(XY)^{2}] - (E[XY])^{2} \\\\ &= E[X^{2}Y^{2}] - (E[X]E[Y])^{2} \\\\ &= E[X^{2}]E[Y^{2}] - (E[X])^{2}(E[Y])^{2} \\\\ &= (E[X^{2}] - (E[X])^{2})(E[Y^{2}] - (E[Y])^{2}) - 0 \\\\ &= D[X]D[Y] \\\\ &= 1 \\end{aligned} \u4e24\u4e2a\u6b63\u6001\u5206\u5e03\u7684\u4e4b\u548c\u4e5f\u662f\u670d\u4ece\u6b63\u6001\u5206\u5e03 N(\\mu_{1} + \\mu_{2}, \\sigma_{1}^{2} + \\sigma_{2}^{2}) N(\\mu_{1} + \\mu_{2}, \\sigma_{1}^{2} + \\sigma_{2}^{2}) \u6837\u672c\u65b9\u5dee Sample Variance \u00b6 \u8bbe\u6837\u672c\u5747\u503c\uff08sample mean\uff09\u662f \\bar{X} \\bar{X} , \u6837\u672c\u65b9\u5dee\uff08sample variance\uff09\u662f S^{2} S^{2} , \u603b\u4f53\u5747\u503c\uff08ensemble average\uff09\u662f \\mu \\mu , \u603b\u4f53\u65b9\u5dee\uff08ensemble variance\uff09\u662f \\sigma^{2} \\sigma^{2} S^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} S^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} \u65e0\u504f\u4f30\u8ba1 Unbiased Estimate \u00b6 \u5047\u8bbe\u6211\u4eec\u60f3\u77e5\u9053\u4e00\u4e2a\u5927\u5b66\u7684\u5b66\u751f\u8eab\u9ad8\uff0c\u8c03\u67e5\u6bcf\u4e00\u4e2a\u5b66\u751f\u4e0d\u592a\u73b0\u5b9e\uff08\u4f46\u662f\u51c6\u786e\u7684\uff09\uff0c\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u968f\u673a\u6311\u9009100\u4f4d\u540c\u5b66\uff0c\u6c42\u4e00\u4e2a\u5747\u503c\u3002\u4e3a\u4e86\u83b7\u5f97\u4e00\u4e2a\u7cbe\u786e\u7684\u4f30\u8ba1\uff0c\u6211\u4eec\u91cd\u590d\u5b9e\u9a8c\uff0c\u7136\u540e\u8ba1\u7b97\u6837\u672c\u5747\u503c\uff0c \\bar{X}_{2} \\bar{X}_{2} , \\bar{X}_{3} \\bar{X}_{3} , \\cdots \\cdots , \\bar{X}_{k} \\bar{X}_{k} \u3002\u8fd9\u91cc \\bar{X} \\bar{X} \u5c31\u79f0\u4e3a\u4e00\u4e2a\u968f\u673a\u53d8\u91cf\uff0c \\bar{X}_{i} \\bar{X}_{i} \u662f\u5176\u53ef\u80fd\u7684\u4e00\u4e2a\u503c\u3002 \u591a\u6b21\u91cd\u590d\u5b9e\u9a8c\u4e0b\uff0c\u671f\u671b\u8d8b\u5411\u4e8e\u771f\u503c\u3002\u6837\u672c\u65b9\u5dee\u5982\u4e0b\uff1a S^{2} = \\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} S^{2} = \\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} \u6709 \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E((\\bar{X} - \\mu)^{2}) \\\\ & = Var(X) - Var(\\bar{X}) \\\\ & = \\sigma^{2} - \\frac{1}{n}\\sigma^{2} \\\\ & = \\frac{n-1}{n}\\sigma^{2} \\leq \\sigma^{2} \\end{aligned} \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E((\\bar{X} - \\mu)^{2}) \\\\ & = Var(X) - Var(\\bar{X}) \\\\ & = \\sigma^{2} - \\frac{1}{n}\\sigma^{2} \\\\ & = \\frac{n-1}{n}\\sigma^{2} \\leq \\sigma^{2} \\end{aligned} \u4e8e\u662f E(S^{2}) = \\frac{n-1}{n}\\sigma^{2} E(S^{2}) = \\frac{n-1}{n}\\sigma^{2} \u5982\u679c\u6211\u4eec\u5904\u4ee5n\uff0c\u6837\u672c\u65b9\u5dee\u4f1a\u6bd4\u603b\u4f53\u65b9\u5dee\u8981\u5c0f\uff0c\u56e0\u6b64\u9700\u8981\u4e58\u4e00\u4e2a S^{2} S^{2} by \\frac{n}{n-1} \\frac{n}{n-1} \u5f97\u5230\u65e0\u504f\u6837\u672c\u65b9\u5dee S^{2} = \\frac{n}{n-1}(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} S^{2} = \\frac{n}{n-1}(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} \u56e0\u6b64 \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n-1}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E(\\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - \\frac{n}{n-1}E((\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}\\sigma^{2} - \\frac{n}{n-1}\\frac{\\sigma^{2}}{n} \\\\ & = \\sigma^{2} \\end{aligned} \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n-1}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E(\\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - \\frac{n}{n-1}E((\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}\\sigma^{2} - \\frac{n}{n-1}\\frac{\\sigma^{2}}{n} \\\\ & = \\sigma^{2} \\end{aligned} \u534f\u65b9\u5dee Covariance \u00b6 \\text{Cov}(f(x), g(y)) = \\text{E}[(f(x) - \\text{E}[f(x)])(g(y) - \\text{E}[g(y)])] \\text{Cov}(f(x), g(y)) = \\text{E}[(f(x) - \\text{E}[f(x)])(g(y) - \\text{E}[g(y)])] \u9898\u76ee \u00b6 \u4e24\u4eba\u540c\u751f\u65e5\u7684\u6982\u7387 \u00b6 \u5047\u8bbe\u6709 k \u4e2a\u4eba\uff0c\u6bcf\u4e00\u4e2a\u7684\u751f\u65e5\u968f\u673a\u843d\u5165365\uff08\u4e0d\u8003\u8651\u95f0\u5e74\uff09\u4e2d\u7684\u6bcf\u4e00\u5929\u3002\u671f\u671b\u81f3\u5c11\u67092\u4e2a\u4eba\u7684\u751f\u65e5\u662f\u540c\u4e00\u5929\u7684\u60c5\u51b5\u4e0b\uff0ck \u7684\u6700\u5c0f\u503c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d\u5bf9\u4efb\u610f\u4e00\u5bf9\u4eba i\u3001j \u800c\u8a00\uff0c\u6211\u4eec\u5b9a\u4e00\u4e2a\u968f\u673a\u53d8\u91cf\uff08indicator\uff09 X_{ij} X_{ij} \uff0ci \u548c j \u540c\u4e00\u5929\u7684\u751f\u65e5\u4e3a 1\uff1b\u5426\u5219\uff0c\u4e3a 0\u3002 X_{ij} = \\begin{cases} 1, \\quad B_{i}=B_{j} \\\\ 0, \\quad \\text{otherwise} \\end{cases} X_{ij} = \\begin{cases} 1, \\quad B_{i}=B_{j} \\\\ 0, \\quad \\text{otherwise} \\end{cases} i \u548c j \u7684\u751f\u65e5\u662f\u540c\u4e00\u5929\u7684\u6982\u7387 Pr[ B_{i}=B_{j} ]= \\frac{1}{365}*\\frac{1}{365}*365 = \\frac{1}{365} Pr[ B_{i}=B_{j} ]= \\frac{1}{365}*\\frac{1}{365}*365 = \\frac{1}{365} \u671f\u671b \\begin{aligned} E[ X_{ij} ] & = \\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}X_{ij}Pr[ B_{i}=B_{j} ] \\\\ & = \\frac{1}{365}{}\\sum_{i=1}^{k}\\sum_{j=i+1}^{k}X_{ij} \\\\ & = \\frac{1}{365}*\\sum_{i=1}^{k-1}[ k-(i+1)+1 ] \\\\ & = \\frac{1}{365}*(\\sum_{i=1}^{k-1}k-\\sum_{i=1}^{k-1}i) \\\\ & = \\frac{1}{365}*[ k(k-1)-\\frac{k(k-1)}{2} ] \\\\ & = \\frac{1}{365}*\\frac{k(k-1)}{2}=1 \\end{aligned} \\begin{aligned} E[ X_{ij} ] & = \\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}X_{ij}Pr[ B_{i}=B_{j} ] \\\\ & = \\frac{1}{365}{}\\sum_{i=1}^{k}\\sum_{j=i+1}^{k}X_{ij} \\\\ & = \\frac{1}{365}*\\sum_{i=1}^{k-1}[ k-(i+1)+1 ] \\\\ & = \\frac{1}{365}*(\\sum_{i=1}^{k-1}k-\\sum_{i=1}^{k-1}i) \\\\ & = \\frac{1}{365}*[ k(k-1)-\\frac{k(k-1)}{2} ] \\\\ & = \\frac{1}{365}*\\frac{k(k-1)}{2}=1 \\end{aligned} \u6c42\u5f97 \\begin{aligned} & k=1 \\pm 27.02 \\\\ & k = 28 \\end{aligned} \\begin{aligned} & k=1 \\pm 27.02 \\\\ & k = 28 \\end{aligned}","title":"\u6982\u7387&\u7edf\u8ba1"},{"location":"math/prob-stat/#_1","text":"","title":"\u6982\u7387"},{"location":"math/prob-stat/#joint-probability","text":"\\begin{aligned} P(X = x \\text{ and } Y = y) &= P(X = x \\mid Y = y) P(y = y) \\\\ &= P(Y = y \\mid X = x) P(X = x) \\end{aligned} \\begin{aligned} P(X = x \\text{ and } Y = y) &= P(X = x \\mid Y = y) P(y = y) \\\\ &= P(Y = y \\mid X = x) P(X = x) \\end{aligned} \u6ee1\u8db3 \\begin{aligned} & \\sum_{x} \\sum_{y} P(X = x \\text{ and } Y = y) = 1 \\\\ & \\int_{x} \\int_{y} f_{X, Y} (x, y) dy dx = 1 \\end{aligned} \\begin{aligned} & \\sum_{x} \\sum_{y} P(X = x \\text{ and } Y = y) = 1 \\\\ & \\int_{x} \\int_{y} f_{X, Y} (x, y) dy dx = 1 \\end{aligned}","title":"\u8054\u5408\u6982\u7387 Joint probability"},{"location":"math/prob-stat/#marginal-probability","text":"\\begin{aligned} & P(X = x) = \\sum_{Y} P(X = a, Y = b) \\\\ & P(Y = b) = \\sum_{X} P(X = a, Y = b) \\end{aligned} \\begin{aligned} & P(X = x) = \\sum_{Y} P(X = a, Y = b) \\\\ & P(Y = b) = \\sum_{X} P(X = a, Y = b) \\end{aligned}","title":"\u8fb9\u9645\u6982\u7387 Marginal Probability"},{"location":"math/prob-stat/#conditional-probability","text":"\\begin{aligned} & \\sum_{x} P(X = a \\mid Y = b) = 1 \\\\ & P(X = a \\mid Y = b) = \\frac{P(X = a, Y = b)}{P(Y = b)} \\end{aligned} \\begin{aligned} & \\sum_{x} P(X = a \\mid Y = b) = 1 \\\\ & P(X = a \\mid Y = b) = \\frac{P(X = a, Y = b)}{P(Y = b)} \\end{aligned}","title":"\u6761\u4ef6\u6982\u7387 Conditional probability"},{"location":"math/prob-stat/#expect","text":"\\begin{aligned} & \\text{E}(X, Y) = \\sum_{i} x_{i} p(x_{i}), \\quad i = 1, 2, \\cdots, n \\\\ & \\text{E}[f] = \\sum_{i} f(x_{i}) p(x_{i}, y_{i}), \\quad i = 1, 2, \\cdots n \\end{aligned} \\begin{aligned} & \\text{E}(X, Y) = \\sum_{i} x_{i} p(x_{i}), \\quad i = 1, 2, \\cdots, n \\\\ & \\text{E}[f] = \\sum_{i} f(x_{i}) p(x_{i}, y_{i}), \\quad i = 1, 2, \\cdots n \\end{aligned}","title":"\u671f\u671b Expect"},{"location":"math/prob-stat/#variance","text":"\\text{Var}(f(x)) = \\text{E}[(f(x) - \\text{E}[f(x)])^{2}] \\text{Var}(f(x)) = \\text{E}[(f(x) - \\text{E}[f(x)])^{2}] \u4e24\u4e2a\u72ec\u7acb\u7684\u6807\u51c6\u6b63\u6001\u5206\u5e03 X \\sim (0, 1) X \\sim (0, 1) Y \\sim (0, 1) Y \\sim (0, 1) \uff0c\u4e24\u8005\u7684\u4e58\u79ef\u4e5f\u662f\u670d\u4ece\u6807\u51c6\u6b63\u6001\u5206\u5e03 E[XY] = E[x] * E[Y] = 0 * 0 = 0 E[XY] = E[x] * E[Y] = 0 * 0 = 0 \\begin{aligned} D[XY] &= E[(XY)^{2}] - (E[XY])^{2} \\\\ &= E[X^{2}Y^{2}] - (E[X]E[Y])^{2} \\\\ &= E[X^{2}]E[Y^{2}] - (E[X])^{2}(E[Y])^{2} \\\\ &= (E[X^{2}] - (E[X])^{2})(E[Y^{2}] - (E[Y])^{2}) - 0 \\\\ &= D[X]D[Y] \\\\ &= 1 \\end{aligned} \\begin{aligned} D[XY] &= E[(XY)^{2}] - (E[XY])^{2} \\\\ &= E[X^{2}Y^{2}] - (E[X]E[Y])^{2} \\\\ &= E[X^{2}]E[Y^{2}] - (E[X])^{2}(E[Y])^{2} \\\\ &= (E[X^{2}] - (E[X])^{2})(E[Y^{2}] - (E[Y])^{2}) - 0 \\\\ &= D[X]D[Y] \\\\ &= 1 \\end{aligned} \u4e24\u4e2a\u6b63\u6001\u5206\u5e03\u7684\u4e4b\u548c\u4e5f\u662f\u670d\u4ece\u6b63\u6001\u5206\u5e03 N(\\mu_{1} + \\mu_{2}, \\sigma_{1}^{2} + \\sigma_{2}^{2}) N(\\mu_{1} + \\mu_{2}, \\sigma_{1}^{2} + \\sigma_{2}^{2})","title":"\u65b9\u5dee Variance"},{"location":"math/prob-stat/#sample-variance","text":"\u8bbe\u6837\u672c\u5747\u503c\uff08sample mean\uff09\u662f \\bar{X} \\bar{X} , \u6837\u672c\u65b9\u5dee\uff08sample variance\uff09\u662f S^{2} S^{2} , \u603b\u4f53\u5747\u503c\uff08ensemble average\uff09\u662f \\mu \\mu , \u603b\u4f53\u65b9\u5dee\uff08ensemble variance\uff09\u662f \\sigma^{2} \\sigma^{2} S^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} S^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}","title":"\u6837\u672c\u65b9\u5dee Sample Variance"},{"location":"math/prob-stat/#unbiased-estimate","text":"\u5047\u8bbe\u6211\u4eec\u60f3\u77e5\u9053\u4e00\u4e2a\u5927\u5b66\u7684\u5b66\u751f\u8eab\u9ad8\uff0c\u8c03\u67e5\u6bcf\u4e00\u4e2a\u5b66\u751f\u4e0d\u592a\u73b0\u5b9e\uff08\u4f46\u662f\u51c6\u786e\u7684\uff09\uff0c\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u968f\u673a\u6311\u9009100\u4f4d\u540c\u5b66\uff0c\u6c42\u4e00\u4e2a\u5747\u503c\u3002\u4e3a\u4e86\u83b7\u5f97\u4e00\u4e2a\u7cbe\u786e\u7684\u4f30\u8ba1\uff0c\u6211\u4eec\u91cd\u590d\u5b9e\u9a8c\uff0c\u7136\u540e\u8ba1\u7b97\u6837\u672c\u5747\u503c\uff0c \\bar{X}_{2} \\bar{X}_{2} , \\bar{X}_{3} \\bar{X}_{3} , \\cdots \\cdots , \\bar{X}_{k} \\bar{X}_{k} \u3002\u8fd9\u91cc \\bar{X} \\bar{X} \u5c31\u79f0\u4e3a\u4e00\u4e2a\u968f\u673a\u53d8\u91cf\uff0c \\bar{X}_{i} \\bar{X}_{i} \u662f\u5176\u53ef\u80fd\u7684\u4e00\u4e2a\u503c\u3002 \u591a\u6b21\u91cd\u590d\u5b9e\u9a8c\u4e0b\uff0c\u671f\u671b\u8d8b\u5411\u4e8e\u771f\u503c\u3002\u6837\u672c\u65b9\u5dee\u5982\u4e0b\uff1a S^{2} = \\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} S^{2} = \\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} \u6709 \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E((\\bar{X} - \\mu)^{2}) \\\\ & = Var(X) - Var(\\bar{X}) \\\\ & = \\sigma^{2} - \\frac{1}{n}\\sigma^{2} \\\\ & = \\frac{n-1}{n}\\sigma^{2} \\leq \\sigma^{2} \\end{aligned} \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - 2(\\bar{X} - \\mu)(\\bar{X}- \\mu) + (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - (\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E((\\bar{X} - \\mu)^{2}) \\\\ & = Var(X) - Var(\\bar{X}) \\\\ & = \\sigma^{2} - \\frac{1}{n}\\sigma^{2} \\\\ & = \\frac{n-1}{n}\\sigma^{2} \\leq \\sigma^{2} \\end{aligned} \u4e8e\u662f E(S^{2}) = \\frac{n-1}{n}\\sigma^{2} E(S^{2}) = \\frac{n-1}{n}\\sigma^{2} \u5982\u679c\u6211\u4eec\u5904\u4ee5n\uff0c\u6837\u672c\u65b9\u5dee\u4f1a\u6bd4\u603b\u4f53\u65b9\u5dee\u8981\u5c0f\uff0c\u56e0\u6b64\u9700\u8981\u4e58\u4e00\u4e2a S^{2} S^{2} by \\frac{n}{n-1} \\frac{n}{n-1} \u5f97\u5230\u65e0\u504f\u6837\u672c\u65b9\u5dee S^{2} = \\frac{n}{n-1}(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} S^{2} = \\frac{n}{n-1}(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2} \u56e0\u6b64 \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n-1}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E(\\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - \\frac{n}{n-1}E((\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}\\sigma^{2} - \\frac{n}{n-1}\\frac{\\sigma^{2}}{n} \\\\ & = \\sigma^{2} \\end{aligned} \\begin{aligned} E(S^{2}) & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}(x_{i} - \\bar{X})^{2}) = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu) - (\\bar{X} - \\mu))^{2}) \\\\ & = E(\\frac{1}{n-1} \\sum_{i=1}^{n}((x_{i} - \\mu)^{2} - 2(x_{i} - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^{2})) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{1}{n-1}\\sum_{i=1}^{n}2(x_{i} - \\mu)(\\bar{X} - \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{1}{n-1}\\sum_{i=1}^{n}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{2n}{n-1}(\\bar{X} - \\mu)(\\bar{X}- \\mu) + \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2} - \\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = E(\\frac{1}{n-1}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - E(\\frac{n}{n-1}(\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}E(\\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\mu)^{2}) - \\frac{n}{n-1}E((\\bar{X} - \\mu)^{2}) \\\\ & = \\frac{n}{n-1}\\sigma^{2} - \\frac{n}{n-1}\\frac{\\sigma^{2}}{n} \\\\ & = \\sigma^{2} \\end{aligned}","title":"\u65e0\u504f\u4f30\u8ba1 Unbiased Estimate"},{"location":"math/prob-stat/#covariance","text":"\\text{Cov}(f(x), g(y)) = \\text{E}[(f(x) - \\text{E}[f(x)])(g(y) - \\text{E}[g(y)])] \\text{Cov}(f(x), g(y)) = \\text{E}[(f(x) - \\text{E}[f(x)])(g(y) - \\text{E}[g(y)])]","title":"\u534f\u65b9\u5dee Covariance"},{"location":"math/prob-stat/#_2","text":"","title":"\u9898\u76ee"},{"location":"math/prob-stat/#_3","text":"\u5047\u8bbe\u6709 k \u4e2a\u4eba\uff0c\u6bcf\u4e00\u4e2a\u7684\u751f\u65e5\u968f\u673a\u843d\u5165365\uff08\u4e0d\u8003\u8651\u95f0\u5e74\uff09\u4e2d\u7684\u6bcf\u4e00\u5929\u3002\u671f\u671b\u81f3\u5c11\u67092\u4e2a\u4eba\u7684\u751f\u65e5\u662f\u540c\u4e00\u5929\u7684\u60c5\u51b5\u4e0b\uff0ck \u7684\u6700\u5c0f\u503c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d\u5bf9\u4efb\u610f\u4e00\u5bf9\u4eba i\u3001j \u800c\u8a00\uff0c\u6211\u4eec\u5b9a\u4e00\u4e2a\u968f\u673a\u53d8\u91cf\uff08indicator\uff09 X_{ij} X_{ij} \uff0ci \u548c j \u540c\u4e00\u5929\u7684\u751f\u65e5\u4e3a 1\uff1b\u5426\u5219\uff0c\u4e3a 0\u3002 X_{ij} = \\begin{cases} 1, \\quad B_{i}=B_{j} \\\\ 0, \\quad \\text{otherwise} \\end{cases} X_{ij} = \\begin{cases} 1, \\quad B_{i}=B_{j} \\\\ 0, \\quad \\text{otherwise} \\end{cases} i \u548c j \u7684\u751f\u65e5\u662f\u540c\u4e00\u5929\u7684\u6982\u7387 Pr[ B_{i}=B_{j} ]= \\frac{1}{365}*\\frac{1}{365}*365 = \\frac{1}{365} Pr[ B_{i}=B_{j} ]= \\frac{1}{365}*\\frac{1}{365}*365 = \\frac{1}{365} \u671f\u671b \\begin{aligned} E[ X_{ij} ] & = \\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}X_{ij}Pr[ B_{i}=B_{j} ] \\\\ & = \\frac{1}{365}{}\\sum_{i=1}^{k}\\sum_{j=i+1}^{k}X_{ij} \\\\ & = \\frac{1}{365}*\\sum_{i=1}^{k-1}[ k-(i+1)+1 ] \\\\ & = \\frac{1}{365}*(\\sum_{i=1}^{k-1}k-\\sum_{i=1}^{k-1}i) \\\\ & = \\frac{1}{365}*[ k(k-1)-\\frac{k(k-1)}{2} ] \\\\ & = \\frac{1}{365}*\\frac{k(k-1)}{2}=1 \\end{aligned} \\begin{aligned} E[ X_{ij} ] & = \\sum_{i=1}^{k-1}\\sum_{j=i+1}^{k}X_{ij}Pr[ B_{i}=B_{j} ] \\\\ & = \\frac{1}{365}{}\\sum_{i=1}^{k}\\sum_{j=i+1}^{k}X_{ij} \\\\ & = \\frac{1}{365}*\\sum_{i=1}^{k-1}[ k-(i+1)+1 ] \\\\ & = \\frac{1}{365}*(\\sum_{i=1}^{k-1}k-\\sum_{i=1}^{k-1}i) \\\\ & = \\frac{1}{365}*[ k(k-1)-\\frac{k(k-1)}{2} ] \\\\ & = \\frac{1}{365}*\\frac{k(k-1)}{2}=1 \\end{aligned} \u6c42\u5f97 \\begin{aligned} & k=1 \\pm 27.02 \\\\ & k = 28 \\end{aligned} \\begin{aligned} & k=1 \\pm 27.02 \\\\ & k = 28 \\end{aligned}","title":"\u4e24\u4eba\u540c\u751f\u65e5\u7684\u6982\u7387"}]}