{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"intro/","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"\u4ecb\u7ecd"},{"location":"intro/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"intro/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"intro/#project-layout","text":"1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"algo/jsoffer/","text":"JS-offer \u00b6 02. \u66ff\u6362\u7a7a\u683c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u6bcf\u4e2a\u7a7a\u683c\u66ff\u6362\u6210\u201c%20\u201d\u3002\u4f8b\u5982\uff0c\u5f53\u5b57\u7b26\u4e32\u4e3aWe Are Happy.\u5219\u7ecf\u8fc7\u66ff\u6362\u4e4b\u540e\u7684\u5b57\u7b26\u4e32\u4e3aWe%20Are%20Happy\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void replaceSpace ( char * str , int length ) { if ( length == 0 ) { return ; } int nSpace = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( str [ i ] == ' ' ) { nSpace ++ ; } } int len = length + 2 * nSpace ; for ( int i = length -1 , j = len -1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) { str [ j -- ] = '0' ; str [ j -- ] = '2' ; str [ j -- ] = '%' ; } else { str [ j -- ] = str [ i ]; } } } }; 03. \u4ece\u5c3e\u5230\u5934\u6253\u5370\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u6309\u94fe\u8868\u4ece\u5c3e\u5230\u5934\u7684\u987a\u5e8f\u8fd4\u56de\u4e00\u4e2aArrayList\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) \uff1a * val(x), next(NULL) { * } * }; */ class Solution { public \uff1a vector < int > printListFromTailToHead ( ListNode * head ) { vector < int > arr ; recurPrintList ( arr , head ); return arr ; } void recurPrintList ( vector < int > & arr , ListNode * head ) { if ( head != nullptr ) { recurPrintList ( arr , head -> next ); arr . push_back ( head -> val ); } } }; 04. \u91cd\u5efa\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u67d0\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\uff0c\u8bf7\u91cd\u5efa\u51fa\u8be5\u4e8c\u53c9\u6811\u3002\u5047\u8bbe\u8f93\u5165\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u4e2d\u90fd\u4e0d\u542b\u91cd\u590d\u7684\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u524d\u5e8f\u904d\u5386\u5e8f\u5217{1,2,4,7,3,5,6,8}\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217{4,7,2,1,5,3,8,6}\uff0c\u5219\u91cd\u5efa\u4e8c\u53c9\u6811\u5e76\u8fd4\u56de\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) {} * }; */ class Solution { public \uff1a TreeNode * reConstructBinaryTree ( vector < int > pre , vector < int > vin ) { int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return construct ( pre , 0 , n -1 , vin , 0 , n -1 ); } TreeNode * construct ( vector < int > pre , int b1 , int e1 , vector < int > vin , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int id = b2 ; for (; id <= e2 ; id ++ ) { if ( vin [ id ] == pre [ b1 ]) { break ; } } root -> left = construct ( pre , b1 + 1 , b1 + ( id - b2 ), vin , b2 , id -1 ); root -> right = construct ( pre , b1 + ( id - b2 ) + 1 , e1 , vin , id + 1 , e2 ); return root ; } }; 05. \u7528\u4e24\u4e2a\u6808\u5b9e\u73b0\u961f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7528\u4e24\u4e2a\u6808\u6765\u5b9e\u73b0\u4e00\u4e2a\u961f\u5217\uff0c\u5b8c\u6210\u961f\u5217\u7684Push\u548cPop\u64cd\u4f5c\u3002 \u961f\u5217\u4e2d\u7684\u5143\u7d20\u4e3aint\u7c7b\u578b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a void push ( int node ) { stack1 . push ( node ); } int pop () { while ( ! stack1 . empty ()) { stack2 . push ( stack1 . top ()); stack1 . pop (); } int res = stack2 . top (); stack2 . pop (); while ( ! stack2 . empty ()) { stack1 . push ( stack2 . top ()); stack2 . pop (); } return res ; } private \uff1a stack < int > stack1 ; stack < int > stack2 ; }; 06. \u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u4e00\u4e2a\u6570\u7ec4\u6700\u5f00\u59cb\u7684\u82e5\u5e72\u4e2a\u5143\u7d20\u642c\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u6570\u7ec4\u7684\u65cb\u8f6c\u3002 \u8f93\u5165\u4e00\u4e2a\u975e\u9012\u51cf\u6392\u5e8f\u7684\u6570\u7ec4\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8f93\u51fa\u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u5143\u7d20\u3002\u4f8b\u5982\u6570\u7ec4{3,4,5,1,2}\u4e3a{1,2,3,4,5}\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8be5\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u4e3a1\u3002NOTE\uff1a\u7ed9\u51fa\u7684\u6240\u6709\u5143\u7d20\u90fd\u5927\u4e8e0\uff0c\u82e5\u6570\u7ec4\u5927\u5c0f\u4e3a0\uff0c\u8bf7\u8fd4\u56de0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a int minNumberInRotateArray ( vector < int > rotateArray ) { int n = int ( rotateArray . size ()); if ( n == 0 ) { return 0 ; } if ( rotateArray [ 0 ] < rotateArray [ n -1 ]) { return rotateArray [ 0 ]; } for ( int i = n -1 ; i > 0 ; i -- ) { if ( rotateArray [ i ] < rotateArray [ i -1 ]) { return rotateArray [ i ]; } } return 0 ; } }; 07. \u6590\u6ce2\u90a3\u5951\u6570\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5927\u5bb6\u90fd\u77e5\u9053\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff0c\u73b0\u5728\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6574\u6570n\uff0c\u8bf7\u4f60\u8f93\u51fa\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7b2cn\u9879\uff08\u4ece0\u5f00\u59cb\uff0c\u7b2c0\u9879\u4e3a0\uff0c\u7b2c1\u9879\u662f1\uff09\u3002n<=39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int Fibonacci ( int n ) { if ( n == 0 || n == 1 ) { return n ; } int t1 = 0 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } }; 08. \u8df3\u53f0\u9636 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\uff08\u5148\u540e\u6b21\u5e8f\u4e0d\u540c\u7b97\u4e0d\u540c\u7684\u7ed3\u679c\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int jumpFloor ( int number ) { if ( number == 0 || number == 1 ) { return 1 ; } int t1 = 1 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } }; 09. \u53d8\u6001\u8df3\u53f0\u9636 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u2026\u2026\u5b83\u4e5f\u53ef\u4ee5\u8df3\u4e0an\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\u3002 1 2 3 4 5 6 7 8 class Solution { public \uff1a int jumpFloorII ( int number ) { int res = 1 ; while ( -- number ) { res *= 2 ; } return res ; } }; 10. \u77e9\u5f62\u8986\u76d6 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6211\u4eec\u53ef\u4ee5\u75282 1\u7684\u5c0f\u77e9\u5f62\u6a2a\u7740\u6216\u8005\u7ad6\u7740\u53bb\u8986\u76d6\u66f4\u5927\u7684\u77e9\u5f62\u3002\u8bf7\u95ee\u7528n\u4e2a2 1\u7684\u5c0f\u77e9\u5f62\u65e0\u91cd\u53e0\u5730\u8986\u76d6\u4e00\u4e2a2 n\u7684\u5927\u77e9\u5f62\uff0c\u603b\u5171\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\uff1f\u6bd4\u5982n=3\u65f6\uff0c2 3\u7684\u77e9\u5f62\u5757\u67093\u79cd\u8986\u76d6\u65b9\u6cd5\uff1a f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int rectCover ( int number ) { if ( number <= 2 ) { return number ; } int t1 = 1 , t2 = 2 , temp = 0 ; for ( int i = 3 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } }; 11. \u4e8c\u8fdb\u5236\u4e2d1\u7684\u4e2a\u6570* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\uff0c\u8f93\u51fa\u8be5\u6570\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d1\u7684\u4e2a\u6570\u3002\u5176\u4e2d\u8d1f\u6570\u7528\u8865\u7801\u8868\u793a\u3002 Solution\uff1a8 & 7 = 1000 & 0111 = 00000 = 0 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public \uff1a int NumberOf1 ( int n ) { int res = 0 ; while ( n ) { n &= n -1 ; res ++ ; } return res ; } }; 12. \u6570\u503c\u7684\u6574\u6570\u6b21\u65b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2adouble\u7c7b\u578b\u7684\u6d6e\u70b9\u6570base\u548cint\u7c7b\u578b\u7684\u6574\u6570exponent\u3002\u6c42base\u7684exponent\u6b21\u65b9\u3002\u4fdd\u8bc1base\u548cexponent\u4e0d\u540c\u65f6\u4e3a0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a double Power ( double base , int exponent ) { if ( exponent == 0 ) { return 1 ; } double res = 1.0 ; bool isNegative = false ; if ( exponent < 0 ) { exponent = - exponent ; isNegative = true ; } while ( exponent -- ) { res *= base ; } if ( isNegative ) { return 1 / res ; } return res ; } }; 13. \u8c03\u6574\u6570\u7ec4\u987a\u5e8f\u4f7f\u5947\u6570\u4f4d\u4e8e\u5076\u6570\u524d\u9762 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6765\u8c03\u6574\u8be5\u6570\u7ec4\u4e2d\u6570\u5b57\u7684\u987a\u5e8f\uff0c\u4f7f\u5f97\u6240\u6709\u7684\u5947\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u524d\u534a\u90e8\u5206\uff0c\u6240\u6709\u7684\u5076\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u540e\u534a\u90e8\u5206\uff0c\u5e76\u4fdd\u8bc1\u5947\u6570\u548c\u5947\u6570\uff0c\u5076\u6570\u548c\u5076\u6570\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a void reOrderArray ( vector < int > & array ) { vector < int > odd , even ; int n = int ( array . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] % 2 ) { odd . push_back ( array [ i ]); } else { even . push_back ( array [ i ]); } } for ( int i = 0 , j = 0 ; i < int ( odd . size ()); i ++ , j ++ ) { array [ j ] = odd [ i ]; } for ( int i = 0 , j = int ( odd . size ()); i < int ( even . size ()); i ++ , j ++ ) { array [ j ] = even [ i ]; } } }; 14. \u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u8f93\u51fa\u8be5\u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindKthToTail ( ListNode * pListHead , unsigned int k ) { if ( k <= 0 ) { return NULL ; } ListNode * p1 = pListHead , * p2 = pListHead ; for ( int i = 0 ; i < k ; i ++ ) { if ( p2 == NULL ) { return p2 ; } p2 = p2 -> next ; } while ( p2 != NULL ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } }; 15. \u53cd\u8f6c\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u53cd\u8f6c\u94fe\u8868\u540e\uff0c\u8f93\u51fa\u65b0\u94fe\u8868\u7684\u8868\u5934\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * ReverseList ( ListNode * pHead ) { if ( pHead == NULL || pHead -> next == NULL ) { return pHead ; } ListNode * p1 = NULL , * p2 = pHead , * p3 = pHead -> next ; while ( p3 != NULL ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; p3 = p3 -> next ; } p2 -> next = p1 ; return p2 ; } }; 16. \u5408\u5e76\u4e24\u4e2a\u6392\u5e8f\u7684\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u5355\u8c03\u9012\u589e\u7684\u94fe\u8868\uff0c\u8f93\u51fa\u4e24\u4e2a\u94fe\u8868\u5408\u6210\u540e\u7684\u94fe\u8868\uff0c\u5f53\u7136\u6211\u4eec\u9700\u8981\u5408\u6210\u540e\u7684\u94fe\u8868\u6ee1\u8db3\u5355\u8c03\u4e0d\u51cf\u89c4\u5219\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * Merge ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL ) { return pHead2 ; } if ( pHead2 == NULL ) { return pHead1 ; } ListNode * head = new ListNode ( 0 ); ListNode * cur = head , * p1 = pHead1 , * p2 = pHead2 ; while ( p1 != NULL && p2 != NULL ) { if ( p1 -> val < p2 -> val ) { cur -> next = p1 ; cur = p1 ; p1 = p1 -> next ; } else { cur -> next = p2 ; cur = p2 ; p2 = p2 -> next ; } } if ( p1 != NULL ) { cur -> next = p1 ; } if ( p2 != NULL ) { cur -> next = p2 ; } return head -> next ; } }; 17. \u6811\u7684\u5b50\u7ed3\u6784 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u68f5\u4e8c\u53c9\u6811A\uff0cB\uff0c\u5224\u65adB\u662f\u4e0d\u662fA\u7684\u5b50\u7ed3\u6784\u3002\uff08ps\uff1a\u6211\u4eec\u7ea6\u5b9a\u7a7a\u6811\u4e0d\u662f\u4efb\u610f\u4e00\u4e2a\u6811\u7684\u5b50\u7ed3\u6784\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a bool HasSubtree ( TreeNode * pRoot1 , TreeNode * pRoot2 ) { if ( pRoot1 == NULL || pRoot2 == NULL ) { return false ; } queue < TreeNode *> qTree ; qTree . push ( pRoot1 ); TreeNode * front = pRoot1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> val == pRoot2 -> val && isSame ( front , pRoot2 )) { return true ; } if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return false ; } bool isSame ( TreeNode * t1 , TreeNode * t2 ) { if ( t2 == NULL ) { return true ; } if ( t1 == NULL || t1 -> val != t2 -> val ) { return false ; } return isSame ( t1 -> left , t2 -> left ) && isSame ( t1 -> right , t2 -> right ); } }; 18. \u4e8c\u53c9\u6811\u7684\u955c\u50cf \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u64cd\u4f5c\u7ed9\u5b9a\u7684\u4e8c\u53c9\u6811\uff0c\u5c06\u5176\u53d8\u6362\u4e3a\u6e90\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a void Mirror ( TreeNode * pRoot ) { if ( pRoot != NULL ) { Mirror ( pRoot -> left ); Mirror ( pRoot -> right ); TreeNode * temp = pRoot -> left ; pRoot -> left = pRoot -> right ; pRoot -> right = temp ; } } }; 19. \u987a\u65f6\u9488\u6253\u5370\u77e9\u9635 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u77e9\u9635\uff0c\u6309\u7167\u4ece\u5916\u5411\u91cc\u4ee5\u987a\u65f6\u9488\u7684\u987a\u5e8f\u4f9d\u6b21\u6253\u5370\u51fa\u6bcf\u4e00\u4e2a\u6570\u5b57\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u5982\u4e0b4 X 4\u77e9\u9635\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u5219\u4f9d\u6b21\u6253\u5370\u51fa\u6570\u5b571,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public \uff1a vector < int > printMatrix ( vector < vector < int > > matrix ) { vector < int > res ; int nRows = int ( matrix . size ()); if ( nRows == 0 ) { return res ; } int nCols = int ( matrix [ 0 ]. size ()); if ( nCols == 0 ) { return res ; } bool ** dp = new bool * [ nRows ]; for ( int i = 0 ; i < nRows ; i ++ ) { dp [ i ] = new bool [ nCols ]{}; } int i = 0 , j = 0 ; int di [ 4 ] = { 0 , 1 , 0 , -1 }, dj [ 4 ] = { 1 , 0 , -1 , 0 }; while ( true ) { bool updated = false ; for ( int k = 0 ; k < 4 ; k ++ ) { while ( isOk ( dp , i + di [ k ], j + dj [ k ], nRows , nCols )) { res . push_back ( matrix [ i ][ j ]); dp [ i ][ j ] = true ; updated = true ; i += di [ k ]; j += dj [ k ]; } } if ( ! updated ) { res . push_back ( matrix [ i ][ j ]); break ; } } for ( i = 0 ; i < nRows ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } bool isOk ( bool ** isVisited , int i , int j , int nRows , int nCols ) { if ( i < 0 || i >= nRows || j < 0 || j >= nCols || isVisited [ i ][ j ]) { return false ; } return true ; } }; 20. \u5305\u542bmin\u51fd\u6570\u7684\u6808* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5b9a\u4e49\u6808\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8bf7\u5728\u8be5\u7c7b\u578b\u4e2d\u5b9e\u73b0\u4e00\u4e2a\u80fd\u591f\u5f97\u5230\u6808\u4e2d\u6240\u542b\u6700\u5c0f\u5143\u7d20\u7684min\u51fd\u6570\uff08\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u4e3aO\uff081\uff09\uff09\u3002\u6ce8\u610f\uff1a\u4fdd\u8bc1\u6d4b\u8bd5\u4e2d\u4e0d\u4f1a\u5f53\u6808\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u5bf9\u6808\u8c03\u7528pop()\u6216\u8005min()\u6216\u8005top()\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { stack < int > s1 ; stack < int > s2 ; public \uff1a void push ( int value ) { s1 . push ( value ); if ( s2 . empty () || value < s2 . top ()) { s2 . push ( value ); } else { s2 . push ( s2 . top ()); } } void pop () { s1 . pop (); s2 . pop (); } int top () { return s1 . top (); } int min () { return s2 . top (); } }; 21. \u6808\u7684\u538b\u5165\u3001\u5f39\u51fa\u5e8f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u7b2c\u4e00\u4e2a\u5e8f\u5217\u8868\u793a\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u8bf7\u5224\u65ad\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u662f\u5426\u53ef\u80fd\u4e3a\u8be5\u6808\u7684\u5f39\u51fa\u987a\u5e8f\u3002\u5047\u8bbe\u538b\u5165\u6808\u7684\u6240\u6709\u6570\u5b57\u5747\u4e0d\u76f8\u7b49\u3002\u4f8b\u5982\u5e8f\u52171,2,3,4,5\u662f\u67d0\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u5e8f\u52174,5,3,2,1\u662f\u8be5\u538b\u6808\u5e8f\u5217\u5bf9\u5e94\u7684\u4e00\u4e2a\u5f39\u51fa\u5e8f\u5217\uff0c\u4f464,3,5,1,2\u5c31\u4e0d\u53ef\u80fd\u662f\u8be5\u538b\u6808\u5e8f\u5217\u7684\u5f39\u51fa\u5e8f\u5217\u3002\uff08\u6ce8\u610f\uff1a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u957f\u5ea6\u662f\u76f8\u7b49\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a bool IsPopOrder ( vector < int > pushV , vector < int > popV ) { int n = int ( pushV . size ()); stack < int > st ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pushV [ i ] == popV [ j ]) { j ++ ; } else { st . push ( pushV [ i ]); } } for (; j < n ; j ++ ) { if ( st . empty () || st . top () != popV [ j ]) { return false ; } st . pop (); } return true ; } }; 22. \u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u540c\u5c42\u8282\u70b9\u4ece\u5de6\u81f3\u53f3\u6253\u5370\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < int > PrintFromTopToBottom ( TreeNode * root ) { vector < int > res ; if ( root == NULL ) { return res ; } TreeNode * front = root ; queue < TreeNode *> qTree ; qTree . push ( root ); while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); res . push_back ( front -> val ); if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return res ; } }; 23. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5224\u65ad\u8be5\u6570\u7ec4\u662f\u4e0d\u662f\u67d0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002\u5982\u679c\u662f\u5219\u8f93\u51faYes,\u5426\u5219\u8f93\u51faNo\u3002\u5047\u8bbe\u8f93\u5165\u7684\u6570\u7ec4\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u4e92\u4e0d\u76f8\u540c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a bool VerifySquenceOfBST ( vector < int > sequence ) { int n = int ( sequence . size ()); if ( n == 0 ) { return false ; } return isPostOrder ( sequence , 0 , n -1 ); } bool isPostOrder ( vector < int > arr , int b , int e ) { if ( b >= e ) { return true ; } int idx = b ; for (; idx <= e ; idx ++ ) { if ( arr [ idx ] >= arr [ e ]) { break ; } } for ( int i = idx ; i < e ; i ++ ) { if ( arr [ i ] < arr [ e ]) { return false ; } } return isPostOrder ( arr , b , idx -1 ) && isPostOrder ( arr , idx , e -1 ); } }; 24. \u4e8c\u53c9\u6811\u4e2d\u548c\u4e3a\u67d0\u4e00\u503c\u7684\u8def\u5f84 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9\u548c\u4e00\u4e2a\u6574\u6570\uff0c\u6309\u5b57\u5178\u5e8f\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u503c\u7684\u548c\u4e3a\u8f93\u5165\u6574\u6570\u7684\u6240\u6709\u8def\u5f84\u3002\u8def\u5f84\u5b9a\u4e49\u4e3a\u4ece\u6811\u7684\u6839\u7ed3\u70b9\u5f00\u59cb\u5f80\u4e0b\u4e00\u76f4\u5230\u53f6\u7ed3\u70b9\u6240\u7ecf\u8fc7\u7684\u7ed3\u70b9\u5f62\u6210\u4e00\u6761\u8def\u5f84\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int > > paths ; if ( root == NULL ) { return paths ; } vector < int > path ; stack < TreeNode *> s ; int size = 0 , sum = 0 ; TreeNode * cur = root ; while ( true ) { while ( cur -> left != NULL || cur -> right != NULL ) { s . push ( cur ); path . push_back ( cur -> val ); size ++ ; sum += cur -> val ; if ( cur -> left != NULL ) { cur = cur -> left ; } else { cur = cur -> right ; } } if ( sum + cur -> val == expectNumber ) { path . push_back ( cur -> val ); paths . push_back ( path ); } while ( ! s . empty () && ( s . top () -> left == NULL || s . top () -> right == NULL || s . top () -> right == cur )) { cur = s . top (); s . pop (); sum -= cur -> val ; size -- ; } if ( s . empty ()) { break ; } cur = s . top () -> right ; path . resize ( size ); } return paths ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int >> res ; if ( root == NULL ) { return res ; } vector < int > arr ; path ( root , expectNumber , res , arr , 0 ); return res ; } void path ( TreeNode * root , int target , vector < vector < int >> & res , vector < int > & arr , int sum ) { if ( root == NULL ) { return ; } arr . push_back ( root -> val ); if ( root -> left == NULL && root -> right == NULL && sum + root -> val == target ) { res . push_back ( arr ); } else { path ( root -> left , target , res , arr , sum + root -> val ); path ( root -> right , target , res , arr , sum + root -> val ); } arr . resize ( arr . size () -1 ); } }; 25. \u590d\u6742\u94fe\u8868\u7684\u590d\u5236* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u590d\u6742\u94fe\u8868\uff08\u6bcf\u4e2a\u8282\u70b9\u4e2d\u6709\u8282\u70b9\u503c\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u7279\u6b8a\u6307\u9488random\u6307\u5411\u4e00\u4e2a\u968f\u673a\u8282\u70b9\uff09\uff0c\u8bf7\u5bf9\u6b64\u94fe\u8868\u8fdb\u884c\u6df1\u62f7\u8d1d\uff0c\u5e76\u8fd4\u56de\u62f7\u8d1d\u540e\u7684\u5934\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\uff0c\u8f93\u51fa\u7ed3\u679c\u4e2d\u8bf7\u4e0d\u8981\u8fd4\u56de\u53c2\u6570\u4e2d\u7684\u8282\u70b9\u5f15\u7528\uff0c\u5426\u5219\u5224\u9898\u7a0b\u5e8f\u4f1a\u76f4\u63a5\u8fd4\u56de\u7a7a\uff09 Solution\uff1aWe copy each node to append itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) \uff1a label(x), next(NULL), random(NULL) { } }; */ class Solution { public \uff1a RandomListNode * Clone ( RandomListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } RandomListNode * p1 = pHead ; while ( p1 != NULL ) { RandomListNode * temp = new RandomListNode ( p1 -> label ); temp -> next = p1 -> next ; p1 -> next = temp ; p1 = p1 -> next -> next ; } p1 = pHead ; while ( p1 != NULL ) { if ( p1 -> random != NULL ) { p1 -> next -> random = p1 -> random -> next ; } p1 = p1 -> next -> next ; } RandomListNode * head = pHead -> next , * p2 = pHead -> next ; p1 = pHead ; while ( p1 != NULL ) { p1 -> next = p2 -> next ; if ( p2 -> next != NULL ) { p2 -> next = p2 -> next -> next ; } p1 = p1 -> next ; p2 = p2 -> next ; } return head ; } }; 26. \u4e8c\u53c9\u641c\u7d22\u6811\u4e0e\u53cc\u5411\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5c06\u8be5\u4e8c\u53c9\u641c\u7d22\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u6392\u5e8f\u7684\u53cc\u5411\u94fe\u8868\u3002\u8981\u6c42\u4e0d\u80fd\u521b\u5efa\u4efb\u4f55\u65b0\u7684\u7ed3\u70b9\uff0c\u53ea\u80fd\u8c03\u6574\u6811\u4e2d\u7ed3\u70b9\u6307\u9488\u7684\u6307\u5411\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } postOrder ( pRootOfTree ); TreeNode * head = pRootOfTree ; while ( head -> left != NULL ) { head = head -> left ; } return head ; } void postOrder ( TreeNode * root ) { if ( root != NULL ) { postOrder ( root -> left ); postOrder ( root -> right ); TreeNode * left = root -> left ; while ( left != NULL && left -> right != NULL ) { left = left -> right ; } root -> left = left ; if ( left != NULL ) { left -> right = root ; } TreeNode * right = root -> right ; while ( right != NULL && right -> left != NULL ) { right = right -> left ; } root -> right = right ; if ( right != NULL ) { right -> left = root ; } } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } TreeNode * head = pRootOfTree , * leftMost = NULL ; inOrder ( pRootOfTree , leftMost ); while ( head -> left != NULL ) { head = head -> left ; } return head ; } void inOrder ( TreeNode * root , TreeNode *& leftMost ) { if ( root != NULL ) { inOrder ( root -> left , leftMost ); if ( leftMost == NULL ) { leftMost = root ; } else { leftMost -> right = root ; root -> left = leftMost ; leftMost = root ; } inOrder ( root -> right , leftMost ); } } }; 28. \u6570\u7ec4\u4e2d\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4{1,2,3,2,2,2,5,4,2}\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u5982\u679c\u4e0d\u5b58\u5728\u5219\u8f93\u51fa0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i -1 ); quickSort ( arr , j + 1 , end ); } } int MoreThanHalfNum_Solution ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return numbers [ 0 ]; } quickSort ( numbers , 0 , n -1 ); if ( n % 2 && numbers [ n / 2 ] != numbers [ n / 2-1 ]) { return 0 ; } int res = numbers [ n / 2 ]; int count = 1 ; int pos = n / 2 - 1 ; while ( pos >= 0 ) { if ( numbers [ pos ] != res ) { break ; } pos -- ; count ++ ; } pos = n / 2 + 1 ; while ( pos < n ) { if ( numbers [ pos ] != res ) { break ; } pos ++ ; count ++ ; } if ( count > n / 2 ) { return res ; } return 0 ; } }; 29. \u6700\u5c0f\u7684K\u4e2a\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165n\u4e2a\u6574\u6570\uff0c\u627e\u51fa\u5176\u4e2d\u6700\u5c0f\u7684K\u4e2a\u6570\u3002\u4f8b\u5982\u8f93\u51654,5,1,6,2,7,3,8\u8fd98\u4e2a\u6570\u5b57\uff0c\u5219\u6700\u5c0f\u76844\u4e2a\u6570\u5b57\u662f1,2,3,4,\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i -1 ); quickSort ( arr , j + 1 , end ); } } vector < int > GetLeastNumbers_Solution ( vector < int > input , int k ) { int n = int ( input . size ()); vector < int > res ; if ( n == 0 || k <= 0 || k > n ) { return res ; } quickSort ( input , 0 , n -1 ); input . resize ( k ); return input ; } }; 31. \u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1\u5230n\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6c42\u51fa1-13\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570,\u5e76\u7b97\u51fa100~1300\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff1f\u4e3a\u6b64\u4ed6\u7279\u522b\u6570\u4e86\u4e00\u4e0b1-13\u4e2d\u5305\u542b1\u7684\u6570\u5b57\u67091\u300110\u300111\u300112\u300113\u56e0\u6b64\u5171\u51fa\u73b06\u6b21,\u4f46\u662f\u5bf9\u4e8e\u540e\u9762\u95ee\u9898\u4ed6\u5c31\u6ca1\u8f99\u4e86\u3002ACMer\u5e0c\u671b\u4f60\u4eec\u5e2e\u5e2e\u4ed6,\u5e76\u628a\u95ee\u9898\u66f4\u52a0\u666e\u904d\u5316,\u53ef\u4ee5\u5f88\u5feb\u7684\u6c42\u51fa\u4efb\u610f\u975e\u8d1f\u6574\u6570\u533a\u95f4\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1 \u5230 n \u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09\u3002 Solution\uff1aTake 2593 as an example, how many '5' does it contain? i = 1, Quotient = 2593 / (10 * i) = 258, Mod = 2593 % (10 * i) = 3. Number of '5'\uff1a 259 * i + (3 > 5) * i = 259. i = 10, Quotient = 2593 / (10 * i) = 25, Mod = 2593 % (10 * i) = 93. Number of '5'\uff1a 25 * i + (9 > 5) * i = 260. i = 100, Quotient = 2593 / (10 * i) = 2, Mod = 2593 % (10 * i) = 593. Number of '5'\uff1a 2 * i + (5 == 5) * (93 + 1) = 294. i = 1000, Quotient = 2593 / (10 * i) = 0 end.Total number of '5'\uff1a 259 + 260 + 294 = 813. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { res += count1 ( i ); } return res ; } int count1 ( int num ) { int res = 0 ; while ( num ) { if ( num % 10 == 1 ) { res ++ ; } num /= 10 ; } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int count = 0 , digit = 1 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int a = n / ( 10 * i ), b = n % ( 10 * i ); count += a * i ; if ( b / i > digit ) { count += i ; } if ( b / i == digit ) { count += b % i + 1 ; } } return count ; } }; 33. \u4e11\u6570* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u53ea\u5305\u542b\u8d28\u56e0\u5b502\u30013\u548c5\u7684\u6570\u79f0\u4f5c\u4e11\u6570\uff08Ugly Number\uff09\u3002\u4f8b\u59826\u30018\u90fd\u662f\u4e11\u6570\uff0c\u4f4614\u4e0d\u662f\uff0c\u56e0\u4e3a\u5b83\u5305\u542b\u8d28\u56e0\u5b507\u3002 \u4e60\u60ef\u4e0a\u6211\u4eec\u628a1\u5f53\u505a\u662f\u7b2c\u4e00\u4e2a\u4e11\u6570\u3002\u6c42\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u7684\u7b2cN\u4e2a\u4e11\u6570\u3002 Solution\uff1aUgly numbers\uff1a 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15...Some ugly number is from a multiplaction of previous number by 2, 3 or 5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a int min ( int a , int b , int c ) { int temp = a < b ? a \uff1a b ; return temp < c ? temp \uff1a c ; } int GetUglyNumber_Solution ( int index ) { if ( index < 2 ) { return index ; } int * arr = new int [ index ]{}; arr [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < index ; i ++ ) { arr [ i ] = min ( arr [ f2 ] * 2 , arr [ f3 ] * 3 , arr [ f5 ] * 5 ); while ( arr [ f2 ] * 2 <= arr [ i ]) { f2 ++ ; } while ( arr [ f3 ] * 3 <= arr [ i ]) { f3 ++ ; } while ( arr [ f5 ] * 5 <= arr [ i ]) { f5 ++ ; } } int res = arr [ index -1 ]; delete [] arr ; return res ; } }; 34. \u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u4f4d\u7f6e \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u5b57\u7b26\u4e32(0<=\u5b57\u7b26\u4e32\u957f\u5ea6<=10000\uff0c\u5168\u90e8\u7531\u5b57\u6bcd\u7ec4\u6210)\u4e2d\u627e\u5230\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26,\u5e76\u8fd4\u56de\u5b83\u7684\u4f4d\u7f6e, \u5982\u679c\u6ca1\u6709\u5219\u8fd4\u56de -1\uff08\u9700\u8981\u533a\u5206\u5927\u5c0f\u5199\uff09.\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a int FirstNotRepeatingChar ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return -1 ; } int N = 256 , pos = n + 1 ; int * ascii = new int [ N ]{}; for ( int i = 0 ; i < n ; i ++ ) { int id = int ( str [ i ]); if ( ascii [ id ] == 0 ) { ascii [ id ] = i + 1 ; } else { ascii [ id ] = -1 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] > 0 && ascii [ i ] < pos ) { pos = ascii [ i ]; } } delete [] ascii ; if ( pos == n + 1 ) { return -1 ; } return pos - 1 ; } }; 35. \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4,\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570P\u3002\u5e76\u5c06P\u5bf91000000007\u53d6\u6a21\u7684\u7ed3\u679c\u8f93\u51fa\u3002 \u5373\u8f93\u51faP%1000000007 \u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u7684\u6570\u7ec4\u4e2d\u6ca1\u6709\u7684\u76f8\u540c\u7684\u6570\u5b57\u6570\u636e\u8303\u56f4\uff1a\u5bf9\u4e8e%50\u7684\u6570\u636e,size<=10 4\u5bf9\u4e8e%75\u7684\u6570\u636e,size<=10 5\u5bf9\u4e8e%100\u7684\u6570\u636e,size<=2*10^5 \u8f93\u51651,2,3,4,5,6,7,0\u8f93\u51fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public \uff1a int InversePairs ( vector < int > data ) { int n = int ( data . size ()); if ( n < 2 ) { return 0 ; } long count = 0 ; mergeSort ( data , 0 , n -1 , count ); return ( count % 1000000007 ); } void mergeSort ( vector < int > & arr , int b , int e , long & count ) { if ( b >= e ) { return ; } int m = ( b + e ) / 2 ; mergeSort ( arr , b , m , count ); mergeSort ( arr , m + 1 , e , count ); merge ( arr , b , m , e , count ); } void merge ( vector < int > & arr , int b , int m , int e , long & count ) { int * temp = new int [ e - b + 1 ]{}; int i = b , j = m + 1 , right = 0 , pos = 0 ; while ( i <= m && j <= e ) { if ( arr [ i ] < arr [ j ]) { temp [ pos ++ ] = arr [ i ++ ]; count += right ; } else { temp [ pos ++ ] = arr [ j ++ ]; right ++ ; } } count += ( m - i + 1 ) * right ; while ( i <= m ) { temp [ pos ++ ] = arr [ i ++ ]; } while ( j <= e ) { temp [ pos ++ ] = arr [ j ++ ]; } for ( int i = b ; i <= e ; i ++ ) { arr [ i ] = temp [ i - b ]; } delete [] temp ; } }; 36. \u4e24\u4e2a\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u94fe\u8868\uff0c\u627e\u51fa\u5b83\u4eec\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\u56e0\u4e3a\u4f20\u5165\u6570\u636e\u662f\u94fe\u8868\uff0c\u6240\u4ee5\u9519\u8bef\u6d4b\u8bd5\u6570\u636e\u7684\u63d0\u793a\u662f\u7528\u5176\u4ed6\u65b9\u5f0f\u663e\u793a\u7684\uff0c\u4fdd\u8bc1\u4f20\u5165\u6570\u636e\u662f\u6b63\u786e\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindFirstCommonNode ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL || pHead2 == NULL ) { return NULL ; } ListNode * p1 = pHead1 , * p2 = pHead2 ; stack < ListNode *> s1 , s2 ; while ( p1 != NULL ) { s1 . push ( p1 ); p1 = p1 -> next ; } while ( p2 != NULL ) { s2 . push ( p2 ); p2 = p2 -> next ; } while ( ! s1 . empty () && ! s2 . empty ()) { if ( s1 . top () != s2 . top ()) { return s1 . top () -> next ; } s1 . pop (); s2 . pop (); } if ( s1 . empty ()) { return pHead1 ; } if ( s2 . empty ()) { return pHead2 ; } return s1 . top () -> next ; } }; 37. \u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7edf\u8ba1\u4e00\u4e2a\u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 class Solution { public \uff1a int GetNumberOfK ( vector < int > data , int k ) { int count = 0 ; for ( int i = 0 ; i < int ( data . size ()); i ++ ) { if ( data [ i ] == k ) { count ++ ; } } return count ; } }; 38. \u4e8c\u53c9\u6811\u7684\u6df1\u5ea6 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6c42\u8be5\u6811\u7684\u6df1\u5ea6\u3002\u4ece\u6839\u7ed3\u70b9\u5230\u53f6\u7ed3\u70b9\u4f9d\u6b21\u7ecf\u8fc7\u7684\u7ed3\u70b9\uff08\u542b\u6839\u3001\u53f6\u7ed3\u70b9\uff09\u5f62\u6210\u6811\u7684\u4e00\u6761\u8def\u5f84\uff0c\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6\u4e3a\u6811\u7684\u6df1\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int dep = 0 ; queue < TreeNode *> qTree ; qTree . push ( pRoot ); TreeNode * front = pRoot , * last = pRoot , * nextLast = pRoot ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> left != NULL ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != NULL ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { dep ++ ; last = nextLast ; } } return dep ; } }; ``` C ++ /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int leftDep = TreeDepth ( pRoot -> left ); int rightDep = TreeDepth ( pRoot -> right ); return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } }; 39. \u5e73\u8861\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u5224\u65ad\u8be5\u4e8c\u53c9\u6811\u662f\u5426\u662f\u5e73\u8861\u4e8c\u53c9\u6811\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8003\u8651\u5176\u5e73\u8861\u6027\uff0c\u4e0d\u9700\u8981\u8003\u8651\u5176\u662f\u4e0d\u662f\u6392\u5e8f\u4e8c\u53c9\u6811\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a bool IsBalanced_Solution ( TreeNode * pRoot ) { bool res = true ; postOrder ( pRoot , res ); return res ; } int postOrder ( TreeNode * root , bool & res ) { if ( root == NULL ) { return 0 ; } int leftDep = postOrder ( root -> left , res ); int rightDep = postOrder ( root -> right , res ); int diff = abs ( leftDep - rightDep ); if ( diff > 1 ) { res = false ; } return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } }; 40. \u6570\u7ec4\u4e2d\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\u91cc\u9664\u4e86\u4e24\u4e2a\u6570\u5b57\u4e4b\u5916\uff0c\u5176\u4ed6\u7684\u6570\u5b57\u90fd\u51fa\u73b0\u4e86\u4e24\u6b21\u3002\u8bf7\u5199\u7a0b\u5e8f\u627e\u51fa\u8fd9\u4e24\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57\u3002 Solution\uff1anum XOR num = 0\uff1a one number XOR itself is 0.We XOR all entire array to get a result of the two single numbers. Then locate the first 1's position, e.g. 6 = 0110, first 1's position is 2 (starting 0 from right to left). We classify the array into two parts by checking if one integer is 1 at its first 1's position. Then do XOR once again for the two parts to find the two single numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a void FindNumsAppearOnce ( vector < int > data , int * num1 , int * num2 ) { int n = int ( data . size ()); if ( n < 2 ) { return ; } int XOR = 0 , pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR ^= data [ i ]; } while ( XOR >> 1 ) { XOR = XOR >> 1 ; pos ++ ; } bool is1Ok = false , is2Ok = false ; int n1 = 0 , n2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if (( data [ i ] >> pos ) & 1 ) { if ( is1Ok ) { n1 ^= data [ i ]; } else { is1Ok = true ; n1 = data [ i ]; } } else { if ( is2Ok ) { n2 ^= data [ i ]; } else { is2Ok = true ; n2 = data [ i ]; } } * num1 = n1 < n2 ? n1 \uff1a n2 ; * num2 = n1 >= n2 ? n1 \uff1a n2 ; } } }; 41. \u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5c0f\u660e\u5f88\u559c\u6b22\u6570\u5b66,\u6709\u4e00\u5929\u4ed6\u5728\u505a\u6570\u5b66\u4f5c\u4e1a\u65f6,\u8981\u6c42\u8ba1\u7b97\u51fa9~16\u7684\u548c,\u4ed6\u9a6c\u4e0a\u5c31\u5199\u51fa\u4e86\u6b63\u786e\u7b54\u6848\u662f100\u3002\u4f46\u662f\u4ed6\u5e76\u4e0d\u6ee1\u8db3\u4e8e\u6b64,\u4ed6\u5728\u60f3\u7a76\u7adf\u6709\u591a\u5c11\u79cd\u8fde\u7eed\u7684\u6b63\u6570\u5e8f\u5217\u7684\u548c\u4e3a100(\u81f3\u5c11\u5305\u62ec\u4e24\u4e2a\u6570)\u3002\u6ca1\u591a\u4e45,\u4ed6\u5c31\u5f97\u5230\u53e6\u4e00\u7ec4\u8fde\u7eed\u6b63\u6570\u548c\u4e3a100\u7684\u5e8f\u5217\uff1a18,19,20,21,22\u3002\u73b0\u5728\u628a\u95ee\u9898\u4ea4\u7ed9\u4f60,\u4f60\u80fd\u4e0d\u80fd\u4e5f\u5f88\u5feb\u7684\u627e\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217? Good Luck!\u8f93\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217\u3002\u5e8f\u5217\u5185\u6309\u7167\u4ece\u5c0f\u81f3\u5927\u7684\u987a\u5e8f\uff0c\u5e8f\u5217\u95f4\u6309\u7167\u5f00\u59cb\u6570\u5b57\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < vector < int > > FindContinuousSequence ( int sum ) { vector < vector < int >> res ; if ( sum < 3 ) { return res ; } for ( int n = sum ; n >= 2 ; n -- ) { int numerator = 2 * sum + n - n * n ; int denominator = 2 * n ; if ( numerator % denominator == 0 ) { int a = numerator / denominator ; if ( a < 1 ) { continue ; } vector < int > arr ; for ( int i = a ; i <= a + n - 1 ; i ++ ) { arr . push_back ( i ); } res . push_back ( arr ); } } return res ; } }; 42. \u548c\u4e3aS\u7684\u4e24\u4e2a\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u9012\u589e\u6392\u5e8f\u7684\u6570\u7ec4\u548c\u4e00\u4e2a\u6570\u5b57S\uff0c\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u4e24\u4e2a\u6570\uff0c\u4f7f\u5f97\u4ed6\u4eec\u7684\u548c\u6b63\u597d\u662fS\uff0c\u5982\u679c\u6709\u591a\u5bf9\u6570\u5b57\u7684\u548c\u7b49\u4e8eS\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\u7684\u4e58\u79ef\u6700\u5c0f\u7684\u3002\u5bf9\u5e94\u6bcf\u4e2a\u6d4b\u8bd5\u6848\u4f8b\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\uff0c\u5c0f\u7684\u5148\u8f93\u51fa\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < int > FindNumbersWithSum ( vector < int > array , int sum ) { vector < int > res ; int n = int ( array . size ()); if ( n == 0 ) { return res ; } int i = 0 , j = n - 1 ; while ( i < j ) { if ( array [ i ] + array [ j ] < sum ) { i ++ ; } else if ( array [ i ] + array [ j ] > sum ) { j -- ; } else { res . push_back ( array [ i ]); res . push_back ( array [ j ]); break ; } } return res ; } }; 43. \u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6c47\u7f16\u8bed\u8a00\u4e2d\u6709\u4e00\u79cd\u79fb\u4f4d\u6307\u4ee4\u53eb\u505a\u5faa\u73af\u5de6\u79fb\uff08ROL\uff09\uff0c\u73b0\u5728\u6709\u4e2a\u7b80\u5355\u7684\u4efb\u52a1\uff0c\u5c31\u662f\u7528\u5b57\u7b26\u4e32\u6a21\u62df\u8fd9\u4e2a\u6307\u4ee4\u7684\u8fd0\u7b97\u7ed3\u679c\u3002\u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5b57\u7b26\u5e8f\u5217S\uff0c\u8bf7\u4f60\u628a\u5176\u5faa\u73af\u5de6\u79fbK\u4f4d\u540e\u7684\u5e8f\u5217\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u5e8f\u5217S=\u201dabcXYZdef\u201d,\u8981\u6c42\u8f93\u51fa\u5faa\u73af\u5de6\u79fb3\u4f4d\u540e\u7684\u7ed3\u679c\uff0c\u5373\u201cXYZdefabc\u201d\u3002\u662f\u4e0d\u662f\u5f88\u7b80\u5355\uff1fOK\uff0c\u641e\u5b9a\u5b83\uff01 1 2 3 4 5 6 7 8 9 10 class Solution { public \uff1a string LeftRotateString ( string str , int n ) { int len = int ( str . length ()); if ( len == 0 || n == 0 || len <= n ) { return str ; } string firtN ( str , 0 , n ); string rest ( str , n , len ); return rest + firtN ; } }; 44. \u7ffb\u8f6c\u5355\u8bcd\u987a\u5e8f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u725b\u5ba2\u6700\u8fd1\u6765\u4e86\u4e00\u4e2a\u65b0\u5458\u5de5Fish\uff0c\u6bcf\u5929\u65e9\u6668\u603b\u662f\u4f1a\u62ff\u7740\u4e00\u672c\u82f1\u6587\u6742\u5fd7\uff0c\u5199\u4e9b\u53e5\u5b50\u5728\u672c\u5b50\u4e0a\u3002\u540c\u4e8bCat\u5bf9Fish\u5199\u7684\u5185\u5bb9\u9887\u611f\u5174\u8da3\uff0c\u6709\u4e00\u5929\u4ed6\u5411Fish\u501f\u6765\u7ffb\u770b\uff0c\u4f46\u5374\u8bfb\u4e0d\u61c2\u5b83\u7684\u610f\u601d\u3002\u4f8b\u5982\uff0c\u201cstudent. a am I\u201d\u3002\u540e\u6765\u624d\u610f\u8bc6\u5230\uff0c\u8fd9\u5bb6\u4f19\u539f\u6765\u628a\u53e5\u5b50\u5355\u8bcd\u7684\u987a\u5e8f\u7ffb\u8f6c\u4e86\uff0c\u6b63\u786e\u7684\u53e5\u5b50\u5e94\u8be5\u662f\u201cI am a student.\u201d\u3002Cat\u5bf9\u4e00\u4e00\u7684\u7ffb\u8f6c\u8fd9\u4e9b\u5355\u8bcd\u987a\u5e8f\u53ef\u4e0d\u5728\u884c\uff0c\u4f60\u80fd\u5e2e\u52a9\u4ed6\u4e48\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } string res = \"\" , word = \"\" ; stack < string > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { s . push ( word ); word = \"\" ; continue ; } word . push_back ( str [ i ]); } s . push ( word ); while ( ! s . empty ()) { res += s . top (); s . pop (); if ( ! s . empty ()) { res . push_back ( ' ' ); } } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { char temp = str [ i ]; str [ i ] = str [ n -1 - i ]; str [ n -1 - i ] = temp ; } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int n = i - 1 , m = j ; while ( m < n ) { char temp = str [ m ]; str [ m ] = str [ n ]; str [ n ] = temp ; m ++ ; n -- ; } j = i + 1 ; } } str [ n ] = '\\0' ; return str ; } }; 45. \u6251\u514b\u724c\u987a\u5b50 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1aLL\u4eca\u5929\u5fc3\u60c5\u7279\u522b\u597d,\u56e0\u4e3a\u4ed6\u53bb\u4e70\u4e86\u4e00\u526f\u6251\u514b\u724c,\u53d1\u73b0\u91cc\u9762\u5c45\u7136\u67092\u4e2a\u5927\u738b,2\u4e2a\u5c0f\u738b(\u4e00\u526f\u724c\u539f\u672c\u662f54\u5f20 _ )...\u4ed6\u968f\u673a\u4ece\u4e2d\u62bd\u51fa\u4e865\u5f20\u724c,\u60f3\u6d4b\u6d4b\u81ea\u5df1\u7684\u624b\u6c14,\u770b\u770b\u80fd\u4e0d\u80fd\u62bd\u5230\u987a\u5b50,\u5982\u679c\u62bd\u5230\u7684\u8bdd,\u4ed6\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968,\u563f\u563f\uff01\uff01\u201c\u7ea2\u5fc3A,\u9ed1\u68433,\u5c0f\u738b,\u5927\u738b,\u65b9\u72475\u201d,\u201cOh My God!\u201d\u4e0d\u662f\u987a\u5b50.....LL\u4e0d\u9ad8\u5174\u4e86,\u4ed6\u60f3\u4e86\u60f3,\u51b3\u5b9a\u5927\\\u5c0f \u738b\u53ef\u4ee5\u770b\u6210\u4efb\u4f55\u6570\u5b57,\u5e76\u4e14A\u770b\u4f5c1,J\u4e3a11,Q\u4e3a12,K\u4e3a13\u3002\u4e0a\u9762\u76845\u5f20\u724c\u5c31\u53ef\u4ee5\u53d8\u6210\u201c1,2,3,4,5\u201d(\u5927\u5c0f\u738b\u5206\u522b\u770b\u4f5c2\u548c4),\u201cSo Lucky!\u201d\u3002LL\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968\u5566\u3002 \u73b0\u5728,\u8981\u6c42\u4f60\u4f7f\u7528\u8fd9\u5e45\u724c\u6a21\u62df\u4e0a\u9762\u7684\u8fc7\u7a0b,\u7136\u540e\u544a\u8bc9\u6211\u4eecLL\u7684\u8fd0\u6c14\u5982\u4f55\uff0c \u5982\u679c\u724c\u80fd\u7ec4\u6210\u987a\u5b50\u5c31\u8f93\u51fatrue\uff0c\u5426\u5219\u5c31\u8f93\u51fafalse\u3002\u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1,\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u5927\u5c0f\u738b\u662f0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public \uff1a bool IsContinuous ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } //sort(numbers.begin(), numbers.end()); quickSort ( numbers , 0 , n -1 ); int num0 = 0 , head = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( numbers [ i ] == 0 ) { num0 ++ ; continue ; } if ( head == 0 ) { head = numbers [ i ]; } else { if ( numbers [ i ] == numbers [ i -1 ]) { return false ; } if ( numbers [ i ] == head + 1 ) { head ++ ; } else { num0 -= numbers [ i ] - head - 1 ; if ( num0 < 0 ) { return false ; } head = numbers [ i ]; } } } return true ; } void quickSort ( vector < int > & arr , int b , int e ) { if ( b < e ) { int i = b , j = e ; while ( i < j ) { while ( i < j && arr [ i ] <= arr [ j ]) { j -- ; } swap ( arr , i , j ); while ( i < j && arr [ i ] <= arr [ j ]) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , b , i -1 ); quickSort ( arr , j + 1 , e ); } } void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } }; 46. \u5b69\u5b50\u4eec\u7684\u6e38\u620f(\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6bcf\u5e74\u516d\u4e00\u513f\u7ae5\u8282,\u725b\u5ba2\u90fd\u4f1a\u51c6\u5907\u4e00\u4e9b\u5c0f\u793c\u7269\u53bb\u770b\u671b\u5b64\u513f\u9662\u7684\u5c0f\u670b\u53cb,\u4eca\u5e74\u4ea6\u662f\u5982\u6b64\u3002HF\u4f5c\u4e3a\u725b\u5ba2\u7684\u8d44\u6df1\u5143\u8001,\u81ea\u7136\u4e5f\u51c6\u5907\u4e86\u4e00\u4e9b\u5c0f\u6e38\u620f\u3002\u5176\u4e2d,\u6709\u4e2a\u6e38\u620f\u662f\u8fd9\u6837\u7684\uff1a\u9996\u5148,\u8ba9\u5c0f\u670b\u53cb\u4eec\u56f4\u6210\u4e00\u4e2a\u5927\u5708\u3002\u7136\u540e,\u4ed6\u968f\u673a\u6307\u5b9a\u4e00\u4e2a\u6570m,\u8ba9\u7f16\u53f7\u4e3a0\u7684\u5c0f\u670b\u53cb\u5f00\u59cb\u62a5\u6570\u3002\u6bcf\u6b21\u558a\u5230m-1\u7684\u90a3\u4e2a\u5c0f\u670b\u53cb\u8981\u51fa\u5217\u5531\u9996\u6b4c,\u7136\u540e\u53ef\u4ee5\u5728\u793c\u54c1\u7bb1\u4e2d\u4efb\u610f\u7684\u6311\u9009\u793c\u7269,\u5e76\u4e14\u4e0d\u518d\u56de\u5230\u5708\u4e2d,\u4ece\u4ed6\u7684\u4e0b\u4e00\u4e2a\u5c0f\u670b\u53cb\u5f00\u59cb,\u7ee7\u7eed0...m-1\u62a5\u6570....\u8fd9\u6837\u4e0b\u53bb....\u76f4\u5230\u5269\u4e0b\u6700\u540e\u4e00\u4e2a\u5c0f\u670b\u53cb,\u53ef\u4ee5\u4e0d\u7528\u8868\u6f14,\u5e76\u4e14\u62ff\u5230\u725b\u5ba2\u540d\u8d35\u7684\u201c\u540d\u4fa6\u63a2\u67ef\u5357\u201d\u5178\u85cf\u7248(\u540d\u989d\u6709\u9650\u54e6!! _ )\u3002\u8bf7\u4f60\u8bd5\u7740\u60f3\u4e0b,\u54ea\u4e2a\u5c0f\u670b\u53cb\u4f1a\u5f97\u5230\u8fd9\u4efd\u793c\u54c1\u5462\uff1f(\u6ce8\uff1a\u5c0f\u670b\u53cb\u7684\u7f16\u53f7\u662f\u4ece0\u5230n-1)\u3002\u5982\u679c\u6ca1\u6709\u5c0f\u670b\u53cb\uff0c\u8bf7\u8fd4\u56de-1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public \uff1a int LastRemaining_Solution ( int n , int m ) { int i = 0 , j = 0 , numOut = 0 , * out = new int [ n ]{}; while ( numOut < n - 1 ) { while ( out [ i ]) { i ++ ; if ( i == n ) { i = 0 ; } } if ( j == m -1 ) { out [ i ] = true ; numOut ++ ; } i ++ ; j ++ ; if ( i == n ) { i = 0 ; } if ( j == m ) { j = 0 ; } } int res = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! out [ i ]) { res = i ; } } delete [] out ; return res ; } }; 47. \u6c421+2+3+...+n \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6c421+2+3+...+n\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u4e58\u9664\u6cd5\u3001for\u3001while\u3001if\u3001else\u3001switch\u3001case\u7b49\u5173\u952e\u5b57\u53ca\u6761\u4ef6\u5224\u65ad\u8bed\u53e5\uff08A?B\uff1aC\uff09\u3002 1 2 3 4 5 6 class Solution { public \uff1a int Sum_Solution ( int n ) { return ( n + 1 ) * n / 2 ; } }; 48. \u4e0d\u7528\u52a0\u51cf\u4e58\u9664\u505a\u52a0\u6cd5* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u6c42\u4e24\u4e2a\u6574\u6570\u4e4b\u548c\uff0c\u8981\u6c42\u5728\u51fd\u6570\u4f53\u5185\u4e0d\u5f97\u4f7f\u7528+\u3001-\u3001*\u3001/\u56db\u5219\u8fd0\u7b97\u7b26\u53f7\u3002 Solution\uff1aXOR + &A = 000101 = 5, B = 010001 = 17 1) sum = 000101 XOR 010001 = 010100 = 20, pos = 000101 & 010001 = 000001 = 1. We have to move left for 000001 at 0-th position (starting from rightmost). 2) if pos is not 0, A = sum, B = (pos << 1) then continue 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a int Add ( int num1 , int num2 ) { int res = num1 ; int pos = num2 ; while ( true ) { res = num1 ^ num2 ; pos = num1 & num2 ; if ( pos == 0 ) { break ; } num1 = res ; num2 = pos << 1 ; } return res ; } }; 49. \u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u4e00\u4e2a\u6574\u6570\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u5b57\u7b26\u4e32\u8f6c\u6362\u6574\u6570\u7684\u5e93\u51fd\u6570\u3002\u6570\u503c\u4e3a0\u6216\u8005\u5b57\u7b26\u4e32\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u6570\u503c\u5219\u8fd4\u56de0\u3002\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32,\u5305\u62ec\u6570\u5b57\u5b57\u6bcd\u7b26\u53f7,\u53ef\u4ee5\u4e3a\u7a7a\u3002\u5982\u679c\u662f\u5408\u6cd5\u7684\u6570\u503c\u8868\u8fbe\u5219\u8fd4\u56de\u8be5\u6570\u5b57\uff0c\u5426\u5219\u8fd4\u56de0\u3002 \u8f93\u5165+21474836471a33 \u8f93\u51fa21474836470 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public \uff1a int StrToInt ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return 0 ; } int num = 0 ; bool isPlus = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 && str [ 0 ] == '-' ) { isPlus = false ; continue ; } if ( i == 0 && str [ 0 ] == '+' ) { continue ; } if ( str [ i ] > '9' || str [ i ] < '0' ) { return 0 ; } num = num * 10 + str [ i ] - '0' ; } if ( ! isPlus ) { return - num ; } return num ; } }; 50. \u6570\u7ec4\u4e2d\u91cd\u590d\u7684\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4\u91cc\u7684\u6240\u6709\u6570\u5b57\u90fd\u57280\u5230n-1\u7684\u8303\u56f4\u5185\u3002 \u6570\u7ec4\u4e2d\u67d0\u4e9b\u6570\u5b57\u662f\u91cd\u590d\u7684\uff0c\u4f46\u4e0d\u77e5\u9053\u6709\u51e0\u4e2a\u6570\u5b57\u662f\u91cd\u590d\u7684\u3002\u4e5f\u4e0d\u77e5\u9053\u6bcf\u4e2a\u6570\u5b57\u91cd\u590d\u51e0\u6b21\u3002\u8bf7\u627e\u51fa\u6570\u7ec4\u4e2d\u4efb\u610f\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b57\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u957f\u5ea6\u4e3a7\u7684\u6570\u7ec4{2,3,1,0,2,5,3}\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u8f93\u51fa\u662f\u7b2c\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b572\u3002\u8fd4\u56de\u63cf\u8ff0\uff1a\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u51fd\u6570\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u628a\u91cd\u590d\u7684\u6570\u5b57\u653e\u5230\u53c2\u6570duplication[0]\u4e2d\u3002\uff08ps\uff1aduplication\u5df2\u7ecf\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u76f4\u63a5\u8d4b\u503c\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public \uff1a // Parameters\uff1a // numbers\uff1a an array of integers // length\uff1a the length of array numbers // duplication\uff1a (Output) the duplicated number in the array number // Return value\uff1a true if the input is valid, and there are some // duplications in the array number // otherwise false bool duplicate ( int numbers [], int length , int * duplication ) { if ( length == 0 ) { return false ; } int * arr = new int [ length ]{}; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ numbers [ i ]] == length ) { arr [ numbers [ i ]] = i ; } if ( arr [ numbers [ i ]] == 0 ) { arr [ numbers [ i ]] = length ; } } int idx = length ; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ i ] == 0 ) { continue ; } if ( idx > arr [ i ]) { idx = arr [ i ]; } } delete [] arr ; if ( idx == length ) { return false ; } * duplication = numbers [ idx ]; return true ; } }; 51. \u6784\u5efa\u4e58\u79ef\u6570\u7ec4 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4A[0,1,...,n-1], \u8bf7\u6784\u5efa\u4e00\u4e2a\u6570\u7ec4B[0,1,...,n-1], \u5176\u4e2dB\u4e2d\u7684\u5143\u7d20 B[i] = A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]\u3002\u4e0d\u80fd\u4f7f\u7528\u9664\u6cd5\u3002\uff08\u6ce8\u610f\uff1a\u89c4\u5b9aB[0] = A[1] * A[2] * ... * A[n-1]\uff0cB[n-1] = A[0] * A[1] * ... * A[n-2];\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a vector < int > multiply ( const vector < int >& A ) { vector < int > res ; int n = int ( A . size ()); if ( n == 0 ) { return res ; } for ( int i = 0 ; i < n ; i ++ ) { int mul = A [ 0 ]; for ( int j = 1 ; j < n ; j ++ ) { if ( j == i ) { continue ; } if ( A [ j ] == 0 ) { mul = 0 ; break ; } mul *= A [ j ]; } res . push_back ( mul ); } return res ; } }; 52. \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5339\u914d\u5305\u62ec'.'\u548c' '\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\u6a21\u5f0f\u4e2d\u7684\u5b57\u7b26'.'\u8868\u793a\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\uff0c\u800c' '\u8868\u793a\u5b83\u524d\u9762\u7684\u5b57\u7b26\u53ef\u4ee5\u51fa\u73b0\u4efb\u610f\u6b21\uff08\u5305\u542b0\u6b21\uff09\u3002\u5728\u672c\u9898\u4e2d\uff0c\u5339\u914d\u662f\u6307\u5b57\u7b26\u4e32\u7684\u6240\u6709\u5b57\u7b26\u5339\u914d\u6574\u4e2a\u6a21\u5f0f\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"aaa\"\u4e0e\u6a21\u5f0f\"a.a\"\u548c\"ab ac a\"\u5339\u914d\uff0c\u4f46\u662f\u4e0e\"aa.a\"\u548c\"ab*a\"\u5747\u4e0d\u5339\u914d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a bool match ( char * str , char * pattern ) { size_t ns = strlen ( str ), np = strlen ( pattern ); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np -1 ; j >= 0 ; j -- ) { bool ijMatch = ( i < ns ) && ( str [ i ] == pattern [ j ] || pattern [ j ] == '.' ); if ( j < np -1 && pattern [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } bool res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } }; 53. \u8868\u793a\u6570\u503c\u7684\u5b57\u7b26\u4e32* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u8868\u793a\u6570\u503c\uff08\u5305\u62ec\u6574\u6570\u548c\u5c0f\u6570\uff09\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"+100\", \"5e2\", \"-123\", \"3.1416\" \u548c \"-1E-16\" \u90fd\u8868\u793a\u6570\u503c\u3002 \u4f46\u662f \"12e\", \"1a3.14\", \"1.2.3\", \"+-5\" \u548c \"12e+4.3\" \u90fd\u4e0d\u662f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a bool isNumeric ( char * string ) { size_t n = strlen ( string ); if ( n == 0 ) { return false ; } bool isEx = false , isPt = false ; for ( int i = 0 ; i < n ; i ++ ) { if (( string [ i ] == '+' || string [ i ] == '-' )) { if ( i == 0 ) { continue ; } if ( string [ i -1 ] == 'E' || string [ i -1 ] == 'e' ) { continue ; } return false ; } if ( string [ i ] == 'e' || string [ i ] == 'E' ) { if ( isEx || i == n -1 ) { return false ; } isEx = true ; continue ; } if ( string [ i ] == '.' ) { if ( isPt || isEx || i == n -1 ) { return false ; } isPt = true ; continue ; } if ( string [ i ] > '9' || string [ i ] < '0' ) { return false ; } } return true ; } }; 54. \u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u91cd\u590d\u7684\u5b57\u7b26* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u627e\u51fa\u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5f53\u4ece\u5b57\u7b26\u6d41\u4e2d\u53ea\u8bfb\u51fa\u524d\u4e24\u4e2a\u5b57\u7b26\"go\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"g\"\u3002\u5f53\u4ece\u8be5\u5b57\u7b26\u6d41\u4e2d\u8bfb\u51fa\u524d\u516d\u4e2a\u5b57\u7b26\u201cgoogle\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"l\"\u3002\u5982\u679c\u5f53\u524d\u5b57\u7b26\u6d41\u6ca1\u6709\u5b58\u5728\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u8fd4\u56de#\u5b57\u7b26\u3002 Solution\uff1aint[0\uff1a256] = 0Give each ACSII a position index in the char flow starting from 1.If repeat appears, set int[i] = -1Return ACSII with minimum position index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { int * ascii ; int N ; int flow ; public \uff1a Solution () { N = 256 ; ascii = new int [ N ]{}; flow = 1 ; } ~ Solution () { delete [] ascii ; } //Insert one char from stringstream void Insert ( char ch ) { int idx = int ( ch ); if ( ascii [ idx ] == 0 ) { ascii [ idx ] = flow ; } else { ascii [ idx ] = -1 ; } flow ++ ; } //return the first appearence once char in current stringstream char FirstAppearingOnce () { int pos = flow , ch = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] < 1 ) { continue ; } if ( pos > ascii [ i ]) { pos = ascii [ i ]; ch = i ; } } if ( pos == flow ) { return '#' ; } return char ( ch ); } }; 55. \u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u7ed3\u70b9* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4e00\u4e2a\u94fe\u8868\uff0c\u82e5\u5176\u4e2d\u5305\u542b\u73af\uff0c\u8bf7\u627e\u51fa\u8be5\u94fe\u8868\u7684\u73af\u7684\u5165\u53e3\u7ed3\u70b9\uff0c\u5426\u5219\uff0c\u8f93\u51fanull\u3002 For the case of circle. Set two pointors p1 and p2 staring from head. p1 moves one step each time; p2 moves 2 steps each time. Because of a loop, p1 and p2 will definitely come across at some node in the loop. Suppose p1 moves x steps, then p2 moves evidently 2x steps. Besides, p2 has covered at least one circile. 2x - x = kn, \\quad k = 1, 2, 3, ... 2x - x = kn, \\quad k = 1, 2, 3, ... where n denotes the length of loop. We can also see both p1 and p2 have covered the part beyond the loop, says L1. x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... So, we one pointor moves starting from M and the other moves starting from head and both of them move with 1 step. Then they will meet again at the statrt of loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * EntryNodeOfLoop ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * p1 = pHead , * p2 = pHead ; while ( p1 != NULL && p2 != NULL ) { p1 = p1 -> next ; p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p1 == p2 ) { break ; } } p2 = pHead ; while ( p2 != p1 ) { p1 = p1 -> next ; p2 = p2 -> next ; } return p1 ; } }; 56. \u5220\u9664\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u6392\u5e8f\u7684\u94fe\u8868\u4e2d\uff0c\u5b58\u5728\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u8bf7\u5220\u9664\u8be5\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u91cd\u590d\u7684\u7ed3\u70b9\u4e0d\u4fdd\u7559\uff0c\u8fd4\u56de\u94fe\u8868\u5934\u6307\u9488\u3002 \u4f8b\u5982\uff0c\u94fe\u88681->2->3->3->4->4->5 \u5904\u7406\u540e\u4e3a 1->2->5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * deleteDuplication ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * pre = new ListNode ( 0 ); pre -> next = pHead ; ListNode * par = pre , * cur = pHead ; bool isDup = false ; while ( cur != NULL ) { while ( cur -> next != NULL && cur -> next -> val == cur -> val ) { cur = cur -> next ; isDup = true ; } cur = cur -> next ; if ( isDup ) { par -> next = cur ; isDup = false ; } else { par = par -> next ; } } pHead = pre -> next ; delete pre ; return pHead ; } }; 57. \u4e8c\u53c9\u6811\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\u548c\u5176\u4e2d\u7684\u4e00\u4e2a\u7ed3\u70b9\uff0c\u8bf7\u627e\u51fa\u4e2d\u5e8f\u904d\u5386\u987a\u5e8f\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u5e76\u4e14\u8fd4\u56de\u3002\u6ce8\u610f\uff0c\u6811\u4e2d\u7684\u7ed3\u70b9\u4e0d\u4ec5\u5305\u542b\u5de6\u53f3\u5b50\u7ed3\u70b9\uff0c\u540c\u65f6\u5305\u542b\u6307\u5411\u7236\u7ed3\u70b9\u7684\u6307\u9488\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) \uff1aval(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public \uff1a TreeLinkNode * GetNext ( TreeLinkNode * pNode ) { if ( pNode == NULL ) { return NULL ; } if ( pNode -> right != NULL ) { TreeLinkNode * curNode = pNode -> right ; while ( curNode -> left != NULL ) { curNode = curNode -> left ; } return curNode ; } if ( pNode -> next == NULL ) { return NULL ; } if ( pNode -> next -> left == pNode ) { return pNode -> next ; } if ( pNode -> next -> next != NULL && pNode -> next -> next -> left == pNode -> next ) { return pNode -> next -> next ; } return NULL ; } }; 58. \u5bf9\u79f0\u7684\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u4e00\u9897\u4e8c\u53c9\u6811\u662f\u4e0d\u662f\u5bf9\u79f0\u7684\u3002\u6ce8\u610f\uff0c\u5982\u679c\u4e00\u4e2a\u4e8c\u53c9\u6811\u540c\u6b64\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u662f\u540c\u6837\u7684\uff0c\u5b9a\u4e49\u5176\u4e3a\u5bf9\u79f0\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a bool isSymmetrical ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return true ; } return isSymmetricalSubtree ( pRoot -> left , pRoot -> right ); } bool isSymmetricalSubtree ( TreeNode * left , TreeNode * right ) { if ( left == NULL && right == NULL ) { return true ; } if ( left == NULL || right == NULL ) { return false ; } if ( left -> val != right -> val ) { return false ; } bool L = isSymmetricalSubtree ( left -> left , right -> right ); bool R = isSymmetricalSubtree ( left -> right , right -> left ); return ( L && R ); } }; 59. \u6309\u4e4b\u5b57\u5f62\u987a\u5e8f\u6253\u5370\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6309\u7167\u4e4b\u5b57\u5f62\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u5373\u7b2c\u4e00\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e8c\u5c42\u6309\u7167\u4ece\u53f3\u81f3\u5de6\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e09\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u5176\u4ed6\u884c\u4ee5\u6b64\u7c7b\u63a8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a void inverse ( vector < int >& arr ) { int len = int ( arr . size ()); for ( int i = 0 ; i < len / 2 ; i ++ ) { int temp = arr [ i ]; arr [ i ] = arr [ len -1 - i ]; arr [ len -1 - i ] = temp ; } } vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int >> res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; int count = 1 ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { if ( count % 2 == 0 ) { inverse ( temp ); } count ++ ; res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } }; 60. \u628a\u4e8c\u53c9\u6811\u6253\u5370\u6210\u591a\u884c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5230\u4e0b\u6309\u5c42\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u540c\u4e00\u5c42\u7ed3\u70b9\u4ece\u5de6\u81f3\u53f3\u8f93\u51fa\u3002\u6bcf\u4e00\u5c42\u8f93\u51fa\u4e00\u884c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int > > res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } }; 61. \u5e8f\u5217\u5316\u4e8c\u53c9\u6811* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u6765\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u4e8c\u53c9\u6811 \u4e8c\u53c9\u6811\u7684\u5e8f\u5217\u5316\u662f\u6307\uff1a\u628a\u4e00\u68f5\u4e8c\u53c9\u6811\u6309\u7167\u67d0\u79cd\u904d\u5386\u65b9\u5f0f\u7684\u7ed3\u679c\u4ee5\u67d0\u79cd\u683c\u5f0f\u4fdd\u5b58\u4e3a\u5b57\u7b26\u4e32\uff0c\u4ece\u800c\u4f7f\u5f97\u5185\u5b58\u4e2d\u5efa\u7acb\u8d77\u6765\u7684\u4e8c\u53c9\u6811\u53ef\u4ee5\u6301\u4e45\u4fdd\u5b58\u3002\u5e8f\u5217\u5316\u53ef\u4ee5\u57fa\u4e8e\u5148\u5e8f\u3001\u4e2d\u5e8f\u3001\u540e\u5e8f\u3001\u5c42\u5e8f\u7684\u4e8c\u53c9\u6811\u904d\u5386\u65b9\u5f0f\u6765\u8fdb\u884c\u4fee\u6539\uff0c\u5e8f\u5217\u5316\u7684\u7ed3\u679c\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5e8f\u5217\u5316\u65f6\u901a\u8fc7 \u67d0\u79cd\u7b26\u53f7\u8868\u793a\u7a7a\u8282\u70b9\uff08#\uff09\uff0c\u4ee5 \uff01 \u8868\u793a\u4e00\u4e2a\u7ed3\u70b9\u503c\u7684\u7ed3\u675f\uff08value!\uff09\u3002\u4e8c\u53c9\u6811\u7684\u53cd\u5e8f\u5217\u5316\u662f\u6307\uff1a\u6839\u636e\u67d0\u79cd\u904d\u5386\u987a\u5e8f\u5f97\u5230\u7684\u5e8f\u5217\u5316\u5b57\u7b26\u4e32\u7ed3\u679cstr\uff0c\u91cd\u6784\u4e8c\u53c9\u6811\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u4e00\u4e2a\u53ea\u6709\u6839\u8282\u70b9\u4e3a1\u7684\u4e8c\u53c9\u6811\u5e8f\u5217\u5316\u4e3a\"1,\"\uff0c\u7136\u540e\u901a\u8fc7\u81ea\u5df1\u7684\u51fd\u6570\u6765\u89e3\u6790\u56de\u8fd9\u4e2a\u4e8c\u53c9\u6811 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a char * Serialize ( TreeNode * root ) { string pre = \"\" , in = \"\" ; preOrder ( root , pre ); inOrder ( root , in ); pre . push_back ( '#' ); pre += in ; int n = int ( pre . length ()); char * str = new char [ n + 1 ]{}; for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = pre [ i ]; } str [ n ] = '\\0' ; return str ; } void preOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { str += to_string ( root -> val ); str . push_back ( ',' ); preOrder ( root -> left , str ); preOrder ( root -> right , str ); } } void inOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { inOrder ( root -> left , str ); str += to_string ( root -> val ); str . push_back ( ',' ); inOrder ( root -> right , str ); } } TreeNode * Deserialize ( char * str ) { vector < int > pre , in ; bool isPre = true ; int val = 0 ; for ( int i = 0 ; i < strlen ( str ); i ++ ) { if ( str [ i ] == '#' ) { isPre = false ; continue ; } if ( str [ i ] == ',' ) { if ( isPre ) { pre . push_back ( val ); } else { in . push_back ( val ); } val = 0 ; continue ; } val = val * 10 + ( str [ i ] - '0' ); } int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return constructTree ( pre , in , 0 , n -1 , 0 , n -1 ); } TreeNode * constructTree ( vector < int > pre , vector < int > in , int b1 , int e1 , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int numLeft = 0 ; for ( int i = b2 ; i <= e2 ; i ++ , numLeft ++ ) { if ( in [ i ] == pre [ b1 ]) { break ; } } root -> left = constructTree ( pre , in , b1 + 1 , b1 + numLeft , b2 , b2 + numLeft -1 ); root -> right = constructTree ( pre , in , b1 + numLeft + 1 , e1 , b2 + numLeft + 1 , e2 ); return root ; } }; 62. \u4e8c\u53c9\u6811\u7684\u7b2ck\u4e2a\u7ed3\u70b9* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u8bf7\u627e\u51fa\u5176\u4e2d\u7684\u7b2ck\u5c0f\u7684\u7ed3\u70b9\u3002\u4f8b\u5982\uff0c\uff085\uff0c3\uff0c7\uff0c2\uff0c4\uff0c6\uff0c8\uff09\u4e2d\uff0c\u6309\u7ed3\u70b9\u6570\u503c\u5927\u5c0f\u987a\u5e8f\u7b2c\u4e09\u5c0f\u7ed3\u70b9\u7684\u503c\u4e3a4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a TreeNode * KthNode ( TreeNode * pRoot , int k ) { TreeNode * res = NULL ; inOrder ( pRoot , k , res ); return res ; } void inOrder ( TreeNode * root , int & k , TreeNode *& res ) { if ( root != NULL ) { inOrder ( root -> left , k , res ); k -- ; if ( k == 0 ) { res = root ; } inOrder ( root -> right , k , res ); } } }; 63. \u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5982\u4f55\u5f97\u5230\u4e00\u4e2a\u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570\uff1f\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5947\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4f4d\u4e8e\u4e2d\u95f4\u7684\u6570\u503c\u3002\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5076\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4e2d\u95f4\u4e24\u4e2a\u6570\u7684\u5e73\u5747\u503c\u3002\u6211\u4eec\u4f7f\u7528Insert()\u65b9\u6cd5\u8bfb\u53d6\u6570\u636e\u6d41\uff0c\u4f7f\u7528GetMedian()\u65b9\u6cd5\u83b7\u53d6\u5f53\u524d\u8bfb\u53d6\u6570\u636e\u7684\u4e2d\u4f4d\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { vector < int > arr ; public \uff1a void Insert ( int num ) { arr . push_back ( num ); } void swap ( vector < int >& arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int >& arr , int begin , int end , int n ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] > arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] > arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i -1 , n ); quickSort ( arr , j + 1 , end , n ); } } double GetMedian () { int n = int ( arr . size ()); quickSort ( arr , 0 , n -1 , n ); if ( n % 2 ) { return arr [ n / 2 ]; } else { return ( arr [( n -1 ) / 2 ] + arr [ n / 2 ]) / 2.0 ; } } }; 64. \u6ed1\u52a8\u7a97\u53e3\u7684\u6700\u5927\u503c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u548c\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f\uff0c\u627e\u51fa\u6240\u6709\u6ed1\u52a8\u7a97\u53e3\u91cc\u6570\u503c\u7684\u6700\u5927\u503c\u3002\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u6570\u7ec4{2,3,4,2,6,2,5,1}\u53ca\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f3\uff0c\u90a3\u4e48\u4e00\u5171\u5b58\u57286\u4e2a\u6ed1\u52a8\u7a97\u53e3\uff0c\u4ed6\u4eec\u7684\u6700\u5927\u503c\u5206\u522b\u4e3a{4,4,6,6,6,5}\uff1b \u9488\u5bf9\u6570\u7ec4{2,3,4,2,6,2,5,1}\u7684\u6ed1\u52a8\u7a97\u53e3\u6709\u4ee5\u4e0b6\u4e2a\uff1a {[2,3,4],2,6,2,5,1}\uff0c {2,[3,4,2],6,2,5,1}\uff0c {2,3,[4,2,6],2,5,1}\uff0c {2,3,4,[2,6,2],5,1}\uff0c {2,3,4,2,[6,2,5],1}\uff0c {2,3,4,2,6,[2,5,1]}\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a vector < int > maxInWindows ( const vector < int >& num , unsigned int size ) { vector < int > res ; int n = int ( num . size ()); if ( n < size || size < 1 ) { return res ; } for ( int i = 0 ; i < n - size + 1 ; i ++ ) { int max = num [ i ]; for ( int j = i + 1 ; j <= i + size - 1 ; j ++ ) { if ( max < num [ j ]) { max = num [ j ]; } } res . push_back ( max ); } return res ; } }; 65. \u77e9\u9635\u4e2d\u7684\u8def\u5f84 \u00b6 \u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u5728\u4e00\u4e2a\u77e9\u9635\u4e2d\u662f\u5426\u5b58\u5728\u4e00\u6761\u5305\u542b\u67d0\u5b57\u7b26\u4e32\u6240\u6709\u5b57\u7b26\u7684\u8def\u5f84\u3002\u8def\u5f84\u53ef\u4ee5\u4ece\u77e9\u9635\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u683c\u5b50\u5f00\u59cb\uff0c\u6bcf\u4e00\u6b65\u53ef\u4ee5\u5728\u77e9\u9635\u4e2d\u5411\u5de6\uff0c\u5411\u53f3\uff0c\u5411\u4e0a\uff0c\u5411\u4e0b\u79fb\u52a8\u4e00\u4e2a\u683c\u5b50\u3002\u5982\u679c\u4e00\u6761\u8def\u5f84\u7ecf\u8fc7\u4e86\u77e9\u9635\u4e2d\u7684\u67d0\u4e00\u4e2a\u683c\u5b50\uff0c\u5219\u8be5\u8def\u5f84\u4e0d\u80fd\u518d\u8fdb\u5165\u8be5\u683c\u5b50\u3002 \u4f8b\u5982 \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} (stock in an array [a, b, c, e, s, f, c, s, a, d, e, e])\u3002 \u77e9\u9635\u4e2d\u5305\u542b\u4e00\u6761\u5b57\u7b26\u4e32\"bcced\"\u7684\u8def\u5f84\uff0c\u4f46\u662f\u77e9\u9635\u4e2d\u4e0d\u5305\u542b\"abcb\"\u8def\u5f84\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26b\u5360\u636e\u4e86\u77e9\u9635\u4e2d\u7684\u7b2c\u4e00\u884c\u7b2c\u4e8c\u4e2a\u683c\u5b50\u4e4b\u540e\uff0c\u8def\u5f84\u4e0d\u80fd\u518d\u6b21\u8fdb\u5165\u8be5\u683c\u5b50\u3002 Solution\uff1aBacktracking\uff1a if we can find one character matched, we continue to explore next one (up, down, left, right); if one character doesn't match, we reset all previous positions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a bool hasPath ( char * matrix , int rows , int cols , char * str ) { bool * dp = new bool [ rows * cols ]{}, res = false ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( isPath ( i , j , rows , cols , matrix , str , dp , 0 )) { res = true ; break ; } } } delete [] dp ; return res ; } bool isPath ( int i , int j , int nRow , int nCol , char * mat , char * str , bool * dp , int k ) { int idx = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ idx ] || mat [ idx ] != str [ k ]) { return false ; } if ( str [ k + 1 ] == '\\0' ) { return true ; } dp [ idx ] = true ; bool u = isPath ( i -1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool d = isPath ( i + 1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool l = isPath ( i , j -1 , nRow , nCol , mat , str , dp , k + 1 ); bool r = isPath ( i , j + 1 , nRow , nCol , mat , str , dp , k + 1 ); dp [ idx ] = false ; return u || d || l || r ; } }; 66. \u673a\u5668\u4eba\u7684\u8fd0\u52a8\u8303\u56f4* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5730\u4e0a\u6709\u4e00\u4e2am\u884c\u548cn\u5217\u7684\u65b9\u683c\u3002\u4e00\u4e2a\u673a\u5668\u4eba\u4ece\u5750\u68070,0\u7684\u683c\u5b50\u5f00\u59cb\u79fb\u52a8\uff0c\u6bcf\u4e00\u6b21\u53ea\u80fd\u5411\u5de6\uff0c\u53f3\uff0c\u4e0a\uff0c\u4e0b\u56db\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u4e0d\u80fd\u8fdb\u5165\u884c\u5750\u6807\u548c\u5217\u5750\u6807\u7684\u6570\u4f4d\u4e4b\u548c\u5927\u4e8ek\u7684\u683c\u5b50\u3002 \u4f8b\u5982\uff0c\u5f53k\u4e3a18\u65f6\uff0c\u673a\u5668\u4eba\u80fd\u591f\u8fdb\u5165\u65b9\u683c\uff0835,37\uff09\uff0c\u56e0\u4e3a3+5+3+7 = 18\u3002\u4f46\u662f\uff0c\u5b83\u4e0d\u80fd\u8fdb\u5165\u65b9\u683c\uff0835,38\uff09\uff0c\u56e0\u4e3a3+5+3+8 = 19\u3002\u8bf7\u95ee\u8be5\u673a\u5668\u4eba\u80fd\u591f\u8fbe\u5230\u591a\u5c11\u4e2a\u683c\u5b50\uff1f Solution\uff1aBacktracking is one of brutal force method in searching. We cannot simply count how many grids which are illegal because the robot can only move one cell once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a int movingCount ( int threshold , int rows , int cols ) { bool * dp = new bool [ rows * cols ]{}; int count = move ( threshold , rows , cols , 0 , 0 , dp ); delete [] dp ; return count ; } int move ( int threshold , int nRow , int nCol , int i , int j , bool * dp ) { int pos = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ pos ] || toSum ( i ) + toSum ( j ) > threshold ) { return 0 ; } dp [ pos ] = true ; int u = move ( threshold , nRow , nCol , i -1 , j , dp ); int d = move ( threshold , nRow , nCol , i + 1 , j , dp ); int l = move ( threshold , nRow , nCol , i , j -1 , dp ); int r = move ( threshold , nRow , nCol , i , j + 1 , dp ); return 1 + u + d + l + r ; } int toSum ( int num ) { int sum = 0 ; while ( num ) { sum += num % 10 ; num /= 10 ; } return sum ; } }; 67. \u526a\u7ef3\u5b50* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4f60\u4e00\u6839\u957f\u5ea6\u4e3an\u7684\u7ef3\u5b50\uff0c\u8bf7\u628a\u7ef3\u5b50\u526a\u6210\u6574\u6570\u957f\u7684m\u6bb5\uff08m\u3001n\u90fd\u662f\u6574\u6570\uff0cn>1\u5e76\u4e14m>1\uff09\uff0c\u6bcf\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u8bb0\u4e3ak[0],k[1],...,k[m]\u3002\u8bf7\u95eek[0]xk[1]x...xk[m]\u53ef\u80fd\u7684\u6700\u5927\u4e58\u79ef\u662f\u591a\u5c11\uff1f\u4f8b\u5982\uff0c\u5f53\u7ef3\u5b50\u7684\u957f\u5ea6\u662f8\u65f6\uff0c\u6211\u4eec\u628a\u5b83\u526a\u6210\u957f\u5ea6\u5206\u522b\u4e3a2\u30013\u30013\u7684\u4e09\u6bb5\uff0c\u6b64\u65f6\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u662f18\u3002 \u793a\u4f8b1\uff1a\u8f93\u51658\u8f93\u51fa18 Solution\uff1aSuppose f(n) denote the max product. We have an interative equation f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} Attention, there is some special case, when n = 2, we should return 1. In iterative equation, f(2) denotes length of the rope. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a int cutRope ( int number ) { int n = number ; if ( n < 2 ) { return 0 ; } if ( n == 2 ) { return 1 ; } if ( n == 3 ) { return 2 ; } int * f = new int [ n + 1 ]{}; f [ 1 ] = 1 ; f [ 2 ] = 2 ; f [ 3 ] = 3 ; int prod = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { int max_prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { prod = f [ j ] * f [ i - j ]; if ( max_prod < prod ) { max_prod = prod ; } } f [ i ] = max_prod ; } int res = f [ n ]; delete [] f ; return res ; } }; 68. OJ\u5728\u7ebf\u7f16\u7a0b\u5e38\u89c1\u8f93\u5165\u8f93\u51fa\u7ec3\u4e60\u573a \u00b6 68.1 A+B(1) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { cout << a + b << endl ; } return 0 ; } 68.2 A+B(2) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6570\u636e\u7ec4\u6570t(1 <= t <= 100)\u63a5\u4e0b\u6765\u6bcf\u884c\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9)\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516521 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> using namespace std ; int main () { int t ; long a , b ; cin >> t ; while ( t -- ) { cin >> a >> b ; cout << ( a + b ) << endl ; } return 0 ; } 68.3 A+B(3) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u5982\u679c\u8f93\u5165\u4e3a0 0\u5219\u7ed3\u675f\u8f93\u5165\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 200 0 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { if ( a == 0 && b == 0 ) { break ; } cout << ( a + b ) << endl ; } return 0 ; } 68.4 A+B(4) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u6bcf\u7ec4\u6570\u636e\u4e00\u884c,\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100), n\u4e3a0\u7684\u65f6\u5019\u7ed3\u675f\u8f93\u5165\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570,\u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 50 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { long sum , a ; int n ; while ( true ) { sum = 0 ; cin >> n ; if ( n == 0 ) { break ; } while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; } 68.5 A+B(5) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7684\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6b63\u6574\u6570t(1 <= t <= 100), \u8868\u793a\u6570\u636e\u7ec4\u6570\u3002\u63a5\u4e0b\u6765t\u884c, \u6bcf\u884c\u4e00\u7ec4\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516524 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { int t , n ; long sum , a ; cin >> t ; while ( t -- ) { cin >> n ; sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; } 68.6 A+B(6) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> using namespace std ; int main () { int n ; long sum , a ; while ( cin >> n ) { sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; } 68.7 A+B(7) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u4e0d\u5b9a\u6709n\u4e2a\u6574\u6570\uff0c\u7a7a\u683c\u9694\u5f00\u3002(1 <= n <= 100)\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 2 34 50 0 0 0 0 \u8f93\u51fa690 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> using namespace std ; int main () { long sum , a ; sum = 0 ; while ( cin >> a ) { sum += a ; if ( cin . get () == '\\n' ) { cout << sum << endl ; sum = 0 ; } } return 0 ; } 68.8 \u5b57\u7b26\u4e32\u6392\u5e8f(1) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6709\u4e24\u884c\uff0c\u7b2c\u4e00\u884cn\u7b2c\u4e8c\u884c\u662fn\u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u5b57\u7b26\u4e32\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7a7a\u683c\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u51655c d a bb e \u8f93\u51faa bb c d e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <string> using namespace std ; void swap ( string * str , int i , int j ) { string temp = str [ i ]; str [ i ] = str [ j ]; str [ j ] = temp ; } void quickSort ( string * str , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( i < j && str [ i ] <= str [ j ]) { j -- ; } swap ( str , i , j ); while ( i < j && str [ i ] <= str [ j ]) { i ++ ; } swap ( str , i , j ); } quickSort ( str , begin , i -1 ); quickSort ( str , j + 1 , end ); } } int main () { int n ; cin >> n ; string * str = new string [ n ]; for ( int i = 0 ; i < n ; i ++ ) { cin >> str [ i ]; } quickSort ( str , 0 , n -1 ); for ( int i = 0 ; i < n -1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n -1 ] << endl ; delete [] str ; return 0 ; } 68.9 \u5b57\u7b26\u4e32\u6392\u5e8f(2) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7\u7a7a\u683c\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u8fc7\u7684\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4e32\u901a\u8fc7\u7a7a\u683c\u9694\u5f00 \u793a\u4f8b1 \u8f93\u5165a c bbf ddddnowcoder \u8f93\u51faa bb cdddd fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <iostream> #include <string> #include <algorithm> #include <vector> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { str . push_back ( temp ); if ( cin . get () == '\\n' ) { sort ( str . begin (), str . end ()); int n = int ( str . size ()); for ( int i = 0 ; i < n -1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n -1 ] << endl ; str . clear (); } } } 68.10 \u5b57\u7b26\u4e32\u6392\u5e8f(3) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7,\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u7528\u4f8b\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7528','\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u5165a,c,bbf,ddddnowcoder \u8f93\u51faa,bb,cdddd,fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> #include <string> #include <vector> #include <algorithm> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { int n = int ( temp . length ()); string s = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp [ i ] == ',' ) { str . push_back ( s ); s = \"\" ; continue ; } s . push_back ( temp [ i ]); } str . push_back ( s ); sort ( str . begin (), str . end ()); n = int ( str . size ()); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ',' ; } cout << str [ n -1 ] << endl ; str . clear (); } } 69. \u5e8f\u5217\u548c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570N\u548c\u957f\u5ea6L\uff0c\u627e\u51fa\u4e00\u6bb5\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8eL\u7684\u8fde\u7eed\u975e\u8d1f\u6574\u6570\uff0c\u4ed6\u4eec\u7684\u548c\u6070\u597d\u4e3aN\u3002\u7b54\u6848\u53ef\u80fd\u6709\u591a\u4e2a\uff0c\u6211\u6211\u4eec\u9700\u8981\u627e\u51fa\u957f\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u4f8b\u5982 N = 18 L = 2\uff1a5 + 6 + 7 = 183 + 4 + 5 + 6 = 18\u90fd\u662f\u6ee1\u8db3\u8981\u6c42\u7684\uff0c\u4f46\u662f\u6211\u4eec\u8f93\u51fa\u66f4\u77ed\u7684 5 6 7 \u793a\u4f8b1\uff1a \u8f93\u516518 2 \u8f93\u51fa5 6 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> using namespace std ; void solution ( int N , int L ) { for ( int m = L ; m <= 100 ; m ++ ) { int x = N / m + ( 1 - m ) / 2 ; //cout << x << endl; if (( 2 * x + m -1 ) * m != 2 * N ) { continue ; } for ( int i = 0 ; i < m -1 ; i ++ ) { cout << ( x + i ) << ' ' ; } cout << ( x + m -1 ) << endl ; return ; } cout << \"No\" << endl ; } int main ( int argc , const char * argv []) { // insert code here... int N , L ; scanf ( \"%d%d\" , & N , & L ); solution ( N , L ); return 0 ; }","title":"\u5251\u6307offer"},{"location":"algo/jsoffer/#js-offer","text":"","title":"JS-offer"},{"location":"algo/jsoffer/#02","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u6bcf\u4e2a\u7a7a\u683c\u66ff\u6362\u6210\u201c%20\u201d\u3002\u4f8b\u5982\uff0c\u5f53\u5b57\u7b26\u4e32\u4e3aWe Are Happy.\u5219\u7ecf\u8fc7\u66ff\u6362\u4e4b\u540e\u7684\u5b57\u7b26\u4e32\u4e3aWe%20Are%20Happy\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void replaceSpace ( char * str , int length ) { if ( length == 0 ) { return ; } int nSpace = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( str [ i ] == ' ' ) { nSpace ++ ; } } int len = length + 2 * nSpace ; for ( int i = length -1 , j = len -1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) { str [ j -- ] = '0' ; str [ j -- ] = '2' ; str [ j -- ] = '%' ; } else { str [ j -- ] = str [ i ]; } } } };","title":"02. \u66ff\u6362\u7a7a\u683c"},{"location":"algo/jsoffer/#03","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u6309\u94fe\u8868\u4ece\u5c3e\u5230\u5934\u7684\u987a\u5e8f\u8fd4\u56de\u4e00\u4e2aArrayList\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) \uff1a * val(x), next(NULL) { * } * }; */ class Solution { public \uff1a vector < int > printListFromTailToHead ( ListNode * head ) { vector < int > arr ; recurPrintList ( arr , head ); return arr ; } void recurPrintList ( vector < int > & arr , ListNode * head ) { if ( head != nullptr ) { recurPrintList ( arr , head -> next ); arr . push_back ( head -> val ); } } };","title":"03. \u4ece\u5c3e\u5230\u5934\u6253\u5370\u94fe\u8868"},{"location":"algo/jsoffer/#04","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u67d0\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\uff0c\u8bf7\u91cd\u5efa\u51fa\u8be5\u4e8c\u53c9\u6811\u3002\u5047\u8bbe\u8f93\u5165\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u4e2d\u90fd\u4e0d\u542b\u91cd\u590d\u7684\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u524d\u5e8f\u904d\u5386\u5e8f\u5217{1,2,4,7,3,5,6,8}\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217{4,7,2,1,5,3,8,6}\uff0c\u5219\u91cd\u5efa\u4e8c\u53c9\u6811\u5e76\u8fd4\u56de\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) {} * }; */ class Solution { public \uff1a TreeNode * reConstructBinaryTree ( vector < int > pre , vector < int > vin ) { int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return construct ( pre , 0 , n -1 , vin , 0 , n -1 ); } TreeNode * construct ( vector < int > pre , int b1 , int e1 , vector < int > vin , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int id = b2 ; for (; id <= e2 ; id ++ ) { if ( vin [ id ] == pre [ b1 ]) { break ; } } root -> left = construct ( pre , b1 + 1 , b1 + ( id - b2 ), vin , b2 , id -1 ); root -> right = construct ( pre , b1 + ( id - b2 ) + 1 , e1 , vin , id + 1 , e2 ); return root ; } };","title":"04. \u91cd\u5efa\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#05","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7528\u4e24\u4e2a\u6808\u6765\u5b9e\u73b0\u4e00\u4e2a\u961f\u5217\uff0c\u5b8c\u6210\u961f\u5217\u7684Push\u548cPop\u64cd\u4f5c\u3002 \u961f\u5217\u4e2d\u7684\u5143\u7d20\u4e3aint\u7c7b\u578b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a void push ( int node ) { stack1 . push ( node ); } int pop () { while ( ! stack1 . empty ()) { stack2 . push ( stack1 . top ()); stack1 . pop (); } int res = stack2 . top (); stack2 . pop (); while ( ! stack2 . empty ()) { stack1 . push ( stack2 . top ()); stack2 . pop (); } return res ; } private \uff1a stack < int > stack1 ; stack < int > stack2 ; };","title":"05. \u7528\u4e24\u4e2a\u6808\u5b9e\u73b0\u961f\u5217"},{"location":"algo/jsoffer/#06","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u4e00\u4e2a\u6570\u7ec4\u6700\u5f00\u59cb\u7684\u82e5\u5e72\u4e2a\u5143\u7d20\u642c\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u6570\u7ec4\u7684\u65cb\u8f6c\u3002 \u8f93\u5165\u4e00\u4e2a\u975e\u9012\u51cf\u6392\u5e8f\u7684\u6570\u7ec4\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8f93\u51fa\u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u5143\u7d20\u3002\u4f8b\u5982\u6570\u7ec4{3,4,5,1,2}\u4e3a{1,2,3,4,5}\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8be5\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u4e3a1\u3002NOTE\uff1a\u7ed9\u51fa\u7684\u6240\u6709\u5143\u7d20\u90fd\u5927\u4e8e0\uff0c\u82e5\u6570\u7ec4\u5927\u5c0f\u4e3a0\uff0c\u8bf7\u8fd4\u56de0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a int minNumberInRotateArray ( vector < int > rotateArray ) { int n = int ( rotateArray . size ()); if ( n == 0 ) { return 0 ; } if ( rotateArray [ 0 ] < rotateArray [ n -1 ]) { return rotateArray [ 0 ]; } for ( int i = n -1 ; i > 0 ; i -- ) { if ( rotateArray [ i ] < rotateArray [ i -1 ]) { return rotateArray [ i ]; } } return 0 ; } };","title":"06. \u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u6570\u5b57"},{"location":"algo/jsoffer/#07","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5927\u5bb6\u90fd\u77e5\u9053\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff0c\u73b0\u5728\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6574\u6570n\uff0c\u8bf7\u4f60\u8f93\u51fa\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7b2cn\u9879\uff08\u4ece0\u5f00\u59cb\uff0c\u7b2c0\u9879\u4e3a0\uff0c\u7b2c1\u9879\u662f1\uff09\u3002n<=39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int Fibonacci ( int n ) { if ( n == 0 || n == 1 ) { return n ; } int t1 = 0 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } };","title":"07. \u6590\u6ce2\u90a3\u5951\u6570\u5217"},{"location":"algo/jsoffer/#08","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\uff08\u5148\u540e\u6b21\u5e8f\u4e0d\u540c\u7b97\u4e0d\u540c\u7684\u7ed3\u679c\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int jumpFloor ( int number ) { if ( number == 0 || number == 1 ) { return 1 ; } int t1 = 1 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } };","title":"08. \u8df3\u53f0\u9636"},{"location":"algo/jsoffer/#09","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u2026\u2026\u5b83\u4e5f\u53ef\u4ee5\u8df3\u4e0an\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\u3002 1 2 3 4 5 6 7 8 class Solution { public \uff1a int jumpFloorII ( int number ) { int res = 1 ; while ( -- number ) { res *= 2 ; } return res ; } };","title":"09. \u53d8\u6001\u8df3\u53f0\u9636"},{"location":"algo/jsoffer/#10","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6211\u4eec\u53ef\u4ee5\u75282 1\u7684\u5c0f\u77e9\u5f62\u6a2a\u7740\u6216\u8005\u7ad6\u7740\u53bb\u8986\u76d6\u66f4\u5927\u7684\u77e9\u5f62\u3002\u8bf7\u95ee\u7528n\u4e2a2 1\u7684\u5c0f\u77e9\u5f62\u65e0\u91cd\u53e0\u5730\u8986\u76d6\u4e00\u4e2a2 n\u7684\u5927\u77e9\u5f62\uff0c\u603b\u5171\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\uff1f\u6bd4\u5982n=3\u65f6\uff0c2 3\u7684\u77e9\u5f62\u5757\u67093\u79cd\u8986\u76d6\u65b9\u6cd5\uff1a f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int rectCover ( int number ) { if ( number <= 2 ) { return number ; } int t1 = 1 , t2 = 2 , temp = 0 ; for ( int i = 3 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } };","title":"10. \u77e9\u5f62\u8986\u76d6"},{"location":"algo/jsoffer/#11-1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\uff0c\u8f93\u51fa\u8be5\u6570\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d1\u7684\u4e2a\u6570\u3002\u5176\u4e2d\u8d1f\u6570\u7528\u8865\u7801\u8868\u793a\u3002 Solution\uff1a8 & 7 = 1000 & 0111 = 00000 = 0 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public \uff1a int NumberOf1 ( int n ) { int res = 0 ; while ( n ) { n &= n -1 ; res ++ ; } return res ; } };","title":"11. \u4e8c\u8fdb\u5236\u4e2d1\u7684\u4e2a\u6570*"},{"location":"algo/jsoffer/#12","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2adouble\u7c7b\u578b\u7684\u6d6e\u70b9\u6570base\u548cint\u7c7b\u578b\u7684\u6574\u6570exponent\u3002\u6c42base\u7684exponent\u6b21\u65b9\u3002\u4fdd\u8bc1base\u548cexponent\u4e0d\u540c\u65f6\u4e3a0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a double Power ( double base , int exponent ) { if ( exponent == 0 ) { return 1 ; } double res = 1.0 ; bool isNegative = false ; if ( exponent < 0 ) { exponent = - exponent ; isNegative = true ; } while ( exponent -- ) { res *= base ; } if ( isNegative ) { return 1 / res ; } return res ; } };","title":"12. \u6570\u503c\u7684\u6574\u6570\u6b21\u65b9"},{"location":"algo/jsoffer/#13","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6765\u8c03\u6574\u8be5\u6570\u7ec4\u4e2d\u6570\u5b57\u7684\u987a\u5e8f\uff0c\u4f7f\u5f97\u6240\u6709\u7684\u5947\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u524d\u534a\u90e8\u5206\uff0c\u6240\u6709\u7684\u5076\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u540e\u534a\u90e8\u5206\uff0c\u5e76\u4fdd\u8bc1\u5947\u6570\u548c\u5947\u6570\uff0c\u5076\u6570\u548c\u5076\u6570\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a void reOrderArray ( vector < int > & array ) { vector < int > odd , even ; int n = int ( array . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] % 2 ) { odd . push_back ( array [ i ]); } else { even . push_back ( array [ i ]); } } for ( int i = 0 , j = 0 ; i < int ( odd . size ()); i ++ , j ++ ) { array [ j ] = odd [ i ]; } for ( int i = 0 , j = int ( odd . size ()); i < int ( even . size ()); i ++ , j ++ ) { array [ j ] = even [ i ]; } } };","title":"13. \u8c03\u6574\u6570\u7ec4\u987a\u5e8f\u4f7f\u5947\u6570\u4f4d\u4e8e\u5076\u6570\u524d\u9762"},{"location":"algo/jsoffer/#14-k","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u8f93\u51fa\u8be5\u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindKthToTail ( ListNode * pListHead , unsigned int k ) { if ( k <= 0 ) { return NULL ; } ListNode * p1 = pListHead , * p2 = pListHead ; for ( int i = 0 ; i < k ; i ++ ) { if ( p2 == NULL ) { return p2 ; } p2 = p2 -> next ; } while ( p2 != NULL ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } };","title":"14. \u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9"},{"location":"algo/jsoffer/#15","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u53cd\u8f6c\u94fe\u8868\u540e\uff0c\u8f93\u51fa\u65b0\u94fe\u8868\u7684\u8868\u5934\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * ReverseList ( ListNode * pHead ) { if ( pHead == NULL || pHead -> next == NULL ) { return pHead ; } ListNode * p1 = NULL , * p2 = pHead , * p3 = pHead -> next ; while ( p3 != NULL ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; p3 = p3 -> next ; } p2 -> next = p1 ; return p2 ; } };","title":"15. \u53cd\u8f6c\u94fe\u8868"},{"location":"algo/jsoffer/#16","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u5355\u8c03\u9012\u589e\u7684\u94fe\u8868\uff0c\u8f93\u51fa\u4e24\u4e2a\u94fe\u8868\u5408\u6210\u540e\u7684\u94fe\u8868\uff0c\u5f53\u7136\u6211\u4eec\u9700\u8981\u5408\u6210\u540e\u7684\u94fe\u8868\u6ee1\u8db3\u5355\u8c03\u4e0d\u51cf\u89c4\u5219\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * Merge ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL ) { return pHead2 ; } if ( pHead2 == NULL ) { return pHead1 ; } ListNode * head = new ListNode ( 0 ); ListNode * cur = head , * p1 = pHead1 , * p2 = pHead2 ; while ( p1 != NULL && p2 != NULL ) { if ( p1 -> val < p2 -> val ) { cur -> next = p1 ; cur = p1 ; p1 = p1 -> next ; } else { cur -> next = p2 ; cur = p2 ; p2 = p2 -> next ; } } if ( p1 != NULL ) { cur -> next = p1 ; } if ( p2 != NULL ) { cur -> next = p2 ; } return head -> next ; } };","title":"16. \u5408\u5e76\u4e24\u4e2a\u6392\u5e8f\u7684\u94fe\u8868"},{"location":"algo/jsoffer/#17","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u68f5\u4e8c\u53c9\u6811A\uff0cB\uff0c\u5224\u65adB\u662f\u4e0d\u662fA\u7684\u5b50\u7ed3\u6784\u3002\uff08ps\uff1a\u6211\u4eec\u7ea6\u5b9a\u7a7a\u6811\u4e0d\u662f\u4efb\u610f\u4e00\u4e2a\u6811\u7684\u5b50\u7ed3\u6784\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a bool HasSubtree ( TreeNode * pRoot1 , TreeNode * pRoot2 ) { if ( pRoot1 == NULL || pRoot2 == NULL ) { return false ; } queue < TreeNode *> qTree ; qTree . push ( pRoot1 ); TreeNode * front = pRoot1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> val == pRoot2 -> val && isSame ( front , pRoot2 )) { return true ; } if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return false ; } bool isSame ( TreeNode * t1 , TreeNode * t2 ) { if ( t2 == NULL ) { return true ; } if ( t1 == NULL || t1 -> val != t2 -> val ) { return false ; } return isSame ( t1 -> left , t2 -> left ) && isSame ( t1 -> right , t2 -> right ); } };","title":"17. \u6811\u7684\u5b50\u7ed3\u6784"},{"location":"algo/jsoffer/#18","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u64cd\u4f5c\u7ed9\u5b9a\u7684\u4e8c\u53c9\u6811\uff0c\u5c06\u5176\u53d8\u6362\u4e3a\u6e90\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a void Mirror ( TreeNode * pRoot ) { if ( pRoot != NULL ) { Mirror ( pRoot -> left ); Mirror ( pRoot -> right ); TreeNode * temp = pRoot -> left ; pRoot -> left = pRoot -> right ; pRoot -> right = temp ; } } };","title":"18. \u4e8c\u53c9\u6811\u7684\u955c\u50cf"},{"location":"algo/jsoffer/#19","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u77e9\u9635\uff0c\u6309\u7167\u4ece\u5916\u5411\u91cc\u4ee5\u987a\u65f6\u9488\u7684\u987a\u5e8f\u4f9d\u6b21\u6253\u5370\u51fa\u6bcf\u4e00\u4e2a\u6570\u5b57\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u5982\u4e0b4 X 4\u77e9\u9635\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u5219\u4f9d\u6b21\u6253\u5370\u51fa\u6570\u5b571,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public \uff1a vector < int > printMatrix ( vector < vector < int > > matrix ) { vector < int > res ; int nRows = int ( matrix . size ()); if ( nRows == 0 ) { return res ; } int nCols = int ( matrix [ 0 ]. size ()); if ( nCols == 0 ) { return res ; } bool ** dp = new bool * [ nRows ]; for ( int i = 0 ; i < nRows ; i ++ ) { dp [ i ] = new bool [ nCols ]{}; } int i = 0 , j = 0 ; int di [ 4 ] = { 0 , 1 , 0 , -1 }, dj [ 4 ] = { 1 , 0 , -1 , 0 }; while ( true ) { bool updated = false ; for ( int k = 0 ; k < 4 ; k ++ ) { while ( isOk ( dp , i + di [ k ], j + dj [ k ], nRows , nCols )) { res . push_back ( matrix [ i ][ j ]); dp [ i ][ j ] = true ; updated = true ; i += di [ k ]; j += dj [ k ]; } } if ( ! updated ) { res . push_back ( matrix [ i ][ j ]); break ; } } for ( i = 0 ; i < nRows ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } bool isOk ( bool ** isVisited , int i , int j , int nRows , int nCols ) { if ( i < 0 || i >= nRows || j < 0 || j >= nCols || isVisited [ i ][ j ]) { return false ; } return true ; } };","title":"19. \u987a\u65f6\u9488\u6253\u5370\u77e9\u9635"},{"location":"algo/jsoffer/#20-min","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5b9a\u4e49\u6808\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8bf7\u5728\u8be5\u7c7b\u578b\u4e2d\u5b9e\u73b0\u4e00\u4e2a\u80fd\u591f\u5f97\u5230\u6808\u4e2d\u6240\u542b\u6700\u5c0f\u5143\u7d20\u7684min\u51fd\u6570\uff08\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u4e3aO\uff081\uff09\uff09\u3002\u6ce8\u610f\uff1a\u4fdd\u8bc1\u6d4b\u8bd5\u4e2d\u4e0d\u4f1a\u5f53\u6808\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u5bf9\u6808\u8c03\u7528pop()\u6216\u8005min()\u6216\u8005top()\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { stack < int > s1 ; stack < int > s2 ; public \uff1a void push ( int value ) { s1 . push ( value ); if ( s2 . empty () || value < s2 . top ()) { s2 . push ( value ); } else { s2 . push ( s2 . top ()); } } void pop () { s1 . pop (); s2 . pop (); } int top () { return s1 . top (); } int min () { return s2 . top (); } };","title":"20. \u5305\u542bmin\u51fd\u6570\u7684\u6808*"},{"location":"algo/jsoffer/#21","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u7b2c\u4e00\u4e2a\u5e8f\u5217\u8868\u793a\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u8bf7\u5224\u65ad\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u662f\u5426\u53ef\u80fd\u4e3a\u8be5\u6808\u7684\u5f39\u51fa\u987a\u5e8f\u3002\u5047\u8bbe\u538b\u5165\u6808\u7684\u6240\u6709\u6570\u5b57\u5747\u4e0d\u76f8\u7b49\u3002\u4f8b\u5982\u5e8f\u52171,2,3,4,5\u662f\u67d0\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u5e8f\u52174,5,3,2,1\u662f\u8be5\u538b\u6808\u5e8f\u5217\u5bf9\u5e94\u7684\u4e00\u4e2a\u5f39\u51fa\u5e8f\u5217\uff0c\u4f464,3,5,1,2\u5c31\u4e0d\u53ef\u80fd\u662f\u8be5\u538b\u6808\u5e8f\u5217\u7684\u5f39\u51fa\u5e8f\u5217\u3002\uff08\u6ce8\u610f\uff1a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u957f\u5ea6\u662f\u76f8\u7b49\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a bool IsPopOrder ( vector < int > pushV , vector < int > popV ) { int n = int ( pushV . size ()); stack < int > st ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pushV [ i ] == popV [ j ]) { j ++ ; } else { st . push ( pushV [ i ]); } } for (; j < n ; j ++ ) { if ( st . empty () || st . top () != popV [ j ]) { return false ; } st . pop (); } return true ; } };","title":"21. \u6808\u7684\u538b\u5165\u3001\u5f39\u51fa\u5e8f\u5217"},{"location":"algo/jsoffer/#22","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u540c\u5c42\u8282\u70b9\u4ece\u5de6\u81f3\u53f3\u6253\u5370\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < int > PrintFromTopToBottom ( TreeNode * root ) { vector < int > res ; if ( root == NULL ) { return res ; } TreeNode * front = root ; queue < TreeNode *> qTree ; qTree . push ( root ); while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); res . push_back ( front -> val ); if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return res ; } };","title":"22. \u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#23","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5224\u65ad\u8be5\u6570\u7ec4\u662f\u4e0d\u662f\u67d0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002\u5982\u679c\u662f\u5219\u8f93\u51faYes,\u5426\u5219\u8f93\u51faNo\u3002\u5047\u8bbe\u8f93\u5165\u7684\u6570\u7ec4\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u4e92\u4e0d\u76f8\u540c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a bool VerifySquenceOfBST ( vector < int > sequence ) { int n = int ( sequence . size ()); if ( n == 0 ) { return false ; } return isPostOrder ( sequence , 0 , n -1 ); } bool isPostOrder ( vector < int > arr , int b , int e ) { if ( b >= e ) { return true ; } int idx = b ; for (; idx <= e ; idx ++ ) { if ( arr [ idx ] >= arr [ e ]) { break ; } } for ( int i = idx ; i < e ; i ++ ) { if ( arr [ i ] < arr [ e ]) { return false ; } } return isPostOrder ( arr , b , idx -1 ) && isPostOrder ( arr , idx , e -1 ); } };","title":"23. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217*"},{"location":"algo/jsoffer/#24","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9\u548c\u4e00\u4e2a\u6574\u6570\uff0c\u6309\u5b57\u5178\u5e8f\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u503c\u7684\u548c\u4e3a\u8f93\u5165\u6574\u6570\u7684\u6240\u6709\u8def\u5f84\u3002\u8def\u5f84\u5b9a\u4e49\u4e3a\u4ece\u6811\u7684\u6839\u7ed3\u70b9\u5f00\u59cb\u5f80\u4e0b\u4e00\u76f4\u5230\u53f6\u7ed3\u70b9\u6240\u7ecf\u8fc7\u7684\u7ed3\u70b9\u5f62\u6210\u4e00\u6761\u8def\u5f84\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int > > paths ; if ( root == NULL ) { return paths ; } vector < int > path ; stack < TreeNode *> s ; int size = 0 , sum = 0 ; TreeNode * cur = root ; while ( true ) { while ( cur -> left != NULL || cur -> right != NULL ) { s . push ( cur ); path . push_back ( cur -> val ); size ++ ; sum += cur -> val ; if ( cur -> left != NULL ) { cur = cur -> left ; } else { cur = cur -> right ; } } if ( sum + cur -> val == expectNumber ) { path . push_back ( cur -> val ); paths . push_back ( path ); } while ( ! s . empty () && ( s . top () -> left == NULL || s . top () -> right == NULL || s . top () -> right == cur )) { cur = s . top (); s . pop (); sum -= cur -> val ; size -- ; } if ( s . empty ()) { break ; } cur = s . top () -> right ; path . resize ( size ); } return paths ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int >> res ; if ( root == NULL ) { return res ; } vector < int > arr ; path ( root , expectNumber , res , arr , 0 ); return res ; } void path ( TreeNode * root , int target , vector < vector < int >> & res , vector < int > & arr , int sum ) { if ( root == NULL ) { return ; } arr . push_back ( root -> val ); if ( root -> left == NULL && root -> right == NULL && sum + root -> val == target ) { res . push_back ( arr ); } else { path ( root -> left , target , res , arr , sum + root -> val ); path ( root -> right , target , res , arr , sum + root -> val ); } arr . resize ( arr . size () -1 ); } };","title":"24. \u4e8c\u53c9\u6811\u4e2d\u548c\u4e3a\u67d0\u4e00\u503c\u7684\u8def\u5f84"},{"location":"algo/jsoffer/#25","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u590d\u6742\u94fe\u8868\uff08\u6bcf\u4e2a\u8282\u70b9\u4e2d\u6709\u8282\u70b9\u503c\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u7279\u6b8a\u6307\u9488random\u6307\u5411\u4e00\u4e2a\u968f\u673a\u8282\u70b9\uff09\uff0c\u8bf7\u5bf9\u6b64\u94fe\u8868\u8fdb\u884c\u6df1\u62f7\u8d1d\uff0c\u5e76\u8fd4\u56de\u62f7\u8d1d\u540e\u7684\u5934\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\uff0c\u8f93\u51fa\u7ed3\u679c\u4e2d\u8bf7\u4e0d\u8981\u8fd4\u56de\u53c2\u6570\u4e2d\u7684\u8282\u70b9\u5f15\u7528\uff0c\u5426\u5219\u5224\u9898\u7a0b\u5e8f\u4f1a\u76f4\u63a5\u8fd4\u56de\u7a7a\uff09 Solution\uff1aWe copy each node to append itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) \uff1a label(x), next(NULL), random(NULL) { } }; */ class Solution { public \uff1a RandomListNode * Clone ( RandomListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } RandomListNode * p1 = pHead ; while ( p1 != NULL ) { RandomListNode * temp = new RandomListNode ( p1 -> label ); temp -> next = p1 -> next ; p1 -> next = temp ; p1 = p1 -> next -> next ; } p1 = pHead ; while ( p1 != NULL ) { if ( p1 -> random != NULL ) { p1 -> next -> random = p1 -> random -> next ; } p1 = p1 -> next -> next ; } RandomListNode * head = pHead -> next , * p2 = pHead -> next ; p1 = pHead ; while ( p1 != NULL ) { p1 -> next = p2 -> next ; if ( p2 -> next != NULL ) { p2 -> next = p2 -> next -> next ; } p1 = p1 -> next ; p2 = p2 -> next ; } return head ; } };","title":"25. \u590d\u6742\u94fe\u8868\u7684\u590d\u5236*"},{"location":"algo/jsoffer/#26","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5c06\u8be5\u4e8c\u53c9\u641c\u7d22\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u6392\u5e8f\u7684\u53cc\u5411\u94fe\u8868\u3002\u8981\u6c42\u4e0d\u80fd\u521b\u5efa\u4efb\u4f55\u65b0\u7684\u7ed3\u70b9\uff0c\u53ea\u80fd\u8c03\u6574\u6811\u4e2d\u7ed3\u70b9\u6307\u9488\u7684\u6307\u5411\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } postOrder ( pRootOfTree ); TreeNode * head = pRootOfTree ; while ( head -> left != NULL ) { head = head -> left ; } return head ; } void postOrder ( TreeNode * root ) { if ( root != NULL ) { postOrder ( root -> left ); postOrder ( root -> right ); TreeNode * left = root -> left ; while ( left != NULL && left -> right != NULL ) { left = left -> right ; } root -> left = left ; if ( left != NULL ) { left -> right = root ; } TreeNode * right = root -> right ; while ( right != NULL && right -> left != NULL ) { right = right -> left ; } root -> right = right ; if ( right != NULL ) { right -> left = root ; } } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } TreeNode * head = pRootOfTree , * leftMost = NULL ; inOrder ( pRootOfTree , leftMost ); while ( head -> left != NULL ) { head = head -> left ; } return head ; } void inOrder ( TreeNode * root , TreeNode *& leftMost ) { if ( root != NULL ) { inOrder ( root -> left , leftMost ); if ( leftMost == NULL ) { leftMost = root ; } else { leftMost -> right = root ; root -> left = leftMost ; leftMost = root ; } inOrder ( root -> right , leftMost ); } } };","title":"26. \u4e8c\u53c9\u641c\u7d22\u6811\u4e0e\u53cc\u5411\u94fe\u8868"},{"location":"algo/jsoffer/#28","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4{1,2,3,2,2,2,5,4,2}\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u5982\u679c\u4e0d\u5b58\u5728\u5219\u8f93\u51fa0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i -1 ); quickSort ( arr , j + 1 , end ); } } int MoreThanHalfNum_Solution ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return numbers [ 0 ]; } quickSort ( numbers , 0 , n -1 ); if ( n % 2 && numbers [ n / 2 ] != numbers [ n / 2-1 ]) { return 0 ; } int res = numbers [ n / 2 ]; int count = 1 ; int pos = n / 2 - 1 ; while ( pos >= 0 ) { if ( numbers [ pos ] != res ) { break ; } pos -- ; count ++ ; } pos = n / 2 + 1 ; while ( pos < n ) { if ( numbers [ pos ] != res ) { break ; } pos ++ ; count ++ ; } if ( count > n / 2 ) { return res ; } return 0 ; } };","title":"28. \u6570\u7ec4\u4e2d\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57"},{"location":"algo/jsoffer/#29-k","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165n\u4e2a\u6574\u6570\uff0c\u627e\u51fa\u5176\u4e2d\u6700\u5c0f\u7684K\u4e2a\u6570\u3002\u4f8b\u5982\u8f93\u51654,5,1,6,2,7,3,8\u8fd98\u4e2a\u6570\u5b57\uff0c\u5219\u6700\u5c0f\u76844\u4e2a\u6570\u5b57\u662f1,2,3,4,\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i -1 ); quickSort ( arr , j + 1 , end ); } } vector < int > GetLeastNumbers_Solution ( vector < int > input , int k ) { int n = int ( input . size ()); vector < int > res ; if ( n == 0 || k <= 0 || k > n ) { return res ; } quickSort ( input , 0 , n -1 ); input . resize ( k ); return input ; } };","title":"29. \u6700\u5c0f\u7684K\u4e2a\u6570"},{"location":"algo/jsoffer/#31-11n1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6c42\u51fa1-13\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570,\u5e76\u7b97\u51fa100~1300\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff1f\u4e3a\u6b64\u4ed6\u7279\u522b\u6570\u4e86\u4e00\u4e0b1-13\u4e2d\u5305\u542b1\u7684\u6570\u5b57\u67091\u300110\u300111\u300112\u300113\u56e0\u6b64\u5171\u51fa\u73b06\u6b21,\u4f46\u662f\u5bf9\u4e8e\u540e\u9762\u95ee\u9898\u4ed6\u5c31\u6ca1\u8f99\u4e86\u3002ACMer\u5e0c\u671b\u4f60\u4eec\u5e2e\u5e2e\u4ed6,\u5e76\u628a\u95ee\u9898\u66f4\u52a0\u666e\u904d\u5316,\u53ef\u4ee5\u5f88\u5feb\u7684\u6c42\u51fa\u4efb\u610f\u975e\u8d1f\u6574\u6570\u533a\u95f4\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1 \u5230 n \u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09\u3002 Solution\uff1aTake 2593 as an example, how many '5' does it contain? i = 1, Quotient = 2593 / (10 * i) = 258, Mod = 2593 % (10 * i) = 3. Number of '5'\uff1a 259 * i + (3 > 5) * i = 259. i = 10, Quotient = 2593 / (10 * i) = 25, Mod = 2593 % (10 * i) = 93. Number of '5'\uff1a 25 * i + (9 > 5) * i = 260. i = 100, Quotient = 2593 / (10 * i) = 2, Mod = 2593 % (10 * i) = 593. Number of '5'\uff1a 2 * i + (5 == 5) * (93 + 1) = 294. i = 1000, Quotient = 2593 / (10 * i) = 0 end.Total number of '5'\uff1a 259 + 260 + 294 = 813. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { res += count1 ( i ); } return res ; } int count1 ( int num ) { int res = 0 ; while ( num ) { if ( num % 10 == 1 ) { res ++ ; } num /= 10 ; } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int count = 0 , digit = 1 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int a = n / ( 10 * i ), b = n % ( 10 * i ); count += a * i ; if ( b / i > digit ) { count += i ; } if ( b / i == digit ) { count += b % i + 1 ; } } return count ; } };","title":"31. \u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1\u5230n\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09*"},{"location":"algo/jsoffer/#33","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u53ea\u5305\u542b\u8d28\u56e0\u5b502\u30013\u548c5\u7684\u6570\u79f0\u4f5c\u4e11\u6570\uff08Ugly Number\uff09\u3002\u4f8b\u59826\u30018\u90fd\u662f\u4e11\u6570\uff0c\u4f4614\u4e0d\u662f\uff0c\u56e0\u4e3a\u5b83\u5305\u542b\u8d28\u56e0\u5b507\u3002 \u4e60\u60ef\u4e0a\u6211\u4eec\u628a1\u5f53\u505a\u662f\u7b2c\u4e00\u4e2a\u4e11\u6570\u3002\u6c42\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u7684\u7b2cN\u4e2a\u4e11\u6570\u3002 Solution\uff1aUgly numbers\uff1a 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15...Some ugly number is from a multiplaction of previous number by 2, 3 or 5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a int min ( int a , int b , int c ) { int temp = a < b ? a \uff1a b ; return temp < c ? temp \uff1a c ; } int GetUglyNumber_Solution ( int index ) { if ( index < 2 ) { return index ; } int * arr = new int [ index ]{}; arr [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < index ; i ++ ) { arr [ i ] = min ( arr [ f2 ] * 2 , arr [ f3 ] * 3 , arr [ f5 ] * 5 ); while ( arr [ f2 ] * 2 <= arr [ i ]) { f2 ++ ; } while ( arr [ f3 ] * 3 <= arr [ i ]) { f3 ++ ; } while ( arr [ f5 ] * 5 <= arr [ i ]) { f5 ++ ; } } int res = arr [ index -1 ]; delete [] arr ; return res ; } };","title":"33. \u4e11\u6570*"},{"location":"algo/jsoffer/#34","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u5b57\u7b26\u4e32(0<=\u5b57\u7b26\u4e32\u957f\u5ea6<=10000\uff0c\u5168\u90e8\u7531\u5b57\u6bcd\u7ec4\u6210)\u4e2d\u627e\u5230\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26,\u5e76\u8fd4\u56de\u5b83\u7684\u4f4d\u7f6e, \u5982\u679c\u6ca1\u6709\u5219\u8fd4\u56de -1\uff08\u9700\u8981\u533a\u5206\u5927\u5c0f\u5199\uff09.\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a int FirstNotRepeatingChar ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return -1 ; } int N = 256 , pos = n + 1 ; int * ascii = new int [ N ]{}; for ( int i = 0 ; i < n ; i ++ ) { int id = int ( str [ i ]); if ( ascii [ id ] == 0 ) { ascii [ id ] = i + 1 ; } else { ascii [ id ] = -1 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] > 0 && ascii [ i ] < pos ) { pos = ascii [ i ]; } } delete [] ascii ; if ( pos == n + 1 ) { return -1 ; } return pos - 1 ; } };","title":"34. \u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u4f4d\u7f6e"},{"location":"algo/jsoffer/#35","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4,\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570P\u3002\u5e76\u5c06P\u5bf91000000007\u53d6\u6a21\u7684\u7ed3\u679c\u8f93\u51fa\u3002 \u5373\u8f93\u51faP%1000000007 \u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u7684\u6570\u7ec4\u4e2d\u6ca1\u6709\u7684\u76f8\u540c\u7684\u6570\u5b57\u6570\u636e\u8303\u56f4\uff1a\u5bf9\u4e8e%50\u7684\u6570\u636e,size<=10 4\u5bf9\u4e8e%75\u7684\u6570\u636e,size<=10 5\u5bf9\u4e8e%100\u7684\u6570\u636e,size<=2*10^5 \u8f93\u51651,2,3,4,5,6,7,0\u8f93\u51fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public \uff1a int InversePairs ( vector < int > data ) { int n = int ( data . size ()); if ( n < 2 ) { return 0 ; } long count = 0 ; mergeSort ( data , 0 , n -1 , count ); return ( count % 1000000007 ); } void mergeSort ( vector < int > & arr , int b , int e , long & count ) { if ( b >= e ) { return ; } int m = ( b + e ) / 2 ; mergeSort ( arr , b , m , count ); mergeSort ( arr , m + 1 , e , count ); merge ( arr , b , m , e , count ); } void merge ( vector < int > & arr , int b , int m , int e , long & count ) { int * temp = new int [ e - b + 1 ]{}; int i = b , j = m + 1 , right = 0 , pos = 0 ; while ( i <= m && j <= e ) { if ( arr [ i ] < arr [ j ]) { temp [ pos ++ ] = arr [ i ++ ]; count += right ; } else { temp [ pos ++ ] = arr [ j ++ ]; right ++ ; } } count += ( m - i + 1 ) * right ; while ( i <= m ) { temp [ pos ++ ] = arr [ i ++ ]; } while ( j <= e ) { temp [ pos ++ ] = arr [ j ++ ]; } for ( int i = b ; i <= e ; i ++ ) { arr [ i ] = temp [ i - b ]; } delete [] temp ; } };","title":"35. \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9*"},{"location":"algo/jsoffer/#36","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u94fe\u8868\uff0c\u627e\u51fa\u5b83\u4eec\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\u56e0\u4e3a\u4f20\u5165\u6570\u636e\u662f\u94fe\u8868\uff0c\u6240\u4ee5\u9519\u8bef\u6d4b\u8bd5\u6570\u636e\u7684\u63d0\u793a\u662f\u7528\u5176\u4ed6\u65b9\u5f0f\u663e\u793a\u7684\uff0c\u4fdd\u8bc1\u4f20\u5165\u6570\u636e\u662f\u6b63\u786e\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindFirstCommonNode ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL || pHead2 == NULL ) { return NULL ; } ListNode * p1 = pHead1 , * p2 = pHead2 ; stack < ListNode *> s1 , s2 ; while ( p1 != NULL ) { s1 . push ( p1 ); p1 = p1 -> next ; } while ( p2 != NULL ) { s2 . push ( p2 ); p2 = p2 -> next ; } while ( ! s1 . empty () && ! s2 . empty ()) { if ( s1 . top () != s2 . top ()) { return s1 . top () -> next ; } s1 . pop (); s2 . pop (); } if ( s1 . empty ()) { return pHead1 ; } if ( s2 . empty ()) { return pHead2 ; } return s1 . top () -> next ; } };","title":"36. \u4e24\u4e2a\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9"},{"location":"algo/jsoffer/#37","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7edf\u8ba1\u4e00\u4e2a\u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 class Solution { public \uff1a int GetNumberOfK ( vector < int > data , int k ) { int count = 0 ; for ( int i = 0 ; i < int ( data . size ()); i ++ ) { if ( data [ i ] == k ) { count ++ ; } } return count ; } };","title":"37. \u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570"},{"location":"algo/jsoffer/#38","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6c42\u8be5\u6811\u7684\u6df1\u5ea6\u3002\u4ece\u6839\u7ed3\u70b9\u5230\u53f6\u7ed3\u70b9\u4f9d\u6b21\u7ecf\u8fc7\u7684\u7ed3\u70b9\uff08\u542b\u6839\u3001\u53f6\u7ed3\u70b9\uff09\u5f62\u6210\u6811\u7684\u4e00\u6761\u8def\u5f84\uff0c\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6\u4e3a\u6811\u7684\u6df1\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int dep = 0 ; queue < TreeNode *> qTree ; qTree . push ( pRoot ); TreeNode * front = pRoot , * last = pRoot , * nextLast = pRoot ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> left != NULL ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != NULL ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { dep ++ ; last = nextLast ; } } return dep ; } }; ``` C ++ /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int leftDep = TreeDepth ( pRoot -> left ); int rightDep = TreeDepth ( pRoot -> right ); return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } };","title":"38. \u4e8c\u53c9\u6811\u7684\u6df1\u5ea6"},{"location":"algo/jsoffer/#39","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u5224\u65ad\u8be5\u4e8c\u53c9\u6811\u662f\u5426\u662f\u5e73\u8861\u4e8c\u53c9\u6811\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8003\u8651\u5176\u5e73\u8861\u6027\uff0c\u4e0d\u9700\u8981\u8003\u8651\u5176\u662f\u4e0d\u662f\u6392\u5e8f\u4e8c\u53c9\u6811\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a bool IsBalanced_Solution ( TreeNode * pRoot ) { bool res = true ; postOrder ( pRoot , res ); return res ; } int postOrder ( TreeNode * root , bool & res ) { if ( root == NULL ) { return 0 ; } int leftDep = postOrder ( root -> left , res ); int rightDep = postOrder ( root -> right , res ); int diff = abs ( leftDep - rightDep ); if ( diff > 1 ) { res = false ; } return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } };","title":"39. \u5e73\u8861\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#40","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\u91cc\u9664\u4e86\u4e24\u4e2a\u6570\u5b57\u4e4b\u5916\uff0c\u5176\u4ed6\u7684\u6570\u5b57\u90fd\u51fa\u73b0\u4e86\u4e24\u6b21\u3002\u8bf7\u5199\u7a0b\u5e8f\u627e\u51fa\u8fd9\u4e24\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57\u3002 Solution\uff1anum XOR num = 0\uff1a one number XOR itself is 0.We XOR all entire array to get a result of the two single numbers. Then locate the first 1's position, e.g. 6 = 0110, first 1's position is 2 (starting 0 from right to left). We classify the array into two parts by checking if one integer is 1 at its first 1's position. Then do XOR once again for the two parts to find the two single numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a void FindNumsAppearOnce ( vector < int > data , int * num1 , int * num2 ) { int n = int ( data . size ()); if ( n < 2 ) { return ; } int XOR = 0 , pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR ^= data [ i ]; } while ( XOR >> 1 ) { XOR = XOR >> 1 ; pos ++ ; } bool is1Ok = false , is2Ok = false ; int n1 = 0 , n2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if (( data [ i ] >> pos ) & 1 ) { if ( is1Ok ) { n1 ^= data [ i ]; } else { is1Ok = true ; n1 = data [ i ]; } } else { if ( is2Ok ) { n2 ^= data [ i ]; } else { is2Ok = true ; n2 = data [ i ]; } } * num1 = n1 < n2 ? n1 \uff1a n2 ; * num2 = n1 >= n2 ? n1 \uff1a n2 ; } } };","title":"40. \u6570\u7ec4\u4e2d\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57*"},{"location":"algo/jsoffer/#41-s","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5c0f\u660e\u5f88\u559c\u6b22\u6570\u5b66,\u6709\u4e00\u5929\u4ed6\u5728\u505a\u6570\u5b66\u4f5c\u4e1a\u65f6,\u8981\u6c42\u8ba1\u7b97\u51fa9~16\u7684\u548c,\u4ed6\u9a6c\u4e0a\u5c31\u5199\u51fa\u4e86\u6b63\u786e\u7b54\u6848\u662f100\u3002\u4f46\u662f\u4ed6\u5e76\u4e0d\u6ee1\u8db3\u4e8e\u6b64,\u4ed6\u5728\u60f3\u7a76\u7adf\u6709\u591a\u5c11\u79cd\u8fde\u7eed\u7684\u6b63\u6570\u5e8f\u5217\u7684\u548c\u4e3a100(\u81f3\u5c11\u5305\u62ec\u4e24\u4e2a\u6570)\u3002\u6ca1\u591a\u4e45,\u4ed6\u5c31\u5f97\u5230\u53e6\u4e00\u7ec4\u8fde\u7eed\u6b63\u6570\u548c\u4e3a100\u7684\u5e8f\u5217\uff1a18,19,20,21,22\u3002\u73b0\u5728\u628a\u95ee\u9898\u4ea4\u7ed9\u4f60,\u4f60\u80fd\u4e0d\u80fd\u4e5f\u5f88\u5feb\u7684\u627e\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217? Good Luck!\u8f93\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217\u3002\u5e8f\u5217\u5185\u6309\u7167\u4ece\u5c0f\u81f3\u5927\u7684\u987a\u5e8f\uff0c\u5e8f\u5217\u95f4\u6309\u7167\u5f00\u59cb\u6570\u5b57\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < vector < int > > FindContinuousSequence ( int sum ) { vector < vector < int >> res ; if ( sum < 3 ) { return res ; } for ( int n = sum ; n >= 2 ; n -- ) { int numerator = 2 * sum + n - n * n ; int denominator = 2 * n ; if ( numerator % denominator == 0 ) { int a = numerator / denominator ; if ( a < 1 ) { continue ; } vector < int > arr ; for ( int i = a ; i <= a + n - 1 ; i ++ ) { arr . push_back ( i ); } res . push_back ( arr ); } } return res ; } };","title":"41. \u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217"},{"location":"algo/jsoffer/#42-s","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u9012\u589e\u6392\u5e8f\u7684\u6570\u7ec4\u548c\u4e00\u4e2a\u6570\u5b57S\uff0c\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u4e24\u4e2a\u6570\uff0c\u4f7f\u5f97\u4ed6\u4eec\u7684\u548c\u6b63\u597d\u662fS\uff0c\u5982\u679c\u6709\u591a\u5bf9\u6570\u5b57\u7684\u548c\u7b49\u4e8eS\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\u7684\u4e58\u79ef\u6700\u5c0f\u7684\u3002\u5bf9\u5e94\u6bcf\u4e2a\u6d4b\u8bd5\u6848\u4f8b\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\uff0c\u5c0f\u7684\u5148\u8f93\u51fa\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < int > FindNumbersWithSum ( vector < int > array , int sum ) { vector < int > res ; int n = int ( array . size ()); if ( n == 0 ) { return res ; } int i = 0 , j = n - 1 ; while ( i < j ) { if ( array [ i ] + array [ j ] < sum ) { i ++ ; } else if ( array [ i ] + array [ j ] > sum ) { j -- ; } else { res . push_back ( array [ i ]); res . push_back ( array [ j ]); break ; } } return res ; } };","title":"42. \u548c\u4e3aS\u7684\u4e24\u4e2a\u6570\u5b57"},{"location":"algo/jsoffer/#43","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6c47\u7f16\u8bed\u8a00\u4e2d\u6709\u4e00\u79cd\u79fb\u4f4d\u6307\u4ee4\u53eb\u505a\u5faa\u73af\u5de6\u79fb\uff08ROL\uff09\uff0c\u73b0\u5728\u6709\u4e2a\u7b80\u5355\u7684\u4efb\u52a1\uff0c\u5c31\u662f\u7528\u5b57\u7b26\u4e32\u6a21\u62df\u8fd9\u4e2a\u6307\u4ee4\u7684\u8fd0\u7b97\u7ed3\u679c\u3002\u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5b57\u7b26\u5e8f\u5217S\uff0c\u8bf7\u4f60\u628a\u5176\u5faa\u73af\u5de6\u79fbK\u4f4d\u540e\u7684\u5e8f\u5217\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u5e8f\u5217S=\u201dabcXYZdef\u201d,\u8981\u6c42\u8f93\u51fa\u5faa\u73af\u5de6\u79fb3\u4f4d\u540e\u7684\u7ed3\u679c\uff0c\u5373\u201cXYZdefabc\u201d\u3002\u662f\u4e0d\u662f\u5f88\u7b80\u5355\uff1fOK\uff0c\u641e\u5b9a\u5b83\uff01 1 2 3 4 5 6 7 8 9 10 class Solution { public \uff1a string LeftRotateString ( string str , int n ) { int len = int ( str . length ()); if ( len == 0 || n == 0 || len <= n ) { return str ; } string firtN ( str , 0 , n ); string rest ( str , n , len ); return rest + firtN ; } };","title":"43. \u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32"},{"location":"algo/jsoffer/#44","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u725b\u5ba2\u6700\u8fd1\u6765\u4e86\u4e00\u4e2a\u65b0\u5458\u5de5Fish\uff0c\u6bcf\u5929\u65e9\u6668\u603b\u662f\u4f1a\u62ff\u7740\u4e00\u672c\u82f1\u6587\u6742\u5fd7\uff0c\u5199\u4e9b\u53e5\u5b50\u5728\u672c\u5b50\u4e0a\u3002\u540c\u4e8bCat\u5bf9Fish\u5199\u7684\u5185\u5bb9\u9887\u611f\u5174\u8da3\uff0c\u6709\u4e00\u5929\u4ed6\u5411Fish\u501f\u6765\u7ffb\u770b\uff0c\u4f46\u5374\u8bfb\u4e0d\u61c2\u5b83\u7684\u610f\u601d\u3002\u4f8b\u5982\uff0c\u201cstudent. a am I\u201d\u3002\u540e\u6765\u624d\u610f\u8bc6\u5230\uff0c\u8fd9\u5bb6\u4f19\u539f\u6765\u628a\u53e5\u5b50\u5355\u8bcd\u7684\u987a\u5e8f\u7ffb\u8f6c\u4e86\uff0c\u6b63\u786e\u7684\u53e5\u5b50\u5e94\u8be5\u662f\u201cI am a student.\u201d\u3002Cat\u5bf9\u4e00\u4e00\u7684\u7ffb\u8f6c\u8fd9\u4e9b\u5355\u8bcd\u987a\u5e8f\u53ef\u4e0d\u5728\u884c\uff0c\u4f60\u80fd\u5e2e\u52a9\u4ed6\u4e48\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } string res = \"\" , word = \"\" ; stack < string > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { s . push ( word ); word = \"\" ; continue ; } word . push_back ( str [ i ]); } s . push ( word ); while ( ! s . empty ()) { res += s . top (); s . pop (); if ( ! s . empty ()) { res . push_back ( ' ' ); } } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { char temp = str [ i ]; str [ i ] = str [ n -1 - i ]; str [ n -1 - i ] = temp ; } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int n = i - 1 , m = j ; while ( m < n ) { char temp = str [ m ]; str [ m ] = str [ n ]; str [ n ] = temp ; m ++ ; n -- ; } j = i + 1 ; } } str [ n ] = '\\0' ; return str ; } };","title":"44. \u7ffb\u8f6c\u5355\u8bcd\u987a\u5e8f\u5217"},{"location":"algo/jsoffer/#45","text":"\u9898\u76ee\u63cf\u8ff0\uff1aLL\u4eca\u5929\u5fc3\u60c5\u7279\u522b\u597d,\u56e0\u4e3a\u4ed6\u53bb\u4e70\u4e86\u4e00\u526f\u6251\u514b\u724c,\u53d1\u73b0\u91cc\u9762\u5c45\u7136\u67092\u4e2a\u5927\u738b,2\u4e2a\u5c0f\u738b(\u4e00\u526f\u724c\u539f\u672c\u662f54\u5f20 _ )...\u4ed6\u968f\u673a\u4ece\u4e2d\u62bd\u51fa\u4e865\u5f20\u724c,\u60f3\u6d4b\u6d4b\u81ea\u5df1\u7684\u624b\u6c14,\u770b\u770b\u80fd\u4e0d\u80fd\u62bd\u5230\u987a\u5b50,\u5982\u679c\u62bd\u5230\u7684\u8bdd,\u4ed6\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968,\u563f\u563f\uff01\uff01\u201c\u7ea2\u5fc3A,\u9ed1\u68433,\u5c0f\u738b,\u5927\u738b,\u65b9\u72475\u201d,\u201cOh My God!\u201d\u4e0d\u662f\u987a\u5b50.....LL\u4e0d\u9ad8\u5174\u4e86,\u4ed6\u60f3\u4e86\u60f3,\u51b3\u5b9a\u5927\\\u5c0f \u738b\u53ef\u4ee5\u770b\u6210\u4efb\u4f55\u6570\u5b57,\u5e76\u4e14A\u770b\u4f5c1,J\u4e3a11,Q\u4e3a12,K\u4e3a13\u3002\u4e0a\u9762\u76845\u5f20\u724c\u5c31\u53ef\u4ee5\u53d8\u6210\u201c1,2,3,4,5\u201d(\u5927\u5c0f\u738b\u5206\u522b\u770b\u4f5c2\u548c4),\u201cSo Lucky!\u201d\u3002LL\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968\u5566\u3002 \u73b0\u5728,\u8981\u6c42\u4f60\u4f7f\u7528\u8fd9\u5e45\u724c\u6a21\u62df\u4e0a\u9762\u7684\u8fc7\u7a0b,\u7136\u540e\u544a\u8bc9\u6211\u4eecLL\u7684\u8fd0\u6c14\u5982\u4f55\uff0c \u5982\u679c\u724c\u80fd\u7ec4\u6210\u987a\u5b50\u5c31\u8f93\u51fatrue\uff0c\u5426\u5219\u5c31\u8f93\u51fafalse\u3002\u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1,\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u5927\u5c0f\u738b\u662f0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public \uff1a bool IsContinuous ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } //sort(numbers.begin(), numbers.end()); quickSort ( numbers , 0 , n -1 ); int num0 = 0 , head = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( numbers [ i ] == 0 ) { num0 ++ ; continue ; } if ( head == 0 ) { head = numbers [ i ]; } else { if ( numbers [ i ] == numbers [ i -1 ]) { return false ; } if ( numbers [ i ] == head + 1 ) { head ++ ; } else { num0 -= numbers [ i ] - head - 1 ; if ( num0 < 0 ) { return false ; } head = numbers [ i ]; } } } return true ; } void quickSort ( vector < int > & arr , int b , int e ) { if ( b < e ) { int i = b , j = e ; while ( i < j ) { while ( i < j && arr [ i ] <= arr [ j ]) { j -- ; } swap ( arr , i , j ); while ( i < j && arr [ i ] <= arr [ j ]) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , b , i -1 ); quickSort ( arr , j + 1 , e ); } } void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } };","title":"45. \u6251\u514b\u724c\u987a\u5b50"},{"location":"algo/jsoffer/#46","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6bcf\u5e74\u516d\u4e00\u513f\u7ae5\u8282,\u725b\u5ba2\u90fd\u4f1a\u51c6\u5907\u4e00\u4e9b\u5c0f\u793c\u7269\u53bb\u770b\u671b\u5b64\u513f\u9662\u7684\u5c0f\u670b\u53cb,\u4eca\u5e74\u4ea6\u662f\u5982\u6b64\u3002HF\u4f5c\u4e3a\u725b\u5ba2\u7684\u8d44\u6df1\u5143\u8001,\u81ea\u7136\u4e5f\u51c6\u5907\u4e86\u4e00\u4e9b\u5c0f\u6e38\u620f\u3002\u5176\u4e2d,\u6709\u4e2a\u6e38\u620f\u662f\u8fd9\u6837\u7684\uff1a\u9996\u5148,\u8ba9\u5c0f\u670b\u53cb\u4eec\u56f4\u6210\u4e00\u4e2a\u5927\u5708\u3002\u7136\u540e,\u4ed6\u968f\u673a\u6307\u5b9a\u4e00\u4e2a\u6570m,\u8ba9\u7f16\u53f7\u4e3a0\u7684\u5c0f\u670b\u53cb\u5f00\u59cb\u62a5\u6570\u3002\u6bcf\u6b21\u558a\u5230m-1\u7684\u90a3\u4e2a\u5c0f\u670b\u53cb\u8981\u51fa\u5217\u5531\u9996\u6b4c,\u7136\u540e\u53ef\u4ee5\u5728\u793c\u54c1\u7bb1\u4e2d\u4efb\u610f\u7684\u6311\u9009\u793c\u7269,\u5e76\u4e14\u4e0d\u518d\u56de\u5230\u5708\u4e2d,\u4ece\u4ed6\u7684\u4e0b\u4e00\u4e2a\u5c0f\u670b\u53cb\u5f00\u59cb,\u7ee7\u7eed0...m-1\u62a5\u6570....\u8fd9\u6837\u4e0b\u53bb....\u76f4\u5230\u5269\u4e0b\u6700\u540e\u4e00\u4e2a\u5c0f\u670b\u53cb,\u53ef\u4ee5\u4e0d\u7528\u8868\u6f14,\u5e76\u4e14\u62ff\u5230\u725b\u5ba2\u540d\u8d35\u7684\u201c\u540d\u4fa6\u63a2\u67ef\u5357\u201d\u5178\u85cf\u7248(\u540d\u989d\u6709\u9650\u54e6!! _ )\u3002\u8bf7\u4f60\u8bd5\u7740\u60f3\u4e0b,\u54ea\u4e2a\u5c0f\u670b\u53cb\u4f1a\u5f97\u5230\u8fd9\u4efd\u793c\u54c1\u5462\uff1f(\u6ce8\uff1a\u5c0f\u670b\u53cb\u7684\u7f16\u53f7\u662f\u4ece0\u5230n-1)\u3002\u5982\u679c\u6ca1\u6709\u5c0f\u670b\u53cb\uff0c\u8bf7\u8fd4\u56de-1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public \uff1a int LastRemaining_Solution ( int n , int m ) { int i = 0 , j = 0 , numOut = 0 , * out = new int [ n ]{}; while ( numOut < n - 1 ) { while ( out [ i ]) { i ++ ; if ( i == n ) { i = 0 ; } } if ( j == m -1 ) { out [ i ] = true ; numOut ++ ; } i ++ ; j ++ ; if ( i == n ) { i = 0 ; } if ( j == m ) { j = 0 ; } } int res = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! out [ i ]) { res = i ; } } delete [] out ; return res ; } };","title":"46. \u5b69\u5b50\u4eec\u7684\u6e38\u620f(\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570)"},{"location":"algo/jsoffer/#47-123n","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6c421+2+3+...+n\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u4e58\u9664\u6cd5\u3001for\u3001while\u3001if\u3001else\u3001switch\u3001case\u7b49\u5173\u952e\u5b57\u53ca\u6761\u4ef6\u5224\u65ad\u8bed\u53e5\uff08A?B\uff1aC\uff09\u3002 1 2 3 4 5 6 class Solution { public \uff1a int Sum_Solution ( int n ) { return ( n + 1 ) * n / 2 ; } };","title":"47. \u6c421+2+3+...+n"},{"location":"algo/jsoffer/#48","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u6c42\u4e24\u4e2a\u6574\u6570\u4e4b\u548c\uff0c\u8981\u6c42\u5728\u51fd\u6570\u4f53\u5185\u4e0d\u5f97\u4f7f\u7528+\u3001-\u3001*\u3001/\u56db\u5219\u8fd0\u7b97\u7b26\u53f7\u3002 Solution\uff1aXOR + &A = 000101 = 5, B = 010001 = 17 1) sum = 000101 XOR 010001 = 010100 = 20, pos = 000101 & 010001 = 000001 = 1. We have to move left for 000001 at 0-th position (starting from rightmost). 2) if pos is not 0, A = sum, B = (pos << 1) then continue 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a int Add ( int num1 , int num2 ) { int res = num1 ; int pos = num2 ; while ( true ) { res = num1 ^ num2 ; pos = num1 & num2 ; if ( pos == 0 ) { break ; } num1 = res ; num2 = pos << 1 ; } return res ; } };","title":"48. \u4e0d\u7528\u52a0\u51cf\u4e58\u9664\u505a\u52a0\u6cd5*"},{"location":"algo/jsoffer/#49","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u4e00\u4e2a\u6574\u6570\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u5b57\u7b26\u4e32\u8f6c\u6362\u6574\u6570\u7684\u5e93\u51fd\u6570\u3002\u6570\u503c\u4e3a0\u6216\u8005\u5b57\u7b26\u4e32\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u6570\u503c\u5219\u8fd4\u56de0\u3002\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32,\u5305\u62ec\u6570\u5b57\u5b57\u6bcd\u7b26\u53f7,\u53ef\u4ee5\u4e3a\u7a7a\u3002\u5982\u679c\u662f\u5408\u6cd5\u7684\u6570\u503c\u8868\u8fbe\u5219\u8fd4\u56de\u8be5\u6570\u5b57\uff0c\u5426\u5219\u8fd4\u56de0\u3002 \u8f93\u5165+21474836471a33 \u8f93\u51fa21474836470 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public \uff1a int StrToInt ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return 0 ; } int num = 0 ; bool isPlus = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 && str [ 0 ] == '-' ) { isPlus = false ; continue ; } if ( i == 0 && str [ 0 ] == '+' ) { continue ; } if ( str [ i ] > '9' || str [ i ] < '0' ) { return 0 ; } num = num * 10 + str [ i ] - '0' ; } if ( ! isPlus ) { return - num ; } return num ; } };","title":"49. \u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570"},{"location":"algo/jsoffer/#50","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4\u91cc\u7684\u6240\u6709\u6570\u5b57\u90fd\u57280\u5230n-1\u7684\u8303\u56f4\u5185\u3002 \u6570\u7ec4\u4e2d\u67d0\u4e9b\u6570\u5b57\u662f\u91cd\u590d\u7684\uff0c\u4f46\u4e0d\u77e5\u9053\u6709\u51e0\u4e2a\u6570\u5b57\u662f\u91cd\u590d\u7684\u3002\u4e5f\u4e0d\u77e5\u9053\u6bcf\u4e2a\u6570\u5b57\u91cd\u590d\u51e0\u6b21\u3002\u8bf7\u627e\u51fa\u6570\u7ec4\u4e2d\u4efb\u610f\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b57\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u957f\u5ea6\u4e3a7\u7684\u6570\u7ec4{2,3,1,0,2,5,3}\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u8f93\u51fa\u662f\u7b2c\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b572\u3002\u8fd4\u56de\u63cf\u8ff0\uff1a\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u51fd\u6570\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u628a\u91cd\u590d\u7684\u6570\u5b57\u653e\u5230\u53c2\u6570duplication[0]\u4e2d\u3002\uff08ps\uff1aduplication\u5df2\u7ecf\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u76f4\u63a5\u8d4b\u503c\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public \uff1a // Parameters\uff1a // numbers\uff1a an array of integers // length\uff1a the length of array numbers // duplication\uff1a (Output) the duplicated number in the array number // Return value\uff1a true if the input is valid, and there are some // duplications in the array number // otherwise false bool duplicate ( int numbers [], int length , int * duplication ) { if ( length == 0 ) { return false ; } int * arr = new int [ length ]{}; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ numbers [ i ]] == length ) { arr [ numbers [ i ]] = i ; } if ( arr [ numbers [ i ]] == 0 ) { arr [ numbers [ i ]] = length ; } } int idx = length ; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ i ] == 0 ) { continue ; } if ( idx > arr [ i ]) { idx = arr [ i ]; } } delete [] arr ; if ( idx == length ) { return false ; } * duplication = numbers [ idx ]; return true ; } };","title":"50. \u6570\u7ec4\u4e2d\u91cd\u590d\u7684\u6570\u5b57"},{"location":"algo/jsoffer/#51","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4A[0,1,...,n-1], \u8bf7\u6784\u5efa\u4e00\u4e2a\u6570\u7ec4B[0,1,...,n-1], \u5176\u4e2dB\u4e2d\u7684\u5143\u7d20 B[i] = A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]\u3002\u4e0d\u80fd\u4f7f\u7528\u9664\u6cd5\u3002\uff08\u6ce8\u610f\uff1a\u89c4\u5b9aB[0] = A[1] * A[2] * ... * A[n-1]\uff0cB[n-1] = A[0] * A[1] * ... * A[n-2];\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a vector < int > multiply ( const vector < int >& A ) { vector < int > res ; int n = int ( A . size ()); if ( n == 0 ) { return res ; } for ( int i = 0 ; i < n ; i ++ ) { int mul = A [ 0 ]; for ( int j = 1 ; j < n ; j ++ ) { if ( j == i ) { continue ; } if ( A [ j ] == 0 ) { mul = 0 ; break ; } mul *= A [ j ]; } res . push_back ( mul ); } return res ; } };","title":"51. \u6784\u5efa\u4e58\u79ef\u6570\u7ec4"},{"location":"algo/jsoffer/#52","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5339\u914d\u5305\u62ec'.'\u548c' '\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\u6a21\u5f0f\u4e2d\u7684\u5b57\u7b26'.'\u8868\u793a\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\uff0c\u800c' '\u8868\u793a\u5b83\u524d\u9762\u7684\u5b57\u7b26\u53ef\u4ee5\u51fa\u73b0\u4efb\u610f\u6b21\uff08\u5305\u542b0\u6b21\uff09\u3002\u5728\u672c\u9898\u4e2d\uff0c\u5339\u914d\u662f\u6307\u5b57\u7b26\u4e32\u7684\u6240\u6709\u5b57\u7b26\u5339\u914d\u6574\u4e2a\u6a21\u5f0f\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"aaa\"\u4e0e\u6a21\u5f0f\"a.a\"\u548c\"ab ac a\"\u5339\u914d\uff0c\u4f46\u662f\u4e0e\"aa.a\"\u548c\"ab*a\"\u5747\u4e0d\u5339\u914d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a bool match ( char * str , char * pattern ) { size_t ns = strlen ( str ), np = strlen ( pattern ); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np -1 ; j >= 0 ; j -- ) { bool ijMatch = ( i < ns ) && ( str [ i ] == pattern [ j ] || pattern [ j ] == '.' ); if ( j < np -1 && pattern [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } bool res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } };","title":"52. \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d*"},{"location":"algo/jsoffer/#53","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u8868\u793a\u6570\u503c\uff08\u5305\u62ec\u6574\u6570\u548c\u5c0f\u6570\uff09\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"+100\", \"5e2\", \"-123\", \"3.1416\" \u548c \"-1E-16\" \u90fd\u8868\u793a\u6570\u503c\u3002 \u4f46\u662f \"12e\", \"1a3.14\", \"1.2.3\", \"+-5\" \u548c \"12e+4.3\" \u90fd\u4e0d\u662f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a bool isNumeric ( char * string ) { size_t n = strlen ( string ); if ( n == 0 ) { return false ; } bool isEx = false , isPt = false ; for ( int i = 0 ; i < n ; i ++ ) { if (( string [ i ] == '+' || string [ i ] == '-' )) { if ( i == 0 ) { continue ; } if ( string [ i -1 ] == 'E' || string [ i -1 ] == 'e' ) { continue ; } return false ; } if ( string [ i ] == 'e' || string [ i ] == 'E' ) { if ( isEx || i == n -1 ) { return false ; } isEx = true ; continue ; } if ( string [ i ] == '.' ) { if ( isPt || isEx || i == n -1 ) { return false ; } isPt = true ; continue ; } if ( string [ i ] > '9' || string [ i ] < '0' ) { return false ; } } return true ; } };","title":"53. \u8868\u793a\u6570\u503c\u7684\u5b57\u7b26\u4e32*"},{"location":"algo/jsoffer/#54","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u627e\u51fa\u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5f53\u4ece\u5b57\u7b26\u6d41\u4e2d\u53ea\u8bfb\u51fa\u524d\u4e24\u4e2a\u5b57\u7b26\"go\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"g\"\u3002\u5f53\u4ece\u8be5\u5b57\u7b26\u6d41\u4e2d\u8bfb\u51fa\u524d\u516d\u4e2a\u5b57\u7b26\u201cgoogle\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"l\"\u3002\u5982\u679c\u5f53\u524d\u5b57\u7b26\u6d41\u6ca1\u6709\u5b58\u5728\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u8fd4\u56de#\u5b57\u7b26\u3002 Solution\uff1aint[0\uff1a256] = 0Give each ACSII a position index in the char flow starting from 1.If repeat appears, set int[i] = -1Return ACSII with minimum position index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { int * ascii ; int N ; int flow ; public \uff1a Solution () { N = 256 ; ascii = new int [ N ]{}; flow = 1 ; } ~ Solution () { delete [] ascii ; } //Insert one char from stringstream void Insert ( char ch ) { int idx = int ( ch ); if ( ascii [ idx ] == 0 ) { ascii [ idx ] = flow ; } else { ascii [ idx ] = -1 ; } flow ++ ; } //return the first appearence once char in current stringstream char FirstAppearingOnce () { int pos = flow , ch = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] < 1 ) { continue ; } if ( pos > ascii [ i ]) { pos = ascii [ i ]; ch = i ; } } if ( pos == flow ) { return '#' ; } return char ( ch ); } };","title":"54. \u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u91cd\u590d\u7684\u5b57\u7b26*"},{"location":"algo/jsoffer/#55","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4e00\u4e2a\u94fe\u8868\uff0c\u82e5\u5176\u4e2d\u5305\u542b\u73af\uff0c\u8bf7\u627e\u51fa\u8be5\u94fe\u8868\u7684\u73af\u7684\u5165\u53e3\u7ed3\u70b9\uff0c\u5426\u5219\uff0c\u8f93\u51fanull\u3002 For the case of circle. Set two pointors p1 and p2 staring from head. p1 moves one step each time; p2 moves 2 steps each time. Because of a loop, p1 and p2 will definitely come across at some node in the loop. Suppose p1 moves x steps, then p2 moves evidently 2x steps. Besides, p2 has covered at least one circile. 2x - x = kn, \\quad k = 1, 2, 3, ... 2x - x = kn, \\quad k = 1, 2, 3, ... where n denotes the length of loop. We can also see both p1 and p2 have covered the part beyond the loop, says L1. x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... So, we one pointor moves starting from M and the other moves starting from head and both of them move with 1 step. Then they will meet again at the statrt of loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * EntryNodeOfLoop ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * p1 = pHead , * p2 = pHead ; while ( p1 != NULL && p2 != NULL ) { p1 = p1 -> next ; p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p1 == p2 ) { break ; } } p2 = pHead ; while ( p2 != p1 ) { p1 = p1 -> next ; p2 = p2 -> next ; } return p1 ; } };","title":"55. \u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u7ed3\u70b9*"},{"location":"algo/jsoffer/#56","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u6392\u5e8f\u7684\u94fe\u8868\u4e2d\uff0c\u5b58\u5728\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u8bf7\u5220\u9664\u8be5\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u91cd\u590d\u7684\u7ed3\u70b9\u4e0d\u4fdd\u7559\uff0c\u8fd4\u56de\u94fe\u8868\u5934\u6307\u9488\u3002 \u4f8b\u5982\uff0c\u94fe\u88681->2->3->3->4->4->5 \u5904\u7406\u540e\u4e3a 1->2->5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * deleteDuplication ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * pre = new ListNode ( 0 ); pre -> next = pHead ; ListNode * par = pre , * cur = pHead ; bool isDup = false ; while ( cur != NULL ) { while ( cur -> next != NULL && cur -> next -> val == cur -> val ) { cur = cur -> next ; isDup = true ; } cur = cur -> next ; if ( isDup ) { par -> next = cur ; isDup = false ; } else { par = par -> next ; } } pHead = pre -> next ; delete pre ; return pHead ; } };","title":"56. \u5220\u9664\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9"},{"location":"algo/jsoffer/#57","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\u548c\u5176\u4e2d\u7684\u4e00\u4e2a\u7ed3\u70b9\uff0c\u8bf7\u627e\u51fa\u4e2d\u5e8f\u904d\u5386\u987a\u5e8f\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u5e76\u4e14\u8fd4\u56de\u3002\u6ce8\u610f\uff0c\u6811\u4e2d\u7684\u7ed3\u70b9\u4e0d\u4ec5\u5305\u542b\u5de6\u53f3\u5b50\u7ed3\u70b9\uff0c\u540c\u65f6\u5305\u542b\u6307\u5411\u7236\u7ed3\u70b9\u7684\u6307\u9488\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) \uff1aval(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public \uff1a TreeLinkNode * GetNext ( TreeLinkNode * pNode ) { if ( pNode == NULL ) { return NULL ; } if ( pNode -> right != NULL ) { TreeLinkNode * curNode = pNode -> right ; while ( curNode -> left != NULL ) { curNode = curNode -> left ; } return curNode ; } if ( pNode -> next == NULL ) { return NULL ; } if ( pNode -> next -> left == pNode ) { return pNode -> next ; } if ( pNode -> next -> next != NULL && pNode -> next -> next -> left == pNode -> next ) { return pNode -> next -> next ; } return NULL ; } };","title":"57. \u4e8c\u53c9\u6811\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9"},{"location":"algo/jsoffer/#58","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u4e00\u9897\u4e8c\u53c9\u6811\u662f\u4e0d\u662f\u5bf9\u79f0\u7684\u3002\u6ce8\u610f\uff0c\u5982\u679c\u4e00\u4e2a\u4e8c\u53c9\u6811\u540c\u6b64\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u662f\u540c\u6837\u7684\uff0c\u5b9a\u4e49\u5176\u4e3a\u5bf9\u79f0\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a bool isSymmetrical ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return true ; } return isSymmetricalSubtree ( pRoot -> left , pRoot -> right ); } bool isSymmetricalSubtree ( TreeNode * left , TreeNode * right ) { if ( left == NULL && right == NULL ) { return true ; } if ( left == NULL || right == NULL ) { return false ; } if ( left -> val != right -> val ) { return false ; } bool L = isSymmetricalSubtree ( left -> left , right -> right ); bool R = isSymmetricalSubtree ( left -> right , right -> left ); return ( L && R ); } };","title":"58. \u5bf9\u79f0\u7684\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#59","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6309\u7167\u4e4b\u5b57\u5f62\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u5373\u7b2c\u4e00\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e8c\u5c42\u6309\u7167\u4ece\u53f3\u81f3\u5de6\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e09\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u5176\u4ed6\u884c\u4ee5\u6b64\u7c7b\u63a8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a void inverse ( vector < int >& arr ) { int len = int ( arr . size ()); for ( int i = 0 ; i < len / 2 ; i ++ ) { int temp = arr [ i ]; arr [ i ] = arr [ len -1 - i ]; arr [ len -1 - i ] = temp ; } } vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int >> res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; int count = 1 ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { if ( count % 2 == 0 ) { inverse ( temp ); } count ++ ; res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } };","title":"59. \u6309\u4e4b\u5b57\u5f62\u987a\u5e8f\u6253\u5370\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#60","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5230\u4e0b\u6309\u5c42\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u540c\u4e00\u5c42\u7ed3\u70b9\u4ece\u5de6\u81f3\u53f3\u8f93\u51fa\u3002\u6bcf\u4e00\u5c42\u8f93\u51fa\u4e00\u884c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int > > res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } };","title":"60. \u628a\u4e8c\u53c9\u6811\u6253\u5370\u6210\u591a\u884c"},{"location":"algo/jsoffer/#61","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u6765\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u4e8c\u53c9\u6811 \u4e8c\u53c9\u6811\u7684\u5e8f\u5217\u5316\u662f\u6307\uff1a\u628a\u4e00\u68f5\u4e8c\u53c9\u6811\u6309\u7167\u67d0\u79cd\u904d\u5386\u65b9\u5f0f\u7684\u7ed3\u679c\u4ee5\u67d0\u79cd\u683c\u5f0f\u4fdd\u5b58\u4e3a\u5b57\u7b26\u4e32\uff0c\u4ece\u800c\u4f7f\u5f97\u5185\u5b58\u4e2d\u5efa\u7acb\u8d77\u6765\u7684\u4e8c\u53c9\u6811\u53ef\u4ee5\u6301\u4e45\u4fdd\u5b58\u3002\u5e8f\u5217\u5316\u53ef\u4ee5\u57fa\u4e8e\u5148\u5e8f\u3001\u4e2d\u5e8f\u3001\u540e\u5e8f\u3001\u5c42\u5e8f\u7684\u4e8c\u53c9\u6811\u904d\u5386\u65b9\u5f0f\u6765\u8fdb\u884c\u4fee\u6539\uff0c\u5e8f\u5217\u5316\u7684\u7ed3\u679c\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5e8f\u5217\u5316\u65f6\u901a\u8fc7 \u67d0\u79cd\u7b26\u53f7\u8868\u793a\u7a7a\u8282\u70b9\uff08#\uff09\uff0c\u4ee5 \uff01 \u8868\u793a\u4e00\u4e2a\u7ed3\u70b9\u503c\u7684\u7ed3\u675f\uff08value!\uff09\u3002\u4e8c\u53c9\u6811\u7684\u53cd\u5e8f\u5217\u5316\u662f\u6307\uff1a\u6839\u636e\u67d0\u79cd\u904d\u5386\u987a\u5e8f\u5f97\u5230\u7684\u5e8f\u5217\u5316\u5b57\u7b26\u4e32\u7ed3\u679cstr\uff0c\u91cd\u6784\u4e8c\u53c9\u6811\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u4e00\u4e2a\u53ea\u6709\u6839\u8282\u70b9\u4e3a1\u7684\u4e8c\u53c9\u6811\u5e8f\u5217\u5316\u4e3a\"1,\"\uff0c\u7136\u540e\u901a\u8fc7\u81ea\u5df1\u7684\u51fd\u6570\u6765\u89e3\u6790\u56de\u8fd9\u4e2a\u4e8c\u53c9\u6811 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a char * Serialize ( TreeNode * root ) { string pre = \"\" , in = \"\" ; preOrder ( root , pre ); inOrder ( root , in ); pre . push_back ( '#' ); pre += in ; int n = int ( pre . length ()); char * str = new char [ n + 1 ]{}; for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = pre [ i ]; } str [ n ] = '\\0' ; return str ; } void preOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { str += to_string ( root -> val ); str . push_back ( ',' ); preOrder ( root -> left , str ); preOrder ( root -> right , str ); } } void inOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { inOrder ( root -> left , str ); str += to_string ( root -> val ); str . push_back ( ',' ); inOrder ( root -> right , str ); } } TreeNode * Deserialize ( char * str ) { vector < int > pre , in ; bool isPre = true ; int val = 0 ; for ( int i = 0 ; i < strlen ( str ); i ++ ) { if ( str [ i ] == '#' ) { isPre = false ; continue ; } if ( str [ i ] == ',' ) { if ( isPre ) { pre . push_back ( val ); } else { in . push_back ( val ); } val = 0 ; continue ; } val = val * 10 + ( str [ i ] - '0' ); } int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return constructTree ( pre , in , 0 , n -1 , 0 , n -1 ); } TreeNode * constructTree ( vector < int > pre , vector < int > in , int b1 , int e1 , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int numLeft = 0 ; for ( int i = b2 ; i <= e2 ; i ++ , numLeft ++ ) { if ( in [ i ] == pre [ b1 ]) { break ; } } root -> left = constructTree ( pre , in , b1 + 1 , b1 + numLeft , b2 , b2 + numLeft -1 ); root -> right = constructTree ( pre , in , b1 + numLeft + 1 , e1 , b2 + numLeft + 1 , e2 ); return root ; } };","title":"61. \u5e8f\u5217\u5316\u4e8c\u53c9\u6811*"},{"location":"algo/jsoffer/#62-k","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u8bf7\u627e\u51fa\u5176\u4e2d\u7684\u7b2ck\u5c0f\u7684\u7ed3\u70b9\u3002\u4f8b\u5982\uff0c\uff085\uff0c3\uff0c7\uff0c2\uff0c4\uff0c6\uff0c8\uff09\u4e2d\uff0c\u6309\u7ed3\u70b9\u6570\u503c\u5927\u5c0f\u987a\u5e8f\u7b2c\u4e09\u5c0f\u7ed3\u70b9\u7684\u503c\u4e3a4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a TreeNode * KthNode ( TreeNode * pRoot , int k ) { TreeNode * res = NULL ; inOrder ( pRoot , k , res ); return res ; } void inOrder ( TreeNode * root , int & k , TreeNode *& res ) { if ( root != NULL ) { inOrder ( root -> left , k , res ); k -- ; if ( k == 0 ) { res = root ; } inOrder ( root -> right , k , res ); } } };","title":"62. \u4e8c\u53c9\u6811\u7684\u7b2ck\u4e2a\u7ed3\u70b9*"},{"location":"algo/jsoffer/#63","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5982\u4f55\u5f97\u5230\u4e00\u4e2a\u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570\uff1f\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5947\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4f4d\u4e8e\u4e2d\u95f4\u7684\u6570\u503c\u3002\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5076\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4e2d\u95f4\u4e24\u4e2a\u6570\u7684\u5e73\u5747\u503c\u3002\u6211\u4eec\u4f7f\u7528Insert()\u65b9\u6cd5\u8bfb\u53d6\u6570\u636e\u6d41\uff0c\u4f7f\u7528GetMedian()\u65b9\u6cd5\u83b7\u53d6\u5f53\u524d\u8bfb\u53d6\u6570\u636e\u7684\u4e2d\u4f4d\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { vector < int > arr ; public \uff1a void Insert ( int num ) { arr . push_back ( num ); } void swap ( vector < int >& arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int >& arr , int begin , int end , int n ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] > arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] > arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i -1 , n ); quickSort ( arr , j + 1 , end , n ); } } double GetMedian () { int n = int ( arr . size ()); quickSort ( arr , 0 , n -1 , n ); if ( n % 2 ) { return arr [ n / 2 ]; } else { return ( arr [( n -1 ) / 2 ] + arr [ n / 2 ]) / 2.0 ; } } };","title":"63. \u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570"},{"location":"algo/jsoffer/#64","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u548c\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f\uff0c\u627e\u51fa\u6240\u6709\u6ed1\u52a8\u7a97\u53e3\u91cc\u6570\u503c\u7684\u6700\u5927\u503c\u3002\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u6570\u7ec4{2,3,4,2,6,2,5,1}\u53ca\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f3\uff0c\u90a3\u4e48\u4e00\u5171\u5b58\u57286\u4e2a\u6ed1\u52a8\u7a97\u53e3\uff0c\u4ed6\u4eec\u7684\u6700\u5927\u503c\u5206\u522b\u4e3a{4,4,6,6,6,5}\uff1b \u9488\u5bf9\u6570\u7ec4{2,3,4,2,6,2,5,1}\u7684\u6ed1\u52a8\u7a97\u53e3\u6709\u4ee5\u4e0b6\u4e2a\uff1a {[2,3,4],2,6,2,5,1}\uff0c {2,[3,4,2],6,2,5,1}\uff0c {2,3,[4,2,6],2,5,1}\uff0c {2,3,4,[2,6,2],5,1}\uff0c {2,3,4,2,[6,2,5],1}\uff0c {2,3,4,2,6,[2,5,1]}\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a vector < int > maxInWindows ( const vector < int >& num , unsigned int size ) { vector < int > res ; int n = int ( num . size ()); if ( n < size || size < 1 ) { return res ; } for ( int i = 0 ; i < n - size + 1 ; i ++ ) { int max = num [ i ]; for ( int j = i + 1 ; j <= i + size - 1 ; j ++ ) { if ( max < num [ j ]) { max = num [ j ]; } } res . push_back ( max ); } return res ; } };","title":"64. \u6ed1\u52a8\u7a97\u53e3\u7684\u6700\u5927\u503c"},{"location":"algo/jsoffer/#65","text":"\u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u5728\u4e00\u4e2a\u77e9\u9635\u4e2d\u662f\u5426\u5b58\u5728\u4e00\u6761\u5305\u542b\u67d0\u5b57\u7b26\u4e32\u6240\u6709\u5b57\u7b26\u7684\u8def\u5f84\u3002\u8def\u5f84\u53ef\u4ee5\u4ece\u77e9\u9635\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u683c\u5b50\u5f00\u59cb\uff0c\u6bcf\u4e00\u6b65\u53ef\u4ee5\u5728\u77e9\u9635\u4e2d\u5411\u5de6\uff0c\u5411\u53f3\uff0c\u5411\u4e0a\uff0c\u5411\u4e0b\u79fb\u52a8\u4e00\u4e2a\u683c\u5b50\u3002\u5982\u679c\u4e00\u6761\u8def\u5f84\u7ecf\u8fc7\u4e86\u77e9\u9635\u4e2d\u7684\u67d0\u4e00\u4e2a\u683c\u5b50\uff0c\u5219\u8be5\u8def\u5f84\u4e0d\u80fd\u518d\u8fdb\u5165\u8be5\u683c\u5b50\u3002 \u4f8b\u5982 \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} (stock in an array [a, b, c, e, s, f, c, s, a, d, e, e])\u3002 \u77e9\u9635\u4e2d\u5305\u542b\u4e00\u6761\u5b57\u7b26\u4e32\"bcced\"\u7684\u8def\u5f84\uff0c\u4f46\u662f\u77e9\u9635\u4e2d\u4e0d\u5305\u542b\"abcb\"\u8def\u5f84\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26b\u5360\u636e\u4e86\u77e9\u9635\u4e2d\u7684\u7b2c\u4e00\u884c\u7b2c\u4e8c\u4e2a\u683c\u5b50\u4e4b\u540e\uff0c\u8def\u5f84\u4e0d\u80fd\u518d\u6b21\u8fdb\u5165\u8be5\u683c\u5b50\u3002 Solution\uff1aBacktracking\uff1a if we can find one character matched, we continue to explore next one (up, down, left, right); if one character doesn't match, we reset all previous positions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a bool hasPath ( char * matrix , int rows , int cols , char * str ) { bool * dp = new bool [ rows * cols ]{}, res = false ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( isPath ( i , j , rows , cols , matrix , str , dp , 0 )) { res = true ; break ; } } } delete [] dp ; return res ; } bool isPath ( int i , int j , int nRow , int nCol , char * mat , char * str , bool * dp , int k ) { int idx = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ idx ] || mat [ idx ] != str [ k ]) { return false ; } if ( str [ k + 1 ] == '\\0' ) { return true ; } dp [ idx ] = true ; bool u = isPath ( i -1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool d = isPath ( i + 1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool l = isPath ( i , j -1 , nRow , nCol , mat , str , dp , k + 1 ); bool r = isPath ( i , j + 1 , nRow , nCol , mat , str , dp , k + 1 ); dp [ idx ] = false ; return u || d || l || r ; } };","title":"65. \u77e9\u9635\u4e2d\u7684\u8def\u5f84"},{"location":"algo/jsoffer/#66","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5730\u4e0a\u6709\u4e00\u4e2am\u884c\u548cn\u5217\u7684\u65b9\u683c\u3002\u4e00\u4e2a\u673a\u5668\u4eba\u4ece\u5750\u68070,0\u7684\u683c\u5b50\u5f00\u59cb\u79fb\u52a8\uff0c\u6bcf\u4e00\u6b21\u53ea\u80fd\u5411\u5de6\uff0c\u53f3\uff0c\u4e0a\uff0c\u4e0b\u56db\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u4e0d\u80fd\u8fdb\u5165\u884c\u5750\u6807\u548c\u5217\u5750\u6807\u7684\u6570\u4f4d\u4e4b\u548c\u5927\u4e8ek\u7684\u683c\u5b50\u3002 \u4f8b\u5982\uff0c\u5f53k\u4e3a18\u65f6\uff0c\u673a\u5668\u4eba\u80fd\u591f\u8fdb\u5165\u65b9\u683c\uff0835,37\uff09\uff0c\u56e0\u4e3a3+5+3+7 = 18\u3002\u4f46\u662f\uff0c\u5b83\u4e0d\u80fd\u8fdb\u5165\u65b9\u683c\uff0835,38\uff09\uff0c\u56e0\u4e3a3+5+3+8 = 19\u3002\u8bf7\u95ee\u8be5\u673a\u5668\u4eba\u80fd\u591f\u8fbe\u5230\u591a\u5c11\u4e2a\u683c\u5b50\uff1f Solution\uff1aBacktracking is one of brutal force method in searching. We cannot simply count how many grids which are illegal because the robot can only move one cell once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a int movingCount ( int threshold , int rows , int cols ) { bool * dp = new bool [ rows * cols ]{}; int count = move ( threshold , rows , cols , 0 , 0 , dp ); delete [] dp ; return count ; } int move ( int threshold , int nRow , int nCol , int i , int j , bool * dp ) { int pos = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ pos ] || toSum ( i ) + toSum ( j ) > threshold ) { return 0 ; } dp [ pos ] = true ; int u = move ( threshold , nRow , nCol , i -1 , j , dp ); int d = move ( threshold , nRow , nCol , i + 1 , j , dp ); int l = move ( threshold , nRow , nCol , i , j -1 , dp ); int r = move ( threshold , nRow , nCol , i , j + 1 , dp ); return 1 + u + d + l + r ; } int toSum ( int num ) { int sum = 0 ; while ( num ) { sum += num % 10 ; num /= 10 ; } return sum ; } };","title":"66. \u673a\u5668\u4eba\u7684\u8fd0\u52a8\u8303\u56f4*"},{"location":"algo/jsoffer/#67","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4f60\u4e00\u6839\u957f\u5ea6\u4e3an\u7684\u7ef3\u5b50\uff0c\u8bf7\u628a\u7ef3\u5b50\u526a\u6210\u6574\u6570\u957f\u7684m\u6bb5\uff08m\u3001n\u90fd\u662f\u6574\u6570\uff0cn>1\u5e76\u4e14m>1\uff09\uff0c\u6bcf\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u8bb0\u4e3ak[0],k[1],...,k[m]\u3002\u8bf7\u95eek[0]xk[1]x...xk[m]\u53ef\u80fd\u7684\u6700\u5927\u4e58\u79ef\u662f\u591a\u5c11\uff1f\u4f8b\u5982\uff0c\u5f53\u7ef3\u5b50\u7684\u957f\u5ea6\u662f8\u65f6\uff0c\u6211\u4eec\u628a\u5b83\u526a\u6210\u957f\u5ea6\u5206\u522b\u4e3a2\u30013\u30013\u7684\u4e09\u6bb5\uff0c\u6b64\u65f6\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u662f18\u3002 \u793a\u4f8b1\uff1a\u8f93\u51658\u8f93\u51fa18 Solution\uff1aSuppose f(n) denote the max product. We have an interative equation f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} Attention, there is some special case, when n = 2, we should return 1. In iterative equation, f(2) denotes length of the rope. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a int cutRope ( int number ) { int n = number ; if ( n < 2 ) { return 0 ; } if ( n == 2 ) { return 1 ; } if ( n == 3 ) { return 2 ; } int * f = new int [ n + 1 ]{}; f [ 1 ] = 1 ; f [ 2 ] = 2 ; f [ 3 ] = 3 ; int prod = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { int max_prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { prod = f [ j ] * f [ i - j ]; if ( max_prod < prod ) { max_prod = prod ; } } f [ i ] = max_prod ; } int res = f [ n ]; delete [] f ; return res ; } };","title":"67. \u526a\u7ef3\u5b50*"},{"location":"algo/jsoffer/#68-oj","text":"","title":"68. OJ\u5728\u7ebf\u7f16\u7a0b\u5e38\u89c1\u8f93\u5165\u8f93\u51fa\u7ec3\u4e60\u573a"},{"location":"algo/jsoffer/#681-ab1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { cout << a + b << endl ; } return 0 ; }","title":"68.1 A+B(1)"},{"location":"algo/jsoffer/#682-ab2","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6570\u636e\u7ec4\u6570t(1 <= t <= 100)\u63a5\u4e0b\u6765\u6bcf\u884c\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9)\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516521 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> using namespace std ; int main () { int t ; long a , b ; cin >> t ; while ( t -- ) { cin >> a >> b ; cout << ( a + b ) << endl ; } return 0 ; }","title":"68.2 A+B(2)"},{"location":"algo/jsoffer/#683-ab3","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u5982\u679c\u8f93\u5165\u4e3a0 0\u5219\u7ed3\u675f\u8f93\u5165\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 200 0 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { if ( a == 0 && b == 0 ) { break ; } cout << ( a + b ) << endl ; } return 0 ; }","title":"68.3 A+B(3)"},{"location":"algo/jsoffer/#684-ab4","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u6bcf\u7ec4\u6570\u636e\u4e00\u884c,\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100), n\u4e3a0\u7684\u65f6\u5019\u7ed3\u675f\u8f93\u5165\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570,\u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 50 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { long sum , a ; int n ; while ( true ) { sum = 0 ; cin >> n ; if ( n == 0 ) { break ; } while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; }","title":"68.4 A+B(4)"},{"location":"algo/jsoffer/#685-ab5","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7684\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6b63\u6574\u6570t(1 <= t <= 100), \u8868\u793a\u6570\u636e\u7ec4\u6570\u3002\u63a5\u4e0b\u6765t\u884c, \u6bcf\u884c\u4e00\u7ec4\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516524 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { int t , n ; long sum , a ; cin >> t ; while ( t -- ) { cin >> n ; sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; }","title":"68.5 A+B(5)"},{"location":"algo/jsoffer/#686-ab6","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> using namespace std ; int main () { int n ; long sum , a ; while ( cin >> n ) { sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; }","title":"68.6 A+B(6)"},{"location":"algo/jsoffer/#687-ab7","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u4e0d\u5b9a\u6709n\u4e2a\u6574\u6570\uff0c\u7a7a\u683c\u9694\u5f00\u3002(1 <= n <= 100)\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 2 34 50 0 0 0 0 \u8f93\u51fa690 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> using namespace std ; int main () { long sum , a ; sum = 0 ; while ( cin >> a ) { sum += a ; if ( cin . get () == '\\n' ) { cout << sum << endl ; sum = 0 ; } } return 0 ; }","title":"68.7 A+B(7)"},{"location":"algo/jsoffer/#688-1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6709\u4e24\u884c\uff0c\u7b2c\u4e00\u884cn\u7b2c\u4e8c\u884c\u662fn\u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u5b57\u7b26\u4e32\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7a7a\u683c\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u51655c d a bb e \u8f93\u51faa bb c d e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <string> using namespace std ; void swap ( string * str , int i , int j ) { string temp = str [ i ]; str [ i ] = str [ j ]; str [ j ] = temp ; } void quickSort ( string * str , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( i < j && str [ i ] <= str [ j ]) { j -- ; } swap ( str , i , j ); while ( i < j && str [ i ] <= str [ j ]) { i ++ ; } swap ( str , i , j ); } quickSort ( str , begin , i -1 ); quickSort ( str , j + 1 , end ); } } int main () { int n ; cin >> n ; string * str = new string [ n ]; for ( int i = 0 ; i < n ; i ++ ) { cin >> str [ i ]; } quickSort ( str , 0 , n -1 ); for ( int i = 0 ; i < n -1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n -1 ] << endl ; delete [] str ; return 0 ; }","title":"68.8 \u5b57\u7b26\u4e32\u6392\u5e8f(1)"},{"location":"algo/jsoffer/#689-2","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7\u7a7a\u683c\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u8fc7\u7684\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4e32\u901a\u8fc7\u7a7a\u683c\u9694\u5f00 \u793a\u4f8b1 \u8f93\u5165a c bbf ddddnowcoder \u8f93\u51faa bb cdddd fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <iostream> #include <string> #include <algorithm> #include <vector> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { str . push_back ( temp ); if ( cin . get () == '\\n' ) { sort ( str . begin (), str . end ()); int n = int ( str . size ()); for ( int i = 0 ; i < n -1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n -1 ] << endl ; str . clear (); } } }","title":"68.9 \u5b57\u7b26\u4e32\u6392\u5e8f(2)"},{"location":"algo/jsoffer/#6810-3","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7,\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u7528\u4f8b\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7528','\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u5165a,c,bbf,ddddnowcoder \u8f93\u51faa,bb,cdddd,fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> #include <string> #include <vector> #include <algorithm> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { int n = int ( temp . length ()); string s = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp [ i ] == ',' ) { str . push_back ( s ); s = \"\" ; continue ; } s . push_back ( temp [ i ]); } str . push_back ( s ); sort ( str . begin (), str . end ()); n = int ( str . size ()); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ',' ; } cout << str [ n -1 ] << endl ; str . clear (); } }","title":"68.10 \u5b57\u7b26\u4e32\u6392\u5e8f(3)"},{"location":"algo/jsoffer/#69","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570N\u548c\u957f\u5ea6L\uff0c\u627e\u51fa\u4e00\u6bb5\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8eL\u7684\u8fde\u7eed\u975e\u8d1f\u6574\u6570\uff0c\u4ed6\u4eec\u7684\u548c\u6070\u597d\u4e3aN\u3002\u7b54\u6848\u53ef\u80fd\u6709\u591a\u4e2a\uff0c\u6211\u6211\u4eec\u9700\u8981\u627e\u51fa\u957f\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u4f8b\u5982 N = 18 L = 2\uff1a5 + 6 + 7 = 183 + 4 + 5 + 6 = 18\u90fd\u662f\u6ee1\u8db3\u8981\u6c42\u7684\uff0c\u4f46\u662f\u6211\u4eec\u8f93\u51fa\u66f4\u77ed\u7684 5 6 7 \u793a\u4f8b1\uff1a \u8f93\u516518 2 \u8f93\u51fa5 6 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> using namespace std ; void solution ( int N , int L ) { for ( int m = L ; m <= 100 ; m ++ ) { int x = N / m + ( 1 - m ) / 2 ; //cout << x << endl; if (( 2 * x + m -1 ) * m != 2 * N ) { continue ; } for ( int i = 0 ; i < m -1 ; i ++ ) { cout << ( x + i ) << ' ' ; } cout << ( x + m -1 ) << endl ; return ; } cout << \"No\" << endl ; } int main ( int argc , const char * argv []) { // insert code here... int N , L ; scanf ( \"%d%d\" , & N , & L ); solution ( N , L ); return 0 ; }","title":"69. \u5e8f\u5217\u548c"},{"location":"algo/two-pointers/","text":"\u76f8\u5173\u9898\u76ee \u00b6 \u300cLeetcode 3. \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u4e0d\u542b\u6709\u91cd\u590d\u5b57\u7b26\u7684 \u6700\u957f\u5b50\u4e32 \u7684\u957f\u5ea6\u3002 \u8f93\u5165: s = \"abcabcbb\" \u8f93\u51fa: 3 \u89e3\u91ca: \u56e0\u4e3a\u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u662f \"abc\"\uff0c\u6240\u4ee5\u5176\u957f\u5ea6\u4e3a 3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lengthOfLongestSubstring ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } int i = 0 , j = 0 , maxLen = 0 ; unordered_set < char > hash ; while ( j < n ) { if ( hash . count ( s [ j ])) { hash . erase ( s [ i ++ ]); } else { hash . insert ( s [ j ++ ]); maxLen = max ( maxLen , j - i ); } } return maxLen ; } \u300cLeetcode 15. \u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u4f60\u4e00\u4e2a\u5305\u542b n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums\uff0c\u5224\u65ad nums \u4e2d\u662f\u5426\u5b58\u5728\u4e09\u4e2a\u5143\u7d20a\uff0cb\uff0cc \uff0c\u4f7f\u5f97 a + b + c = 0 \uff1f\u8bf7\u4f60\u627e\u51fa\u6240\u6709\u548c\u4e3a 0 \u4e14\u4e0d\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 \u6ce8\u610f\uff1a\u7b54\u6848\u4e2d\u4e0d\u53ef\u4ee5\u5305\u542b\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < vector < int >> threeSum ( vector < int >& nums ) { int n = int ( nums . size ()); vector < vector < int >> ans ; if ( n < 3 ) { return ans ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) { j ++ ; } else if ( sum > 0 ) { k -- ; } else { while ( i < k && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < k && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( j < k && nums [ k ] == nums [ k -1 ]) { k -- ; } ans . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); j ++ ; k -- ; } } } return ans ; } \u300cLeetcode 16. \u6700\u63a5\u8fd1\u7684\u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5305\u62ec n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums \u548c \u4e00\u4e2a\u76ee\u6807\u503c target\u3002\u627e\u51fa nums \u4e2d\u7684\u4e09\u4e2a\u6574\u6570\uff0c\u4f7f\u5f97\u5b83\u4eec\u7684\u548c\u4e0e target \u6700\u63a5\u8fd1\u3002\u8fd4\u56de\u8fd9\u4e09\u4e2a\u6570\u7684\u548c\u3002\u5047\u5b9a\u6bcf\u7ec4\u8f93\u5165\u53ea\u5b58\u5728\u552f\u4e00\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int threeSumClosest ( vector < int >& nums , int target ) { int n = int ( nums . size ()), res = 0 , diff = ( 1l l << 31 ) - 1 ; if ( n < 3 ) { return 0 ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i <= n -3 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( abs ( sum - target ) < diff ) { diff = abs ( sum - target ); res = sum ; } if ( sum < target ) { j ++ ; } else if ( sum > target ) { k -- ; } else { return target ; } } } return res ; }","title":"\u53cc\u6307\u9488"},{"location":"algo/two-pointers/#_1","text":"\u300cLeetcode 3. \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u4e0d\u542b\u6709\u91cd\u590d\u5b57\u7b26\u7684 \u6700\u957f\u5b50\u4e32 \u7684\u957f\u5ea6\u3002 \u8f93\u5165: s = \"abcabcbb\" \u8f93\u51fa: 3 \u89e3\u91ca: \u56e0\u4e3a\u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u662f \"abc\"\uff0c\u6240\u4ee5\u5176\u957f\u5ea6\u4e3a 3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lengthOfLongestSubstring ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } int i = 0 , j = 0 , maxLen = 0 ; unordered_set < char > hash ; while ( j < n ) { if ( hash . count ( s [ j ])) { hash . erase ( s [ i ++ ]); } else { hash . insert ( s [ j ++ ]); maxLen = max ( maxLen , j - i ); } } return maxLen ; } \u300cLeetcode 15. \u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u4f60\u4e00\u4e2a\u5305\u542b n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums\uff0c\u5224\u65ad nums \u4e2d\u662f\u5426\u5b58\u5728\u4e09\u4e2a\u5143\u7d20a\uff0cb\uff0cc \uff0c\u4f7f\u5f97 a + b + c = 0 \uff1f\u8bf7\u4f60\u627e\u51fa\u6240\u6709\u548c\u4e3a 0 \u4e14\u4e0d\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 \u6ce8\u610f\uff1a\u7b54\u6848\u4e2d\u4e0d\u53ef\u4ee5\u5305\u542b\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < vector < int >> threeSum ( vector < int >& nums ) { int n = int ( nums . size ()); vector < vector < int >> ans ; if ( n < 3 ) { return ans ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) { j ++ ; } else if ( sum > 0 ) { k -- ; } else { while ( i < k && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < k && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( j < k && nums [ k ] == nums [ k -1 ]) { k -- ; } ans . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); j ++ ; k -- ; } } } return ans ; } \u300cLeetcode 16. \u6700\u63a5\u8fd1\u7684\u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5305\u62ec n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums \u548c \u4e00\u4e2a\u76ee\u6807\u503c target\u3002\u627e\u51fa nums \u4e2d\u7684\u4e09\u4e2a\u6574\u6570\uff0c\u4f7f\u5f97\u5b83\u4eec\u7684\u548c\u4e0e target \u6700\u63a5\u8fd1\u3002\u8fd4\u56de\u8fd9\u4e09\u4e2a\u6570\u7684\u548c\u3002\u5047\u5b9a\u6bcf\u7ec4\u8f93\u5165\u53ea\u5b58\u5728\u552f\u4e00\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int threeSumClosest ( vector < int >& nums , int target ) { int n = int ( nums . size ()), res = 0 , diff = ( 1l l << 31 ) - 1 ; if ( n < 3 ) { return 0 ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i <= n -3 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( abs ( sum - target ) < diff ) { diff = abs ( sum - target ); res = sum ; } if ( sum < target ) { j ++ ; } else if ( sum > target ) { k -- ; } else { return target ; } } } return res ; }","title":"\u76f8\u5173\u9898\u76ee"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","text":"1. \u7b80\u4ecb \u00b6 \u52a8\u6001\u89c4\u5212\uff08Dynamic programming\uff0c\u7b80\u79f0 DP\uff09\u5c06\u613f\u95ee\u9898\u62c6\u5206\u6210\u82e5\u5e72\u5b50\u95ee\u9898\uff08\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff09\uff0c\u901a\u8fc7\u5206\u522b\u6c42\u89e3\u5b50\u95ee\u9898\uff0c\u5f97\u5230\u613f\u95ee\u9898\u89e3\u7684\u4e00\u79cd\u7b97\u6cd5\u3002 2. \u8981\u7d20 \u00b6 \u5982\u679c\u4e00\u4e2a\u95ee\u9898\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7\u52a8\u6001\u89c4\u5212\u7684\u65b9\u6cd5\u6c42\u89e3 \u6700\u4f18\u5b50\u7ed3\u6784\uff08optimal structure\uff09 \u91cd\u53e0\u5b50\u95ee\u9898\uff08overlap subproblem\uff09 3. \u8ba1\u7b97\u6b65\u9aa4 \u00b6 \uff081\uff09\u63cf\u8ff0\u6700\u4f18\u89e3\u7684\u7ed3\u6784\uff0c\u5373\u7528\u4e00\u4e2a\u72b6\u6001\u8868\u793a\u6700\u4f18\u89e3 \uff082\uff09\u4ee5\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u7684\u5f62\u5f0f\uff0c\u9012\u5f52\u5730\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \uff083\uff09\u81ea\u4e0b\u800c\u4e0a\uff08bottom-top\uff09\u6216\u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u5730\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \uff084\uff09\u6839\u636e\uff083\uff09\u4e2d\u7684\u8fc7\u7a0b\u503c\uff0c\u6784\u9020\u6700\u4f18\u89e3\uff1b\u5982\u679c\u53ea\u9700\u8981\u6700\u4f18\u89e3\u7684\u503c\uff0c\u5219\u65e0\u9700\u672c\u6b65\u9aa4 4. \u52a8\u6001\u89c4\u5212\u7684\u7279\u70b9 \u00b6 \u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff1a\u4fdd\u5b58\u4e86\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4e2d\u95f4\u503c\uff0c\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97 \u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u6216\u8005\u9012\u5f52\u662f\u4e00\u79cd\u5907\u5fd8\u5f55\uff08memorization\uff09\u65b9\u6cd5 \u4e25\u683c\u6765\u8bf4\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6709\u81ea\u4e0b\u800c\u4e0a\u7684\u65b9\u5f0f\uff1b\u5982\u679c\u6240\u6709\u7684\u5b50\u95ee\u9898\u90fd\u4f1a\u88ab\u8ba1\u7b97\u4e00\u6b21\uff0c\u90a3\u4e48\u52a8\u6001\u89c4\u5212\u5177\u6709\u4f18\u52bf\uff0c\u53cd\u4e4b\uff08\u526a\u679d\u60c5\u51b5\uff09\uff0c\u5907\u5fd8\u5f55\u6cd5\u5177\u6709\u4f18\u52bf 5. \u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5fc3\u7684\u6bd4\u8f83 \u00b6 \u76f8\u540c\u70b9\uff1a\u5177\u5907\u6700\u4f18\u5b50\u7ed3\u6784 \u4e0d\u540c\u70b9\uff1a \u52a8\u6001\u89c4\u5212\u7684\u5b50\u95ee\u9898\u662f\u91cd\u53e0\u7684\uff0c\u8d2a\u5fc3\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0 \u52a8\u6001\u89c4\u5212\u4e0d\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u7684\u6027\u8d28 \u8d2a\u5fc3\u7684\u524d\u8fdb\u8def\u7ebf\u662f\u4e00\u6761\u7ebf\uff0c\u52a8\u6001\u89c4\u5212\u662f\u4e00\u4e2aDAG 6. \u7ecf\u5178\u95ee\u9898 \u00b6 6.1 \u7f16\u8f91\u8ddd\u79bb \u00b6 6.1.1 Levenshtein distance \u00b6 \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} a, b denote two strings to compare. If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 , delete a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 , insert b_{j} b_{j} at a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} , replace a_{i} a_{i} with b_{j} b_{j} \u300c\u4ee3\u7801\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 void EDprocess ( string s1 , string s2 , int i , int j , int ** dp , string str ) { if ( i == 0 && j == 0 ) { return ; } else if ( i == 0 || ( j > 0 && dp [ i ][ j ] == dp [ i ][ j -1 ] + 1 )) { string ss = str . substr ( 0 , i ); ss . push_back ( s2 [ j -1 ]); str = ss + str . substr ( i , str . length () - i ); printf ( \"insert %c: %s \\n \" , s2 [ j -1 ], str . c_str ()); EDprocess ( s1 , s2 , i , j -1 , dp , str ); } else if ( j == 0 || ( i > 0 && dp [ i ][ j ] == dp [ i -1 ][ j ] + 1 )) { string ss = str . substr ( 0 , i -1 ); str = ss + str . substr ( i , str . length () - i ); printf ( \"delete %c: %s \\n \" , s1 [ i -1 ], str . c_str ()); EDprocess ( s1 , s2 , i -1 , j , dp , str ); } else { if ( s1 [ i -1 ] != s2 [ j -1 ]) { str [ i -1 ] = s2 [ j -1 ]; printf ( \"replace %c with %c: %s \\n \" , s1 [ i -1 ], s2 [ j -1 ], str . c_str ()); } EDprocess ( s1 , s2 , i -1 , j -1 , dp , str ); } } void printDP ( string s1 , string s2 , int n1 , int n2 , int ** dp ) { for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { printf ( \"%d \\t \" , dp [ i ][ j ]); } printf ( \" \\n \" ); } printf ( \"s1 = %s \\n \" , s1 . c_str ()); EDprocess ( s1 , s2 , n1 , n2 , dp , s1 ); printf ( \"s2 = %s \\n \" , s2 . c_str ()); } int LD ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = i > j ? i : j ; } else { int a = dp [ i -1 ][ j ] + 1 ; int b = dp [ i ][ j -1 ] + 1 ; int c = dp [ i -1 ][ j -1 ] + ( s1 [ i -1 ] != s2 [ j -1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } printDP ( s1 , s2 , n1 , n2 , dp ); int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } /* 0 1 2 3 4 5 6 1 0 1 2 3 4 5 2 1 0 1 2 3 4 3 2 1 1 1 2 3 4 3 2 1 2 2 3 5 4 3 2 2 3 2 6 5 4 3 3 2 3 s1 = ecoles insert e: ecolese replace e with o: ecolose delete o: eclose s2 = eclose Edit distance = 3 */ 6.1.2 Damerau-Levenshtein distance \u00b6 \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \u8fde\u7eed\u5b50\u6570\u7ec4\u6700\u5927\u548c\u3001\u6700\u5927\u79ef \u00b6 \u300cLeetcode 53. \u6700\u5927\u5b50\u5e8f\u548c\u300d \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u5230\u4e00\u4e2a\u5177\u6709\u6700\u5927\u548c\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u5b50\u6570\u7ec4\u6700\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff09\uff0c\u8fd4\u56de\u5176\u6700\u5927\u548c\u3002 Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. 1 2 3 4 5 6 7 8 9 10 int maxSubArray ( vector < int >& nums ) { int n = int ( nums . size ()); int maxSum = - ( 1l l << 31 ), curSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; } if ( curSum > maxSum ) { maxSum = curSum ; } } return maxSum ; } \u300c\u6700\u5927\u548c\u7684\u5b50\u6570\u7ec4\u300d \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u5230\u4e00\u4e2a\u5177\u6709\u6700\u5927\u548c\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u5b50\u6570\u7ec4\u6700\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff09\uff0c\u8fd4\u56de\u5176\u6700\u5927\u548c\u3002 Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: [4,-1,2,1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 vector < int > getMaxSumEpisode ( vector < int > nums ) { // vector<int> nums {1, 2, -1, 3}; int n = int ( nums . size ()); vector < int > ans ; if ( n == 0 ) { return ans ; } int maxSum = - ( 1l l << 31 ), curSum = 0 ; int left = 0 , right = 0 , begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; begin = i ; } if ( maxSum < curSum ) { maxSum = curSum ; left = begin ; right = i ; } } for ( int i = left ; i <= right ; i ++ ) { ans . push_back ( nums [ i ]); } return ans ; } \u300cLeetcode 152. \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4\u300d Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. 1 2 3 4 5 6 7 8 9 10 11 int maxProduct ( vector < int >& nums ) { int n = int ( nums . size ()); int minF = nums [ 0 ], maxF = nums [ 0 ], ans = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _min = minF , _max = maxF ; minF = min ( nums [ i ], min ( _min * nums [ i ], _max * nums [ i ])); maxF = max ( nums [ i ], max ( _min * nums [ i ], _max * nums [ i ])); ans = max ( ans , maxF ); } return ans ; } \u300cLeetcode 1186. \u5220\u9664\u4e00\u6b21\u5f97\u5230\u5b50\u6570\u7ec4\u6700\u5927\u548c\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u67d0\u4e2a \u975e\u7a7a \u5b50\u6570\u7ec4\uff08\u8fde\u7eed\u5143\u7d20\uff09\u5728\u6267\u884c\u4e00\u6b21\u53ef\u9009\u7684\u5220\u9664\u64cd\u4f5c\u540e\uff0c\u6240\u80fd\u5f97\u5230 \u7684\u6700\u5927\u5143\u7d20\u603b\u548c\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u53ef\u4ee5\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u51fa\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5e76\u53ef\u4ee5\u51b3\u5b9a\u8981\u4e0d\u8981\u4ece\u4e2d\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff08\u53ea\u80fd\u5220\u4e00\u6b21\u54e6\uff09\uff0c \uff08\u5220\u9664\u540e\uff09\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5e94\u5f53\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8be5\u5b50\u6570\u7ec4\uff08\u5269\u4e0b\uff09\u7684\u5143\u7d20\u603b\u548c\u662f\u6240\u6709\u5b50\u6570\u7ec4\u4e4b\u4e2d\u6700\u5927\u7684\u3002 \u6ce8\u610f\uff0c\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u5b50\u6570\u7ec4 \u4e0d\u80fd\u4e3a\u7a7a\u3002 \u8bf7\u770b\u793a\u4f8b\uff1a \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aarr = [1,-2,0,3] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u6211\u4eec\u53ef\u4ee5\u9009\u51fa [1, -2, 0, 3]\uff0c\u7136\u540e\u5220\u6389 -2\uff0c\u8fd9\u6837\u5f97\u5230 [1, 0, 3]\uff0c\u548c\u6700\u5927\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aarr = [1,-2,-2,3] \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u6211\u4eec\u76f4\u63a5\u9009\u51fa [3]\uff0c\u8fd9\u5c31\u662f\u6700\u5927\u548c\u3002 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1aarr = [-1,-1,-1,-1] \u8f93\u51fa\uff1a-1 \u89e3\u91ca\uff1a\u6700\u540e\u5f97\u5230\u7684\u5b50\u6570\u7ec4\u4e0d\u80fd\u4e3a\u7a7a\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u9009\u62e9 [-1] \u5e76\u4ece\u4e2d\u5220\u53bb -1 \u6765\u5f97\u5230 0\u3002 \u6211\u4eec\u5e94\u8be5\u76f4\u63a5\u9009\u62e9 [-1]\uff0c\u6216\u8005\u9009\u62e9 [-1, -1] \u518d\u4ece\u4e2d\u5220\u53bb\u4e00\u4e2a -1\u3002 */ class Solution { public : int maximumSum ( vector < int >& arr ) { int n = ( int ) arr . size (); if ( n == 0 ) { return 0 ; } const int minEle = * min_element ( arr . begin (), arr . end ()); int dp0 = arr [ 0 ], dp1 = minEle , ans = dp0 ; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 + arr [ i ], arr [ i ]); int tmp1 = max ( dp0 , dp1 + arr [ i ]); dp0 = tmp0 ; dp1 = tmp1 ; ans = max ( ans , max ( dp0 , dp1 )); } return ans ; } }; \u300c\u6700\u957f01\u7b49\u91cf\u5b50\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int getLongest01SubstrLen ( string str ) { //str = \"0010011001001010110\", ans = 16 int len = 0 , n = ( int ) str . length (); vector < int > dp ( n + 1 , 0 ); unordered_map < int , int > dict ; dict [ 0 ] = n ; int pos = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { dp [ i ] = dp [ i + 1 ] + 1 ; } else { dp [ i ] = dp [ i + 1 ] - 1 ; } if ( dict . find ( dp [ i ]) != dict . end ()) { len = max ( len , dict [ dp [ i ]] - i ); pos = i ; } else { dict [ dp [ i ]] = i ; } } printf ( \"maxLenSubstr = %s \\n \" , str . substr ( pos , len ). c_str ()); return len ; } \u80cc\u5305\u95ee\u9898 \u00b6 \u300c01\u80cc\u5305\u300d \u4e00\u4e2a\u80cc\u5305\u6709\u4e00\u5b9a\u7684\u627f\u91cdcap\uff0c\u6709N\u4ef6\u7269\u54c1\uff0c\u6bcf\u4ef6\u90fd\u6709\u81ea\u5df1\u7684\u4ef7\u503c\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4v\u4e2d\uff0c\u4e5f\u90fd\u6709\u81ea\u5df1\u7684\u91cd\u91cf\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4w\u4e2d\uff0c\u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u9009\u62e9\u8981\u88c5\u5165\u80cc\u5305\u8fd8\u662f\u4e0d\u88c5\u5165\u80cc\u5305\uff0c\u8981\u6c42\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u7684\u524d\u63d0\u4e0b\uff0c\u9009\u51fa\u7269\u54c1\u7684\u603b\u4ef7\u503c\u6700\u5927\u3002\u7ed9\u5b9a\u7269\u54c1\u7684\u91cd\u91cfw\u4ef7\u503cv\u53ca\u7269\u54c1\u6570n\u548c\u627f\u91cdcap\u3002\u8bf7\u8fd4\u56de\u6700\u5927\u603b\u4ef7\u503c\u3002 \u6d4b\u8bd5\u6837\u4f8b\uff1a [1,2,3],[1,2,3],3,6 \u8fd4\u56de\uff1a6 \u52a8\u6001\u89c4\u5212\uff1adp[i][j]\u8868\u793a\u524di\u4ef6\u7269\u54c1\u5728\u6700\u5927\u91cd\u91cfj\u7684\u6761\u4ef6\u4e0b\u7684\u4ef7\u503c dp[i][j] =\\max \\begin{cases} dp[i-1]][j], &\\quad \\text{we don't put i-th item in our bag} \\\\ dp[i-1][j - w[i-1]], &\\quad \\text{otherwise, but } j > w[i-1], i = 1, 2, ..., N \\end{cases} dp[i][j] =\\max \\begin{cases} dp[i-1]][j], &\\quad \\text{we don't put i-th item in our bag} \\\\ dp[i-1][j - w[i-1]], &\\quad \\text{otherwise, but } j > w[i-1], i = 1, 2, ..., N \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* * * v[]: value for each item * w[]: weight for each item * W: capacity limit * N: number of item */ int knapsack ( int v [], int w [], int W , int N ) { int ** dp = new int * [ N + 1 ]; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = new int [ W + 1 ]{}; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( j < w [ i -1 ]) { dp [ i ][ j ] = dp [ i -1 ][ j ]; } else { dp [ i ][ j ] = max ( dp [ i -1 ][ j ], dp [ i -1 ][ j - w [ i -1 ]] + v [ i -1 ]); } } } int res = dp [ N ][ W ]; for ( int i = 0 ; i <= N ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } \u300cLeetcode 416. \u5206\u5272\u7b49\u548c\u5b50\u96c6\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u4f60\u4e00\u4e2a \u53ea\u5305\u542b\u6b63\u6574\u6570 \u7684 \u975e\u7a7a \u6570\u7ec4 nums \u3002\u8bf7\u4f60\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u6570\u7ec4\u5206\u5272 \u6210\u4e24\u4e2a\u5b50\u96c6\uff0c\u4f7f\u5f97\u4e24\u4e2a\u5b50\u96c6\u7684\u5143\u7d20\u548c\u76f8\u7b49\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [1,5,11,5] \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a\u6570\u7ec4\u53ef\u4ee5\u5206\u5272\u6210 [1, 5, 5] \u548c [11] \u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [1,2,3,5] \u8f93\u51fa\uff1afalse \u89e3\u91ca\uff1a\u6570\u7ec4\u4e0d\u80fd\u5206\u5272\u6210\u4e24\u4e2a\u5143\u7d20\u548c\u76f8\u7b49\u7684\u5b50\u96c6\u3002 */ class Solution { public : bool canPartition ( vector < int >& nums ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } int sum = 0 ; for ( int & num : nums ) { sum += num ; } if ( sum % 2 == 1 ) { return false ; } int target = sum / 2 ; bool * dp = new bool [ target + 1 ]{}; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = target ; j >= nums [ i ]; j -- ) { if ( i == 0 ) { dp [ j ] = ( j == nums [ i ]); } else if ( j == 0 ) { dp [ j ] = true ; } else { dp [ j ] = dp [ j ] || dp [ j - nums [ i ]]; } } } bool ans = dp [ target ]; delete [] dp ; return ans ; } }; \u6b63\u65b9\u5f62 \u00b6 \u300cLeetcode 221. \u6700\u5927\u6b63\u65b9\u5f62\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 \u8f93\u51fa4 */ int maximalSquare ( vector < vector < char >>& matrix ) { int nRow = ( int ) matrix . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) matrix [ 0 ]. size (); if ( nCol == 0 ) { return 0 ; } vector < vector < int >> dp ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ] == '1' ) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], min ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j + 1 ])) + 1 ; } ans = max ( ans , dp [ i ][ j ] * dp [ i ][ j ]); } } return ans ; } \u300cLeetcode 1277. \u7edf\u8ba1\u5168\u4e3a 1 \u7684\u6b63\u65b9\u5f62\u5b50\u77e9\u9635\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 0 1 1 1 1 1 1 1 0 1 1 1 \u8f93\u51fa15 */ int countSquares ( vector < vector < int >>& matrix ) { int nRow = ( int ) matrix . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) matrix [ 0 ]. size (); if ( nCol == 0 ) { return 0 ; } vector < vector < int >> dp ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ]) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], min ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j + 1 ])) + 1 ; } ans += dp [ i ][ j ]; } } return ans ; } \u7f16\u8f91\u8ddd\u79bb \u00b6 \u300cLeetcode 72. \u7f16\u8f91\u8ddd\u79bb\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* \u7ed9\u4f60\u4e24\u4e2a\u5355\u8bcd word1 \u548c word2\uff0c\u8bf7\u4f60\u8ba1\u7b97\u51fa\u5c06 word1 \u8f6c\u6362\u6210 word2 \u6240\u4f7f\u7528\u7684\u6700\u5c11\u64cd\u4f5c\u6570 \u3002 \u4f60\u53ef\u4ee5\u5bf9\u4e00\u4e2a\u5355\u8bcd\u8fdb\u884c\u5982\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a \u63d2\u5165\u4e00\u4e2a\u5b57\u7b26 \u5220\u9664\u4e00\u4e2a\u5b57\u7b26 \u66ff\u6362\u4e00\u4e2a\u5b57\u7b26 \u8f93\u5165\uff1aword1 = \"horse\", word2 = \"ros\" \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a horse -> rorse (\u5c06 'h' \u66ff\u6362\u4e3a 'r') rorse -> rose (\u5220\u9664 'r') rose -> ros (\u5220\u9664 'e') */ int minDistance ( string word1 , string word2 ) { string s1 = word1 , s2 = word2 ; int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = max ( i , j ); } else { int a = dp [ i -1 ][ j ] + 1 ; int b = dp [ i ][ j -1 ] + 1 ; int c = dp [ i -1 ][ j -1 ] + ( s1 [ i -1 ] != s2 [ j -1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 35. \u6700\u5c0f\u7f16\u8f91\u4ee3\u4ef7\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u518d\u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570ic\uff0cdc\u548crc\uff0c\u5206\u522b\u4ee3\u8868\u63d2\u5165\u3001 \u5220\u9664\u548c\u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\u7684\u4ee3\u4ef7\uff0c\u8bf7\u8f93\u51fa\u5c06str1\u7f16\u8f91\u6210str2\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u793a\u4f8b1 \u8f93\u5165 \"abc\",\"adc\",5,3,2 \u8fd4\u56de\u503c 2 \u793a\u4f8b2 \u8f93\u5165 \"abc\",\"adc\",5,3,100 \u8fd4\u56de\u503c 8 */ /** * min edit cost * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @param ic int\u6574\u578b insert cost * @param dc int\u6574\u578b delete cost * @param rc int\u6574\u578b replace cost * @return int\u6574\u578b */ int minEditCost ( string str1 , string str2 , int ic , int dc , int rc ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 ) { dp [ i ][ j ] = ic * j ; } else if ( j == 0 ) { dp [ i ][ j ] = dc * i ; } else { int ist = dp [ i ][ j -1 ] + ic ; int dlt = dp [ i -1 ][ j ] + dc ; int rpl = dp [ i -1 ][ j -1 ] + rc * ( str1 [ i -1 ] != str2 [ j -1 ]); dp [ i ][ j ] = min ( ist , min ( dlt , rpl )); } } } return dp [ n1 ][ n2 ]; } \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u00b6 \u300cLeetcode 1143. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32 text1 \u548c text2\uff0c\u8fd4\u56de\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f \u516c\u5171\u5b50\u5e8f\u5217 \u7684\u957f\u5ea6\u3002\u5982\u679c\u4e0d\u5b58\u5728 \u516c\u5171\u5b50\u5e8f\u5217 \uff0c\u8fd4\u56de 0 \u3002 \u4e00\u4e2a\u5b57\u7b26\u4e32\u7684 \u5b50\u5e8f\u5217 \u662f\u6307\u8fd9\u6837\u4e00\u4e2a\u65b0\u7684\u5b57\u7b26\u4e32\uff1a\u5b83\u662f\u7531\u539f\u5b57\u7b26\u4e32\u5728\u4e0d\u6539\u53d8 \u5b57\u7b26\u7684\u76f8\u5bf9\u987a\u5e8f\u7684\u60c5\u51b5\u4e0b\u5220\u9664\u67d0\u4e9b\u5b57\u7b26\uff08\u4e5f\u53ef\u4ee5\u4e0d\u5220\u9664\u4efb\u4f55\u5b57\u7b26\uff09\u540e\u7ec4\u6210\u7684\u65b0\u5b57\u7b26\u4e32\u3002 \u4f8b\u5982\uff0c\"ace\" \u662f \"abcde\" \u7684\u5b50\u5e8f\u5217\uff0c\u4f46 \"aec\" \u4e0d\u662f \"abcde\" \u7684\u5b50\u5e8f\u5217\u3002 \u4e24\u4e2a\u5b57\u7b26\u4e32\u7684 \u516c\u5171\u5b50\u5e8f\u5217 \u662f\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\u6240\u5171\u540c\u62e5\u6709\u7684\u5b50\u5e8f\u5217\u3002 \u8f93\u5165\uff1atext1 = \"abcde\", text2 = \"ace\" \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u662f \"ace\" \uff0c\u5b83\u7684\u957f\u5ea6\u4e3a 3 \u3002 */ int longestCommonSubsequence ( string text1 , string text2 ) { string s1 = text1 , s2 = text2 ; int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i < n1 + 1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 1 ; i < n1 + 1 ; i ++ ) { for ( int j = 1 ; j < n2 + 1 ; j ++ ) { if ( s1 [ i -1 ] == s2 [ j -1 ]) { dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; } else { dp [ i ][ j ] = ( dp [ i -1 ][ j ] > dp [ i ][ j -1 ] ? dp [ i -1 ][ j ] : dp [ i ][ j -1 ]); } } } int lcs = dp [ n1 ][ n2 ]; for ( int i = 0 ; i < n1 + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return lcs ; } \u300c\u7a0b\u5e8f\u5458\u4ee3\u7801\u9762\u8bd5\u6307\u5357 31. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u8f93\u51fa\u8fde\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u8fc7\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u8f93\u5165\u63cf\u8ff0: \u8f93\u51fa\u5305\u62ec\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u4ee3\u8868\u5b57\u7b26\u4e32str1\uff0c\u7b2c\u4e8c\u884c\u4ee3\u8868str2\u3002 \u8f93\u51fa\u63cf\u8ff0: \u8f93\u51fa\u4e00\u884c\uff0c\u4ee3\u8868\u4ed6\u4eec\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u679c\u516c\u5171\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u793a\u4f8b1 \u8f93\u5165 1A2C3D4B56 B1D23CA45B6A \u8f93\u51fa 123456 \u8bf4\u660e \"123456\"\u548c\u201c12C4B6\u201d\u90fd\u662f\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u4efb\u610f\u8f93\u51fa\u4e00\u4e2a\u3002 */ #include <iostream> #include <string> #include <vector> using namespace std ; string LCS ( string s1 , string s2 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); string ans = \"\" ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( s1 [ i ] == s2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); } } } int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( s1 [ i ] == s2 [ j ]) { ans . push_back ( s1 [ i ]); i ++ ; j ++ ; } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } return dp [ 0 ][ 0 ] ? ans : \"-1\" ; } int main ( int argc , const char * argv []) { // insert code here... string s1 = \"1A2C3D4B56\" , s2 = \"B1D23CA45B6A\" ; cin >> s1 >> s2 ; printf ( \"%s \\n \" , LCS ( s1 , s2 ). c_str ()); return 0 ; } \u6700\u957f\u516c\u5171\u5b50\u4e32 \u00b6 \u300cLeetcode 718. \u6700\u957f\u91cd\u590d\u5b50\u6570\u7ec4\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* \u7ed9\u4e24\u4e2a\u6574\u6570\u6570\u7ec4 A \u548c B \uff0c\u8fd4\u56de\u4e24\u4e2a\u6570\u7ec4\u4e2d\u516c\u5171\u7684\u3001\u957f\u5ea6\u6700\u957f\u7684\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u3002 Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3, 2, 1]. */ int findLength ( vector < int >& A , vector < int >& B ) { int na = int ( A . size ()), nb = int ( B . size ()); vector < vector < int >> dp ( na + 1 , vector < int > ( nb + 1 , 0 )); int ans = 0 ; for ( int i = 1 ; i <= na ; i ++ ) { for ( int j = 1 ; j <= nb ; j ++ ) { if ( A [ i -1 ] == B [ j -1 ]) { dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; ans = max ( ans , dp [ i ][ j ]); } } } return ans ; } \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 127. \u6700\u957f\u516c\u5171\u5b50\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2,\u8f93\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32 \u9898\u76ee\u4fdd\u8bc1str1\u548cstr2\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b1 \u8f93\u5165 \"1AB2345CD\",\"12345EF\" \u8fd4\u56de\u503c \"2345\" */ class Solution { public : /** * longest common substring * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @return string\u5b57\u7b26\u4e32 */ string LCS ( string str1 , string str2 ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); int len = 1 , pos = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( str1 [ i ] == str2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; if ( len < dp [ i ][ j ]) { len = dp [ i ][ j ]; pos = i ; } } } } return str1 . substr ( pos , len ); } }; \u5e8f\u5217\u578bDP \u00b6 \u300cLeetcode 740. \u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u4f60\u53ef\u4ee5\u5bf9\u5b83\u8fdb\u884c\u4e00\u4e9b\u64cd\u4f5c\u3002 \u6bcf\u6b21\u64cd\u4f5c\u4e2d\uff0c\u9009\u62e9\u4efb\u610f\u4e00\u4e2a nums[i] \uff0c\u5220\u9664\u5b83\u5e76\u83b7\u5f97 nums[i] \u7684\u70b9\u6570\u3002 \u4e4b\u540e\uff0c\u4f60\u5fc5\u987b\u5220\u9664\u6bcf\u4e2a\u7b49\u4e8e nums[i] - 1 \u6216 nums[i] + 1 \u7684\u5143\u7d20\u3002 \u5f00\u59cb\u4f60\u62e5\u6709 0 \u4e2a\u70b9\u6570\u3002\u8fd4\u56de\u4f60\u80fd\u901a\u8fc7\u8fd9\u4e9b\u64cd\u4f5c\u83b7\u5f97\u7684\u6700\u5927\u70b9\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [3,4,2] \u8f93\u51fa\uff1a6 \u89e3\u91ca\uff1a \u5220\u9664 4 \u83b7\u5f97 4 \u4e2a\u70b9\u6570\uff0c\u56e0\u6b64 3 \u4e5f\u88ab\u5220\u9664\u3002 \u4e4b\u540e\uff0c\u5220\u9664 2 \u83b7\u5f97 2 \u4e2a\u70b9\u6570\u3002\u603b\u5171\u83b7\u5f97 6 \u4e2a\u70b9\u6570\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [2,2,3,3,3,4] \u8f93\u51fa\uff1a9 \u89e3\u91ca\uff1a \u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u63a5\u7740\u8981\u5220\u9664\u4e24\u4e2a 2 \u548c 4 \u3002 \u4e4b\u540e\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\u3002 \u603b\u5171\u83b7\u5f97 9 \u4e2a\u70b9\u6570\u3002 */ class Solution { public : int deleteAndEarn ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } map < int , int >:: iterator iter = ++ cnt . begin (); int lastN = cnt . begin () -> first , lastC = cnt . begin () -> second ; int a = 0 , b = lastN * lastC ; for (; iter != cnt . end (); iter ++ ) { int na = max ( a , b ), nb = iter -> first * iter -> second ; if ( lastN + 1 == iter -> first ) { nb += a ; } else { nb += max ( a , b ); } a = na ; b = nb ; lastN = iter -> first ; } return max ( a , b ); } }; \u68cb\u76d8\u5f62DP \u00b6 \u300cLeetcode 62. \u4e0d\u540c\u8def\u5f84\u300d \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* \u4e00\u4e2a\u673a\u5668\u4eba\u4f4d\u4e8e\u4e00\u4e2a m x n \u7f51\u683c\u7684\u5de6\u4e0a\u89d2 \uff08\u8d77\u59cb\u70b9\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a \u201cStart\u201d \uff09\u3002 \u673a\u5668\u4eba\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u6b65\u3002\u673a\u5668\u4eba\u8bd5\u56fe\u8fbe\u5230\u7f51\u683c\u7684\u53f3\u4e0b\u89d2\uff08\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a \u201cFinish\u201d \uff09\u3002 \u95ee\u603b\u5171\u6709\u591a\u5c11\u6761\u4e0d\u540c\u7684\u8def\u5f84\uff1f Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Down -> Down 2. Down -> Down -> Right 3. Down -> Right -> Down */ int uniquePaths ( int m , int n ) { int ** dp = new int * [ m ]; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] = new int [ n ]{}; } for ( int i = 0 ; i < m ; i ++ ) { dp [ i ][ 0 ] = 1 ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ][ j ] = 1 ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ i ][ j ] = dp [ i -1 ][ j ] + dp [ i ][ j -1 ]; } } int ans = dp [ m -1 ][ n -1 ]; for ( int i = 0 ; i < m ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300cLeetcode 63. \u4e0d\u540c\u8def\u5f84II\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u4e00\u4e2a\u673a\u5668\u4eba\u4f4d\u4e8e\u4e00\u4e2a m x n \u7f51\u683c\u7684\u5de6\u4e0a\u89d2 \uff08\u8d77\u59cb\u70b9\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a\u201cStart\u201d \uff09\u3002 \u673a\u5668\u4eba\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u6b65\u3002\u673a\u5668\u4eba\u8bd5\u56fe\u8fbe\u5230\u7f51\u683c\u7684\u53f3\u4e0b\u89d2\uff08\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a\u201cFinish\u201d\uff09\u3002 \u73b0\u5728\u8003\u8651\u7f51\u683c\u4e2d\u6709\u969c\u788d\u7269\u3002\u90a3\u4e48\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u5c06\u4f1a\u6709\u591a\u5c11\u6761\u4e0d\u540c\u7684\u8def\u5f84\uff1f Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right */ int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { vector < vector < int >> mat = obstacleGrid ; int m = int ( mat . size ()); if ( m == 0 ) { return 0 ; } int n = int ( mat [ 0 ]. size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ m ]; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] = new int [ n ]{}; } if ( mat [ 0 ][ 0 ]) { return 0 ; } dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { if ( mat [ i ][ 0 ]) { dp [ i ][ 0 ] = 0 ; } else { dp [ i ][ 0 ] = dp [ i -1 ][ 0 ]; } } for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ 0 ][ j ]) { dp [ 0 ][ j ] = 0 ; } else { dp [ 0 ][ j ] = dp [ 0 ][ j -1 ]; } } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ][ j ]) { dp [ i ][ j ] = 0 ; } else { dp [ i ][ j ] = dp [ i -1 ][ j ] + dp [ i ][ j -1 ]; } } } int ans = dp [ m -1 ][ n -1 ]; for ( int i = 0 ; i < m ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300cLeetcode 63. \u6700\u5c0f\u8def\u5f84\u548c\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u7ed9\u5b9a\u4e00\u4e2a\u5305\u542b\u975e\u8d1f\u6574\u6570\u7684 m x n \u7f51\u683c grid \uff0c\u8bf7\u627e\u51fa\u4e00\u6761\u4ece\u5de6\u4e0a\u89d2 \u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\uff0c\u4f7f\u5f97\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u603b\u548c\u4e3a\u6700\u5c0f\u3002 \u8bf4\u660e\uff1a\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u6b65\u3002 1 3 1 1 5 1 4 2 1 Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum. */ int minPathSum ( vector < vector < int >>& grid ) { int m = int ( grid . size ()); if ( m == 0 ) { return 0 ; } int n = int ( grid [ 0 ]. size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ m ]; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] = new int [ n ]{}; } dp [ 0 ][ 0 ] = grid [ 0 ][ 0 ]; for ( int i = 1 ; i < m ; i ++ ) { dp [ i ][ 0 ] = dp [ i -1 ][ 0 ] + grid [ i ][ 0 ]; } for ( int j = 1 ; j < n ; j ++ ) { dp [ 0 ][ j ] = dp [ 0 ][ j -1 ] + grid [ 0 ][ j ]; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ i ][ j ] = min ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]) + grid [ i ][ j ]; } } int ans = dp [ m -1 ][ n -1 ]; for ( int i = 0 ; i < m ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300c\u7a0b\u5e8f\u5458\u4ee3\u7801\u9762\u8bd5\u6307\u5357 17. \u673a\u5668\u4eba\u8fbe\u5230\u6307\u5b9a\u4f4d\u7f6e\u65b9\u6cd5\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* \u9898\u76ee\u63cf\u8ff0 \u5047\u8bbe\u6709\u6392\u6210\u4e00\u884c\u7684N\u4e2a\u4f4d\u7f6e\uff0c\u8bb0\u4e3a1~N\uff0c\u5f00\u59cb\u65f6\u673a\u5668\u4eba\u5728M\u4f4d\u7f6e\uff0c\u673a\u5668\u4eba\u53ef\u4ee5\u5f80\u5de6\u6216\u8005\u5f80\u53f3\u8d70\uff0c \u5982\u679c\u673a\u5668\u4eba\u57281\u4f4d\u7f6e\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u673a\u5668\u4eba\u53ea\u80fd\u8d70\u52302\u4f4d\u7f6e\uff0c\u5982\u679c\u673a\u5668\u4eba\u5728N\u4f4d\u7f6e\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u673a \u5668\u4eba\u53ea\u80fd\u8d70\u5230N-1\u4f4d\u7f6e\u3002\u89c4\u5b9a\u673a\u5668\u4eba\u53ea\u80fd\u8d70k\u6b65\uff0c\u6700\u7ec8\u80fd\u6765\u5230P\u4f4d\u7f6e\u7684\u65b9\u6cd5\u6709\u591a\u5c11\u79cd\u3002\u7531\u4e8e\u65b9 \u6848\u6570\u53ef\u80fd\u6bd4\u8f83\u5927\uff0c\u6240\u4ee5\u7b54\u6848\u9700\u8981\u5bf91e9+7\u53d6\u6a21\u3002 \u8f93\u5165\u63cf\u8ff0: \u8f93\u51fa\u5305\u62ec\u4e00\u884c\u56db\u4e2a\u6b63\u6574\u6570N\uff082<=N<=5000\uff09\u3001M(1<=M<=N)\u3001K(1<=K<=5000)\u3001P(1<=P<=N)\u3002 \u8f93\u51fa\u63cf\u8ff0: \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u4ee3\u8868\u6700\u7ec8\u8d70\u5230P\u7684\u65b9\u6cd5\u6570\u5bf910^9+7\u53d6\u6a21\u540e\u7684\u503c\u3002 \u793a\u4f8b1 \u8f93\u5165 \u590d\u5236 5 2 3 3 \u8f93\u51fa \u590d\u5236 3 \u8bf4\u660e 1).2->1,1->2,2->3 2).2->3,3->2,2->3 3).2->3,3->4,4->3 */ #include <iostream> #include <vector> using namespace std ; int moveRobot ( int N , int M , int K , int P ) { const int MOD = 1000000007 ; vector < vector < int >> dp ( N + 2 , vector < int > ( 2 , 0 )); dp [ M ][ 0 ] = 1 ; while ( K -- ) { for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ][ 1 ] = ( dp [ i -1 ][ 0 ] + dp [ i + 1 ][ 0 ]) % MOD ; } for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ][ 0 ] = dp [ i ][ 1 ]; } } return dp [ P ][ 1 ]; } int main ( int argc , const char * argv []) { int N = 5 , M = 2 , K = 3 , P = 3 ; scanf ( \"%d %d %d %d\" , & N , & M , & K , & P ); printf ( \"%d \\n \" , moveRobot ( N , M , K , P )); return 0 ; } \u300cLeetcode 1269. \u505c\u5728\u539f\u5730\u7684\u65b9\u6848\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* \u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a arrLen \u7684\u6570\u7ec4\uff0c\u5f00\u59cb\u6709\u4e00\u4e2a\u6307\u9488\u5728\u7d22\u5f15 0 \u5904\u3002 \u6bcf\u4e00\u6b65\u64cd\u4f5c\u4e2d\uff0c\u4f60\u53ef\u4ee5\u5c06\u6307\u9488\u5411\u5de6\u6216\u5411\u53f3\u79fb\u52a8 1 \u6b65\uff0c\u6216\u8005\u505c\u5728\u539f\u5730 \uff08\u6307\u9488\u4e0d\u80fd\u88ab\u79fb\u52a8\u5230\u6570\u7ec4\u8303\u56f4\u5916\uff09\u3002 \u7ed9\u4f60\u4e24\u4e2a\u6574\u6570 steps \u548c arrLen \uff0c\u8bf7\u4f60\u8ba1\u7b97\u5e76\u8fd4\u56de\uff1a\u5728\u6070\u597d\u6267\u884c steps \u6b21\u64cd\u4f5c\u4ee5\u540e\uff0c\u6307\u9488\u4ecd\u7136\u6307\u5411\u7d22\u5f15 0 \u5904\u7684\u65b9\u6848\u6570\u3002 \u7531\u4e8e\u7b54\u6848\u53ef\u80fd\u4f1a\u5f88\u5927\uff0c\u8bf7\u8fd4\u56de\u65b9\u6848\u6570 \u6a21 10^9 + 7 \u540e\u7684\u7ed3\u679c\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1asteps = 3, arrLen = 2 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a3 \u6b65\u540e\uff0c\u603b\u5171\u6709 4 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5411\u53f3\uff0c\u5411\u5de6\uff0c\u4e0d\u52a8 \u4e0d\u52a8\uff0c\u5411\u53f3\uff0c\u5411\u5de6 \u5411\u53f3\uff0c\u4e0d\u52a8\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8\uff0c\u4e0d\u52a8 \u793a\u4f8b 2 \u8f93\u5165\uff1asteps = 2, arrLen = 4 \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a2 \u6b65\u540e\uff0c\u603b\u5171\u6709 2 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5411\u53f3\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1asteps = 4, arrLen = 2 \u8f93\u51fa\uff1a8 */ int numWays ( int steps , int arrLen ) { const int MOD = 1000000007 ; int n = min ( arrLen , steps / 2 + 1 ); vector < int > dp ( n , 0 ); dp [ 0 ] = 1 ; while ( steps -- ) { vector < int > tmp = dp ; for ( int i = 0 ; i < n ; i ++ ) { long a = i == 0 ? 0 : tmp [ i - 1 ]; long b = i == n - 1 ? 0 : tmp [ i + 1 ]; long c = tmp [ i ]; dp [ i ] = ( a + b + c ) % MOD ; } } return dp [ 0 ]; }","title":"\u52a8\u6001\u89c4\u5212"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#1","text":"\u52a8\u6001\u89c4\u5212\uff08Dynamic programming\uff0c\u7b80\u79f0 DP\uff09\u5c06\u613f\u95ee\u9898\u62c6\u5206\u6210\u82e5\u5e72\u5b50\u95ee\u9898\uff08\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff09\uff0c\u901a\u8fc7\u5206\u522b\u6c42\u89e3\u5b50\u95ee\u9898\uff0c\u5f97\u5230\u613f\u95ee\u9898\u89e3\u7684\u4e00\u79cd\u7b97\u6cd5\u3002","title":"1. \u7b80\u4ecb"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#2","text":"\u5982\u679c\u4e00\u4e2a\u95ee\u9898\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7\u52a8\u6001\u89c4\u5212\u7684\u65b9\u6cd5\u6c42\u89e3 \u6700\u4f18\u5b50\u7ed3\u6784\uff08optimal structure\uff09 \u91cd\u53e0\u5b50\u95ee\u9898\uff08overlap subproblem\uff09","title":"2. \u8981\u7d20"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#3","text":"\uff081\uff09\u63cf\u8ff0\u6700\u4f18\u89e3\u7684\u7ed3\u6784\uff0c\u5373\u7528\u4e00\u4e2a\u72b6\u6001\u8868\u793a\u6700\u4f18\u89e3 \uff082\uff09\u4ee5\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u7684\u5f62\u5f0f\uff0c\u9012\u5f52\u5730\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \uff083\uff09\u81ea\u4e0b\u800c\u4e0a\uff08bottom-top\uff09\u6216\u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u5730\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \uff084\uff09\u6839\u636e\uff083\uff09\u4e2d\u7684\u8fc7\u7a0b\u503c\uff0c\u6784\u9020\u6700\u4f18\u89e3\uff1b\u5982\u679c\u53ea\u9700\u8981\u6700\u4f18\u89e3\u7684\u503c\uff0c\u5219\u65e0\u9700\u672c\u6b65\u9aa4","title":"3. \u8ba1\u7b97\u6b65\u9aa4"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#4","text":"\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff1a\u4fdd\u5b58\u4e86\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4e2d\u95f4\u503c\uff0c\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97 \u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u6216\u8005\u9012\u5f52\u662f\u4e00\u79cd\u5907\u5fd8\u5f55\uff08memorization\uff09\u65b9\u6cd5 \u4e25\u683c\u6765\u8bf4\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6709\u81ea\u4e0b\u800c\u4e0a\u7684\u65b9\u5f0f\uff1b\u5982\u679c\u6240\u6709\u7684\u5b50\u95ee\u9898\u90fd\u4f1a\u88ab\u8ba1\u7b97\u4e00\u6b21\uff0c\u90a3\u4e48\u52a8\u6001\u89c4\u5212\u5177\u6709\u4f18\u52bf\uff0c\u53cd\u4e4b\uff08\u526a\u679d\u60c5\u51b5\uff09\uff0c\u5907\u5fd8\u5f55\u6cd5\u5177\u6709\u4f18\u52bf","title":"4. \u52a8\u6001\u89c4\u5212\u7684\u7279\u70b9"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#5","text":"\u76f8\u540c\u70b9\uff1a\u5177\u5907\u6700\u4f18\u5b50\u7ed3\u6784 \u4e0d\u540c\u70b9\uff1a \u52a8\u6001\u89c4\u5212\u7684\u5b50\u95ee\u9898\u662f\u91cd\u53e0\u7684\uff0c\u8d2a\u5fc3\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0 \u52a8\u6001\u89c4\u5212\u4e0d\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u7684\u6027\u8d28 \u8d2a\u5fc3\u7684\u524d\u8fdb\u8def\u7ebf\u662f\u4e00\u6761\u7ebf\uff0c\u52a8\u6001\u89c4\u5212\u662f\u4e00\u4e2aDAG","title":"5. \u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5fc3\u7684\u6bd4\u8f83"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#6","text":"","title":"6. \u7ecf\u5178\u95ee\u9898"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#61","text":"","title":"6.1 \u7f16\u8f91\u8ddd\u79bb"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#611-levenshtein-distance","text":"\\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} a, b denote two strings to compare. If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 , delete a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 , insert b_{j} b_{j} at a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} , replace a_{i} a_{i} with b_{j} b_{j} \u300c\u4ee3\u7801\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 void EDprocess ( string s1 , string s2 , int i , int j , int ** dp , string str ) { if ( i == 0 && j == 0 ) { return ; } else if ( i == 0 || ( j > 0 && dp [ i ][ j ] == dp [ i ][ j -1 ] + 1 )) { string ss = str . substr ( 0 , i ); ss . push_back ( s2 [ j -1 ]); str = ss + str . substr ( i , str . length () - i ); printf ( \"insert %c: %s \\n \" , s2 [ j -1 ], str . c_str ()); EDprocess ( s1 , s2 , i , j -1 , dp , str ); } else if ( j == 0 || ( i > 0 && dp [ i ][ j ] == dp [ i -1 ][ j ] + 1 )) { string ss = str . substr ( 0 , i -1 ); str = ss + str . substr ( i , str . length () - i ); printf ( \"delete %c: %s \\n \" , s1 [ i -1 ], str . c_str ()); EDprocess ( s1 , s2 , i -1 , j , dp , str ); } else { if ( s1 [ i -1 ] != s2 [ j -1 ]) { str [ i -1 ] = s2 [ j -1 ]; printf ( \"replace %c with %c: %s \\n \" , s1 [ i -1 ], s2 [ j -1 ], str . c_str ()); } EDprocess ( s1 , s2 , i -1 , j -1 , dp , str ); } } void printDP ( string s1 , string s2 , int n1 , int n2 , int ** dp ) { for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { printf ( \"%d \\t \" , dp [ i ][ j ]); } printf ( \" \\n \" ); } printf ( \"s1 = %s \\n \" , s1 . c_str ()); EDprocess ( s1 , s2 , n1 , n2 , dp , s1 ); printf ( \"s2 = %s \\n \" , s2 . c_str ()); } int LD ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = i > j ? i : j ; } else { int a = dp [ i -1 ][ j ] + 1 ; int b = dp [ i ][ j -1 ] + 1 ; int c = dp [ i -1 ][ j -1 ] + ( s1 [ i -1 ] != s2 [ j -1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } printDP ( s1 , s2 , n1 , n2 , dp ); int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } /* 0 1 2 3 4 5 6 1 0 1 2 3 4 5 2 1 0 1 2 3 4 3 2 1 1 1 2 3 4 3 2 1 2 2 3 5 4 3 2 2 3 2 6 5 4 3 3 2 3 s1 = ecoles insert e: ecolese replace e with o: ecolose delete o: eclose s2 = eclose Edit distance = 3 */","title":"6.1.1 Levenshtein distance"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#612-damerau-levenshtein-distance","text":"\\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases}","title":"6.1.2 Damerau-Levenshtein distance"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_1","text":"\u300cLeetcode 53. \u6700\u5927\u5b50\u5e8f\u548c\u300d \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u5230\u4e00\u4e2a\u5177\u6709\u6700\u5927\u548c\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u5b50\u6570\u7ec4\u6700\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff09\uff0c\u8fd4\u56de\u5176\u6700\u5927\u548c\u3002 Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. 1 2 3 4 5 6 7 8 9 10 int maxSubArray ( vector < int >& nums ) { int n = int ( nums . size ()); int maxSum = - ( 1l l << 31 ), curSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; } if ( curSum > maxSum ) { maxSum = curSum ; } } return maxSum ; } \u300c\u6700\u5927\u548c\u7684\u5b50\u6570\u7ec4\u300d \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u5230\u4e00\u4e2a\u5177\u6709\u6700\u5927\u548c\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u5b50\u6570\u7ec4\u6700\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff09\uff0c\u8fd4\u56de\u5176\u6700\u5927\u548c\u3002 Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: [4,-1,2,1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 vector < int > getMaxSumEpisode ( vector < int > nums ) { // vector<int> nums {1, 2, -1, 3}; int n = int ( nums . size ()); vector < int > ans ; if ( n == 0 ) { return ans ; } int maxSum = - ( 1l l << 31 ), curSum = 0 ; int left = 0 , right = 0 , begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; begin = i ; } if ( maxSum < curSum ) { maxSum = curSum ; left = begin ; right = i ; } } for ( int i = left ; i <= right ; i ++ ) { ans . push_back ( nums [ i ]); } return ans ; } \u300cLeetcode 152. \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4\u300d Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. 1 2 3 4 5 6 7 8 9 10 11 int maxProduct ( vector < int >& nums ) { int n = int ( nums . size ()); int minF = nums [ 0 ], maxF = nums [ 0 ], ans = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _min = minF , _max = maxF ; minF = min ( nums [ i ], min ( _min * nums [ i ], _max * nums [ i ])); maxF = max ( nums [ i ], max ( _min * nums [ i ], _max * nums [ i ])); ans = max ( ans , maxF ); } return ans ; } \u300cLeetcode 1186. \u5220\u9664\u4e00\u6b21\u5f97\u5230\u5b50\u6570\u7ec4\u6700\u5927\u548c\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u67d0\u4e2a \u975e\u7a7a \u5b50\u6570\u7ec4\uff08\u8fde\u7eed\u5143\u7d20\uff09\u5728\u6267\u884c\u4e00\u6b21\u53ef\u9009\u7684\u5220\u9664\u64cd\u4f5c\u540e\uff0c\u6240\u80fd\u5f97\u5230 \u7684\u6700\u5927\u5143\u7d20\u603b\u548c\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u53ef\u4ee5\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u51fa\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5e76\u53ef\u4ee5\u51b3\u5b9a\u8981\u4e0d\u8981\u4ece\u4e2d\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff08\u53ea\u80fd\u5220\u4e00\u6b21\u54e6\uff09\uff0c \uff08\u5220\u9664\u540e\uff09\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5e94\u5f53\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8be5\u5b50\u6570\u7ec4\uff08\u5269\u4e0b\uff09\u7684\u5143\u7d20\u603b\u548c\u662f\u6240\u6709\u5b50\u6570\u7ec4\u4e4b\u4e2d\u6700\u5927\u7684\u3002 \u6ce8\u610f\uff0c\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u5b50\u6570\u7ec4 \u4e0d\u80fd\u4e3a\u7a7a\u3002 \u8bf7\u770b\u793a\u4f8b\uff1a \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aarr = [1,-2,0,3] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u6211\u4eec\u53ef\u4ee5\u9009\u51fa [1, -2, 0, 3]\uff0c\u7136\u540e\u5220\u6389 -2\uff0c\u8fd9\u6837\u5f97\u5230 [1, 0, 3]\uff0c\u548c\u6700\u5927\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aarr = [1,-2,-2,3] \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u6211\u4eec\u76f4\u63a5\u9009\u51fa [3]\uff0c\u8fd9\u5c31\u662f\u6700\u5927\u548c\u3002 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1aarr = [-1,-1,-1,-1] \u8f93\u51fa\uff1a-1 \u89e3\u91ca\uff1a\u6700\u540e\u5f97\u5230\u7684\u5b50\u6570\u7ec4\u4e0d\u80fd\u4e3a\u7a7a\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u9009\u62e9 [-1] \u5e76\u4ece\u4e2d\u5220\u53bb -1 \u6765\u5f97\u5230 0\u3002 \u6211\u4eec\u5e94\u8be5\u76f4\u63a5\u9009\u62e9 [-1]\uff0c\u6216\u8005\u9009\u62e9 [-1, -1] \u518d\u4ece\u4e2d\u5220\u53bb\u4e00\u4e2a -1\u3002 */ class Solution { public : int maximumSum ( vector < int >& arr ) { int n = ( int ) arr . size (); if ( n == 0 ) { return 0 ; } const int minEle = * min_element ( arr . begin (), arr . end ()); int dp0 = arr [ 0 ], dp1 = minEle , ans = dp0 ; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 + arr [ i ], arr [ i ]); int tmp1 = max ( dp0 , dp1 + arr [ i ]); dp0 = tmp0 ; dp1 = tmp1 ; ans = max ( ans , max ( dp0 , dp1 )); } return ans ; } }; \u300c\u6700\u957f01\u7b49\u91cf\u5b50\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int getLongest01SubstrLen ( string str ) { //str = \"0010011001001010110\", ans = 16 int len = 0 , n = ( int ) str . length (); vector < int > dp ( n + 1 , 0 ); unordered_map < int , int > dict ; dict [ 0 ] = n ; int pos = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { dp [ i ] = dp [ i + 1 ] + 1 ; } else { dp [ i ] = dp [ i + 1 ] - 1 ; } if ( dict . find ( dp [ i ]) != dict . end ()) { len = max ( len , dict [ dp [ i ]] - i ); pos = i ; } else { dict [ dp [ i ]] = i ; } } printf ( \"maxLenSubstr = %s \\n \" , str . substr ( pos , len ). c_str ()); return len ; }","title":"\u8fde\u7eed\u5b50\u6570\u7ec4\u6700\u5927\u548c\u3001\u6700\u5927\u79ef"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_2","text":"\u300c01\u80cc\u5305\u300d \u4e00\u4e2a\u80cc\u5305\u6709\u4e00\u5b9a\u7684\u627f\u91cdcap\uff0c\u6709N\u4ef6\u7269\u54c1\uff0c\u6bcf\u4ef6\u90fd\u6709\u81ea\u5df1\u7684\u4ef7\u503c\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4v\u4e2d\uff0c\u4e5f\u90fd\u6709\u81ea\u5df1\u7684\u91cd\u91cf\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4w\u4e2d\uff0c\u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u9009\u62e9\u8981\u88c5\u5165\u80cc\u5305\u8fd8\u662f\u4e0d\u88c5\u5165\u80cc\u5305\uff0c\u8981\u6c42\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u7684\u524d\u63d0\u4e0b\uff0c\u9009\u51fa\u7269\u54c1\u7684\u603b\u4ef7\u503c\u6700\u5927\u3002\u7ed9\u5b9a\u7269\u54c1\u7684\u91cd\u91cfw\u4ef7\u503cv\u53ca\u7269\u54c1\u6570n\u548c\u627f\u91cdcap\u3002\u8bf7\u8fd4\u56de\u6700\u5927\u603b\u4ef7\u503c\u3002 \u6d4b\u8bd5\u6837\u4f8b\uff1a [1,2,3],[1,2,3],3,6 \u8fd4\u56de\uff1a6 \u52a8\u6001\u89c4\u5212\uff1adp[i][j]\u8868\u793a\u524di\u4ef6\u7269\u54c1\u5728\u6700\u5927\u91cd\u91cfj\u7684\u6761\u4ef6\u4e0b\u7684\u4ef7\u503c dp[i][j] =\\max \\begin{cases} dp[i-1]][j], &\\quad \\text{we don't put i-th item in our bag} \\\\ dp[i-1][j - w[i-1]], &\\quad \\text{otherwise, but } j > w[i-1], i = 1, 2, ..., N \\end{cases} dp[i][j] =\\max \\begin{cases} dp[i-1]][j], &\\quad \\text{we don't put i-th item in our bag} \\\\ dp[i-1][j - w[i-1]], &\\quad \\text{otherwise, but } j > w[i-1], i = 1, 2, ..., N \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* * * v[]: value for each item * w[]: weight for each item * W: capacity limit * N: number of item */ int knapsack ( int v [], int w [], int W , int N ) { int ** dp = new int * [ N + 1 ]; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = new int [ W + 1 ]{}; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( j < w [ i -1 ]) { dp [ i ][ j ] = dp [ i -1 ][ j ]; } else { dp [ i ][ j ] = max ( dp [ i -1 ][ j ], dp [ i -1 ][ j - w [ i -1 ]] + v [ i -1 ]); } } } int res = dp [ N ][ W ]; for ( int i = 0 ; i <= N ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } \u300cLeetcode 416. \u5206\u5272\u7b49\u548c\u5b50\u96c6\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u4f60\u4e00\u4e2a \u53ea\u5305\u542b\u6b63\u6574\u6570 \u7684 \u975e\u7a7a \u6570\u7ec4 nums \u3002\u8bf7\u4f60\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u6570\u7ec4\u5206\u5272 \u6210\u4e24\u4e2a\u5b50\u96c6\uff0c\u4f7f\u5f97\u4e24\u4e2a\u5b50\u96c6\u7684\u5143\u7d20\u548c\u76f8\u7b49\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [1,5,11,5] \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a\u6570\u7ec4\u53ef\u4ee5\u5206\u5272\u6210 [1, 5, 5] \u548c [11] \u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [1,2,3,5] \u8f93\u51fa\uff1afalse \u89e3\u91ca\uff1a\u6570\u7ec4\u4e0d\u80fd\u5206\u5272\u6210\u4e24\u4e2a\u5143\u7d20\u548c\u76f8\u7b49\u7684\u5b50\u96c6\u3002 */ class Solution { public : bool canPartition ( vector < int >& nums ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } int sum = 0 ; for ( int & num : nums ) { sum += num ; } if ( sum % 2 == 1 ) { return false ; } int target = sum / 2 ; bool * dp = new bool [ target + 1 ]{}; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = target ; j >= nums [ i ]; j -- ) { if ( i == 0 ) { dp [ j ] = ( j == nums [ i ]); } else if ( j == 0 ) { dp [ j ] = true ; } else { dp [ j ] = dp [ j ] || dp [ j - nums [ i ]]; } } } bool ans = dp [ target ]; delete [] dp ; return ans ; } };","title":"\u80cc\u5305\u95ee\u9898"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_3","text":"\u300cLeetcode 221. \u6700\u5927\u6b63\u65b9\u5f62\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 \u8f93\u51fa4 */ int maximalSquare ( vector < vector < char >>& matrix ) { int nRow = ( int ) matrix . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) matrix [ 0 ]. size (); if ( nCol == 0 ) { return 0 ; } vector < vector < int >> dp ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ] == '1' ) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], min ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j + 1 ])) + 1 ; } ans = max ( ans , dp [ i ][ j ] * dp [ i ][ j ]); } } return ans ; } \u300cLeetcode 1277. \u7edf\u8ba1\u5168\u4e3a 1 \u7684\u6b63\u65b9\u5f62\u5b50\u77e9\u9635\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 0 1 1 1 1 1 1 1 0 1 1 1 \u8f93\u51fa15 */ int countSquares ( vector < vector < int >>& matrix ) { int nRow = ( int ) matrix . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) matrix [ 0 ]. size (); if ( nCol == 0 ) { return 0 ; } vector < vector < int >> dp ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ]) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], min ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j + 1 ])) + 1 ; } ans += dp [ i ][ j ]; } } return ans ; }","title":"\u6b63\u65b9\u5f62"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_4","text":"\u300cLeetcode 72. \u7f16\u8f91\u8ddd\u79bb\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* \u7ed9\u4f60\u4e24\u4e2a\u5355\u8bcd word1 \u548c word2\uff0c\u8bf7\u4f60\u8ba1\u7b97\u51fa\u5c06 word1 \u8f6c\u6362\u6210 word2 \u6240\u4f7f\u7528\u7684\u6700\u5c11\u64cd\u4f5c\u6570 \u3002 \u4f60\u53ef\u4ee5\u5bf9\u4e00\u4e2a\u5355\u8bcd\u8fdb\u884c\u5982\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a \u63d2\u5165\u4e00\u4e2a\u5b57\u7b26 \u5220\u9664\u4e00\u4e2a\u5b57\u7b26 \u66ff\u6362\u4e00\u4e2a\u5b57\u7b26 \u8f93\u5165\uff1aword1 = \"horse\", word2 = \"ros\" \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a horse -> rorse (\u5c06 'h' \u66ff\u6362\u4e3a 'r') rorse -> rose (\u5220\u9664 'r') rose -> ros (\u5220\u9664 'e') */ int minDistance ( string word1 , string word2 ) { string s1 = word1 , s2 = word2 ; int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = max ( i , j ); } else { int a = dp [ i -1 ][ j ] + 1 ; int b = dp [ i ][ j -1 ] + 1 ; int c = dp [ i -1 ][ j -1 ] + ( s1 [ i -1 ] != s2 [ j -1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 35. \u6700\u5c0f\u7f16\u8f91\u4ee3\u4ef7\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u518d\u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570ic\uff0cdc\u548crc\uff0c\u5206\u522b\u4ee3\u8868\u63d2\u5165\u3001 \u5220\u9664\u548c\u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\u7684\u4ee3\u4ef7\uff0c\u8bf7\u8f93\u51fa\u5c06str1\u7f16\u8f91\u6210str2\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u793a\u4f8b1 \u8f93\u5165 \"abc\",\"adc\",5,3,2 \u8fd4\u56de\u503c 2 \u793a\u4f8b2 \u8f93\u5165 \"abc\",\"adc\",5,3,100 \u8fd4\u56de\u503c 8 */ /** * min edit cost * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @param ic int\u6574\u578b insert cost * @param dc int\u6574\u578b delete cost * @param rc int\u6574\u578b replace cost * @return int\u6574\u578b */ int minEditCost ( string str1 , string str2 , int ic , int dc , int rc ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 ) { dp [ i ][ j ] = ic * j ; } else if ( j == 0 ) { dp [ i ][ j ] = dc * i ; } else { int ist = dp [ i ][ j -1 ] + ic ; int dlt = dp [ i -1 ][ j ] + dc ; int rpl = dp [ i -1 ][ j -1 ] + rc * ( str1 [ i -1 ] != str2 [ j -1 ]); dp [ i ][ j ] = min ( ist , min ( dlt , rpl )); } } } return dp [ n1 ][ n2 ]; }","title":"\u7f16\u8f91\u8ddd\u79bb"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_5","text":"\u300cLeetcode 1143. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32 text1 \u548c text2\uff0c\u8fd4\u56de\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f \u516c\u5171\u5b50\u5e8f\u5217 \u7684\u957f\u5ea6\u3002\u5982\u679c\u4e0d\u5b58\u5728 \u516c\u5171\u5b50\u5e8f\u5217 \uff0c\u8fd4\u56de 0 \u3002 \u4e00\u4e2a\u5b57\u7b26\u4e32\u7684 \u5b50\u5e8f\u5217 \u662f\u6307\u8fd9\u6837\u4e00\u4e2a\u65b0\u7684\u5b57\u7b26\u4e32\uff1a\u5b83\u662f\u7531\u539f\u5b57\u7b26\u4e32\u5728\u4e0d\u6539\u53d8 \u5b57\u7b26\u7684\u76f8\u5bf9\u987a\u5e8f\u7684\u60c5\u51b5\u4e0b\u5220\u9664\u67d0\u4e9b\u5b57\u7b26\uff08\u4e5f\u53ef\u4ee5\u4e0d\u5220\u9664\u4efb\u4f55\u5b57\u7b26\uff09\u540e\u7ec4\u6210\u7684\u65b0\u5b57\u7b26\u4e32\u3002 \u4f8b\u5982\uff0c\"ace\" \u662f \"abcde\" \u7684\u5b50\u5e8f\u5217\uff0c\u4f46 \"aec\" \u4e0d\u662f \"abcde\" \u7684\u5b50\u5e8f\u5217\u3002 \u4e24\u4e2a\u5b57\u7b26\u4e32\u7684 \u516c\u5171\u5b50\u5e8f\u5217 \u662f\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\u6240\u5171\u540c\u62e5\u6709\u7684\u5b50\u5e8f\u5217\u3002 \u8f93\u5165\uff1atext1 = \"abcde\", text2 = \"ace\" \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u662f \"ace\" \uff0c\u5b83\u7684\u957f\u5ea6\u4e3a 3 \u3002 */ int longestCommonSubsequence ( string text1 , string text2 ) { string s1 = text1 , s2 = text2 ; int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i < n1 + 1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 1 ; i < n1 + 1 ; i ++ ) { for ( int j = 1 ; j < n2 + 1 ; j ++ ) { if ( s1 [ i -1 ] == s2 [ j -1 ]) { dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; } else { dp [ i ][ j ] = ( dp [ i -1 ][ j ] > dp [ i ][ j -1 ] ? dp [ i -1 ][ j ] : dp [ i ][ j -1 ]); } } } int lcs = dp [ n1 ][ n2 ]; for ( int i = 0 ; i < n1 + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return lcs ; } \u300c\u7a0b\u5e8f\u5458\u4ee3\u7801\u9762\u8bd5\u6307\u5357 31. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u8f93\u51fa\u8fde\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u8fc7\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u8f93\u5165\u63cf\u8ff0: \u8f93\u51fa\u5305\u62ec\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u4ee3\u8868\u5b57\u7b26\u4e32str1\uff0c\u7b2c\u4e8c\u884c\u4ee3\u8868str2\u3002 \u8f93\u51fa\u63cf\u8ff0: \u8f93\u51fa\u4e00\u884c\uff0c\u4ee3\u8868\u4ed6\u4eec\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u679c\u516c\u5171\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u793a\u4f8b1 \u8f93\u5165 1A2C3D4B56 B1D23CA45B6A \u8f93\u51fa 123456 \u8bf4\u660e \"123456\"\u548c\u201c12C4B6\u201d\u90fd\u662f\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u4efb\u610f\u8f93\u51fa\u4e00\u4e2a\u3002 */ #include <iostream> #include <string> #include <vector> using namespace std ; string LCS ( string s1 , string s2 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); string ans = \"\" ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( s1 [ i ] == s2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); } } } int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( s1 [ i ] == s2 [ j ]) { ans . push_back ( s1 [ i ]); i ++ ; j ++ ; } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } return dp [ 0 ][ 0 ] ? ans : \"-1\" ; } int main ( int argc , const char * argv []) { // insert code here... string s1 = \"1A2C3D4B56\" , s2 = \"B1D23CA45B6A\" ; cin >> s1 >> s2 ; printf ( \"%s \\n \" , LCS ( s1 , s2 ). c_str ()); return 0 ; }","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#_6","text":"\u300cLeetcode 718. \u6700\u957f\u91cd\u590d\u5b50\u6570\u7ec4\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* \u7ed9\u4e24\u4e2a\u6574\u6570\u6570\u7ec4 A \u548c B \uff0c\u8fd4\u56de\u4e24\u4e2a\u6570\u7ec4\u4e2d\u516c\u5171\u7684\u3001\u957f\u5ea6\u6700\u957f\u7684\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u3002 Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3, 2, 1]. */ int findLength ( vector < int >& A , vector < int >& B ) { int na = int ( A . size ()), nb = int ( B . size ()); vector < vector < int >> dp ( na + 1 , vector < int > ( nb + 1 , 0 )); int ans = 0 ; for ( int i = 1 ; i <= na ; i ++ ) { for ( int j = 1 ; j <= nb ; j ++ ) { if ( A [ i -1 ] == B [ j -1 ]) { dp [ i ][ j ] = dp [ i -1 ][ j -1 ] + 1 ; ans = max ( ans , dp [ i ][ j ]); } } } return ans ; } \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 127. \u6700\u957f\u516c\u5171\u5b50\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2,\u8f93\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32 \u9898\u76ee\u4fdd\u8bc1str1\u548cstr2\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b1 \u8f93\u5165 \"1AB2345CD\",\"12345EF\" \u8fd4\u56de\u503c \"2345\" */ class Solution { public : /** * longest common substring * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @return string\u5b57\u7b26\u4e32 */ string LCS ( string str1 , string str2 ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); int len = 1 , pos = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( str1 [ i ] == str2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; if ( len < dp [ i ][ j ]) { len = dp [ i ][ j ]; pos = i ; } } } } return str1 . substr ( pos , len ); } };","title":"\u6700\u957f\u516c\u5171\u5b50\u4e32"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#dp","text":"\u300cLeetcode 740. \u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u4f60\u53ef\u4ee5\u5bf9\u5b83\u8fdb\u884c\u4e00\u4e9b\u64cd\u4f5c\u3002 \u6bcf\u6b21\u64cd\u4f5c\u4e2d\uff0c\u9009\u62e9\u4efb\u610f\u4e00\u4e2a nums[i] \uff0c\u5220\u9664\u5b83\u5e76\u83b7\u5f97 nums[i] \u7684\u70b9\u6570\u3002 \u4e4b\u540e\uff0c\u4f60\u5fc5\u987b\u5220\u9664\u6bcf\u4e2a\u7b49\u4e8e nums[i] - 1 \u6216 nums[i] + 1 \u7684\u5143\u7d20\u3002 \u5f00\u59cb\u4f60\u62e5\u6709 0 \u4e2a\u70b9\u6570\u3002\u8fd4\u56de\u4f60\u80fd\u901a\u8fc7\u8fd9\u4e9b\u64cd\u4f5c\u83b7\u5f97\u7684\u6700\u5927\u70b9\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [3,4,2] \u8f93\u51fa\uff1a6 \u89e3\u91ca\uff1a \u5220\u9664 4 \u83b7\u5f97 4 \u4e2a\u70b9\u6570\uff0c\u56e0\u6b64 3 \u4e5f\u88ab\u5220\u9664\u3002 \u4e4b\u540e\uff0c\u5220\u9664 2 \u83b7\u5f97 2 \u4e2a\u70b9\u6570\u3002\u603b\u5171\u83b7\u5f97 6 \u4e2a\u70b9\u6570\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [2,2,3,3,3,4] \u8f93\u51fa\uff1a9 \u89e3\u91ca\uff1a \u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u63a5\u7740\u8981\u5220\u9664\u4e24\u4e2a 2 \u548c 4 \u3002 \u4e4b\u540e\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\u3002 \u603b\u5171\u83b7\u5f97 9 \u4e2a\u70b9\u6570\u3002 */ class Solution { public : int deleteAndEarn ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } map < int , int >:: iterator iter = ++ cnt . begin (); int lastN = cnt . begin () -> first , lastC = cnt . begin () -> second ; int a = 0 , b = lastN * lastC ; for (; iter != cnt . end (); iter ++ ) { int na = max ( a , b ), nb = iter -> first * iter -> second ; if ( lastN + 1 == iter -> first ) { nb += a ; } else { nb += max ( a , b ); } a = na ; b = nb ; lastN = iter -> first ; } return max ( a , b ); } };","title":"\u5e8f\u5217\u578bDP"},{"location":"algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#dp_1","text":"\u300cLeetcode 62. \u4e0d\u540c\u8def\u5f84\u300d \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* \u4e00\u4e2a\u673a\u5668\u4eba\u4f4d\u4e8e\u4e00\u4e2a m x n \u7f51\u683c\u7684\u5de6\u4e0a\u89d2 \uff08\u8d77\u59cb\u70b9\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a \u201cStart\u201d \uff09\u3002 \u673a\u5668\u4eba\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u6b65\u3002\u673a\u5668\u4eba\u8bd5\u56fe\u8fbe\u5230\u7f51\u683c\u7684\u53f3\u4e0b\u89d2\uff08\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a \u201cFinish\u201d \uff09\u3002 \u95ee\u603b\u5171\u6709\u591a\u5c11\u6761\u4e0d\u540c\u7684\u8def\u5f84\uff1f Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Down -> Down 2. Down -> Down -> Right 3. Down -> Right -> Down */ int uniquePaths ( int m , int n ) { int ** dp = new int * [ m ]; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] = new int [ n ]{}; } for ( int i = 0 ; i < m ; i ++ ) { dp [ i ][ 0 ] = 1 ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ][ j ] = 1 ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ i ][ j ] = dp [ i -1 ][ j ] + dp [ i ][ j -1 ]; } } int ans = dp [ m -1 ][ n -1 ]; for ( int i = 0 ; i < m ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300cLeetcode 63. \u4e0d\u540c\u8def\u5f84II\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u4e00\u4e2a\u673a\u5668\u4eba\u4f4d\u4e8e\u4e00\u4e2a m x n \u7f51\u683c\u7684\u5de6\u4e0a\u89d2 \uff08\u8d77\u59cb\u70b9\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a\u201cStart\u201d \uff09\u3002 \u673a\u5668\u4eba\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u6b65\u3002\u673a\u5668\u4eba\u8bd5\u56fe\u8fbe\u5230\u7f51\u683c\u7684\u53f3\u4e0b\u89d2\uff08\u5728\u4e0b\u56fe\u4e2d\u6807\u8bb0\u4e3a\u201cFinish\u201d\uff09\u3002 \u73b0\u5728\u8003\u8651\u7f51\u683c\u4e2d\u6709\u969c\u788d\u7269\u3002\u90a3\u4e48\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u5c06\u4f1a\u6709\u591a\u5c11\u6761\u4e0d\u540c\u7684\u8def\u5f84\uff1f Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right */ int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { vector < vector < int >> mat = obstacleGrid ; int m = int ( mat . size ()); if ( m == 0 ) { return 0 ; } int n = int ( mat [ 0 ]. size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ m ]; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] = new int [ n ]{}; } if ( mat [ 0 ][ 0 ]) { return 0 ; } dp [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { if ( mat [ i ][ 0 ]) { dp [ i ][ 0 ] = 0 ; } else { dp [ i ][ 0 ] = dp [ i -1 ][ 0 ]; } } for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ 0 ][ j ]) { dp [ 0 ][ j ] = 0 ; } else { dp [ 0 ][ j ] = dp [ 0 ][ j -1 ]; } } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ][ j ]) { dp [ i ][ j ] = 0 ; } else { dp [ i ][ j ] = dp [ i -1 ][ j ] + dp [ i ][ j -1 ]; } } } int ans = dp [ m -1 ][ n -1 ]; for ( int i = 0 ; i < m ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300cLeetcode 63. \u6700\u5c0f\u8def\u5f84\u548c\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u7ed9\u5b9a\u4e00\u4e2a\u5305\u542b\u975e\u8d1f\u6574\u6570\u7684 m x n \u7f51\u683c grid \uff0c\u8bf7\u627e\u51fa\u4e00\u6761\u4ece\u5de6\u4e0a\u89d2 \u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\uff0c\u4f7f\u5f97\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u603b\u548c\u4e3a\u6700\u5c0f\u3002 \u8bf4\u660e\uff1a\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u6b65\u3002 1 3 1 1 5 1 4 2 1 Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum. */ int minPathSum ( vector < vector < int >>& grid ) { int m = int ( grid . size ()); if ( m == 0 ) { return 0 ; } int n = int ( grid [ 0 ]. size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ m ]; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] = new int [ n ]{}; } dp [ 0 ][ 0 ] = grid [ 0 ][ 0 ]; for ( int i = 1 ; i < m ; i ++ ) { dp [ i ][ 0 ] = dp [ i -1 ][ 0 ] + grid [ i ][ 0 ]; } for ( int j = 1 ; j < n ; j ++ ) { dp [ 0 ][ j ] = dp [ 0 ][ j -1 ] + grid [ 0 ][ j ]; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ i ][ j ] = min ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]) + grid [ i ][ j ]; } } int ans = dp [ m -1 ][ n -1 ]; for ( int i = 0 ; i < m ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } \u300c\u7a0b\u5e8f\u5458\u4ee3\u7801\u9762\u8bd5\u6307\u5357 17. \u673a\u5668\u4eba\u8fbe\u5230\u6307\u5b9a\u4f4d\u7f6e\u65b9\u6cd5\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* \u9898\u76ee\u63cf\u8ff0 \u5047\u8bbe\u6709\u6392\u6210\u4e00\u884c\u7684N\u4e2a\u4f4d\u7f6e\uff0c\u8bb0\u4e3a1~N\uff0c\u5f00\u59cb\u65f6\u673a\u5668\u4eba\u5728M\u4f4d\u7f6e\uff0c\u673a\u5668\u4eba\u53ef\u4ee5\u5f80\u5de6\u6216\u8005\u5f80\u53f3\u8d70\uff0c \u5982\u679c\u673a\u5668\u4eba\u57281\u4f4d\u7f6e\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u673a\u5668\u4eba\u53ea\u80fd\u8d70\u52302\u4f4d\u7f6e\uff0c\u5982\u679c\u673a\u5668\u4eba\u5728N\u4f4d\u7f6e\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u673a \u5668\u4eba\u53ea\u80fd\u8d70\u5230N-1\u4f4d\u7f6e\u3002\u89c4\u5b9a\u673a\u5668\u4eba\u53ea\u80fd\u8d70k\u6b65\uff0c\u6700\u7ec8\u80fd\u6765\u5230P\u4f4d\u7f6e\u7684\u65b9\u6cd5\u6709\u591a\u5c11\u79cd\u3002\u7531\u4e8e\u65b9 \u6848\u6570\u53ef\u80fd\u6bd4\u8f83\u5927\uff0c\u6240\u4ee5\u7b54\u6848\u9700\u8981\u5bf91e9+7\u53d6\u6a21\u3002 \u8f93\u5165\u63cf\u8ff0: \u8f93\u51fa\u5305\u62ec\u4e00\u884c\u56db\u4e2a\u6b63\u6574\u6570N\uff082<=N<=5000\uff09\u3001M(1<=M<=N)\u3001K(1<=K<=5000)\u3001P(1<=P<=N)\u3002 \u8f93\u51fa\u63cf\u8ff0: \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u4ee3\u8868\u6700\u7ec8\u8d70\u5230P\u7684\u65b9\u6cd5\u6570\u5bf910^9+7\u53d6\u6a21\u540e\u7684\u503c\u3002 \u793a\u4f8b1 \u8f93\u5165 \u590d\u5236 5 2 3 3 \u8f93\u51fa \u590d\u5236 3 \u8bf4\u660e 1).2->1,1->2,2->3 2).2->3,3->2,2->3 3).2->3,3->4,4->3 */ #include <iostream> #include <vector> using namespace std ; int moveRobot ( int N , int M , int K , int P ) { const int MOD = 1000000007 ; vector < vector < int >> dp ( N + 2 , vector < int > ( 2 , 0 )); dp [ M ][ 0 ] = 1 ; while ( K -- ) { for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ][ 1 ] = ( dp [ i -1 ][ 0 ] + dp [ i + 1 ][ 0 ]) % MOD ; } for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ][ 0 ] = dp [ i ][ 1 ]; } } return dp [ P ][ 1 ]; } int main ( int argc , const char * argv []) { int N = 5 , M = 2 , K = 3 , P = 3 ; scanf ( \"%d %d %d %d\" , & N , & M , & K , & P ); printf ( \"%d \\n \" , moveRobot ( N , M , K , P )); return 0 ; } \u300cLeetcode 1269. \u505c\u5728\u539f\u5730\u7684\u65b9\u6848\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* \u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a arrLen \u7684\u6570\u7ec4\uff0c\u5f00\u59cb\u6709\u4e00\u4e2a\u6307\u9488\u5728\u7d22\u5f15 0 \u5904\u3002 \u6bcf\u4e00\u6b65\u64cd\u4f5c\u4e2d\uff0c\u4f60\u53ef\u4ee5\u5c06\u6307\u9488\u5411\u5de6\u6216\u5411\u53f3\u79fb\u52a8 1 \u6b65\uff0c\u6216\u8005\u505c\u5728\u539f\u5730 \uff08\u6307\u9488\u4e0d\u80fd\u88ab\u79fb\u52a8\u5230\u6570\u7ec4\u8303\u56f4\u5916\uff09\u3002 \u7ed9\u4f60\u4e24\u4e2a\u6574\u6570 steps \u548c arrLen \uff0c\u8bf7\u4f60\u8ba1\u7b97\u5e76\u8fd4\u56de\uff1a\u5728\u6070\u597d\u6267\u884c steps \u6b21\u64cd\u4f5c\u4ee5\u540e\uff0c\u6307\u9488\u4ecd\u7136\u6307\u5411\u7d22\u5f15 0 \u5904\u7684\u65b9\u6848\u6570\u3002 \u7531\u4e8e\u7b54\u6848\u53ef\u80fd\u4f1a\u5f88\u5927\uff0c\u8bf7\u8fd4\u56de\u65b9\u6848\u6570 \u6a21 10^9 + 7 \u540e\u7684\u7ed3\u679c\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1asteps = 3, arrLen = 2 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a3 \u6b65\u540e\uff0c\u603b\u5171\u6709 4 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5411\u53f3\uff0c\u5411\u5de6\uff0c\u4e0d\u52a8 \u4e0d\u52a8\uff0c\u5411\u53f3\uff0c\u5411\u5de6 \u5411\u53f3\uff0c\u4e0d\u52a8\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8\uff0c\u4e0d\u52a8 \u793a\u4f8b 2 \u8f93\u5165\uff1asteps = 2, arrLen = 4 \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a2 \u6b65\u540e\uff0c\u603b\u5171\u6709 2 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5411\u53f3\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1asteps = 4, arrLen = 2 \u8f93\u51fa\uff1a8 */ int numWays ( int steps , int arrLen ) { const int MOD = 1000000007 ; int n = min ( arrLen , steps / 2 + 1 ); vector < int > dp ( n , 0 ); dp [ 0 ] = 1 ; while ( steps -- ) { vector < int > tmp = dp ; for ( int i = 0 ; i < n ; i ++ ) { long a = i == 0 ? 0 : tmp [ i - 1 ]; long b = i == n - 1 ? 0 : tmp [ i + 1 ]; long c = tmp [ i ]; dp [ i ] = ( a + b + c ) % MOD ; } } return dp [ 0 ]; }","title":"\u68cb\u76d8\u5f62DP"},{"location":"data-structure/string/match/","text":"1. KMP \u00b6 KMP\u8bb2\u6c42\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u5339\u914d\uff0c\u5f53\u51fa\u73b0\u8bef\u5339\u914d\u7684\u5b57\u7b26\u65f6\uff0c\u5c06\u6a21\u5f0f\u4e32P\u5411\u53f3\u79fb\u52a8\u82e5\u5e72\u8ddd\u79bb\u3002KMP\u501f\u52a9P\u7684\u524d\u7f00\uff08\u5386\u53f2\u5339\u914d\u4fe1\u606f\uff09\u6784\u5efanext\u6570\u7ec4\u3002\u5c06P\u524d\u7f00\u4e2d\u4e0e\u5931\u914d\u5b57\u7b26\u524d\u6700\u5927\u91cd\u5408\u7684\u4f4d\u7f6e\u5bf9\u9f50\u3002P\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u53d1\u751f\u5931\u914d\u65f6\uff0c\u5bf9\u5e94\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u8be5\u662f-1\uff0c\u8868\u793a\u5c06\u6574\u4e2aP\u79fb\u52a8\u5230\u5931\u914d\u5b57\u7b26\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002 \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \u4e3a\u4e86\u66f4\u52a0\u9ad8\u6548\u5730\u79fb\u52a8P\uff0cnext\u6570\u7ec4\u8868\u793a\u5730\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u5f53\u5c3d\u53ef\u80fd\u5730\u5c0f \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) , \u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0cm\u662fP\u7684\u957f\u5ea6\uff0cn\u662fT\u7684\u957f\u5ea6 \u300cLeetcode 28. \u5b9e\u73b0 strStr()\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahaystack = \"hello\", needle = \"ll\" \u8f93\u51fa\uff1a2 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahaystack = \"aaaaa\", needle = \"bba\" \u8f93\u51fa\uff1a-1 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahaystack = \"\", needle = \"\" \u8f93\u51fa\uff1a0 */ int strStr ( string haystack , string needle ) { int n = ( int ) haystack . length (), m = ( int ) needle . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return -1 ; } vector < int > next ( m , -1 ); int j = 0 , k = -1 ; while ( j < m - 1 ) { if ( k < 0 || needle [ j ] == needle [ k ]) { j ++ ; k ++ ; next [ j ] = needle [ j ] != needle [ k ] ? k : next [ k ]; } else { k = next [ k ]; } } int i = 0 ; j = 0 ; while ( i < n && j < m ) { if ( j < 0 || haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } return i - j > n - m ? -1 : i - j ; } \u300cLeetcode 214. \u6700\u77ed\u56de\u6587\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u5728\u5b57\u7b26\u4e32\u524d\u9762\u6dfb\u52a0\u5b57\u7b26\u5c06\u5176\u8f6c\u6362\u4e3a\u56de\u6587\u4e32\u3002 \u627e\u5230\u5e76\u8fd4\u56de\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f\u8f6c\u6362\u7684\u6700\u77ed\u56de\u6587\u4e32\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1as = \"aacecaaa\" \u8f93\u51fa\uff1a\"aaacecaaa\" \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1as = \"abcd\" \u8f93\u51fa\uff1a\"dcbabcd\" */ string shortestPalindrome ( string s ) { int n = ( int ) s . length (); if ( n <= 1 ) { return s ; } vector < int > next ( n , -1 ); int i = 0 , pos = -1 ; while ( i < n - 1 ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i ++ ; pos ++ ; next [ i ] = s [ i ] != s [ pos ] ? pos : next [ pos ]; } else { pos = next [ pos ]; } } pos = 0 ; i = n - 1 ; while ( i >= 0 && pos < n ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i -- ; pos ++ ; } else { pos = next [ pos ]; } } string ans = s . substr ( pos , n - pos ); reverse ( ans . begin (), ans . end ()); return ans + s ; } 2. Boyer-Moore \u00b6 2.1. \u574f\u5b57\u7b26 \u00b6 \u5f53\u6a21\u5f0f\u4e32P\u4e0e\u6587\u672c\u4e32T\u5728\u67d0\u4ee5\u4f4d\u7f6epos\u53d1\u751f\u4e0d\u5339\u914d\u65f6\uff0cT[pos]\u53eb\u505a\u574f\u5b57\u7b26\u3002 1.1 \u574f\u5b57\u7b26\u54c8\u5e0c\u8868\u7684\u6784\u9020\uff0c\u4e00\u904d\u626b\u63cf\u5c06P\u4e2d\u7684\u5b57\u7b26\u4f4d\u7f6e\u4fdd\u5b58\u5728\u5b57\u5178\u4e2d\uff0ckey\u4e3a\u5b57\u7b26\u672c\u8eab\uff0cvalue\u4e3a\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u3002 1.2 \u5f53\u574f\u5b57\u7b26\u4e0d\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06\u6a21\u5f0f\u4e32\u5168\u90e8\u79fb\u52a8\u5230\u574f\u5b57\u7b26\u540e\u4e00\u4f4d \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} 1.3 \u5f53\u574f\u5b57\u7b26\u51fa\u73b0\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06P\u4e2d\u6700\u8fd1\u7684\u5b57\u7b26\u4e0eT\u4e2d\u7684\u574f\u5b57\u7b26\u5bf9\u5e94 \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \u4f46\u662f\u5982\u679c\u574f\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u5927\u4e8e\u4e0d\u5339\u914d\u7684\u4f4d\u7f6ej\u65f6\uff0c\u79fb\u52a8\u7684\u8ddd\u79bb\u662f\u8d1f\u6570 \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0cBM\u8fd8\u9700\u8981\u597d\u540e\u7f00\u89c4\u5219\u3002 2.2. \u597d\u540e\u7f00 \u00b6 \u56e0\u4e3aT\u4e0eP\u7684\u5339\u914d\u662f\u4ece\u5de6\u5230\u53f3\uff08\u79fb\u52a8\u65b9\u5411\u4e00\u76f4\u662f\u5411\u53f3\uff09\uff0c\u5f53\u51fa\u73b0\u574f\u5b57\u7b26\u65f6\uff0cP\u7684\u540e\u534a\u90e8\u5206\uff08\u5982\u679c\u6709\uff09\u4e00\u5b9a\u662f\u5339\u914d\u597d\u7684\uff0c\u8fd9\u90e8\u5206\u53eb\u505a\u597d\u540e\u7f00\u3002 2.2.1 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06P\u7684\u597d\u540e\u7f00\u5339\u914d\u7684\u524d\u7f00\u90e8\u5206\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} 2.2.2 \u597d\u540e\u7f00\u7684\u90e8\u5206\uff08\u540e\u7f00\uff09\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06\u90e8\u5206\u540e\u7f00\uff08P\u524d\u7f00\u4e2d\u7684\uff09\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} 2.2.3 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u6ca1\u6709\u51fa\u73b0\uff0c\u5c06P\u6574\u4f53\u79fb\u52a8lenP\uff08P\u7684\u957f\u5ea6\uff09 \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} 2.2.4 \u597d\u540e\u7f00\u7684\u6784\u9020 \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} k\u8868\u793a\u597d\u540e\u7f00\u7684\u957f\u5ea6\uff08\u4ece1\u5f00\u59cb\uff09\uff0cpos\u8868\u793a\u597d\u540e\u7f00\u5728\u524d\u7f00\u51fa\u73b0\u7684\u4f4d\u7f6e\uff08\u82e5\u4e0d\u5b58\u5728\u4e3a-1\uff09, T/F\u8868\u793a\u957f\u5ea6\u4e3ak\u7684\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u4f8b\u5982 \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} 2.3. \u574f\u5b57\u7b26\u4e0e\u597d\u540e\u7f00\u7ec4\u5408 \u00b6 \u5206\u522b\u8ba1\u7b97\u4e24\u79cd\u89c4\u5219\u4e0b\u79fb\u52a8\u7684\u8ddd\u79bb\uff0c\u53d6\u8f83\u5927\u8005\u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m + \\Sigma) O(m + \\Sigma) \uff1b\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u6700\u597d\u60c5\u51b5\u4e0b O(\\frac{n}{m}) O(\\frac{n}{m}) \uff0c\u6700\u5dee\u60c5\u51b5\u4e0b O(n+m) O(n+m) \u300cBoyerMoore\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BoyerMoore { vector < int > bc ; vector < int > suffix ; bool * prefix ; string T , P ; int nT , nP ; public : const int N = 256 ; BoyerMoore ( string text , string pattern ) { T = text ; P = pattern ; nT = ( int ) T . length (); nP = ( int ) P . length (); } ~ BoyerMoore () { delete [] prefix ; } void buildBadCharacter () { bc . resize ( N , -1 ); for ( int i = 0 ; i < nP ; i ++ ) { bc [ P [ i ]] = i ; } } void buildGoodSuffix () { suffix . resize ( nP , -1 ); prefix = new bool [ nP ]{}; for ( int i = 0 ; i < nP - 1 ; i ++ ) { // k\u4ee3\u8868\u540e\u7f00\u7684\u957f\u5ea6 int j = i , k = 0 ; while ( j >= 0 && P [ j ] == P [ nP - 1 - k ]) { k ++ ; j -- ; suffix [ k ] = j + 1 ; } if ( j == -1 ) { prefix [ k ] = true ; } } } int stepsToMoveWithGoodSuffix ( int idxBC ) { int k = nP - idxBC - 1 ; if ( k == 0 ) { return 0 ; } if ( suffix [ k ] != -1 ) { return idxBC - suffix [ k ] + 1 ; } for ( int i = k - 1 ; i > 0 ; i -- ) { if ( prefix [ i ]) { return nP - i - suffix [ i ]; } } return nP ; } vector < int > match () { buildBadCharacter (); buildGoodSuffix (); vector < int > ans ; int k = nP - 1 ; while ( k < nT ) { int i = k , j = nP - 1 ; while ( j >= 0 && T [ i ] == P [ j ]) { i -- ; j -- ; } if ( j == -1 ) { ans . emplace_back ( i + 1 ); k ++ ; continue ; } int stepsWithBC = nP - 1 - bc [ T [ i ]] - ( k - i ); int stepsWithGS = stepsToMoveWithGoodSuffix ( j ); k += max ( stepsWithBC , stepsWithGS ); } return ans ; } bool isMatch () { return ! match (). empty (); } }; /* string T = \"ababab\", P = \"abab\"; // aaabaaabbbabaa,babb: -1 // ababbbbaaabbbaaa,bbbb: 3 BoyerMoore bm(T, P); vector<int> pos = bm.match(); // [0 2] */ 3. Rabin-Karp \u00b6 \u5229\u7528\u54c8\u5e0c\u7684\u65b9\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u6210\u4e00\u4e2a\u6570\u3002\u7531\u6b64\uff0c\u4e24\u5b57\u7b26\u4e32\u4e4b\u95f4\u7684\u6bd4\u8f83\u8f6c\u5316\u4e3a\u4e24\u6570\u5b57\u7684\u6bd4\u8f83\u3002\u5982\u679c\u51fa\u73b0\u6563\u5217\u51b2\u7a81\uff0c\u9010\u4e00\u6bd4\u8f83\u4e24\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u3002 \u300cRabin-Karp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return -1 ; } int key = 0 , value = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { key += P [ i ]; value += T [ i ]; } key += P [ m -1 ]; for ( int i = m - 1 , j = -1 ; i < n ; i ++ ) { value += T [ i ]; if ( j >= 0 ) { value -= T [ j ]; } j ++ ; if ( value == key ) { int x = j , y = 0 ; while ( x <= i && y < m && T [ x ] == P [ y ]) { x ++ ; y ++ ; } if ( y == m ) { return j ; } } } return -1 ; } int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return -1 ; } for ( int i = 0 ; i <= n - m ; i ++ ) { if ( T . substr ( i , m ) == P ) { return i ; } } return -1 ; }","title":"\u5339\u914d"},{"location":"data-structure/string/match/#1-kmp","text":"KMP\u8bb2\u6c42\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u5339\u914d\uff0c\u5f53\u51fa\u73b0\u8bef\u5339\u914d\u7684\u5b57\u7b26\u65f6\uff0c\u5c06\u6a21\u5f0f\u4e32P\u5411\u53f3\u79fb\u52a8\u82e5\u5e72\u8ddd\u79bb\u3002KMP\u501f\u52a9P\u7684\u524d\u7f00\uff08\u5386\u53f2\u5339\u914d\u4fe1\u606f\uff09\u6784\u5efanext\u6570\u7ec4\u3002\u5c06P\u524d\u7f00\u4e2d\u4e0e\u5931\u914d\u5b57\u7b26\u524d\u6700\u5927\u91cd\u5408\u7684\u4f4d\u7f6e\u5bf9\u9f50\u3002P\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u53d1\u751f\u5931\u914d\u65f6\uff0c\u5bf9\u5e94\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u8be5\u662f-1\uff0c\u8868\u793a\u5c06\u6574\u4e2aP\u79fb\u52a8\u5230\u5931\u914d\u5b57\u7b26\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002 \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \u4e3a\u4e86\u66f4\u52a0\u9ad8\u6548\u5730\u79fb\u52a8P\uff0cnext\u6570\u7ec4\u8868\u793a\u5730\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u5f53\u5c3d\u53ef\u80fd\u5730\u5c0f \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) , \u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0cm\u662fP\u7684\u957f\u5ea6\uff0cn\u662fT\u7684\u957f\u5ea6 \u300cLeetcode 28. \u5b9e\u73b0 strStr()\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahaystack = \"hello\", needle = \"ll\" \u8f93\u51fa\uff1a2 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahaystack = \"aaaaa\", needle = \"bba\" \u8f93\u51fa\uff1a-1 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahaystack = \"\", needle = \"\" \u8f93\u51fa\uff1a0 */ int strStr ( string haystack , string needle ) { int n = ( int ) haystack . length (), m = ( int ) needle . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return -1 ; } vector < int > next ( m , -1 ); int j = 0 , k = -1 ; while ( j < m - 1 ) { if ( k < 0 || needle [ j ] == needle [ k ]) { j ++ ; k ++ ; next [ j ] = needle [ j ] != needle [ k ] ? k : next [ k ]; } else { k = next [ k ]; } } int i = 0 ; j = 0 ; while ( i < n && j < m ) { if ( j < 0 || haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } return i - j > n - m ? -1 : i - j ; } \u300cLeetcode 214. \u6700\u77ed\u56de\u6587\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u5728\u5b57\u7b26\u4e32\u524d\u9762\u6dfb\u52a0\u5b57\u7b26\u5c06\u5176\u8f6c\u6362\u4e3a\u56de\u6587\u4e32\u3002 \u627e\u5230\u5e76\u8fd4\u56de\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f\u8f6c\u6362\u7684\u6700\u77ed\u56de\u6587\u4e32\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1as = \"aacecaaa\" \u8f93\u51fa\uff1a\"aaacecaaa\" \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1as = \"abcd\" \u8f93\u51fa\uff1a\"dcbabcd\" */ string shortestPalindrome ( string s ) { int n = ( int ) s . length (); if ( n <= 1 ) { return s ; } vector < int > next ( n , -1 ); int i = 0 , pos = -1 ; while ( i < n - 1 ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i ++ ; pos ++ ; next [ i ] = s [ i ] != s [ pos ] ? pos : next [ pos ]; } else { pos = next [ pos ]; } } pos = 0 ; i = n - 1 ; while ( i >= 0 && pos < n ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i -- ; pos ++ ; } else { pos = next [ pos ]; } } string ans = s . substr ( pos , n - pos ); reverse ( ans . begin (), ans . end ()); return ans + s ; }","title":"1. KMP"},{"location":"data-structure/string/match/#2-boyer-moore","text":"","title":"2. Boyer-Moore"},{"location":"data-structure/string/match/#21","text":"\u5f53\u6a21\u5f0f\u4e32P\u4e0e\u6587\u672c\u4e32T\u5728\u67d0\u4ee5\u4f4d\u7f6epos\u53d1\u751f\u4e0d\u5339\u914d\u65f6\uff0cT[pos]\u53eb\u505a\u574f\u5b57\u7b26\u3002 1.1 \u574f\u5b57\u7b26\u54c8\u5e0c\u8868\u7684\u6784\u9020\uff0c\u4e00\u904d\u626b\u63cf\u5c06P\u4e2d\u7684\u5b57\u7b26\u4f4d\u7f6e\u4fdd\u5b58\u5728\u5b57\u5178\u4e2d\uff0ckey\u4e3a\u5b57\u7b26\u672c\u8eab\uff0cvalue\u4e3a\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u3002 1.2 \u5f53\u574f\u5b57\u7b26\u4e0d\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06\u6a21\u5f0f\u4e32\u5168\u90e8\u79fb\u52a8\u5230\u574f\u5b57\u7b26\u540e\u4e00\u4f4d \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} 1.3 \u5f53\u574f\u5b57\u7b26\u51fa\u73b0\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06P\u4e2d\u6700\u8fd1\u7684\u5b57\u7b26\u4e0eT\u4e2d\u7684\u574f\u5b57\u7b26\u5bf9\u5e94 \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \u4f46\u662f\u5982\u679c\u574f\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u5927\u4e8e\u4e0d\u5339\u914d\u7684\u4f4d\u7f6ej\u65f6\uff0c\u79fb\u52a8\u7684\u8ddd\u79bb\u662f\u8d1f\u6570 \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0cBM\u8fd8\u9700\u8981\u597d\u540e\u7f00\u89c4\u5219\u3002","title":"2.1. \u574f\u5b57\u7b26"},{"location":"data-structure/string/match/#22","text":"\u56e0\u4e3aT\u4e0eP\u7684\u5339\u914d\u662f\u4ece\u5de6\u5230\u53f3\uff08\u79fb\u52a8\u65b9\u5411\u4e00\u76f4\u662f\u5411\u53f3\uff09\uff0c\u5f53\u51fa\u73b0\u574f\u5b57\u7b26\u65f6\uff0cP\u7684\u540e\u534a\u90e8\u5206\uff08\u5982\u679c\u6709\uff09\u4e00\u5b9a\u662f\u5339\u914d\u597d\u7684\uff0c\u8fd9\u90e8\u5206\u53eb\u505a\u597d\u540e\u7f00\u3002 2.2.1 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06P\u7684\u597d\u540e\u7f00\u5339\u914d\u7684\u524d\u7f00\u90e8\u5206\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} 2.2.2 \u597d\u540e\u7f00\u7684\u90e8\u5206\uff08\u540e\u7f00\uff09\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06\u90e8\u5206\u540e\u7f00\uff08P\u524d\u7f00\u4e2d\u7684\uff09\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} 2.2.3 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u6ca1\u6709\u51fa\u73b0\uff0c\u5c06P\u6574\u4f53\u79fb\u52a8lenP\uff08P\u7684\u957f\u5ea6\uff09 \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} 2.2.4 \u597d\u540e\u7f00\u7684\u6784\u9020 \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} k\u8868\u793a\u597d\u540e\u7f00\u7684\u957f\u5ea6\uff08\u4ece1\u5f00\u59cb\uff09\uff0cpos\u8868\u793a\u597d\u540e\u7f00\u5728\u524d\u7f00\u51fa\u73b0\u7684\u4f4d\u7f6e\uff08\u82e5\u4e0d\u5b58\u5728\u4e3a-1\uff09, T/F\u8868\u793a\u957f\u5ea6\u4e3ak\u7684\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u4f8b\u5982 \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned}","title":"2.2. \u597d\u540e\u7f00"},{"location":"data-structure/string/match/#23","text":"\u5206\u522b\u8ba1\u7b97\u4e24\u79cd\u89c4\u5219\u4e0b\u79fb\u52a8\u7684\u8ddd\u79bb\uff0c\u53d6\u8f83\u5927\u8005\u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m + \\Sigma) O(m + \\Sigma) \uff1b\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u6700\u597d\u60c5\u51b5\u4e0b O(\\frac{n}{m}) O(\\frac{n}{m}) \uff0c\u6700\u5dee\u60c5\u51b5\u4e0b O(n+m) O(n+m) \u300cBoyerMoore\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BoyerMoore { vector < int > bc ; vector < int > suffix ; bool * prefix ; string T , P ; int nT , nP ; public : const int N = 256 ; BoyerMoore ( string text , string pattern ) { T = text ; P = pattern ; nT = ( int ) T . length (); nP = ( int ) P . length (); } ~ BoyerMoore () { delete [] prefix ; } void buildBadCharacter () { bc . resize ( N , -1 ); for ( int i = 0 ; i < nP ; i ++ ) { bc [ P [ i ]] = i ; } } void buildGoodSuffix () { suffix . resize ( nP , -1 ); prefix = new bool [ nP ]{}; for ( int i = 0 ; i < nP - 1 ; i ++ ) { // k\u4ee3\u8868\u540e\u7f00\u7684\u957f\u5ea6 int j = i , k = 0 ; while ( j >= 0 && P [ j ] == P [ nP - 1 - k ]) { k ++ ; j -- ; suffix [ k ] = j + 1 ; } if ( j == -1 ) { prefix [ k ] = true ; } } } int stepsToMoveWithGoodSuffix ( int idxBC ) { int k = nP - idxBC - 1 ; if ( k == 0 ) { return 0 ; } if ( suffix [ k ] != -1 ) { return idxBC - suffix [ k ] + 1 ; } for ( int i = k - 1 ; i > 0 ; i -- ) { if ( prefix [ i ]) { return nP - i - suffix [ i ]; } } return nP ; } vector < int > match () { buildBadCharacter (); buildGoodSuffix (); vector < int > ans ; int k = nP - 1 ; while ( k < nT ) { int i = k , j = nP - 1 ; while ( j >= 0 && T [ i ] == P [ j ]) { i -- ; j -- ; } if ( j == -1 ) { ans . emplace_back ( i + 1 ); k ++ ; continue ; } int stepsWithBC = nP - 1 - bc [ T [ i ]] - ( k - i ); int stepsWithGS = stepsToMoveWithGoodSuffix ( j ); k += max ( stepsWithBC , stepsWithGS ); } return ans ; } bool isMatch () { return ! match (). empty (); } }; /* string T = \"ababab\", P = \"abab\"; // aaabaaabbbabaa,babb: -1 // ababbbbaaabbbaaa,bbbb: 3 BoyerMoore bm(T, P); vector<int> pos = bm.match(); // [0 2] */","title":"2.3. \u574f\u5b57\u7b26\u4e0e\u597d\u540e\u7f00\u7ec4\u5408"},{"location":"data-structure/string/match/#3-rabin-karp","text":"\u5229\u7528\u54c8\u5e0c\u7684\u65b9\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u6210\u4e00\u4e2a\u6570\u3002\u7531\u6b64\uff0c\u4e24\u5b57\u7b26\u4e32\u4e4b\u95f4\u7684\u6bd4\u8f83\u8f6c\u5316\u4e3a\u4e24\u6570\u5b57\u7684\u6bd4\u8f83\u3002\u5982\u679c\u51fa\u73b0\u6563\u5217\u51b2\u7a81\uff0c\u9010\u4e00\u6bd4\u8f83\u4e24\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u3002 \u300cRabin-Karp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return -1 ; } int key = 0 , value = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { key += P [ i ]; value += T [ i ]; } key += P [ m -1 ]; for ( int i = m - 1 , j = -1 ; i < n ; i ++ ) { value += T [ i ]; if ( j >= 0 ) { value -= T [ j ]; } j ++ ; if ( value == key ) { int x = j , y = 0 ; while ( x <= i && y < m && T [ x ] == P [ y ]) { x ++ ; y ++ ; } if ( y == m ) { return j ; } } } return -1 ; } int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return -1 ; } for ( int i = 0 ; i <= n - m ; i ++ ) { if ( T . substr ( i , m ) == P ) { return i ; } } return -1 ; }","title":"3. Rabin-Karp"}]}