{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"\u4ecb\u7ecd"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"algo/greedy/","text":"\u8d2a\u5fc3 \u00b6 \u8d2a\u5fc3\u7b97\u6cd5\u662f\u4e00\u79cd\u9009\u62e9\u7b97\u6cd5\uff0c\u5177\u6709\u300c\u77ed\u89c6\u300d\u7279\u70b9\uff0c\u5373\u4f18\u5148\u9009\u62e9\u5f53\u524d\u6700\u6709\u5229\u7684\u65b9\u6848\u3002 \u9898\u76ee \u00b6 \u5206\u914d\u4eba\u5458 \u00b6 \u516c\u53f8\u6709 2n \u4e2a\u5e94\u8058\u8005\u53c2\u52a0\u9762\u8bd5\uff0c\u53ef\u4ee5\u9009\u62e9A\u3001B\u5176\u4e2d\u4e00\u5904\uff0c\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 costs =[[259, 770], [448, 54], [926, 667], [184, 139], [840, 118], [577, 469]] \u8868\u793a\u5e94\u8058\u8005\u53bbA\u3001B\u4e24\u5904\u7684\u8d39\u7528\uff0c\u73b0\u5728\u9700\u8981\u5e73\u5747\u5206\u522b 2n \u4e2a\u4eba\u5230 A\u3001B \u4e24\u5904\uff0c\u8bd5\u95ee\uff0c\u6700\u5c0f\u7684\u6210\u672c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u8003\u8651 2n \u4e2a\u4eba\u90fd\u53bb B \u65f6\uff0c\u603b\u7684\u8d39\u7528\u662f \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \u3002\u6b64\u65f6\uff0c\u6211\u4eec\u9700\u8981\u9009\u62e9 n \u4e2a\u4eba\u653e\u5230 A \u5904\uff0c\u90a3\u4e48\u5982\u4f55\u9009\u62e9\u5462\uff1f\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u5982\u679c\u5c06\u4e00\u4e2a\u4eba\u4ece B \u653e\u5230 A\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u603b\u6210\u672c\u53d8\u5316\u91cf\u662f \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \uff0c\u521a\u597d\u5bf9\u5e94\u7740\u6210\u672cA - B\uff0c\u90a3\u4e48\u5bf9\u4e8e n \u4e2a\u4eba\uff0c\u6211\u4eec\u5e0c\u671b\u9009\u62e9\u524d n \u4e2a\u6700\u5c0f\u5dee\u503c\u3002\u5047\u8bbe\u8bf4\uff0c\u6211\u4eec\u6709\u4e00\u4e2a\u89e3\uff0c\u4e0d\u662f\u5dee\u503c\u7684\u524d n \u4e2a\uff0c\u90a3\u4e48\u6211\u4eec\u603b\u53ef\u4ee5\u627e\u5230\u4e00\u4e2a\u66f4\u5c0f\u7684\u5dee\u503c\uff0c\u4f7f\u5f97\u603b\u7684\u8d39\u7528\u53d8\u5c0f\uff0c\u8fd9\u5c31\u662f\u8d2a\u5fc3\u7684\u601d\u60f3\u3002 \u8fd9\u91cc\uff0c\u6211\u4eec\u7528\u4e86\u6392\u5e8f\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u4e2d\u95f4\u7684\u67d0\u4e00\u4e2a\u503c\uff0c\u4f7f\u5f97\u524d n \u4e2a\u5dee\u503c\u5747\u5c0f\u96e8\u540e n \u4e2a\u5dee\u503c\u3002\u6539\u8fdb\u7684\u5feb\u6392\u80fd\u591f\u5b9e\u73b0\u6b64\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int twoCitySchedCost ( vector < vector < int >>& costs ) { int ans = 0 , n = ( int ) costs . size (); int l = 0 , r = n - 1 ; while ( true ) { while ( l < r ) { while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { r -- ; } swap ( costs [ l ], costs [ r ]); while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { l ++ ; } swap ( costs [ l ], costs [ r ]); } if ( 2 * l == n - 2 ) { break ; } if ( 2 * l > n - 2 ) { r = l - 1 ; l = 0 ; } else { l ++ ; r = n - 1 ; } } for ( int i = 0 ; i < n / 2 ; i ++ ) { ans += costs [ i ][ 0 ] + costs [ n - 1 - i ][ 1 ]; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u5e94\u8058\u8005\u7684\u603b\u4eba\u6570\u3002 \u4e70\u96ea\u7cd5 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4 costs = [1, 3, 2, 4, 1] \u8868\u793a\u96ea\u7cd5\u7684\u4ef7\u683c\uff0c\u4ee5\u53ca\u4e00\u4e2a\u6574\u6570 coins = 7 \u8868\u793a\u6301\u6709\u7684\u91d1\u989d\uff0c\u8bd5\u95ee\uff0c\u6211\u4eec\u53ef\u4ee5\u4e70\u591a\u5c11\u652f\u96ea\u7cd5\uff1f \u300c\u5206\u6790\u300d \u5c06\u96ea\u7cd5\u7684\u4ef7\u683c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u6c42\u7d2f\u8ba1\u82b1\u8d39\u4e0d\u8d85\u8fc7\u7ed9\u5b9a\u91d1\u989d\u7684\u96ea\u7cd5\u6570\u76ee\u3002\u4e3a\u4ec0\u4e48\u8fd9\u6837\u662f\u6b63\u786e\u7684\uff1f\u6392\u5e8f\u540e\u7684\u96ea\u7cd5\u4ef7\u683c\uff1a c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} \u7ecf\u8fc7\u8ba1\u7b97\uff0c\u53d1\u73b0\u524d k \u652f\u96ea\u7cd5\u662f\u80fd\u591f\u4e70\u4e0b\u7684\uff0c\u7b2c k + 1 \u652f\u96ea\u7cd5\u662f\u4e0d\u80fd\u4e70\u4e0b\u3002\u6b64\u65f6\u662f\u6700\u4f18\u89e3\u3002\u5f53\u7136\uff0c\u4f1a\u5b58\u5728\u53e6\u4e00\u79cd\u60c5\u51b5\uff0c\u67d0\u652f\u96ea\u7cd5\u4e0d\u662f\u4ef7\u683c\u524d k \u5c0f\u7684\uff0c\u4f46\u662f\u5df2\u7136\u80fd\u591f\u4e70\u4e0b\uff0c\u6b64\u65f6\u5bf9\u5e94\u7684\u7ed9\u5b9a\u7684\u94b1\u6ca1\u6709\u90fd\u82b1\u5b8c\u3002\u5373\u4fbf\u5982\u6b64\uff0c\u96ea\u7cd5\u7684\u603b\u6570\u5df2\u7136\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 int maxIceCream ( vector < int >& costs , int coins ) { int ans = 0 ; sort ( costs . begin (), costs . end ()); for ( int cost : costs ) { if ( cost > coins ) { return ans ; } coins -= cost ; ans ++ ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u96ea\u7cd5\u7684\u6570\u76ee\u3002 \u7531 X \u5230 Y \u7684\u6700\u5c11\u64cd\u4f5c\u6570 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u6b63\u6570 X \u548c Y\uff0c\u53ea\u80fd\u5c06 X \u52a0\u500d\u6216\u8005\u5c06 X \u51cf\u53bb\u4e00\uff0c\u8bd5\u95ee\u7ecf\u8fc7\u591a\u5c11\u6b21\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u53ef\u4ee5\u628a X \u53d8\u6210 Y\uff1f \u300c\u5206\u6790\u300d \u5982\u679c X >= Y\uff0c\u90a3\u4e48\u53ea\u80fd\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\uff1b\u53cd\u4e4b\uff0c\u6267\u884c\u52a0\u500d\u64cd\u4f5c\u5feb\u901f\u903c\u8fd1 Y \uff0c\u5728\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\u3002\u4f46\u662f\u5728\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\uff0c\u8003\u8651\u5230\u6570\u636e\u8303\u56f4\u95ee\u9898\uff0c\u6211\u4eec\u503e\u5411\u4f7f\u7528\u9006\u5411\u601d\u7ef4\uff0c\u5373\u5c06 Y \u51cf\u534a\u6216\u8005\u52a0\u4e00\u53d8\u6210 X\u3002\u6ce8\u610f\u5230\uff0c\u5f53 Y \u4e3a\u5947\u6570\u65f6\uff0c\u53ea\u80fd\u6267\u884c\u52a0\u4e00\u64cd\u4f5c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int brokenCalc ( int x , int y ) { if ( x >= y ) { return x - y ; } int ans = 0 ; while ( x < y ) { if ( y % 2 != 0 ) { y ++ ; } else { y >>= 1 ; } ans ++ ; } return ans + x - y ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log y) O(\\log y) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u8d2a\u5fc3"},{"location":"algo/greedy/#_1","text":"\u8d2a\u5fc3\u7b97\u6cd5\u662f\u4e00\u79cd\u9009\u62e9\u7b97\u6cd5\uff0c\u5177\u6709\u300c\u77ed\u89c6\u300d\u7279\u70b9\uff0c\u5373\u4f18\u5148\u9009\u62e9\u5f53\u524d\u6700\u6709\u5229\u7684\u65b9\u6848\u3002","title":"\u8d2a\u5fc3"},{"location":"algo/greedy/#_2","text":"","title":"\u9898\u76ee"},{"location":"algo/greedy/#_3","text":"\u516c\u53f8\u6709 2n \u4e2a\u5e94\u8058\u8005\u53c2\u52a0\u9762\u8bd5\uff0c\u53ef\u4ee5\u9009\u62e9A\u3001B\u5176\u4e2d\u4e00\u5904\uff0c\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 costs =[[259, 770], [448, 54], [926, 667], [184, 139], [840, 118], [577, 469]] \u8868\u793a\u5e94\u8058\u8005\u53bbA\u3001B\u4e24\u5904\u7684\u8d39\u7528\uff0c\u73b0\u5728\u9700\u8981\u5e73\u5747\u5206\u522b 2n \u4e2a\u4eba\u5230 A\u3001B \u4e24\u5904\uff0c\u8bd5\u95ee\uff0c\u6700\u5c0f\u7684\u6210\u672c\u662f\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u8003\u8651 2n \u4e2a\u4eba\u90fd\u53bb B \u65f6\uff0c\u603b\u7684\u8d39\u7528\u662f \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \\sum_{i = 1}^{n} \\text{costs[ i ][ 1 ]} \u3002\u6b64\u65f6\uff0c\u6211\u4eec\u9700\u8981\u9009\u62e9 n \u4e2a\u4eba\u653e\u5230 A \u5904\uff0c\u90a3\u4e48\u5982\u4f55\u9009\u62e9\u5462\uff1f\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u5982\u679c\u5c06\u4e00\u4e2a\u4eba\u4ece B \u653e\u5230 A\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u603b\u6210\u672c\u53d8\u5316\u91cf\u662f \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \\text{costs[ i ][ 0 ] - costs[ i ][ 1 ]} \uff0c\u521a\u597d\u5bf9\u5e94\u7740\u6210\u672cA - B\uff0c\u90a3\u4e48\u5bf9\u4e8e n \u4e2a\u4eba\uff0c\u6211\u4eec\u5e0c\u671b\u9009\u62e9\u524d n \u4e2a\u6700\u5c0f\u5dee\u503c\u3002\u5047\u8bbe\u8bf4\uff0c\u6211\u4eec\u6709\u4e00\u4e2a\u89e3\uff0c\u4e0d\u662f\u5dee\u503c\u7684\u524d n \u4e2a\uff0c\u90a3\u4e48\u6211\u4eec\u603b\u53ef\u4ee5\u627e\u5230\u4e00\u4e2a\u66f4\u5c0f\u7684\u5dee\u503c\uff0c\u4f7f\u5f97\u603b\u7684\u8d39\u7528\u53d8\u5c0f\uff0c\u8fd9\u5c31\u662f\u8d2a\u5fc3\u7684\u601d\u60f3\u3002 \u8fd9\u91cc\uff0c\u6211\u4eec\u7528\u4e86\u6392\u5e8f\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u4e2d\u95f4\u7684\u67d0\u4e00\u4e2a\u503c\uff0c\u4f7f\u5f97\u524d n \u4e2a\u5dee\u503c\u5747\u5c0f\u96e8\u540e n \u4e2a\u5dee\u503c\u3002\u6539\u8fdb\u7684\u5feb\u6392\u80fd\u591f\u5b9e\u73b0\u6b64\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int twoCitySchedCost ( vector < vector < int >>& costs ) { int ans = 0 , n = ( int ) costs . size (); int l = 0 , r = n - 1 ; while ( true ) { while ( l < r ) { while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { r -- ; } swap ( costs [ l ], costs [ r ]); while ( l < r && costs [ l ][ 0 ] - costs [ l ][ 1 ] <= costs [ r ][ 0 ] - costs [ r ][ 1 ]) { l ++ ; } swap ( costs [ l ], costs [ r ]); } if ( 2 * l == n - 2 ) { break ; } if ( 2 * l > n - 2 ) { r = l - 1 ; l = 0 ; } else { l ++ ; r = n - 1 ; } } for ( int i = 0 ; i < n / 2 ; i ++ ) { ans += costs [ i ][ 0 ] + costs [ n - 1 - i ][ 1 ]; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u5e94\u8058\u8005\u7684\u603b\u4eba\u6570\u3002","title":"\u5206\u914d\u4eba\u5458"},{"location":"algo/greedy/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4 costs = [1, 3, 2, 4, 1] \u8868\u793a\u96ea\u7cd5\u7684\u4ef7\u683c\uff0c\u4ee5\u53ca\u4e00\u4e2a\u6574\u6570 coins = 7 \u8868\u793a\u6301\u6709\u7684\u91d1\u989d\uff0c\u8bd5\u95ee\uff0c\u6211\u4eec\u53ef\u4ee5\u4e70\u591a\u5c11\u652f\u96ea\u7cd5\uff1f \u300c\u5206\u6790\u300d \u5c06\u96ea\u7cd5\u7684\u4ef7\u683c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u6c42\u7d2f\u8ba1\u82b1\u8d39\u4e0d\u8d85\u8fc7\u7ed9\u5b9a\u91d1\u989d\u7684\u96ea\u7cd5\u6570\u76ee\u3002\u4e3a\u4ec0\u4e48\u8fd9\u6837\u662f\u6b63\u786e\u7684\uff1f\u6392\u5e8f\u540e\u7684\u96ea\u7cd5\u4ef7\u683c\uff1a c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} c_{0} \\leq c_{1} \\leq ... \\leq c_{k} \\leq ... \\leq c_{n-1} \u7ecf\u8fc7\u8ba1\u7b97\uff0c\u53d1\u73b0\u524d k \u652f\u96ea\u7cd5\u662f\u80fd\u591f\u4e70\u4e0b\u7684\uff0c\u7b2c k + 1 \u652f\u96ea\u7cd5\u662f\u4e0d\u80fd\u4e70\u4e0b\u3002\u6b64\u65f6\u662f\u6700\u4f18\u89e3\u3002\u5f53\u7136\uff0c\u4f1a\u5b58\u5728\u53e6\u4e00\u79cd\u60c5\u51b5\uff0c\u67d0\u652f\u96ea\u7cd5\u4e0d\u662f\u4ef7\u683c\u524d k \u5c0f\u7684\uff0c\u4f46\u662f\u5df2\u7136\u80fd\u591f\u4e70\u4e0b\uff0c\u6b64\u65f6\u5bf9\u5e94\u7684\u7ed9\u5b9a\u7684\u94b1\u6ca1\u6709\u90fd\u82b1\u5b8c\u3002\u5373\u4fbf\u5982\u6b64\uff0c\u96ea\u7cd5\u7684\u603b\u6570\u5df2\u7136\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 int maxIceCream ( vector < int >& costs , int coins ) { int ans = 0 ; sort ( costs . begin (), costs . end ()); for ( int cost : costs ) { if ( cost > coins ) { return ans ; } coins -= cost ; ans ++ ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \uff0c\u5176\u4e2d n \u662f\u96ea\u7cd5\u7684\u6570\u76ee\u3002","title":"\u4e70\u96ea\u7cd5"},{"location":"algo/greedy/#x-y","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6b63\u6570 X \u548c Y\uff0c\u53ea\u80fd\u5c06 X \u52a0\u500d\u6216\u8005\u5c06 X \u51cf\u53bb\u4e00\uff0c\u8bd5\u95ee\u7ecf\u8fc7\u591a\u5c11\u6b21\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u53ef\u4ee5\u628a X \u53d8\u6210 Y\uff1f \u300c\u5206\u6790\u300d \u5982\u679c X >= Y\uff0c\u90a3\u4e48\u53ea\u80fd\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\uff1b\u53cd\u4e4b\uff0c\u6267\u884c\u52a0\u500d\u64cd\u4f5c\u5feb\u901f\u903c\u8fd1 Y \uff0c\u5728\u6267\u884c\u51cf\u4e00\u64cd\u4f5c\u3002\u4f46\u662f\u5728\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\uff0c\u8003\u8651\u5230\u6570\u636e\u8303\u56f4\u95ee\u9898\uff0c\u6211\u4eec\u503e\u5411\u4f7f\u7528\u9006\u5411\u601d\u7ef4\uff0c\u5373\u5c06 Y \u51cf\u534a\u6216\u8005\u52a0\u4e00\u53d8\u6210 X\u3002\u6ce8\u610f\u5230\uff0c\u5f53 Y \u4e3a\u5947\u6570\u65f6\uff0c\u53ea\u80fd\u6267\u884c\u52a0\u4e00\u64cd\u4f5c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int brokenCalc ( int x , int y ) { if ( x >= y ) { return x - y ; } int ans = 0 ; while ( x < y ) { if ( y % 2 != 0 ) { y ++ ; } else { y >>= 1 ; } ans ++ ; } return ans + x - y ; } \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(\\log y) O(\\log y) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(1) O(1) \u3002","title":"\u7531 X \u5230 Y \u7684\u6700\u5c11\u64cd\u4f5c\u6570"},{"location":"algo/jsoffer/","text":"JS-offer \u00b6 02. \u66ff\u6362\u7a7a\u683c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u6bcf\u4e2a\u7a7a\u683c\u66ff\u6362\u6210\u201c%20\u201d\u3002\u4f8b\u5982\uff0c\u5f53\u5b57\u7b26\u4e32\u4e3aWe Are Happy.\u5219\u7ecf\u8fc7\u66ff\u6362\u4e4b\u540e\u7684\u5b57\u7b26\u4e32\u4e3aWe%20Are%20Happy\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void replaceSpace ( char * str , int length ) { if ( length == 0 ) { return ; } int nSpace = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( str [ i ] == ' ' ) { nSpace ++ ; } } int len = length + 2 * nSpace ; for ( int i = length - 1 , j = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) { str [ j -- ] = '0' ; str [ j -- ] = '2' ; str [ j -- ] = '%' ; } else { str [ j -- ] = str [ i ]; } } } }; 03. \u4ece\u5c3e\u5230\u5934\u6253\u5370\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u6309\u94fe\u8868\u4ece\u5c3e\u5230\u5934\u7684\u987a\u5e8f\u8fd4\u56de\u4e00\u4e2aArrayList\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) \uff1a * val(x), next(NULL) { * } * }; */ class Solution { public \uff1a vector < int > printListFromTailToHead ( ListNode * head ) { vector < int > arr ; recurPrintList ( arr , head ); return arr ; } void recurPrintList ( vector < int > & arr , ListNode * head ) { if ( head != nullptr ) { recurPrintList ( arr , head -> next ); arr . push_back ( head -> val ); } } }; 04. \u91cd\u5efa\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u67d0\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\uff0c\u8bf7\u91cd\u5efa\u51fa\u8be5\u4e8c\u53c9\u6811\u3002\u5047\u8bbe\u8f93\u5165\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u4e2d\u90fd\u4e0d\u542b\u91cd\u590d\u7684\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u524d\u5e8f\u904d\u5386\u5e8f\u5217{1,2,4,7,3,5,6,8}\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217{4,7,2,1,5,3,8,6}\uff0c\u5219\u91cd\u5efa\u4e8c\u53c9\u6811\u5e76\u8fd4\u56de\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) {} * }; */ class Solution { public \uff1a TreeNode * reConstructBinaryTree ( vector < int > pre , vector < int > vin ) { int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return construct ( pre , 0 , n - 1 , vin , 0 , n - 1 ); } TreeNode * construct ( vector < int > pre , int b1 , int e1 , vector < int > vin , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int id = b2 ; for (; id <= e2 ; id ++ ) { if ( vin [ id ] == pre [ b1 ]) { break ; } } root -> left = construct ( pre , b1 + 1 , b1 + ( id - b2 ), vin , b2 , id - 1 ); root -> right = construct ( pre , b1 + ( id - b2 ) + 1 , e1 , vin , id + 1 , e2 ); return root ; } }; 05. \u7528\u4e24\u4e2a\u6808\u5b9e\u73b0\u961f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7528\u4e24\u4e2a\u6808\u6765\u5b9e\u73b0\u4e00\u4e2a\u961f\u5217\uff0c\u5b8c\u6210\u961f\u5217\u7684Push\u548cPop\u64cd\u4f5c\u3002 \u961f\u5217\u4e2d\u7684\u5143\u7d20\u4e3aint\u7c7b\u578b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a void push ( int node ) { stack1 . push ( node ); } int pop () { while ( ! stack1 . empty ()) { stack2 . push ( stack1 . top ()); stack1 . pop (); } int res = stack2 . top (); stack2 . pop (); while ( ! stack2 . empty ()) { stack1 . push ( stack2 . top ()); stack2 . pop (); } return res ; } private \uff1a stack < int > stack1 ; stack < int > stack2 ; }; 06. \u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u4e00\u4e2a\u6570\u7ec4\u6700\u5f00\u59cb\u7684\u82e5\u5e72\u4e2a\u5143\u7d20\u642c\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u6570\u7ec4\u7684\u65cb\u8f6c\u3002 \u8f93\u5165\u4e00\u4e2a\u975e\u9012\u51cf\u6392\u5e8f\u7684\u6570\u7ec4\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8f93\u51fa\u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u5143\u7d20\u3002\u4f8b\u5982\u6570\u7ec4{3,4,5,1,2}\u4e3a{1,2,3,4,5}\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8be5\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u4e3a1\u3002NOTE\uff1a\u7ed9\u51fa\u7684\u6240\u6709\u5143\u7d20\u90fd\u5927\u4e8e0\uff0c\u82e5\u6570\u7ec4\u5927\u5c0f\u4e3a0\uff0c\u8bf7\u8fd4\u56de0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a int minNumberInRotateArray ( vector < int > rotateArray ) { int n = int ( rotateArray . size ()); if ( n == 0 ) { return 0 ; } if ( rotateArray [ 0 ] < rotateArray [ n - 1 ]) { return rotateArray [ 0 ]; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( rotateArray [ i ] < rotateArray [ i - 1 ]) { return rotateArray [ i ]; } } return 0 ; } }; 07. \u6590\u6ce2\u90a3\u5951\u6570\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5927\u5bb6\u90fd\u77e5\u9053\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff0c\u73b0\u5728\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6574\u6570n\uff0c\u8bf7\u4f60\u8f93\u51fa\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7b2cn\u9879\uff08\u4ece0\u5f00\u59cb\uff0c\u7b2c0\u9879\u4e3a0\uff0c\u7b2c1\u9879\u662f1\uff09\u3002n<=39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int Fibonacci ( int n ) { if ( n == 0 || n == 1 ) { return n ; } int t1 = 0 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } }; 08. \u8df3\u53f0\u9636 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\uff08\u5148\u540e\u6b21\u5e8f\u4e0d\u540c\u7b97\u4e0d\u540c\u7684\u7ed3\u679c\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int jumpFloor ( int number ) { if ( number == 0 || number == 1 ) { return 1 ; } int t1 = 1 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } }; 09. \u53d8\u6001\u8df3\u53f0\u9636 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u2026\u2026\u5b83\u4e5f\u53ef\u4ee5\u8df3\u4e0an\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\u3002 1 2 3 4 5 6 7 8 class Solution { public \uff1a int jumpFloorII ( int number ) { int res = 1 ; while ( -- number ) { res *= 2 ; } return res ; } }; 10. \u77e9\u5f62\u8986\u76d6 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6211\u4eec\u53ef\u4ee5\u75282 1\u7684\u5c0f\u77e9\u5f62\u6a2a\u7740\u6216\u8005\u7ad6\u7740\u53bb\u8986\u76d6\u66f4\u5927\u7684\u77e9\u5f62\u3002\u8bf7\u95ee\u7528n\u4e2a2 1\u7684\u5c0f\u77e9\u5f62\u65e0\u91cd\u53e0\u5730\u8986\u76d6\u4e00\u4e2a2 n\u7684\u5927\u77e9\u5f62\uff0c\u603b\u5171\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\uff1f\u6bd4\u5982n=3\u65f6\uff0c2 3\u7684\u77e9\u5f62\u5757\u67093\u79cd\u8986\u76d6\u65b9\u6cd5\uff1a f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int rectCover ( int number ) { if ( number <= 2 ) { return number ; } int t1 = 1 , t2 = 2 , temp = 0 ; for ( int i = 3 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } }; 12. \u6570\u503c\u7684\u6574\u6570\u6b21\u65b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2adouble\u7c7b\u578b\u7684\u6d6e\u70b9\u6570base\u548cint\u7c7b\u578b\u7684\u6574\u6570exponent\u3002\u6c42base\u7684exponent\u6b21\u65b9\u3002\u4fdd\u8bc1base\u548cexponent\u4e0d\u540c\u65f6\u4e3a0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a double Power ( double base , int exponent ) { if ( exponent == 0 ) { return 1 ; } double res = 1.0 ; bool isNegative = false ; if ( exponent < 0 ) { exponent = - exponent ; isNegative = true ; } while ( exponent -- ) { res *= base ; } if ( isNegative ) { return 1 / res ; } return res ; } }; 13. \u8c03\u6574\u6570\u7ec4\u987a\u5e8f\u4f7f\u5947\u6570\u4f4d\u4e8e\u5076\u6570\u524d\u9762 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6765\u8c03\u6574\u8be5\u6570\u7ec4\u4e2d\u6570\u5b57\u7684\u987a\u5e8f\uff0c\u4f7f\u5f97\u6240\u6709\u7684\u5947\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u524d\u534a\u90e8\u5206\uff0c\u6240\u6709\u7684\u5076\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u540e\u534a\u90e8\u5206\uff0c\u5e76\u4fdd\u8bc1\u5947\u6570\u548c\u5947\u6570\uff0c\u5076\u6570\u548c\u5076\u6570\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a void reOrderArray ( vector < int > & array ) { vector < int > odd , even ; int n = int ( array . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] % 2 ) { odd . push_back ( array [ i ]); } else { even . push_back ( array [ i ]); } } for ( int i = 0 , j = 0 ; i < int ( odd . size ()); i ++ , j ++ ) { array [ j ] = odd [ i ]; } for ( int i = 0 , j = int ( odd . size ()); i < int ( even . size ()); i ++ , j ++ ) { array [ j ] = even [ i ]; } } }; 14. \u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u8f93\u51fa\u8be5\u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindKthToTail ( ListNode * pListHead , unsigned int k ) { if ( k <= 0 ) { return NULL ; } ListNode * p1 = pListHead , * p2 = pListHead ; for ( int i = 0 ; i < k ; i ++ ) { if ( p2 == NULL ) { return p2 ; } p2 = p2 -> next ; } while ( p2 != NULL ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } }; 15. \u53cd\u8f6c\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u53cd\u8f6c\u94fe\u8868\u540e\uff0c\u8f93\u51fa\u65b0\u94fe\u8868\u7684\u8868\u5934\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * ReverseList ( ListNode * pHead ) { if ( pHead == NULL || pHead -> next == NULL ) { return pHead ; } ListNode * p1 = NULL , * p2 = pHead , * p3 = pHead -> next ; while ( p3 != NULL ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; p3 = p3 -> next ; } p2 -> next = p1 ; return p2 ; } }; 16. \u5408\u5e76\u4e24\u4e2a\u6392\u5e8f\u7684\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u5355\u8c03\u9012\u589e\u7684\u94fe\u8868\uff0c\u8f93\u51fa\u4e24\u4e2a\u94fe\u8868\u5408\u6210\u540e\u7684\u94fe\u8868\uff0c\u5f53\u7136\u6211\u4eec\u9700\u8981\u5408\u6210\u540e\u7684\u94fe\u8868\u6ee1\u8db3\u5355\u8c03\u4e0d\u51cf\u89c4\u5219\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * Merge ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL ) { return pHead2 ; } if ( pHead2 == NULL ) { return pHead1 ; } ListNode * head = new ListNode ( 0 ); ListNode * cur = head , * p1 = pHead1 , * p2 = pHead2 ; while ( p1 != NULL && p2 != NULL ) { if ( p1 -> val < p2 -> val ) { cur -> next = p1 ; cur = p1 ; p1 = p1 -> next ; } else { cur -> next = p2 ; cur = p2 ; p2 = p2 -> next ; } } if ( p1 != NULL ) { cur -> next = p1 ; } if ( p2 != NULL ) { cur -> next = p2 ; } return head -> next ; } }; 17. \u6811\u7684\u5b50\u7ed3\u6784 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u68f5\u4e8c\u53c9\u6811A\uff0cB\uff0c\u5224\u65adB\u662f\u4e0d\u662fA\u7684\u5b50\u7ed3\u6784\u3002\uff08ps\uff1a\u6211\u4eec\u7ea6\u5b9a\u7a7a\u6811\u4e0d\u662f\u4efb\u610f\u4e00\u4e2a\u6811\u7684\u5b50\u7ed3\u6784\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a bool HasSubtree ( TreeNode * pRoot1 , TreeNode * pRoot2 ) { if ( pRoot1 == NULL || pRoot2 == NULL ) { return false ; } queue < TreeNode *> qTree ; qTree . push ( pRoot1 ); TreeNode * front = pRoot1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> val == pRoot2 -> val && isSame ( front , pRoot2 )) { return true ; } if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return false ; } bool isSame ( TreeNode * t1 , TreeNode * t2 ) { if ( t2 == NULL ) { return true ; } if ( t1 == NULL || t1 -> val != t2 -> val ) { return false ; } return isSame ( t1 -> left , t2 -> left ) && isSame ( t1 -> right , t2 -> right ); } }; 18. \u4e8c\u53c9\u6811\u7684\u955c\u50cf \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u64cd\u4f5c\u7ed9\u5b9a\u7684\u4e8c\u53c9\u6811\uff0c\u5c06\u5176\u53d8\u6362\u4e3a\u6e90\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a void Mirror ( TreeNode * pRoot ) { if ( pRoot != NULL ) { Mirror ( pRoot -> left ); Mirror ( pRoot -> right ); TreeNode * temp = pRoot -> left ; pRoot -> left = pRoot -> right ; pRoot -> right = temp ; } } }; 19. \u987a\u65f6\u9488\u6253\u5370\u77e9\u9635 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u77e9\u9635\uff0c\u6309\u7167\u4ece\u5916\u5411\u91cc\u4ee5\u987a\u65f6\u9488\u7684\u987a\u5e8f\u4f9d\u6b21\u6253\u5370\u51fa\u6bcf\u4e00\u4e2a\u6570\u5b57\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u5982\u4e0b4 X 4\u77e9\u9635\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u5219\u4f9d\u6b21\u6253\u5370\u51fa\u6570\u5b571,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public \uff1a vector < int > printMatrix ( vector < vector < int > > matrix ) { vector < int > res ; int nRows = int ( matrix . size ()); if ( nRows == 0 ) { return res ; } int nCols = int ( matrix [ 0 ]. size ()); if ( nCols == 0 ) { return res ; } bool ** dp = new bool * [ nRows ]; for ( int i = 0 ; i < nRows ; i ++ ) { dp [ i ] = new bool [ nCols ]{}; } int i = 0 , j = 0 ; int di [ 4 ] = { 0 , 1 , 0 , - 1 }, dj [ 4 ] = { 1 , 0 , - 1 , 0 }; while ( true ) { bool updated = false ; for ( int k = 0 ; k < 4 ; k ++ ) { while ( isOk ( dp , i + di [ k ], j + dj [ k ], nRows , nCols )) { res . push_back ( matrix [ i ][ j ]); dp [ i ][ j ] = true ; updated = true ; i += di [ k ]; j += dj [ k ]; } } if ( ! updated ) { res . push_back ( matrix [ i ][ j ]); break ; } } for ( i = 0 ; i < nRows ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } bool isOk ( bool ** isVisited , int i , int j , int nRows , int nCols ) { if ( i < 0 || i >= nRows || j < 0 || j >= nCols || isVisited [ i ][ j ]) { return false ; } return true ; } }; 20. \u5305\u542bmin\u51fd\u6570\u7684\u6808* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5b9a\u4e49\u6808\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8bf7\u5728\u8be5\u7c7b\u578b\u4e2d\u5b9e\u73b0\u4e00\u4e2a\u80fd\u591f\u5f97\u5230\u6808\u4e2d\u6240\u542b\u6700\u5c0f\u5143\u7d20\u7684min\u51fd\u6570\uff08\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u4e3aO\uff081\uff09\uff09\u3002\u6ce8\u610f\uff1a\u4fdd\u8bc1\u6d4b\u8bd5\u4e2d\u4e0d\u4f1a\u5f53\u6808\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u5bf9\u6808\u8c03\u7528pop()\u6216\u8005min()\u6216\u8005top()\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { stack < int > s1 ; stack < int > s2 ; public \uff1a void push ( int value ) { s1 . push ( value ); if ( s2 . empty () || value < s2 . top ()) { s2 . push ( value ); } else { s2 . push ( s2 . top ()); } } void pop () { s1 . pop (); s2 . pop (); } int top () { return s1 . top (); } int min () { return s2 . top (); } }; 21. \u6808\u7684\u538b\u5165\u3001\u5f39\u51fa\u5e8f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u7b2c\u4e00\u4e2a\u5e8f\u5217\u8868\u793a\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u8bf7\u5224\u65ad\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u662f\u5426\u53ef\u80fd\u4e3a\u8be5\u6808\u7684\u5f39\u51fa\u987a\u5e8f\u3002\u5047\u8bbe\u538b\u5165\u6808\u7684\u6240\u6709\u6570\u5b57\u5747\u4e0d\u76f8\u7b49\u3002\u4f8b\u5982\u5e8f\u52171,2,3,4,5\u662f\u67d0\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u5e8f\u52174,5,3,2,1\u662f\u8be5\u538b\u6808\u5e8f\u5217\u5bf9\u5e94\u7684\u4e00\u4e2a\u5f39\u51fa\u5e8f\u5217\uff0c\u4f464,3,5,1,2\u5c31\u4e0d\u53ef\u80fd\u662f\u8be5\u538b\u6808\u5e8f\u5217\u7684\u5f39\u51fa\u5e8f\u5217\u3002\uff08\u6ce8\u610f\uff1a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u957f\u5ea6\u662f\u76f8\u7b49\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a bool IsPopOrder ( vector < int > pushV , vector < int > popV ) { int n = int ( pushV . size ()); stack < int > st ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pushV [ i ] == popV [ j ]) { j ++ ; } else { st . push ( pushV [ i ]); } } for (; j < n ; j ++ ) { if ( st . empty () || st . top () != popV [ j ]) { return false ; } st . pop (); } return true ; } }; 22. \u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u540c\u5c42\u8282\u70b9\u4ece\u5de6\u81f3\u53f3\u6253\u5370\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < int > PrintFromTopToBottom ( TreeNode * root ) { vector < int > res ; if ( root == NULL ) { return res ; } TreeNode * front = root ; queue < TreeNode *> qTree ; qTree . push ( root ); while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); res . push_back ( front -> val ); if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return res ; } }; 23. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5224\u65ad\u8be5\u6570\u7ec4\u662f\u4e0d\u662f\u67d0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002\u5982\u679c\u662f\u5219\u8f93\u51faYes,\u5426\u5219\u8f93\u51faNo\u3002\u5047\u8bbe\u8f93\u5165\u7684\u6570\u7ec4\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u4e92\u4e0d\u76f8\u540c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a bool VerifySquenceOfBST ( vector < int > sequence ) { int n = int ( sequence . size ()); if ( n == 0 ) { return false ; } return isPostOrder ( sequence , 0 , n - 1 ); } bool isPostOrder ( vector < int > arr , int b , int e ) { if ( b >= e ) { return true ; } int idx = b ; for (; idx <= e ; idx ++ ) { if ( arr [ idx ] >= arr [ e ]) { break ; } } for ( int i = idx ; i < e ; i ++ ) { if ( arr [ i ] < arr [ e ]) { return false ; } } return isPostOrder ( arr , b , idx - 1 ) && isPostOrder ( arr , idx , e - 1 ); } }; 24. \u4e8c\u53c9\u6811\u4e2d\u548c\u4e3a\u67d0\u4e00\u503c\u7684\u8def\u5f84 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9\u548c\u4e00\u4e2a\u6574\u6570\uff0c\u6309\u5b57\u5178\u5e8f\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u503c\u7684\u548c\u4e3a\u8f93\u5165\u6574\u6570\u7684\u6240\u6709\u8def\u5f84\u3002\u8def\u5f84\u5b9a\u4e49\u4e3a\u4ece\u6811\u7684\u6839\u7ed3\u70b9\u5f00\u59cb\u5f80\u4e0b\u4e00\u76f4\u5230\u53f6\u7ed3\u70b9\u6240\u7ecf\u8fc7\u7684\u7ed3\u70b9\u5f62\u6210\u4e00\u6761\u8def\u5f84\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int > > paths ; if ( root == NULL ) { return paths ; } vector < int > path ; stack < TreeNode *> s ; int size = 0 , sum = 0 ; TreeNode * cur = root ; while ( true ) { while ( cur -> left != NULL || cur -> right != NULL ) { s . push ( cur ); path . push_back ( cur -> val ); size ++ ; sum += cur -> val ; if ( cur -> left != NULL ) { cur = cur -> left ; } else { cur = cur -> right ; } } if ( sum + cur -> val == expectNumber ) { path . push_back ( cur -> val ); paths . push_back ( path ); } while ( ! s . empty () && ( s . top () -> left == NULL || s . top () -> right == NULL || s . top () -> right == cur )) { cur = s . top (); s . pop (); sum -= cur -> val ; size -- ; } if ( s . empty ()) { break ; } cur = s . top () -> right ; path . resize ( size ); } return paths ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int >> res ; if ( root == NULL ) { return res ; } vector < int > arr ; path ( root , expectNumber , res , arr , 0 ); return res ; } void path ( TreeNode * root , int target , vector < vector < int >> & res , vector < int > & arr , int sum ) { if ( root == NULL ) { return ; } arr . push_back ( root -> val ); if ( root -> left == NULL && root -> right == NULL && sum + root -> val == target ) { res . push_back ( arr ); } else { path ( root -> left , target , res , arr , sum + root -> val ); path ( root -> right , target , res , arr , sum + root -> val ); } arr . resize ( arr . size () - 1 ); } }; 25. \u590d\u6742\u94fe\u8868\u7684\u590d\u5236* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u590d\u6742\u94fe\u8868\uff08\u6bcf\u4e2a\u8282\u70b9\u4e2d\u6709\u8282\u70b9\u503c\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u7279\u6b8a\u6307\u9488random\u6307\u5411\u4e00\u4e2a\u968f\u673a\u8282\u70b9\uff09\uff0c\u8bf7\u5bf9\u6b64\u94fe\u8868\u8fdb\u884c\u6df1\u62f7\u8d1d\uff0c\u5e76\u8fd4\u56de\u62f7\u8d1d\u540e\u7684\u5934\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\uff0c\u8f93\u51fa\u7ed3\u679c\u4e2d\u8bf7\u4e0d\u8981\u8fd4\u56de\u53c2\u6570\u4e2d\u7684\u8282\u70b9\u5f15\u7528\uff0c\u5426\u5219\u5224\u9898\u7a0b\u5e8f\u4f1a\u76f4\u63a5\u8fd4\u56de\u7a7a\uff09 Solution\uff1aWe copy each node to append itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) \uff1a label(x), next(NULL), random(NULL) { } }; */ class Solution { public \uff1a RandomListNode * Clone ( RandomListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } RandomListNode * p1 = pHead ; while ( p1 != NULL ) { RandomListNode * temp = new RandomListNode ( p1 -> label ); temp -> next = p1 -> next ; p1 -> next = temp ; p1 = p1 -> next -> next ; } p1 = pHead ; while ( p1 != NULL ) { if ( p1 -> random != NULL ) { p1 -> next -> random = p1 -> random -> next ; } p1 = p1 -> next -> next ; } RandomListNode * head = pHead -> next , * p2 = pHead -> next ; p1 = pHead ; while ( p1 != NULL ) { p1 -> next = p2 -> next ; if ( p2 -> next != NULL ) { p2 -> next = p2 -> next -> next ; } p1 = p1 -> next ; p2 = p2 -> next ; } return head ; } }; 26. \u4e8c\u53c9\u641c\u7d22\u6811\u4e0e\u53cc\u5411\u94fe\u8868 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5c06\u8be5\u4e8c\u53c9\u641c\u7d22\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u6392\u5e8f\u7684\u53cc\u5411\u94fe\u8868\u3002\u8981\u6c42\u4e0d\u80fd\u521b\u5efa\u4efb\u4f55\u65b0\u7684\u7ed3\u70b9\uff0c\u53ea\u80fd\u8c03\u6574\u6811\u4e2d\u7ed3\u70b9\u6307\u9488\u7684\u6307\u5411\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } postOrder ( pRootOfTree ); TreeNode * head = pRootOfTree ; while ( head -> left != NULL ) { head = head -> left ; } return head ; } void postOrder ( TreeNode * root ) { if ( root != NULL ) { postOrder ( root -> left ); postOrder ( root -> right ); TreeNode * left = root -> left ; while ( left != NULL && left -> right != NULL ) { left = left -> right ; } root -> left = left ; if ( left != NULL ) { left -> right = root ; } TreeNode * right = root -> right ; while ( right != NULL && right -> left != NULL ) { right = right -> left ; } root -> right = right ; if ( right != NULL ) { right -> left = root ; } } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } TreeNode * head = pRootOfTree , * leftMost = NULL ; inOrder ( pRootOfTree , leftMost ); while ( head -> left != NULL ) { head = head -> left ; } return head ; } void inOrder ( TreeNode * root , TreeNode *& leftMost ) { if ( root != NULL ) { inOrder ( root -> left , leftMost ); if ( leftMost == NULL ) { leftMost = root ; } else { leftMost -> right = root ; root -> left = leftMost ; leftMost = root ; } inOrder ( root -> right , leftMost ); } } }; 28. \u6570\u7ec4\u4e2d\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4{1,2,3,2,2,2,5,4,2}\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u5982\u679c\u4e0d\u5b58\u5728\u5219\u8f93\u51fa0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i - 1 ); quickSort ( arr , j + 1 , end ); } } int MoreThanHalfNum_Solution ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return numbers [ 0 ]; } quickSort ( numbers , 0 , n - 1 ); if ( n % 2 && numbers [ n / 2 ] != numbers [ n / 2 - 1 ]) { return 0 ; } int res = numbers [ n / 2 ]; int count = 1 ; int pos = n / 2 - 1 ; while ( pos >= 0 ) { if ( numbers [ pos ] != res ) { break ; } pos -- ; count ++ ; } pos = n / 2 + 1 ; while ( pos < n ) { if ( numbers [ pos ] != res ) { break ; } pos ++ ; count ++ ; } if ( count > n / 2 ) { return res ; } return 0 ; } }; 29. \u6700\u5c0f\u7684K\u4e2a\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165n\u4e2a\u6574\u6570\uff0c\u627e\u51fa\u5176\u4e2d\u6700\u5c0f\u7684K\u4e2a\u6570\u3002\u4f8b\u5982\u8f93\u51654,5,1,6,2,7,3,8\u8fd98\u4e2a\u6570\u5b57\uff0c\u5219\u6700\u5c0f\u76844\u4e2a\u6570\u5b57\u662f1,2,3,4,\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i - 1 ); quickSort ( arr , j + 1 , end ); } } vector < int > GetLeastNumbers_Solution ( vector < int > input , int k ) { int n = int ( input . size ()); vector < int > res ; if ( n == 0 || k <= 0 || k > n ) { return res ; } quickSort ( input , 0 , n - 1 ); input . resize ( k ); return input ; } }; 31. \u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1\u5230n\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6c42\u51fa1-13\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570,\u5e76\u7b97\u51fa100~1300\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff1f\u4e3a\u6b64\u4ed6\u7279\u522b\u6570\u4e86\u4e00\u4e0b1-13\u4e2d\u5305\u542b1\u7684\u6570\u5b57\u67091\u300110\u300111\u300112\u300113\u56e0\u6b64\u5171\u51fa\u73b06\u6b21,\u4f46\u662f\u5bf9\u4e8e\u540e\u9762\u95ee\u9898\u4ed6\u5c31\u6ca1\u8f99\u4e86\u3002ACMer\u5e0c\u671b\u4f60\u4eec\u5e2e\u5e2e\u4ed6,\u5e76\u628a\u95ee\u9898\u66f4\u52a0\u666e\u904d\u5316,\u53ef\u4ee5\u5f88\u5feb\u7684\u6c42\u51fa\u4efb\u610f\u975e\u8d1f\u6574\u6570\u533a\u95f4\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1 \u5230 n \u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09\u3002 Solution\uff1aTake 2593 as an example, how many '5' does it contain? i = 1, Quotient = 2593 / (10 * i) = 258, Mod = 2593 % (10 * i) = 3. Number of '5'\uff1a 259 * i + (3 > 5) * i = 259. i = 10, Quotient = 2593 / (10 * i) = 25, Mod = 2593 % (10 * i) = 93. Number of '5'\uff1a 25 * i + (9 > 5) * i = 260. i = 100, Quotient = 2593 / (10 * i) = 2, Mod = 2593 % (10 * i) = 593. Number of '5'\uff1a 2 * i + (5 == 5) * (93 + 1) = 294. i = 1000, Quotient = 2593 / (10 * i) = 0 end.Total number of '5'\uff1a 259 + 260 + 294 = 813. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { res += count1 ( i ); } return res ; } int count1 ( int num ) { int res = 0 ; while ( num ) { if ( num % 10 == 1 ) { res ++ ; } num /= 10 ; } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int count = 0 , digit = 1 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int a = n / ( 10 * i ), b = n % ( 10 * i ); count += a * i ; if ( b / i > digit ) { count += i ; } if ( b / i == digit ) { count += b % i + 1 ; } } return count ; } }; 33. \u4e11\u6570* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u53ea\u5305\u542b\u8d28\u56e0\u5b502\u30013\u548c5\u7684\u6570\u79f0\u4f5c\u4e11\u6570\uff08Ugly Number\uff09\u3002\u4f8b\u59826\u30018\u90fd\u662f\u4e11\u6570\uff0c\u4f4614\u4e0d\u662f\uff0c\u56e0\u4e3a\u5b83\u5305\u542b\u8d28\u56e0\u5b507\u3002 \u4e60\u60ef\u4e0a\u6211\u4eec\u628a1\u5f53\u505a\u662f\u7b2c\u4e00\u4e2a\u4e11\u6570\u3002\u6c42\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u7684\u7b2cN\u4e2a\u4e11\u6570\u3002 Solution\uff1aUgly numbers\uff1a 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15...Some ugly number is from a multiplaction of previous number by 2, 3 or 5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a int min ( int a , int b , int c ) { int temp = a < b ? a \uff1a b ; return temp < c ? temp \uff1a c ; } int GetUglyNumber_Solution ( int index ) { if ( index < 2 ) { return index ; } int * arr = new int [ index ]{}; arr [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < index ; i ++ ) { arr [ i ] = min ( arr [ f2 ] * 2 , arr [ f3 ] * 3 , arr [ f5 ] * 5 ); while ( arr [ f2 ] * 2 <= arr [ i ]) { f2 ++ ; } while ( arr [ f3 ] * 3 <= arr [ i ]) { f3 ++ ; } while ( arr [ f5 ] * 5 <= arr [ i ]) { f5 ++ ; } } int res = arr [ index - 1 ]; delete [] arr ; return res ; } }; 34. \u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u4f4d\u7f6e \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u5b57\u7b26\u4e32(0<=\u5b57\u7b26\u4e32\u957f\u5ea6<=10000\uff0c\u5168\u90e8\u7531\u5b57\u6bcd\u7ec4\u6210)\u4e2d\u627e\u5230\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26,\u5e76\u8fd4\u56de\u5b83\u7684\u4f4d\u7f6e, \u5982\u679c\u6ca1\u6709\u5219\u8fd4\u56de -1\uff08\u9700\u8981\u533a\u5206\u5927\u5c0f\u5199\uff09.\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a int FirstNotRepeatingChar ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return - 1 ; } int N = 256 , pos = n + 1 ; int * ascii = new int [ N ]{}; for ( int i = 0 ; i < n ; i ++ ) { int id = int ( str [ i ]); if ( ascii [ id ] == 0 ) { ascii [ id ] = i + 1 ; } else { ascii [ id ] = - 1 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] > 0 && ascii [ i ] < pos ) { pos = ascii [ i ]; } } delete [] ascii ; if ( pos == n + 1 ) { return - 1 ; } return pos - 1 ; } }; 35. \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4,\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570P\u3002\u5e76\u5c06P\u5bf91000000007\u53d6\u6a21\u7684\u7ed3\u679c\u8f93\u51fa\u3002 \u5373\u8f93\u51faP%1000000007 \u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u7684\u6570\u7ec4\u4e2d\u6ca1\u6709\u7684\u76f8\u540c\u7684\u6570\u5b57\u6570\u636e\u8303\u56f4\uff1a\u5bf9\u4e8e%50\u7684\u6570\u636e,size<=10 4\u5bf9\u4e8e%75\u7684\u6570\u636e,size<=10 5\u5bf9\u4e8e%100\u7684\u6570\u636e,size<=2*10^5 \u8f93\u51651,2,3,4,5,6,7,0\u8f93\u51fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public \uff1a int InversePairs ( vector < int > data ) { int n = int ( data . size ()); if ( n < 2 ) { return 0 ; } long count = 0 ; mergeSort ( data , 0 , n - 1 , count ); return ( count % 1000000007 ); } void mergeSort ( vector < int > & arr , int b , int e , long & count ) { if ( b >= e ) { return ; } int m = ( b + e ) / 2 ; mergeSort ( arr , b , m , count ); mergeSort ( arr , m + 1 , e , count ); merge ( arr , b , m , e , count ); } void merge ( vector < int > & arr , int b , int m , int e , long & count ) { int * temp = new int [ e - b + 1 ]{}; int i = b , j = m + 1 , right = 0 , pos = 0 ; while ( i <= m && j <= e ) { if ( arr [ i ] < arr [ j ]) { temp [ pos ++ ] = arr [ i ++ ]; count += right ; } else { temp [ pos ++ ] = arr [ j ++ ]; right ++ ; } } count += ( m - i + 1 ) * right ; while ( i <= m ) { temp [ pos ++ ] = arr [ i ++ ]; } while ( j <= e ) { temp [ pos ++ ] = arr [ j ++ ]; } for ( int i = b ; i <= e ; i ++ ) { arr [ i ] = temp [ i - b ]; } delete [] temp ; } }; 36. \u4e24\u4e2a\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u94fe\u8868\uff0c\u627e\u51fa\u5b83\u4eec\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\u56e0\u4e3a\u4f20\u5165\u6570\u636e\u662f\u94fe\u8868\uff0c\u6240\u4ee5\u9519\u8bef\u6d4b\u8bd5\u6570\u636e\u7684\u63d0\u793a\u662f\u7528\u5176\u4ed6\u65b9\u5f0f\u663e\u793a\u7684\uff0c\u4fdd\u8bc1\u4f20\u5165\u6570\u636e\u662f\u6b63\u786e\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindFirstCommonNode ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL || pHead2 == NULL ) { return NULL ; } ListNode * p1 = pHead1 , * p2 = pHead2 ; stack < ListNode *> s1 , s2 ; while ( p1 != NULL ) { s1 . push ( p1 ); p1 = p1 -> next ; } while ( p2 != NULL ) { s2 . push ( p2 ); p2 = p2 -> next ; } while ( ! s1 . empty () && ! s2 . empty ()) { if ( s1 . top () != s2 . top ()) { return s1 . top () -> next ; } s1 . pop (); s2 . pop (); } if ( s1 . empty ()) { return pHead1 ; } if ( s2 . empty ()) { return pHead2 ; } return s1 . top () -> next ; } }; 37. \u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7edf\u8ba1\u4e00\u4e2a\u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 class Solution { public \uff1a int GetNumberOfK ( vector < int > data , int k ) { int count = 0 ; for ( int i = 0 ; i < int ( data . size ()); i ++ ) { if ( data [ i ] == k ) { count ++ ; } } return count ; } }; 38. \u4e8c\u53c9\u6811\u7684\u6df1\u5ea6 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6c42\u8be5\u6811\u7684\u6df1\u5ea6\u3002\u4ece\u6839\u7ed3\u70b9\u5230\u53f6\u7ed3\u70b9\u4f9d\u6b21\u7ecf\u8fc7\u7684\u7ed3\u70b9\uff08\u542b\u6839\u3001\u53f6\u7ed3\u70b9\uff09\u5f62\u6210\u6811\u7684\u4e00\u6761\u8def\u5f84\uff0c\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6\u4e3a\u6811\u7684\u6df1\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int dep = 0 ; queue < TreeNode *> qTree ; qTree . push ( pRoot ); TreeNode * front = pRoot , * last = pRoot , * nextLast = pRoot ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> left != NULL ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != NULL ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { dep ++ ; last = nextLast ; } } return dep ; } }; ``` C ++ /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int leftDep = TreeDepth ( pRoot -> left ); int rightDep = TreeDepth ( pRoot -> right ); return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } }; 39. \u5e73\u8861\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u5224\u65ad\u8be5\u4e8c\u53c9\u6811\u662f\u5426\u662f\u5e73\u8861\u4e8c\u53c9\u6811\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8003\u8651\u5176\u5e73\u8861\u6027\uff0c\u4e0d\u9700\u8981\u8003\u8651\u5176\u662f\u4e0d\u662f\u6392\u5e8f\u4e8c\u53c9\u6811\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a bool IsBalanced_Solution ( TreeNode * pRoot ) { bool res = true ; postOrder ( pRoot , res ); return res ; } int postOrder ( TreeNode * root , bool & res ) { if ( root == NULL ) { return 0 ; } int leftDep = postOrder ( root -> left , res ); int rightDep = postOrder ( root -> right , res ); int diff = abs ( leftDep - rightDep ); if ( diff > 1 ) { res = false ; } return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } }; 40. \u6570\u7ec4\u4e2d\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\u91cc\u9664\u4e86\u4e24\u4e2a\u6570\u5b57\u4e4b\u5916\uff0c\u5176\u4ed6\u7684\u6570\u5b57\u90fd\u51fa\u73b0\u4e86\u4e24\u6b21\u3002\u8bf7\u5199\u7a0b\u5e8f\u627e\u51fa\u8fd9\u4e24\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57\u3002 Solution\uff1anum XOR num = 0\uff1a one number XOR itself is 0.We XOR all entire array to get a result of the two single numbers. Then locate the first 1's position, e.g. 6 = 0110, first 1's position is 2 (starting 0 from right to left). We classify the array into two parts by checking if one integer is 1 at its first 1's position. Then do XOR once again for the two parts to find the two single numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a void FindNumsAppearOnce ( vector < int > data , int * num1 , int * num2 ) { int n = int ( data . size ()); if ( n < 2 ) { return ; } int XOR = 0 , pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR ^= data [ i ]; } while ( XOR >> 1 ) { XOR = XOR >> 1 ; pos ++ ; } bool is1Ok = false , is2Ok = false ; int n1 = 0 , n2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if (( data [ i ] >> pos ) & 1 ) { if ( is1Ok ) { n1 ^= data [ i ]; } else { is1Ok = true ; n1 = data [ i ]; } } else { if ( is2Ok ) { n2 ^= data [ i ]; } else { is2Ok = true ; n2 = data [ i ]; } } * num1 = n1 < n2 ? n1 \uff1a n2 ; * num2 = n1 >= n2 ? n1 \uff1a n2 ; } } }; 41. \u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5c0f\u660e\u5f88\u559c\u6b22\u6570\u5b66,\u6709\u4e00\u5929\u4ed6\u5728\u505a\u6570\u5b66\u4f5c\u4e1a\u65f6,\u8981\u6c42\u8ba1\u7b97\u51fa9~16\u7684\u548c,\u4ed6\u9a6c\u4e0a\u5c31\u5199\u51fa\u4e86\u6b63\u786e\u7b54\u6848\u662f100\u3002\u4f46\u662f\u4ed6\u5e76\u4e0d\u6ee1\u8db3\u4e8e\u6b64,\u4ed6\u5728\u60f3\u7a76\u7adf\u6709\u591a\u5c11\u79cd\u8fde\u7eed\u7684\u6b63\u6570\u5e8f\u5217\u7684\u548c\u4e3a100(\u81f3\u5c11\u5305\u62ec\u4e24\u4e2a\u6570)\u3002\u6ca1\u591a\u4e45,\u4ed6\u5c31\u5f97\u5230\u53e6\u4e00\u7ec4\u8fde\u7eed\u6b63\u6570\u548c\u4e3a100\u7684\u5e8f\u5217\uff1a18,19,20,21,22\u3002\u73b0\u5728\u628a\u95ee\u9898\u4ea4\u7ed9\u4f60,\u4f60\u80fd\u4e0d\u80fd\u4e5f\u5f88\u5feb\u7684\u627e\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217? Good Luck!\u8f93\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217\u3002\u5e8f\u5217\u5185\u6309\u7167\u4ece\u5c0f\u81f3\u5927\u7684\u987a\u5e8f\uff0c\u5e8f\u5217\u95f4\u6309\u7167\u5f00\u59cb\u6570\u5b57\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < vector < int > > FindContinuousSequence ( int sum ) { vector < vector < int >> res ; if ( sum < 3 ) { return res ; } for ( int n = sum ; n >= 2 ; n -- ) { int numerator = 2 * sum + n - n * n ; int denominator = 2 * n ; if ( numerator % denominator == 0 ) { int a = numerator / denominator ; if ( a < 1 ) { continue ; } vector < int > arr ; for ( int i = a ; i <= a + n - 1 ; i ++ ) { arr . push_back ( i ); } res . push_back ( arr ); } } return res ; } }; 42. \u548c\u4e3aS\u7684\u4e24\u4e2a\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u9012\u589e\u6392\u5e8f\u7684\u6570\u7ec4\u548c\u4e00\u4e2a\u6570\u5b57S\uff0c\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u4e24\u4e2a\u6570\uff0c\u4f7f\u5f97\u4ed6\u4eec\u7684\u548c\u6b63\u597d\u662fS\uff0c\u5982\u679c\u6709\u591a\u5bf9\u6570\u5b57\u7684\u548c\u7b49\u4e8eS\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\u7684\u4e58\u79ef\u6700\u5c0f\u7684\u3002\u5bf9\u5e94\u6bcf\u4e2a\u6d4b\u8bd5\u6848\u4f8b\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\uff0c\u5c0f\u7684\u5148\u8f93\u51fa\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < int > FindNumbersWithSum ( vector < int > array , int sum ) { vector < int > res ; int n = int ( array . size ()); if ( n == 0 ) { return res ; } int i = 0 , j = n - 1 ; while ( i < j ) { if ( array [ i ] + array [ j ] < sum ) { i ++ ; } else if ( array [ i ] + array [ j ] > sum ) { j -- ; } else { res . push_back ( array [ i ]); res . push_back ( array [ j ]); break ; } } return res ; } }; 43. \u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6c47\u7f16\u8bed\u8a00\u4e2d\u6709\u4e00\u79cd\u79fb\u4f4d\u6307\u4ee4\u53eb\u505a\u5faa\u73af\u5de6\u79fb\uff08ROL\uff09\uff0c\u73b0\u5728\u6709\u4e2a\u7b80\u5355\u7684\u4efb\u52a1\uff0c\u5c31\u662f\u7528\u5b57\u7b26\u4e32\u6a21\u62df\u8fd9\u4e2a\u6307\u4ee4\u7684\u8fd0\u7b97\u7ed3\u679c\u3002\u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5b57\u7b26\u5e8f\u5217S\uff0c\u8bf7\u4f60\u628a\u5176\u5faa\u73af\u5de6\u79fbK\u4f4d\u540e\u7684\u5e8f\u5217\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u5e8f\u5217S=\u201dabcXYZdef\u201d,\u8981\u6c42\u8f93\u51fa\u5faa\u73af\u5de6\u79fb3\u4f4d\u540e\u7684\u7ed3\u679c\uff0c\u5373\u201cXYZdefabc\u201d\u3002\u662f\u4e0d\u662f\u5f88\u7b80\u5355\uff1fOK\uff0c\u641e\u5b9a\u5b83\uff01 1 2 3 4 5 6 7 8 9 10 class Solution { public \uff1a string LeftRotateString ( string str , int n ) { int len = int ( str . length ()); if ( len == 0 || n == 0 || len <= n ) { return str ; } string firtN ( str , 0 , n ); string rest ( str , n , len ); return rest + firtN ; } }; 44. \u7ffb\u8f6c\u5355\u8bcd\u987a\u5e8f\u5217 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u725b\u5ba2\u6700\u8fd1\u6765\u4e86\u4e00\u4e2a\u65b0\u5458\u5de5Fish\uff0c\u6bcf\u5929\u65e9\u6668\u603b\u662f\u4f1a\u62ff\u7740\u4e00\u672c\u82f1\u6587\u6742\u5fd7\uff0c\u5199\u4e9b\u53e5\u5b50\u5728\u672c\u5b50\u4e0a\u3002\u540c\u4e8bCat\u5bf9Fish\u5199\u7684\u5185\u5bb9\u9887\u611f\u5174\u8da3\uff0c\u6709\u4e00\u5929\u4ed6\u5411Fish\u501f\u6765\u7ffb\u770b\uff0c\u4f46\u5374\u8bfb\u4e0d\u61c2\u5b83\u7684\u610f\u601d\u3002\u4f8b\u5982\uff0c\u201cstudent. a am I\u201d\u3002\u540e\u6765\u624d\u610f\u8bc6\u5230\uff0c\u8fd9\u5bb6\u4f19\u539f\u6765\u628a\u53e5\u5b50\u5355\u8bcd\u7684\u987a\u5e8f\u7ffb\u8f6c\u4e86\uff0c\u6b63\u786e\u7684\u53e5\u5b50\u5e94\u8be5\u662f\u201cI am a student.\u201d\u3002Cat\u5bf9\u4e00\u4e00\u7684\u7ffb\u8f6c\u8fd9\u4e9b\u5355\u8bcd\u987a\u5e8f\u53ef\u4e0d\u5728\u884c\uff0c\u4f60\u80fd\u5e2e\u52a9\u4ed6\u4e48\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } string res = \"\" , word = \"\" ; stack < string > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { s . push ( word ); word = \"\" ; continue ; } word . push_back ( str [ i ]); } s . push ( word ); while ( ! s . empty ()) { res += s . top (); s . pop (); if ( ! s . empty ()) { res . push_back ( ' ' ); } } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { char temp = str [ i ]; str [ i ] = str [ n - 1 - i ]; str [ n - 1 - i ] = temp ; } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int n = i - 1 , m = j ; while ( m < n ) { char temp = str [ m ]; str [ m ] = str [ n ]; str [ n ] = temp ; m ++ ; n -- ; } j = i + 1 ; } } str [ n ] = '\\0' ; return str ; } }; 45. \u6251\u514b\u724c\u987a\u5b50 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1aLL\u4eca\u5929\u5fc3\u60c5\u7279\u522b\u597d,\u56e0\u4e3a\u4ed6\u53bb\u4e70\u4e86\u4e00\u526f\u6251\u514b\u724c,\u53d1\u73b0\u91cc\u9762\u5c45\u7136\u67092\u4e2a\u5927\u738b,2\u4e2a\u5c0f\u738b(\u4e00\u526f\u724c\u539f\u672c\u662f54\u5f20 _ )...\u4ed6\u968f\u673a\u4ece\u4e2d\u62bd\u51fa\u4e865\u5f20\u724c,\u60f3\u6d4b\u6d4b\u81ea\u5df1\u7684\u624b\u6c14,\u770b\u770b\u80fd\u4e0d\u80fd\u62bd\u5230\u987a\u5b50,\u5982\u679c\u62bd\u5230\u7684\u8bdd,\u4ed6\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968,\u563f\u563f\uff01\uff01\u201c\u7ea2\u5fc3A,\u9ed1\u68433,\u5c0f\u738b,\u5927\u738b,\u65b9\u72475\u201d,\u201cOh My God!\u201d\u4e0d\u662f\u987a\u5b50.....LL\u4e0d\u9ad8\u5174\u4e86,\u4ed6\u60f3\u4e86\u60f3,\u51b3\u5b9a\u5927\\\u5c0f \u738b\u53ef\u4ee5\u770b\u6210\u4efb\u4f55\u6570\u5b57,\u5e76\u4e14A\u770b\u4f5c1,J\u4e3a11,Q\u4e3a12,K\u4e3a13\u3002\u4e0a\u9762\u76845\u5f20\u724c\u5c31\u53ef\u4ee5\u53d8\u6210\u201c1,2,3,4,5\u201d(\u5927\u5c0f\u738b\u5206\u522b\u770b\u4f5c2\u548c4),\u201cSo Lucky!\u201d\u3002LL\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968\u5566\u3002 \u73b0\u5728,\u8981\u6c42\u4f60\u4f7f\u7528\u8fd9\u5e45\u724c\u6a21\u62df\u4e0a\u9762\u7684\u8fc7\u7a0b,\u7136\u540e\u544a\u8bc9\u6211\u4eecLL\u7684\u8fd0\u6c14\u5982\u4f55\uff0c \u5982\u679c\u724c\u80fd\u7ec4\u6210\u987a\u5b50\u5c31\u8f93\u51fatrue\uff0c\u5426\u5219\u5c31\u8f93\u51fafalse\u3002\u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1,\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u5927\u5c0f\u738b\u662f0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public \uff1a bool IsContinuous ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } //sort(numbers.begin(), numbers.end()); quickSort ( numbers , 0 , n - 1 ); int num0 = 0 , head = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( numbers [ i ] == 0 ) { num0 ++ ; continue ; } if ( head == 0 ) { head = numbers [ i ]; } else { if ( numbers [ i ] == numbers [ i - 1 ]) { return false ; } if ( numbers [ i ] == head + 1 ) { head ++ ; } else { num0 -= numbers [ i ] - head - 1 ; if ( num0 < 0 ) { return false ; } head = numbers [ i ]; } } } return true ; } void quickSort ( vector < int > & arr , int b , int e ) { if ( b < e ) { int i = b , j = e ; while ( i < j ) { while ( i < j && arr [ i ] <= arr [ j ]) { j -- ; } swap ( arr , i , j ); while ( i < j && arr [ i ] <= arr [ j ]) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , b , i - 1 ); quickSort ( arr , j + 1 , e ); } } void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } }; 46. \u5b69\u5b50\u4eec\u7684\u6e38\u620f(\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6bcf\u5e74\u516d\u4e00\u513f\u7ae5\u8282,\u725b\u5ba2\u90fd\u4f1a\u51c6\u5907\u4e00\u4e9b\u5c0f\u793c\u7269\u53bb\u770b\u671b\u5b64\u513f\u9662\u7684\u5c0f\u670b\u53cb,\u4eca\u5e74\u4ea6\u662f\u5982\u6b64\u3002HF\u4f5c\u4e3a\u725b\u5ba2\u7684\u8d44\u6df1\u5143\u8001,\u81ea\u7136\u4e5f\u51c6\u5907\u4e86\u4e00\u4e9b\u5c0f\u6e38\u620f\u3002\u5176\u4e2d,\u6709\u4e2a\u6e38\u620f\u662f\u8fd9\u6837\u7684\uff1a\u9996\u5148,\u8ba9\u5c0f\u670b\u53cb\u4eec\u56f4\u6210\u4e00\u4e2a\u5927\u5708\u3002\u7136\u540e,\u4ed6\u968f\u673a\u6307\u5b9a\u4e00\u4e2a\u6570m,\u8ba9\u7f16\u53f7\u4e3a0\u7684\u5c0f\u670b\u53cb\u5f00\u59cb\u62a5\u6570\u3002\u6bcf\u6b21\u558a\u5230m-1\u7684\u90a3\u4e2a\u5c0f\u670b\u53cb\u8981\u51fa\u5217\u5531\u9996\u6b4c,\u7136\u540e\u53ef\u4ee5\u5728\u793c\u54c1\u7bb1\u4e2d\u4efb\u610f\u7684\u6311\u9009\u793c\u7269,\u5e76\u4e14\u4e0d\u518d\u56de\u5230\u5708\u4e2d,\u4ece\u4ed6\u7684\u4e0b\u4e00\u4e2a\u5c0f\u670b\u53cb\u5f00\u59cb,\u7ee7\u7eed0...m-1\u62a5\u6570....\u8fd9\u6837\u4e0b\u53bb....\u76f4\u5230\u5269\u4e0b\u6700\u540e\u4e00\u4e2a\u5c0f\u670b\u53cb,\u53ef\u4ee5\u4e0d\u7528\u8868\u6f14,\u5e76\u4e14\u62ff\u5230\u725b\u5ba2\u540d\u8d35\u7684\u201c\u540d\u4fa6\u63a2\u67ef\u5357\u201d\u5178\u85cf\u7248(\u540d\u989d\u6709\u9650\u54e6!! _ )\u3002\u8bf7\u4f60\u8bd5\u7740\u60f3\u4e0b,\u54ea\u4e2a\u5c0f\u670b\u53cb\u4f1a\u5f97\u5230\u8fd9\u4efd\u793c\u54c1\u5462\uff1f(\u6ce8\uff1a\u5c0f\u670b\u53cb\u7684\u7f16\u53f7\u662f\u4ece0\u5230n-1)\u3002\u5982\u679c\u6ca1\u6709\u5c0f\u670b\u53cb\uff0c\u8bf7\u8fd4\u56de-1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public \uff1a int LastRemaining_Solution ( int n , int m ) { int i = 0 , j = 0 , numOut = 0 , * out = new int [ n ]{}; while ( numOut < n - 1 ) { while ( out [ i ]) { i ++ ; if ( i == n ) { i = 0 ; } } if ( j == m - 1 ) { out [ i ] = true ; numOut ++ ; } i ++ ; j ++ ; if ( i == n ) { i = 0 ; } if ( j == m ) { j = 0 ; } } int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! out [ i ]) { res = i ; } } delete [] out ; return res ; } }; 47. \u6c421+2+3+...+n \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u6c421+2+3+...+n\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u4e58\u9664\u6cd5\u3001for\u3001while\u3001if\u3001else\u3001switch\u3001case\u7b49\u5173\u952e\u5b57\u53ca\u6761\u4ef6\u5224\u65ad\u8bed\u53e5\uff08A?B\uff1aC\uff09\u3002 1 2 3 4 5 6 class Solution { public \uff1a int Sum_Solution ( int n ) { return ( n + 1 ) * n / 2 ; } }; 48. \u4e0d\u7528\u52a0\u51cf\u4e58\u9664\u505a\u52a0\u6cd5* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u6c42\u4e24\u4e2a\u6574\u6570\u4e4b\u548c\uff0c\u8981\u6c42\u5728\u51fd\u6570\u4f53\u5185\u4e0d\u5f97\u4f7f\u7528+\u3001-\u3001*\u3001/\u56db\u5219\u8fd0\u7b97\u7b26\u53f7\u3002 Solution\uff1aXOR + &A = 000101 = 5, B = 010001 = 17 1) sum = 000101 XOR 010001 = 010100 = 20, pos = 000101 & 010001 = 000001 = 1. We have to move left for 000001 at 0-th position (starting from rightmost). 2) if pos is not 0, A = sum, B = (pos << 1) then continue 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a int Add ( int num1 , int num2 ) { int res = num1 ; int pos = num2 ; while ( true ) { res = num1 ^ num2 ; pos = num1 & num2 ; if ( pos == 0 ) { break ; } num1 = res ; num2 = pos << 1 ; } return res ; } }; 49. \u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u4e00\u4e2a\u6574\u6570\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u5b57\u7b26\u4e32\u8f6c\u6362\u6574\u6570\u7684\u5e93\u51fd\u6570\u3002\u6570\u503c\u4e3a0\u6216\u8005\u5b57\u7b26\u4e32\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u6570\u503c\u5219\u8fd4\u56de0\u3002\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32,\u5305\u62ec\u6570\u5b57\u5b57\u6bcd\u7b26\u53f7,\u53ef\u4ee5\u4e3a\u7a7a\u3002\u5982\u679c\u662f\u5408\u6cd5\u7684\u6570\u503c\u8868\u8fbe\u5219\u8fd4\u56de\u8be5\u6570\u5b57\uff0c\u5426\u5219\u8fd4\u56de0\u3002 \u8f93\u5165+21474836471a33 \u8f93\u51fa21474836470 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public \uff1a int StrToInt ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return 0 ; } int num = 0 ; bool isPlus = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 && str [ 0 ] == '-' ) { isPlus = false ; continue ; } if ( i == 0 && str [ 0 ] == '+' ) { continue ; } if ( str [ i ] > '9' || str [ i ] < '0' ) { return 0 ; } num = num * 10 + str [ i ] - '0' ; } if ( ! isPlus ) { return - num ; } return num ; } }; 50. \u6570\u7ec4\u4e2d\u91cd\u590d\u7684\u6570\u5b57 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4\u91cc\u7684\u6240\u6709\u6570\u5b57\u90fd\u57280\u5230n-1\u7684\u8303\u56f4\u5185\u3002 \u6570\u7ec4\u4e2d\u67d0\u4e9b\u6570\u5b57\u662f\u91cd\u590d\u7684\uff0c\u4f46\u4e0d\u77e5\u9053\u6709\u51e0\u4e2a\u6570\u5b57\u662f\u91cd\u590d\u7684\u3002\u4e5f\u4e0d\u77e5\u9053\u6bcf\u4e2a\u6570\u5b57\u91cd\u590d\u51e0\u6b21\u3002\u8bf7\u627e\u51fa\u6570\u7ec4\u4e2d\u4efb\u610f\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b57\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u957f\u5ea6\u4e3a7\u7684\u6570\u7ec4{2,3,1,0,2,5,3}\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u8f93\u51fa\u662f\u7b2c\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b572\u3002\u8fd4\u56de\u63cf\u8ff0\uff1a\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u51fd\u6570\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u628a\u91cd\u590d\u7684\u6570\u5b57\u653e\u5230\u53c2\u6570duplication[0]\u4e2d\u3002\uff08ps\uff1aduplication\u5df2\u7ecf\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u76f4\u63a5\u8d4b\u503c\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public \uff1a // Parameters\uff1a // numbers\uff1a an array of integers // length\uff1a the length of array numbers // duplication\uff1a (Output) the duplicated number in the array number // Return value\uff1a true if the input is valid, and there are some // duplications in the array number // otherwise false bool duplicate ( int numbers [], int length , int * duplication ) { if ( length == 0 ) { return false ; } int * arr = new int [ length ]{}; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ numbers [ i ]] == length ) { arr [ numbers [ i ]] = i ; } if ( arr [ numbers [ i ]] == 0 ) { arr [ numbers [ i ]] = length ; } } int idx = length ; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ i ] == 0 ) { continue ; } if ( idx > arr [ i ]) { idx = arr [ i ]; } } delete [] arr ; if ( idx == length ) { return false ; } * duplication = numbers [ idx ]; return true ; } }; 51. \u6784\u5efa\u4e58\u79ef\u6570\u7ec4 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4A[0,1,...,n-1], \u8bf7\u6784\u5efa\u4e00\u4e2a\u6570\u7ec4B[0,1,...,n-1], \u5176\u4e2dB\u4e2d\u7684\u5143\u7d20 B[i] = A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]\u3002\u4e0d\u80fd\u4f7f\u7528\u9664\u6cd5\u3002\uff08\u6ce8\u610f\uff1a\u89c4\u5b9aB[0] = A[1] * A[2] * ... * A[n-1]\uff0cB[n-1] = A[0] * A[1] * ... * A[n-2];\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a vector < int > multiply ( const vector < int >& A ) { vector < int > res ; int n = int ( A . size ()); if ( n == 0 ) { return res ; } for ( int i = 0 ; i < n ; i ++ ) { int mul = A [ 0 ]; for ( int j = 1 ; j < n ; j ++ ) { if ( j == i ) { continue ; } if ( A [ j ] == 0 ) { mul = 0 ; break ; } mul *= A [ j ]; } res . push_back ( mul ); } return res ; } }; 52. \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5339\u914d\u5305\u62ec'.'\u548c' '\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\u6a21\u5f0f\u4e2d\u7684\u5b57\u7b26'.'\u8868\u793a\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\uff0c\u800c' '\u8868\u793a\u5b83\u524d\u9762\u7684\u5b57\u7b26\u53ef\u4ee5\u51fa\u73b0\u4efb\u610f\u6b21\uff08\u5305\u542b0\u6b21\uff09\u3002\u5728\u672c\u9898\u4e2d\uff0c\u5339\u914d\u662f\u6307\u5b57\u7b26\u4e32\u7684\u6240\u6709\u5b57\u7b26\u5339\u914d\u6574\u4e2a\u6a21\u5f0f\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"aaa\"\u4e0e\u6a21\u5f0f\"a.a\"\u548c\"ab ac a\"\u5339\u914d\uff0c\u4f46\u662f\u4e0e\"aa.a\"\u548c\"ab*a\"\u5747\u4e0d\u5339\u914d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a bool match ( char * str , char * pattern ) { size_t ns = strlen ( str ), np = strlen ( pattern ); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = ( i < ns ) && ( str [ i ] == pattern [ j ] || pattern [ j ] == '.' ); if ( j < np - 1 && pattern [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } bool res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } }; 53. \u8868\u793a\u6570\u503c\u7684\u5b57\u7b26\u4e32* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u8868\u793a\u6570\u503c\uff08\u5305\u62ec\u6574\u6570\u548c\u5c0f\u6570\uff09\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"+100\", \"5e2\", \"-123\", \"3.1416\" \u548c \"-1E-16\" \u90fd\u8868\u793a\u6570\u503c\u3002 \u4f46\u662f \"12e\", \"1a3.14\", \"1.2.3\", \"+-5\" \u548c \"12e+4.3\" \u90fd\u4e0d\u662f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a bool isNumeric ( char * string ) { size_t n = strlen ( string ); if ( n == 0 ) { return false ; } bool isEx = false , isPt = false ; for ( int i = 0 ; i < n ; i ++ ) { if (( string [ i ] == '+' || string [ i ] == '-' )) { if ( i == 0 ) { continue ; } if ( string [ i - 1 ] == 'E' || string [ i - 1 ] == 'e' ) { continue ; } return false ; } if ( string [ i ] == 'e' || string [ i ] == 'E' ) { if ( isEx || i == n - 1 ) { return false ; } isEx = true ; continue ; } if ( string [ i ] == '.' ) { if ( isPt || isEx || i == n - 1 ) { return false ; } isPt = true ; continue ; } if ( string [ i ] > '9' || string [ i ] < '0' ) { return false ; } } return true ; } }; 54. \u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u91cd\u590d\u7684\u5b57\u7b26* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u627e\u51fa\u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5f53\u4ece\u5b57\u7b26\u6d41\u4e2d\u53ea\u8bfb\u51fa\u524d\u4e24\u4e2a\u5b57\u7b26\"go\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"g\"\u3002\u5f53\u4ece\u8be5\u5b57\u7b26\u6d41\u4e2d\u8bfb\u51fa\u524d\u516d\u4e2a\u5b57\u7b26\u201cgoogle\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"l\"\u3002\u5982\u679c\u5f53\u524d\u5b57\u7b26\u6d41\u6ca1\u6709\u5b58\u5728\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u8fd4\u56de#\u5b57\u7b26\u3002 Solution\uff1aint[0\uff1a256] = 0Give each ACSII a position index in the char flow starting from 1.If repeat appears, set int[i] = -1Return ACSII with minimum position index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { int * ascii ; int N ; int flow ; public \uff1a Solution () { N = 256 ; ascii = new int [ N ]{}; flow = 1 ; } ~ Solution () { delete [] ascii ; } //Insert one char from stringstream void Insert ( char ch ) { int idx = int ( ch ); if ( ascii [ idx ] == 0 ) { ascii [ idx ] = flow ; } else { ascii [ idx ] = - 1 ; } flow ++ ; } //return the first appearence once char in current stringstream char FirstAppearingOnce () { int pos = flow , ch = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] < 1 ) { continue ; } if ( pos > ascii [ i ]) { pos = ascii [ i ]; ch = i ; } } if ( pos == flow ) { return '#' ; } return char ( ch ); } }; 55. \u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u7ed3\u70b9* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4e00\u4e2a\u94fe\u8868\uff0c\u82e5\u5176\u4e2d\u5305\u542b\u73af\uff0c\u8bf7\u627e\u51fa\u8be5\u94fe\u8868\u7684\u73af\u7684\u5165\u53e3\u7ed3\u70b9\uff0c\u5426\u5219\uff0c\u8f93\u51fanull\u3002 For the case of circle. Set two pointors p1 and p2 staring from head. p1 moves one step each time; p2 moves 2 steps each time. Because of a loop, p1 and p2 will definitely come across at some node in the loop. Suppose p1 moves x steps, then p2 moves evidently 2x steps. Besides, p2 has covered at least one circile. 2x - x = kn, \\quad k = 1, 2, 3, ... 2x - x = kn, \\quad k = 1, 2, 3, ... where n denotes the length of loop. We can also see both p1 and p2 have covered the part beyond the loop, says L1. x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... So, we one pointor moves starting from M and the other moves starting from head and both of them move with 1 step. Then they will meet again at the statrt of loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * EntryNodeOfLoop ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * p1 = pHead , * p2 = pHead ; while ( p1 != NULL && p2 != NULL ) { p1 = p1 -> next ; p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p1 == p2 ) { break ; } } p2 = pHead ; while ( p2 != p1 ) { p1 = p1 -> next ; p2 = p2 -> next ; } return p1 ; } }; 56. \u5220\u9664\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u6392\u5e8f\u7684\u94fe\u8868\u4e2d\uff0c\u5b58\u5728\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u8bf7\u5220\u9664\u8be5\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u91cd\u590d\u7684\u7ed3\u70b9\u4e0d\u4fdd\u7559\uff0c\u8fd4\u56de\u94fe\u8868\u5934\u6307\u9488\u3002 \u4f8b\u5982\uff0c\u94fe\u88681->2->3->3->4->4->5 \u5904\u7406\u540e\u4e3a 1->2->5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * deleteDuplication ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * pre = new ListNode ( 0 ); pre -> next = pHead ; ListNode * par = pre , * cur = pHead ; bool isDup = false ; while ( cur != NULL ) { while ( cur -> next != NULL && cur -> next -> val == cur -> val ) { cur = cur -> next ; isDup = true ; } cur = cur -> next ; if ( isDup ) { par -> next = cur ; isDup = false ; } else { par = par -> next ; } } pHead = pre -> next ; delete pre ; return pHead ; } }; 57. \u4e8c\u53c9\u6811\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\u548c\u5176\u4e2d\u7684\u4e00\u4e2a\u7ed3\u70b9\uff0c\u8bf7\u627e\u51fa\u4e2d\u5e8f\u904d\u5386\u987a\u5e8f\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u5e76\u4e14\u8fd4\u56de\u3002\u6ce8\u610f\uff0c\u6811\u4e2d\u7684\u7ed3\u70b9\u4e0d\u4ec5\u5305\u542b\u5de6\u53f3\u5b50\u7ed3\u70b9\uff0c\u540c\u65f6\u5305\u542b\u6307\u5411\u7236\u7ed3\u70b9\u7684\u6307\u9488\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) \uff1aval(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public \uff1a TreeLinkNode * GetNext ( TreeLinkNode * pNode ) { if ( pNode == NULL ) { return NULL ; } if ( pNode -> right != NULL ) { TreeLinkNode * curNode = pNode -> right ; while ( curNode -> left != NULL ) { curNode = curNode -> left ; } return curNode ; } if ( pNode -> next == NULL ) { return NULL ; } if ( pNode -> next -> left == pNode ) { return pNode -> next ; } if ( pNode -> next -> next != NULL && pNode -> next -> next -> left == pNode -> next ) { return pNode -> next -> next ; } return NULL ; } }; 58. \u5bf9\u79f0\u7684\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u4e00\u9897\u4e8c\u53c9\u6811\u662f\u4e0d\u662f\u5bf9\u79f0\u7684\u3002\u6ce8\u610f\uff0c\u5982\u679c\u4e00\u4e2a\u4e8c\u53c9\u6811\u540c\u6b64\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u662f\u540c\u6837\u7684\uff0c\u5b9a\u4e49\u5176\u4e3a\u5bf9\u79f0\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a bool isSymmetrical ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return true ; } return isSymmetricalSubtree ( pRoot -> left , pRoot -> right ); } bool isSymmetricalSubtree ( TreeNode * left , TreeNode * right ) { if ( left == NULL && right == NULL ) { return true ; } if ( left == NULL || right == NULL ) { return false ; } if ( left -> val != right -> val ) { return false ; } bool L = isSymmetricalSubtree ( left -> left , right -> right ); bool R = isSymmetricalSubtree ( left -> right , right -> left ); return ( L && R ); } }; 59. \u6309\u4e4b\u5b57\u5f62\u987a\u5e8f\u6253\u5370\u4e8c\u53c9\u6811 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6309\u7167\u4e4b\u5b57\u5f62\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u5373\u7b2c\u4e00\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e8c\u5c42\u6309\u7167\u4ece\u53f3\u81f3\u5de6\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e09\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u5176\u4ed6\u884c\u4ee5\u6b64\u7c7b\u63a8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a void inverse ( vector < int >& arr ) { int len = int ( arr . size ()); for ( int i = 0 ; i < len / 2 ; i ++ ) { int temp = arr [ i ]; arr [ i ] = arr [ len - 1 - i ]; arr [ len - 1 - i ] = temp ; } } vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int >> res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; int count = 1 ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { if ( count % 2 == 0 ) { inverse ( temp ); } count ++ ; res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } }; 60. \u628a\u4e8c\u53c9\u6811\u6253\u5370\u6210\u591a\u884c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5230\u4e0b\u6309\u5c42\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u540c\u4e00\u5c42\u7ed3\u70b9\u4ece\u5de6\u81f3\u53f3\u8f93\u51fa\u3002\u6bcf\u4e00\u5c42\u8f93\u51fa\u4e00\u884c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int > > res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } }; 61. \u5e8f\u5217\u5316\u4e8c\u53c9\u6811* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u6765\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u4e8c\u53c9\u6811 \u4e8c\u53c9\u6811\u7684\u5e8f\u5217\u5316\u662f\u6307\uff1a\u628a\u4e00\u68f5\u4e8c\u53c9\u6811\u6309\u7167\u67d0\u79cd\u904d\u5386\u65b9\u5f0f\u7684\u7ed3\u679c\u4ee5\u67d0\u79cd\u683c\u5f0f\u4fdd\u5b58\u4e3a\u5b57\u7b26\u4e32\uff0c\u4ece\u800c\u4f7f\u5f97\u5185\u5b58\u4e2d\u5efa\u7acb\u8d77\u6765\u7684\u4e8c\u53c9\u6811\u53ef\u4ee5\u6301\u4e45\u4fdd\u5b58\u3002\u5e8f\u5217\u5316\u53ef\u4ee5\u57fa\u4e8e\u5148\u5e8f\u3001\u4e2d\u5e8f\u3001\u540e\u5e8f\u3001\u5c42\u5e8f\u7684\u4e8c\u53c9\u6811\u904d\u5386\u65b9\u5f0f\u6765\u8fdb\u884c\u4fee\u6539\uff0c\u5e8f\u5217\u5316\u7684\u7ed3\u679c\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5e8f\u5217\u5316\u65f6\u901a\u8fc7 \u67d0\u79cd\u7b26\u53f7\u8868\u793a\u7a7a\u8282\u70b9\uff08#\uff09\uff0c\u4ee5 \uff01 \u8868\u793a\u4e00\u4e2a\u7ed3\u70b9\u503c\u7684\u7ed3\u675f\uff08value!\uff09\u3002\u4e8c\u53c9\u6811\u7684\u53cd\u5e8f\u5217\u5316\u662f\u6307\uff1a\u6839\u636e\u67d0\u79cd\u904d\u5386\u987a\u5e8f\u5f97\u5230\u7684\u5e8f\u5217\u5316\u5b57\u7b26\u4e32\u7ed3\u679cstr\uff0c\u91cd\u6784\u4e8c\u53c9\u6811\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u4e00\u4e2a\u53ea\u6709\u6839\u8282\u70b9\u4e3a1\u7684\u4e8c\u53c9\u6811\u5e8f\u5217\u5316\u4e3a\"1,\"\uff0c\u7136\u540e\u901a\u8fc7\u81ea\u5df1\u7684\u51fd\u6570\u6765\u89e3\u6790\u56de\u8fd9\u4e2a\u4e8c\u53c9\u6811 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a char * Serialize ( TreeNode * root ) { string pre = \"\" , in = \"\" ; preOrder ( root , pre ); inOrder ( root , in ); pre . push_back ( '#' ); pre += in ; int n = int ( pre . length ()); char * str = new char [ n + 1 ]{}; for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = pre [ i ]; } str [ n ] = '\\0' ; return str ; } void preOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { str += to_string ( root -> val ); str . push_back ( ',' ); preOrder ( root -> left , str ); preOrder ( root -> right , str ); } } void inOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { inOrder ( root -> left , str ); str += to_string ( root -> val ); str . push_back ( ',' ); inOrder ( root -> right , str ); } } TreeNode * Deserialize ( char * str ) { vector < int > pre , in ; bool isPre = true ; int val = 0 ; for ( int i = 0 ; i < strlen ( str ); i ++ ) { if ( str [ i ] == '#' ) { isPre = false ; continue ; } if ( str [ i ] == ',' ) { if ( isPre ) { pre . push_back ( val ); } else { in . push_back ( val ); } val = 0 ; continue ; } val = val * 10 + ( str [ i ] - '0' ); } int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return constructTree ( pre , in , 0 , n - 1 , 0 , n - 1 ); } TreeNode * constructTree ( vector < int > pre , vector < int > in , int b1 , int e1 , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int numLeft = 0 ; for ( int i = b2 ; i <= e2 ; i ++ , numLeft ++ ) { if ( in [ i ] == pre [ b1 ]) { break ; } } root -> left = constructTree ( pre , in , b1 + 1 , b1 + numLeft , b2 , b2 + numLeft - 1 ); root -> right = constructTree ( pre , in , b1 + numLeft + 1 , e1 , b2 + numLeft + 1 , e2 ); return root ; } }; 62. \u4e8c\u53c9\u6811\u7684\u7b2ck\u4e2a\u7ed3\u70b9* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u8bf7\u627e\u51fa\u5176\u4e2d\u7684\u7b2ck\u5c0f\u7684\u7ed3\u70b9\u3002\u4f8b\u5982\uff0c\uff085\uff0c3\uff0c7\uff0c2\uff0c4\uff0c6\uff0c8\uff09\u4e2d\uff0c\u6309\u7ed3\u70b9\u6570\u503c\u5927\u5c0f\u987a\u5e8f\u7b2c\u4e09\u5c0f\u7ed3\u70b9\u7684\u503c\u4e3a4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a TreeNode * KthNode ( TreeNode * pRoot , int k ) { TreeNode * res = NULL ; inOrder ( pRoot , k , res ); return res ; } void inOrder ( TreeNode * root , int & k , TreeNode *& res ) { if ( root != NULL ) { inOrder ( root -> left , k , res ); k -- ; if ( k == 0 ) { res = root ; } inOrder ( root -> right , k , res ); } } }; 63. \u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5982\u4f55\u5f97\u5230\u4e00\u4e2a\u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570\uff1f\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5947\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4f4d\u4e8e\u4e2d\u95f4\u7684\u6570\u503c\u3002\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5076\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4e2d\u95f4\u4e24\u4e2a\u6570\u7684\u5e73\u5747\u503c\u3002\u6211\u4eec\u4f7f\u7528Insert()\u65b9\u6cd5\u8bfb\u53d6\u6570\u636e\u6d41\uff0c\u4f7f\u7528GetMedian()\u65b9\u6cd5\u83b7\u53d6\u5f53\u524d\u8bfb\u53d6\u6570\u636e\u7684\u4e2d\u4f4d\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { vector < int > arr ; public \uff1a void Insert ( int num ) { arr . push_back ( num ); } void swap ( vector < int >& arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int >& arr , int begin , int end , int n ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] > arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] > arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i - 1 , n ); quickSort ( arr , j + 1 , end , n ); } } double GetMedian () { int n = int ( arr . size ()); quickSort ( arr , 0 , n - 1 , n ); if ( n % 2 ) { return arr [ n / 2 ]; } else { return ( arr [( n - 1 ) / 2 ] + arr [ n / 2 ]) / 2.0 ; } } }; 64. \u6ed1\u52a8\u7a97\u53e3\u7684\u6700\u5927\u503c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u548c\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f\uff0c\u627e\u51fa\u6240\u6709\u6ed1\u52a8\u7a97\u53e3\u91cc\u6570\u503c\u7684\u6700\u5927\u503c\u3002\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u6570\u7ec4{2,3,4,2,6,2,5,1}\u53ca\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f3\uff0c\u90a3\u4e48\u4e00\u5171\u5b58\u57286\u4e2a\u6ed1\u52a8\u7a97\u53e3\uff0c\u4ed6\u4eec\u7684\u6700\u5927\u503c\u5206\u522b\u4e3a{4,4,6,6,6,5}\uff1b \u9488\u5bf9\u6570\u7ec4{2,3,4,2,6,2,5,1}\u7684\u6ed1\u52a8\u7a97\u53e3\u6709\u4ee5\u4e0b6\u4e2a\uff1a {[2,3,4],2,6,2,5,1}\uff0c {2,[3,4,2],6,2,5,1}\uff0c {2,3,[4,2,6],2,5,1}\uff0c {2,3,4,[2,6,2],5,1}\uff0c {2,3,4,2,[6,2,5],1}\uff0c {2,3,4,2,6,[2,5,1]}\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a vector < int > maxInWindows ( const vector < int >& num , unsigned int size ) { vector < int > res ; int n = int ( num . size ()); if ( n < size || size < 1 ) { return res ; } for ( int i = 0 ; i < n - size + 1 ; i ++ ) { int max = num [ i ]; for ( int j = i + 1 ; j <= i + size - 1 ; j ++ ) { if ( max < num [ j ]) { max = num [ j ]; } } res . push_back ( max ); } return res ; } }; 65. \u77e9\u9635\u4e2d\u7684\u8def\u5f84 \u00b6 \u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u5728\u4e00\u4e2a\u77e9\u9635\u4e2d\u662f\u5426\u5b58\u5728\u4e00\u6761\u5305\u542b\u67d0\u5b57\u7b26\u4e32\u6240\u6709\u5b57\u7b26\u7684\u8def\u5f84\u3002\u8def\u5f84\u53ef\u4ee5\u4ece\u77e9\u9635\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u683c\u5b50\u5f00\u59cb\uff0c\u6bcf\u4e00\u6b65\u53ef\u4ee5\u5728\u77e9\u9635\u4e2d\u5411\u5de6\uff0c\u5411\u53f3\uff0c\u5411\u4e0a\uff0c\u5411\u4e0b\u79fb\u52a8\u4e00\u4e2a\u683c\u5b50\u3002\u5982\u679c\u4e00\u6761\u8def\u5f84\u7ecf\u8fc7\u4e86\u77e9\u9635\u4e2d\u7684\u67d0\u4e00\u4e2a\u683c\u5b50\uff0c\u5219\u8be5\u8def\u5f84\u4e0d\u80fd\u518d\u8fdb\u5165\u8be5\u683c\u5b50\u3002 \u4f8b\u5982 \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} (stock in an array [a, b, c, e, s, f, c, s, a, d, e, e])\u3002 \u77e9\u9635\u4e2d\u5305\u542b\u4e00\u6761\u5b57\u7b26\u4e32\"bcced\"\u7684\u8def\u5f84\uff0c\u4f46\u662f\u77e9\u9635\u4e2d\u4e0d\u5305\u542b\"abcb\"\u8def\u5f84\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26b\u5360\u636e\u4e86\u77e9\u9635\u4e2d\u7684\u7b2c\u4e00\u884c\u7b2c\u4e8c\u4e2a\u683c\u5b50\u4e4b\u540e\uff0c\u8def\u5f84\u4e0d\u80fd\u518d\u6b21\u8fdb\u5165\u8be5\u683c\u5b50\u3002 Solution\uff1aBacktracking\uff1a if we can find one character matched, we continue to explore next one (up, down, left, right); if one character doesn't match, we reset all previous positions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a bool hasPath ( char * matrix , int rows , int cols , char * str ) { bool * dp = new bool [ rows * cols ]{}, res = false ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( isPath ( i , j , rows , cols , matrix , str , dp , 0 )) { res = true ; break ; } } } delete [] dp ; return res ; } bool isPath ( int i , int j , int nRow , int nCol , char * mat , char * str , bool * dp , int k ) { int idx = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ idx ] || mat [ idx ] != str [ k ]) { return false ; } if ( str [ k + 1 ] == '\\0' ) { return true ; } dp [ idx ] = true ; bool u = isPath ( i - 1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool d = isPath ( i + 1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool l = isPath ( i , j - 1 , nRow , nCol , mat , str , dp , k + 1 ); bool r = isPath ( i , j + 1 , nRow , nCol , mat , str , dp , k + 1 ); dp [ idx ] = false ; return u || d || l || r ; } }; 66. \u673a\u5668\u4eba\u7684\u8fd0\u52a8\u8303\u56f4* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5730\u4e0a\u6709\u4e00\u4e2am\u884c\u548cn\u5217\u7684\u65b9\u683c\u3002\u4e00\u4e2a\u673a\u5668\u4eba\u4ece\u5750\u68070,0\u7684\u683c\u5b50\u5f00\u59cb\u79fb\u52a8\uff0c\u6bcf\u4e00\u6b21\u53ea\u80fd\u5411\u5de6\uff0c\u53f3\uff0c\u4e0a\uff0c\u4e0b\u56db\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u4e0d\u80fd\u8fdb\u5165\u884c\u5750\u6807\u548c\u5217\u5750\u6807\u7684\u6570\u4f4d\u4e4b\u548c\u5927\u4e8ek\u7684\u683c\u5b50\u3002 \u4f8b\u5982\uff0c\u5f53k\u4e3a18\u65f6\uff0c\u673a\u5668\u4eba\u80fd\u591f\u8fdb\u5165\u65b9\u683c\uff0835,37\uff09\uff0c\u56e0\u4e3a3+5+3+7 = 18\u3002\u4f46\u662f\uff0c\u5b83\u4e0d\u80fd\u8fdb\u5165\u65b9\u683c\uff0835,38\uff09\uff0c\u56e0\u4e3a3+5+3+8 = 19\u3002\u8bf7\u95ee\u8be5\u673a\u5668\u4eba\u80fd\u591f\u8fbe\u5230\u591a\u5c11\u4e2a\u683c\u5b50\uff1f Solution\uff1aBacktracking is one of brutal force method in searching. We cannot simply count how many grids which are illegal because the robot can only move one cell once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a int movingCount ( int threshold , int rows , int cols ) { bool * dp = new bool [ rows * cols ]{}; int count = move ( threshold , rows , cols , 0 , 0 , dp ); delete [] dp ; return count ; } int move ( int threshold , int nRow , int nCol , int i , int j , bool * dp ) { int pos = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ pos ] || toSum ( i ) + toSum ( j ) > threshold ) { return 0 ; } dp [ pos ] = true ; int u = move ( threshold , nRow , nCol , i - 1 , j , dp ); int d = move ( threshold , nRow , nCol , i + 1 , j , dp ); int l = move ( threshold , nRow , nCol , i , j - 1 , dp ); int r = move ( threshold , nRow , nCol , i , j + 1 , dp ); return 1 + u + d + l + r ; } int toSum ( int num ) { int sum = 0 ; while ( num ) { sum += num % 10 ; num /= 10 ; } return sum ; } }; 67. \u526a\u7ef3\u5b50* \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4f60\u4e00\u6839\u957f\u5ea6\u4e3an\u7684\u7ef3\u5b50\uff0c\u8bf7\u628a\u7ef3\u5b50\u526a\u6210\u6574\u6570\u957f\u7684m\u6bb5\uff08m\u3001n\u90fd\u662f\u6574\u6570\uff0cn>1\u5e76\u4e14m>1\uff09\uff0c\u6bcf\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u8bb0\u4e3ak[0],k[1],...,k[m]\u3002\u8bf7\u95eek[0]xk[1]x...xk[m]\u53ef\u80fd\u7684\u6700\u5927\u4e58\u79ef\u662f\u591a\u5c11\uff1f\u4f8b\u5982\uff0c\u5f53\u7ef3\u5b50\u7684\u957f\u5ea6\u662f8\u65f6\uff0c\u6211\u4eec\u628a\u5b83\u526a\u6210\u957f\u5ea6\u5206\u522b\u4e3a2\u30013\u30013\u7684\u4e09\u6bb5\uff0c\u6b64\u65f6\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u662f18\u3002 \u793a\u4f8b1\uff1a\u8f93\u51658\u8f93\u51fa18 Solution\uff1aSuppose f(n) denote the max product. We have an interative equation f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} Attention, there is some special case, when n = 2, we should return 1. In iterative equation, f(2) denotes length of the rope. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a int cutRope ( int number ) { int n = number ; if ( n < 2 ) { return 0 ; } if ( n == 2 ) { return 1 ; } if ( n == 3 ) { return 2 ; } int * f = new int [ n + 1 ]{}; f [ 1 ] = 1 ; f [ 2 ] = 2 ; f [ 3 ] = 3 ; int prod = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { int max_prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { prod = f [ j ] * f [ i - j ]; if ( max_prod < prod ) { max_prod = prod ; } } f [ i ] = max_prod ; } int res = f [ n ]; delete [] f ; return res ; } }; 68. OJ\u5728\u7ebf\u7f16\u7a0b\u5e38\u89c1\u8f93\u5165\u8f93\u51fa\u7ec3\u4e60\u573a \u00b6 68.1 A+B(1) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { cout << a + b << endl ; } return 0 ; } 68.2 A+B(2) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6570\u636e\u7ec4\u6570t(1 <= t <= 100)\u63a5\u4e0b\u6765\u6bcf\u884c\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9)\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516521 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> using namespace std ; int main () { int t ; long a , b ; cin >> t ; while ( t -- ) { cin >> a >> b ; cout << ( a + b ) << endl ; } return 0 ; } 68.3 A+B(3) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u5982\u679c\u8f93\u5165\u4e3a0 0\u5219\u7ed3\u675f\u8f93\u5165\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 200 0 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { if ( a == 0 && b == 0 ) { break ; } cout << ( a + b ) << endl ; } return 0 ; } 68.4 A+B(4) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u6bcf\u7ec4\u6570\u636e\u4e00\u884c,\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100), n\u4e3a0\u7684\u65f6\u5019\u7ed3\u675f\u8f93\u5165\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570,\u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 50 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { long sum , a ; int n ; while ( true ) { sum = 0 ; cin >> n ; if ( n == 0 ) { break ; } while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; } 68.5 A+B(5) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7684\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6b63\u6574\u6570t(1 <= t <= 100), \u8868\u793a\u6570\u636e\u7ec4\u6570\u3002\u63a5\u4e0b\u6765t\u884c, \u6bcf\u884c\u4e00\u7ec4\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516524 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { int t , n ; long sum , a ; cin >> t ; while ( t -- ) { cin >> n ; sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; } 68.6 A+B(6) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> using namespace std ; int main () { int n ; long sum , a ; while ( cin >> n ) { sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; } 68.7 A+B(7) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u4e0d\u5b9a\u6709n\u4e2a\u6574\u6570\uff0c\u7a7a\u683c\u9694\u5f00\u3002(1 <= n <= 100)\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 2 34 50 0 0 0 0 \u8f93\u51fa690 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> using namespace std ; int main () { long sum , a ; sum = 0 ; while ( cin >> a ) { sum += a ; if ( cin . get () == '\\n' ) { cout << sum << endl ; sum = 0 ; } } return 0 ; } 68.8 \u5b57\u7b26\u4e32\u6392\u5e8f(1) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6709\u4e24\u884c\uff0c\u7b2c\u4e00\u884cn\u7b2c\u4e8c\u884c\u662fn\u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u5b57\u7b26\u4e32\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7a7a\u683c\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u51655c d a bb e \u8f93\u51faa bb c d e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <string> using namespace std ; void swap ( string * str , int i , int j ) { string temp = str [ i ]; str [ i ] = str [ j ]; str [ j ] = temp ; } void quickSort ( string * str , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( i < j && str [ i ] <= str [ j ]) { j -- ; } swap ( str , i , j ); while ( i < j && str [ i ] <= str [ j ]) { i ++ ; } swap ( str , i , j ); } quickSort ( str , begin , i - 1 ); quickSort ( str , j + 1 , end ); } } int main () { int n ; cin >> n ; string * str = new string [ n ]; for ( int i = 0 ; i < n ; i ++ ) { cin >> str [ i ]; } quickSort ( str , 0 , n - 1 ); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n - 1 ] << endl ; delete [] str ; return 0 ; } 68.9 \u5b57\u7b26\u4e32\u6392\u5e8f(2) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7\u7a7a\u683c\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u8fc7\u7684\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4e32\u901a\u8fc7\u7a7a\u683c\u9694\u5f00 \u793a\u4f8b1 \u8f93\u5165a c bbf ddddnowcoder \u8f93\u51faa bb cdddd fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <iostream> #include <string> #include <algorithm> #include <vector> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { str . push_back ( temp ); if ( cin . get () == '\\n' ) { sort ( str . begin (), str . end ()); int n = int ( str . size ()); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n - 1 ] << endl ; str . clear (); } } } 68.10 \u5b57\u7b26\u4e32\u6392\u5e8f(3) \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7,\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u7528\u4f8b\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7528','\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u5165a,c,bbf,ddddnowcoder \u8f93\u51faa,bb,cdddd,fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> #include <string> #include <vector> #include <algorithm> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { int n = int ( temp . length ()); string s = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp [ i ] == ',' ) { str . push_back ( s ); s = \"\" ; continue ; } s . push_back ( temp [ i ]); } str . push_back ( s ); sort ( str . begin (), str . end ()); n = int ( str . size ()); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ',' ; } cout << str [ n - 1 ] << endl ; str . clear (); } } 69. \u5e8f\u5217\u548c \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570N\u548c\u957f\u5ea6L\uff0c\u627e\u51fa\u4e00\u6bb5\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8eL\u7684\u8fde\u7eed\u975e\u8d1f\u6574\u6570\uff0c\u4ed6\u4eec\u7684\u548c\u6070\u597d\u4e3aN\u3002\u7b54\u6848\u53ef\u80fd\u6709\u591a\u4e2a\uff0c\u6211\u6211\u4eec\u9700\u8981\u627e\u51fa\u957f\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u4f8b\u5982 N = 18 L = 2\uff1a5 + 6 + 7 = 183 + 4 + 5 + 6 = 18\u90fd\u662f\u6ee1\u8db3\u8981\u6c42\u7684\uff0c\u4f46\u662f\u6211\u4eec\u8f93\u51fa\u66f4\u77ed\u7684 5 6 7 \u793a\u4f8b1\uff1a \u8f93\u516518 2 \u8f93\u51fa5 6 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> using namespace std ; void solution ( int N , int L ) { for ( int m = L ; m <= 100 ; m ++ ) { int x = N / m + ( 1 - m ) / 2 ; //cout << x << endl; if (( 2 * x + m - 1 ) * m != 2 * N ) { continue ; } for ( int i = 0 ; i < m - 1 ; i ++ ) { cout << ( x + i ) << ' ' ; } cout << ( x + m - 1 ) << endl ; return ; } cout << \"No\" << endl ; } int main ( int argc , const char * argv []) { // insert code here... int N , L ; scanf ( \"%d%d\" , & N , & L ); solution ( N , L ); return 0 ; }","title":"\u5251\u6307offer"},{"location":"algo/jsoffer/#js-offer","text":"","title":"JS-offer"},{"location":"algo/jsoffer/#02","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u6bcf\u4e2a\u7a7a\u683c\u66ff\u6362\u6210\u201c%20\u201d\u3002\u4f8b\u5982\uff0c\u5f53\u5b57\u7b26\u4e32\u4e3aWe Are Happy.\u5219\u7ecf\u8fc7\u66ff\u6362\u4e4b\u540e\u7684\u5b57\u7b26\u4e32\u4e3aWe%20Are%20Happy\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void replaceSpace ( char * str , int length ) { if ( length == 0 ) { return ; } int nSpace = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( str [ i ] == ' ' ) { nSpace ++ ; } } int len = length + 2 * nSpace ; for ( int i = length - 1 , j = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) { str [ j -- ] = '0' ; str [ j -- ] = '2' ; str [ j -- ] = '%' ; } else { str [ j -- ] = str [ i ]; } } } };","title":"02. \u66ff\u6362\u7a7a\u683c"},{"location":"algo/jsoffer/#03","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u6309\u94fe\u8868\u4ece\u5c3e\u5230\u5934\u7684\u987a\u5e8f\u8fd4\u56de\u4e00\u4e2aArrayList\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) \uff1a * val(x), next(NULL) { * } * }; */ class Solution { public \uff1a vector < int > printListFromTailToHead ( ListNode * head ) { vector < int > arr ; recurPrintList ( arr , head ); return arr ; } void recurPrintList ( vector < int > & arr , ListNode * head ) { if ( head != nullptr ) { recurPrintList ( arr , head -> next ); arr . push_back ( head -> val ); } } };","title":"03. \u4ece\u5c3e\u5230\u5934\u6253\u5370\u94fe\u8868"},{"location":"algo/jsoffer/#04","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u67d0\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\uff0c\u8bf7\u91cd\u5efa\u51fa\u8be5\u4e8c\u53c9\u6811\u3002\u5047\u8bbe\u8f93\u5165\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u4e2d\u90fd\u4e0d\u542b\u91cd\u590d\u7684\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u524d\u5e8f\u904d\u5386\u5e8f\u5217{1,2,4,7,3,5,6,8}\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217{4,7,2,1,5,3,8,6}\uff0c\u5219\u91cd\u5efa\u4e8c\u53c9\u6811\u5e76\u8fd4\u56de\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) {} * }; */ class Solution { public \uff1a TreeNode * reConstructBinaryTree ( vector < int > pre , vector < int > vin ) { int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return construct ( pre , 0 , n - 1 , vin , 0 , n - 1 ); } TreeNode * construct ( vector < int > pre , int b1 , int e1 , vector < int > vin , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int id = b2 ; for (; id <= e2 ; id ++ ) { if ( vin [ id ] == pre [ b1 ]) { break ; } } root -> left = construct ( pre , b1 + 1 , b1 + ( id - b2 ), vin , b2 , id - 1 ); root -> right = construct ( pre , b1 + ( id - b2 ) + 1 , e1 , vin , id + 1 , e2 ); return root ; } };","title":"04. \u91cd\u5efa\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#05","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7528\u4e24\u4e2a\u6808\u6765\u5b9e\u73b0\u4e00\u4e2a\u961f\u5217\uff0c\u5b8c\u6210\u961f\u5217\u7684Push\u548cPop\u64cd\u4f5c\u3002 \u961f\u5217\u4e2d\u7684\u5143\u7d20\u4e3aint\u7c7b\u578b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a void push ( int node ) { stack1 . push ( node ); } int pop () { while ( ! stack1 . empty ()) { stack2 . push ( stack1 . top ()); stack1 . pop (); } int res = stack2 . top (); stack2 . pop (); while ( ! stack2 . empty ()) { stack1 . push ( stack2 . top ()); stack2 . pop (); } return res ; } private \uff1a stack < int > stack1 ; stack < int > stack2 ; };","title":"05. \u7528\u4e24\u4e2a\u6808\u5b9e\u73b0\u961f\u5217"},{"location":"algo/jsoffer/#06","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u4e00\u4e2a\u6570\u7ec4\u6700\u5f00\u59cb\u7684\u82e5\u5e72\u4e2a\u5143\u7d20\u642c\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u6570\u7ec4\u7684\u65cb\u8f6c\u3002 \u8f93\u5165\u4e00\u4e2a\u975e\u9012\u51cf\u6392\u5e8f\u7684\u6570\u7ec4\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8f93\u51fa\u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u5143\u7d20\u3002\u4f8b\u5982\u6570\u7ec4{3,4,5,1,2}\u4e3a{1,2,3,4,5}\u7684\u4e00\u4e2a\u65cb\u8f6c\uff0c\u8be5\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u4e3a1\u3002NOTE\uff1a\u7ed9\u51fa\u7684\u6240\u6709\u5143\u7d20\u90fd\u5927\u4e8e0\uff0c\u82e5\u6570\u7ec4\u5927\u5c0f\u4e3a0\uff0c\u8bf7\u8fd4\u56de0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a int minNumberInRotateArray ( vector < int > rotateArray ) { int n = int ( rotateArray . size ()); if ( n == 0 ) { return 0 ; } if ( rotateArray [ 0 ] < rotateArray [ n - 1 ]) { return rotateArray [ 0 ]; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( rotateArray [ i ] < rotateArray [ i - 1 ]) { return rotateArray [ i ]; } } return 0 ; } };","title":"06. \u65cb\u8f6c\u6570\u7ec4\u7684\u6700\u5c0f\u6570\u5b57"},{"location":"algo/jsoffer/#07","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5927\u5bb6\u90fd\u77e5\u9053\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff0c\u73b0\u5728\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6574\u6570n\uff0c\u8bf7\u4f60\u8f93\u51fa\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7b2cn\u9879\uff08\u4ece0\u5f00\u59cb\uff0c\u7b2c0\u9879\u4e3a0\uff0c\u7b2c1\u9879\u662f1\uff09\u3002n<=39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int Fibonacci ( int n ) { if ( n == 0 || n == 1 ) { return n ; } int t1 = 0 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } };","title":"07. \u6590\u6ce2\u90a3\u5951\u6570\u5217"},{"location":"algo/jsoffer/#08","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\uff08\u5148\u540e\u6b21\u5e8f\u4e0d\u540c\u7b97\u4e0d\u540c\u7684\u7ed3\u679c\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int jumpFloor ( int number ) { if ( number == 0 || number == 1 ) { return 1 ; } int t1 = 1 , t2 = 1 , temp = 0 ; for ( int i = 2 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } };","title":"08. \u8df3\u53f0\u9636"},{"location":"algo/jsoffer/#09","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u53ea\u9752\u86d9\u4e00\u6b21\u53ef\u4ee5\u8df3\u4e0a1\u7ea7\u53f0\u9636\uff0c\u4e5f\u53ef\u4ee5\u8df3\u4e0a2\u7ea7\u2026\u2026\u5b83\u4e5f\u53ef\u4ee5\u8df3\u4e0an\u7ea7\u3002\u6c42\u8be5\u9752\u86d9\u8df3\u4e0a\u4e00\u4e2an\u7ea7\u7684\u53f0\u9636\u603b\u5171\u6709\u591a\u5c11\u79cd\u8df3\u6cd5\u3002 1 2 3 4 5 6 7 8 class Solution { public \uff1a int jumpFloorII ( int number ) { int res = 1 ; while ( -- number ) { res *= 2 ; } return res ; } };","title":"09. \u53d8\u6001\u8df3\u53f0\u9636"},{"location":"algo/jsoffer/#10","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6211\u4eec\u53ef\u4ee5\u75282 1\u7684\u5c0f\u77e9\u5f62\u6a2a\u7740\u6216\u8005\u7ad6\u7740\u53bb\u8986\u76d6\u66f4\u5927\u7684\u77e9\u5f62\u3002\u8bf7\u95ee\u7528n\u4e2a2 1\u7684\u5c0f\u77e9\u5f62\u65e0\u91cd\u53e0\u5730\u8986\u76d6\u4e00\u4e2a2 n\u7684\u5927\u77e9\u5f62\uff0c\u603b\u5171\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\uff1f\u6bd4\u5982n=3\u65f6\uff0c2 3\u7684\u77e9\u5f62\u5757\u67093\u79cd\u8986\u76d6\u65b9\u6cd5\uff1a f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} f(n) = \\begin{cases} n, \\quad n =1, 2 \\\\ f(n-1) + f(n-2), \\quad n = 3, 4, 5, ... \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public \uff1a int rectCover ( int number ) { if ( number <= 2 ) { return number ; } int t1 = 1 , t2 = 2 , temp = 0 ; for ( int i = 3 ; i <= number ; i ++ ) { temp = t2 + t1 ; t1 = t2 ; t2 = temp ; } return t2 ; } };","title":"10. \u77e9\u5f62\u8986\u76d6"},{"location":"algo/jsoffer/#12","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2adouble\u7c7b\u578b\u7684\u6d6e\u70b9\u6570base\u548cint\u7c7b\u578b\u7684\u6574\u6570exponent\u3002\u6c42base\u7684exponent\u6b21\u65b9\u3002\u4fdd\u8bc1base\u548cexponent\u4e0d\u540c\u65f6\u4e3a0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public \uff1a double Power ( double base , int exponent ) { if ( exponent == 0 ) { return 1 ; } double res = 1.0 ; bool isNegative = false ; if ( exponent < 0 ) { exponent = - exponent ; isNegative = true ; } while ( exponent -- ) { res *= base ; } if ( isNegative ) { return 1 / res ; } return res ; } };","title":"12. \u6570\u503c\u7684\u6574\u6570\u6b21\u65b9"},{"location":"algo/jsoffer/#13","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6765\u8c03\u6574\u8be5\u6570\u7ec4\u4e2d\u6570\u5b57\u7684\u987a\u5e8f\uff0c\u4f7f\u5f97\u6240\u6709\u7684\u5947\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u524d\u534a\u90e8\u5206\uff0c\u6240\u6709\u7684\u5076\u6570\u4f4d\u4e8e\u6570\u7ec4\u7684\u540e\u534a\u90e8\u5206\uff0c\u5e76\u4fdd\u8bc1\u5947\u6570\u548c\u5947\u6570\uff0c\u5076\u6570\u548c\u5076\u6570\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u53d8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a void reOrderArray ( vector < int > & array ) { vector < int > odd , even ; int n = int ( array . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] % 2 ) { odd . push_back ( array [ i ]); } else { even . push_back ( array [ i ]); } } for ( int i = 0 , j = 0 ; i < int ( odd . size ()); i ++ , j ++ ) { array [ j ] = odd [ i ]; } for ( int i = 0 , j = int ( odd . size ()); i < int ( even . size ()); i ++ , j ++ ) { array [ j ] = even [ i ]; } } };","title":"13. \u8c03\u6574\u6570\u7ec4\u987a\u5e8f\u4f7f\u5947\u6570\u4f4d\u4e8e\u5076\u6570\u524d\u9762"},{"location":"algo/jsoffer/#14-k","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u8f93\u51fa\u8be5\u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindKthToTail ( ListNode * pListHead , unsigned int k ) { if ( k <= 0 ) { return NULL ; } ListNode * p1 = pListHead , * p2 = pListHead ; for ( int i = 0 ; i < k ; i ++ ) { if ( p2 == NULL ) { return p2 ; } p2 = p2 -> next ; } while ( p2 != NULL ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } };","title":"14. \u94fe\u8868\u4e2d\u5012\u6570\u7b2ck\u4e2a\u7ed3\u70b9"},{"location":"algo/jsoffer/#15","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u94fe\u8868\uff0c\u53cd\u8f6c\u94fe\u8868\u540e\uff0c\u8f93\u51fa\u65b0\u94fe\u8868\u7684\u8868\u5934\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * ReverseList ( ListNode * pHead ) { if ( pHead == NULL || pHead -> next == NULL ) { return pHead ; } ListNode * p1 = NULL , * p2 = pHead , * p3 = pHead -> next ; while ( p3 != NULL ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; p3 = p3 -> next ; } p2 -> next = p1 ; return p2 ; } };","title":"15. \u53cd\u8f6c\u94fe\u8868"},{"location":"algo/jsoffer/#16","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u5355\u8c03\u9012\u589e\u7684\u94fe\u8868\uff0c\u8f93\u51fa\u4e24\u4e2a\u94fe\u8868\u5408\u6210\u540e\u7684\u94fe\u8868\uff0c\u5f53\u7136\u6211\u4eec\u9700\u8981\u5408\u6210\u540e\u7684\u94fe\u8868\u6ee1\u8db3\u5355\u8c03\u4e0d\u51cf\u89c4\u5219\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * Merge ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL ) { return pHead2 ; } if ( pHead2 == NULL ) { return pHead1 ; } ListNode * head = new ListNode ( 0 ); ListNode * cur = head , * p1 = pHead1 , * p2 = pHead2 ; while ( p1 != NULL && p2 != NULL ) { if ( p1 -> val < p2 -> val ) { cur -> next = p1 ; cur = p1 ; p1 = p1 -> next ; } else { cur -> next = p2 ; cur = p2 ; p2 = p2 -> next ; } } if ( p1 != NULL ) { cur -> next = p1 ; } if ( p2 != NULL ) { cur -> next = p2 ; } return head -> next ; } };","title":"16. \u5408\u5e76\u4e24\u4e2a\u6392\u5e8f\u7684\u94fe\u8868"},{"location":"algo/jsoffer/#17","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u68f5\u4e8c\u53c9\u6811A\uff0cB\uff0c\u5224\u65adB\u662f\u4e0d\u662fA\u7684\u5b50\u7ed3\u6784\u3002\uff08ps\uff1a\u6211\u4eec\u7ea6\u5b9a\u7a7a\u6811\u4e0d\u662f\u4efb\u610f\u4e00\u4e2a\u6811\u7684\u5b50\u7ed3\u6784\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a bool HasSubtree ( TreeNode * pRoot1 , TreeNode * pRoot2 ) { if ( pRoot1 == NULL || pRoot2 == NULL ) { return false ; } queue < TreeNode *> qTree ; qTree . push ( pRoot1 ); TreeNode * front = pRoot1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> val == pRoot2 -> val && isSame ( front , pRoot2 )) { return true ; } if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return false ; } bool isSame ( TreeNode * t1 , TreeNode * t2 ) { if ( t2 == NULL ) { return true ; } if ( t1 == NULL || t1 -> val != t2 -> val ) { return false ; } return isSame ( t1 -> left , t2 -> left ) && isSame ( t1 -> right , t2 -> right ); } };","title":"17. \u6811\u7684\u5b50\u7ed3\u6784"},{"location":"algo/jsoffer/#18","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u64cd\u4f5c\u7ed9\u5b9a\u7684\u4e8c\u53c9\u6811\uff0c\u5c06\u5176\u53d8\u6362\u4e3a\u6e90\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a void Mirror ( TreeNode * pRoot ) { if ( pRoot != NULL ) { Mirror ( pRoot -> left ); Mirror ( pRoot -> right ); TreeNode * temp = pRoot -> left ; pRoot -> left = pRoot -> right ; pRoot -> right = temp ; } } };","title":"18. \u4e8c\u53c9\u6811\u7684\u955c\u50cf"},{"location":"algo/jsoffer/#19","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u77e9\u9635\uff0c\u6309\u7167\u4ece\u5916\u5411\u91cc\u4ee5\u987a\u65f6\u9488\u7684\u987a\u5e8f\u4f9d\u6b21\u6253\u5370\u51fa\u6bcf\u4e00\u4e2a\u6570\u5b57\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u5982\u4e0b4 X 4\u77e9\u9635\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u5219\u4f9d\u6b21\u6253\u5370\u51fa\u6570\u5b571,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public \uff1a vector < int > printMatrix ( vector < vector < int > > matrix ) { vector < int > res ; int nRows = int ( matrix . size ()); if ( nRows == 0 ) { return res ; } int nCols = int ( matrix [ 0 ]. size ()); if ( nCols == 0 ) { return res ; } bool ** dp = new bool * [ nRows ]; for ( int i = 0 ; i < nRows ; i ++ ) { dp [ i ] = new bool [ nCols ]{}; } int i = 0 , j = 0 ; int di [ 4 ] = { 0 , 1 , 0 , - 1 }, dj [ 4 ] = { 1 , 0 , - 1 , 0 }; while ( true ) { bool updated = false ; for ( int k = 0 ; k < 4 ; k ++ ) { while ( isOk ( dp , i + di [ k ], j + dj [ k ], nRows , nCols )) { res . push_back ( matrix [ i ][ j ]); dp [ i ][ j ] = true ; updated = true ; i += di [ k ]; j += dj [ k ]; } } if ( ! updated ) { res . push_back ( matrix [ i ][ j ]); break ; } } for ( i = 0 ; i < nRows ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } bool isOk ( bool ** isVisited , int i , int j , int nRows , int nCols ) { if ( i < 0 || i >= nRows || j < 0 || j >= nCols || isVisited [ i ][ j ]) { return false ; } return true ; } };","title":"19. \u987a\u65f6\u9488\u6253\u5370\u77e9\u9635"},{"location":"algo/jsoffer/#20-min","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5b9a\u4e49\u6808\u7684\u6570\u636e\u7ed3\u6784\uff0c\u8bf7\u5728\u8be5\u7c7b\u578b\u4e2d\u5b9e\u73b0\u4e00\u4e2a\u80fd\u591f\u5f97\u5230\u6808\u4e2d\u6240\u542b\u6700\u5c0f\u5143\u7d20\u7684min\u51fd\u6570\uff08\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u4e3aO\uff081\uff09\uff09\u3002\u6ce8\u610f\uff1a\u4fdd\u8bc1\u6d4b\u8bd5\u4e2d\u4e0d\u4f1a\u5f53\u6808\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u5bf9\u6808\u8c03\u7528pop()\u6216\u8005min()\u6216\u8005top()\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { stack < int > s1 ; stack < int > s2 ; public \uff1a void push ( int value ) { s1 . push ( value ); if ( s2 . empty () || value < s2 . top ()) { s2 . push ( value ); } else { s2 . push ( s2 . top ()); } } void pop () { s1 . pop (); s2 . pop (); } int top () { return s1 . top (); } int min () { return s2 . top (); } };","title":"20. \u5305\u542bmin\u51fd\u6570\u7684\u6808*"},{"location":"algo/jsoffer/#21","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u6574\u6570\u5e8f\u5217\uff0c\u7b2c\u4e00\u4e2a\u5e8f\u5217\u8868\u793a\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u8bf7\u5224\u65ad\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u662f\u5426\u53ef\u80fd\u4e3a\u8be5\u6808\u7684\u5f39\u51fa\u987a\u5e8f\u3002\u5047\u8bbe\u538b\u5165\u6808\u7684\u6240\u6709\u6570\u5b57\u5747\u4e0d\u76f8\u7b49\u3002\u4f8b\u5982\u5e8f\u52171,2,3,4,5\u662f\u67d0\u6808\u7684\u538b\u5165\u987a\u5e8f\uff0c\u5e8f\u52174,5,3,2,1\u662f\u8be5\u538b\u6808\u5e8f\u5217\u5bf9\u5e94\u7684\u4e00\u4e2a\u5f39\u51fa\u5e8f\u5217\uff0c\u4f464,3,5,1,2\u5c31\u4e0d\u53ef\u80fd\u662f\u8be5\u538b\u6808\u5e8f\u5217\u7684\u5f39\u51fa\u5e8f\u5217\u3002\uff08\u6ce8\u610f\uff1a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u957f\u5ea6\u662f\u76f8\u7b49\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a bool IsPopOrder ( vector < int > pushV , vector < int > popV ) { int n = int ( pushV . size ()); stack < int > st ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pushV [ i ] == popV [ j ]) { j ++ ; } else { st . push ( pushV [ i ]); } } for (; j < n ; j ++ ) { if ( st . empty () || st . top () != popV [ j ]) { return false ; } st . pop (); } return true ; } };","title":"21. \u6808\u7684\u538b\u5165\u3001\u5f39\u51fa\u5e8f\u5217"},{"location":"algo/jsoffer/#22","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u540c\u5c42\u8282\u70b9\u4ece\u5de6\u81f3\u53f3\u6253\u5370\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < int > PrintFromTopToBottom ( TreeNode * root ) { vector < int > res ; if ( root == NULL ) { return res ; } TreeNode * front = root ; queue < TreeNode *> qTree ; qTree . push ( root ); while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); res . push_back ( front -> val ); if ( front -> left != NULL ) { qTree . push ( front -> left ); } if ( front -> right != NULL ) { qTree . push ( front -> right ); } } return res ; } };","title":"22. \u4ece\u4e0a\u5f80\u4e0b\u6253\u5370\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#23","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5224\u65ad\u8be5\u6570\u7ec4\u662f\u4e0d\u662f\u67d0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002\u5982\u679c\u662f\u5219\u8f93\u51faYes,\u5426\u5219\u8f93\u51faNo\u3002\u5047\u8bbe\u8f93\u5165\u7684\u6570\u7ec4\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u4e92\u4e0d\u76f8\u540c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a bool VerifySquenceOfBST ( vector < int > sequence ) { int n = int ( sequence . size ()); if ( n == 0 ) { return false ; } return isPostOrder ( sequence , 0 , n - 1 ); } bool isPostOrder ( vector < int > arr , int b , int e ) { if ( b >= e ) { return true ; } int idx = b ; for (; idx <= e ; idx ++ ) { if ( arr [ idx ] >= arr [ e ]) { break ; } } for ( int i = idx ; i < e ; i ++ ) { if ( arr [ i ] < arr [ e ]) { return false ; } } return isPostOrder ( arr , b , idx - 1 ) && isPostOrder ( arr , idx , e - 1 ); } };","title":"23. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217*"},{"location":"algo/jsoffer/#24","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9\u548c\u4e00\u4e2a\u6574\u6570\uff0c\u6309\u5b57\u5178\u5e8f\u6253\u5370\u51fa\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u503c\u7684\u548c\u4e3a\u8f93\u5165\u6574\u6570\u7684\u6240\u6709\u8def\u5f84\u3002\u8def\u5f84\u5b9a\u4e49\u4e3a\u4ece\u6811\u7684\u6839\u7ed3\u70b9\u5f00\u59cb\u5f80\u4e0b\u4e00\u76f4\u5230\u53f6\u7ed3\u70b9\u6240\u7ecf\u8fc7\u7684\u7ed3\u70b9\u5f62\u6210\u4e00\u6761\u8def\u5f84\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int > > paths ; if ( root == NULL ) { return paths ; } vector < int > path ; stack < TreeNode *> s ; int size = 0 , sum = 0 ; TreeNode * cur = root ; while ( true ) { while ( cur -> left != NULL || cur -> right != NULL ) { s . push ( cur ); path . push_back ( cur -> val ); size ++ ; sum += cur -> val ; if ( cur -> left != NULL ) { cur = cur -> left ; } else { cur = cur -> right ; } } if ( sum + cur -> val == expectNumber ) { path . push_back ( cur -> val ); paths . push_back ( path ); } while ( ! s . empty () && ( s . top () -> left == NULL || s . top () -> right == NULL || s . top () -> right == cur )) { cur = s . top (); s . pop (); sum -= cur -> val ; size -- ; } if ( s . empty ()) { break ; } cur = s . top () -> right ; path . resize ( size ); } return paths ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { vector < vector < int >> res ; if ( root == NULL ) { return res ; } vector < int > arr ; path ( root , expectNumber , res , arr , 0 ); return res ; } void path ( TreeNode * root , int target , vector < vector < int >> & res , vector < int > & arr , int sum ) { if ( root == NULL ) { return ; } arr . push_back ( root -> val ); if ( root -> left == NULL && root -> right == NULL && sum + root -> val == target ) { res . push_back ( arr ); } else { path ( root -> left , target , res , arr , sum + root -> val ); path ( root -> right , target , res , arr , sum + root -> val ); } arr . resize ( arr . size () - 1 ); } };","title":"24. \u4e8c\u53c9\u6811\u4e2d\u548c\u4e3a\u67d0\u4e00\u503c\u7684\u8def\u5f84"},{"location":"algo/jsoffer/#25","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u590d\u6742\u94fe\u8868\uff08\u6bcf\u4e2a\u8282\u70b9\u4e2d\u6709\u8282\u70b9\u503c\uff0c\u4ee5\u53ca\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u7279\u6b8a\u6307\u9488random\u6307\u5411\u4e00\u4e2a\u968f\u673a\u8282\u70b9\uff09\uff0c\u8bf7\u5bf9\u6b64\u94fe\u8868\u8fdb\u884c\u6df1\u62f7\u8d1d\uff0c\u5e76\u8fd4\u56de\u62f7\u8d1d\u540e\u7684\u5934\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\uff0c\u8f93\u51fa\u7ed3\u679c\u4e2d\u8bf7\u4e0d\u8981\u8fd4\u56de\u53c2\u6570\u4e2d\u7684\u8282\u70b9\u5f15\u7528\uff0c\u5426\u5219\u5224\u9898\u7a0b\u5e8f\u4f1a\u76f4\u63a5\u8fd4\u56de\u7a7a\uff09 Solution\uff1aWe copy each node to append itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) \uff1a label(x), next(NULL), random(NULL) { } }; */ class Solution { public \uff1a RandomListNode * Clone ( RandomListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } RandomListNode * p1 = pHead ; while ( p1 != NULL ) { RandomListNode * temp = new RandomListNode ( p1 -> label ); temp -> next = p1 -> next ; p1 -> next = temp ; p1 = p1 -> next -> next ; } p1 = pHead ; while ( p1 != NULL ) { if ( p1 -> random != NULL ) { p1 -> next -> random = p1 -> random -> next ; } p1 = p1 -> next -> next ; } RandomListNode * head = pHead -> next , * p2 = pHead -> next ; p1 = pHead ; while ( p1 != NULL ) { p1 -> next = p2 -> next ; if ( p2 -> next != NULL ) { p2 -> next = p2 -> next -> next ; } p1 = p1 -> next ; p2 = p2 -> next ; } return head ; } };","title":"25. \u590d\u6742\u94fe\u8868\u7684\u590d\u5236*"},{"location":"algo/jsoffer/#26","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5c06\u8be5\u4e8c\u53c9\u641c\u7d22\u6811\u8f6c\u6362\u6210\u4e00\u4e2a\u6392\u5e8f\u7684\u53cc\u5411\u94fe\u8868\u3002\u8981\u6c42\u4e0d\u80fd\u521b\u5efa\u4efb\u4f55\u65b0\u7684\u7ed3\u70b9\uff0c\u53ea\u80fd\u8c03\u6574\u6811\u4e2d\u7ed3\u70b9\u6307\u9488\u7684\u6307\u5411\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } postOrder ( pRootOfTree ); TreeNode * head = pRootOfTree ; while ( head -> left != NULL ) { head = head -> left ; } return head ; } void postOrder ( TreeNode * root ) { if ( root != NULL ) { postOrder ( root -> left ); postOrder ( root -> right ); TreeNode * left = root -> left ; while ( left != NULL && left -> right != NULL ) { left = left -> right ; } root -> left = left ; if ( left != NULL ) { left -> right = root ; } TreeNode * right = root -> right ; while ( right != NULL && right -> left != NULL ) { right = right -> left ; } root -> right = right ; if ( right != NULL ) { right -> left = root ; } } } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) { return NULL ; } TreeNode * head = pRootOfTree , * leftMost = NULL ; inOrder ( pRootOfTree , leftMost ); while ( head -> left != NULL ) { head = head -> left ; } return head ; } void inOrder ( TreeNode * root , TreeNode *& leftMost ) { if ( root != NULL ) { inOrder ( root -> left , leftMost ); if ( leftMost == NULL ) { leftMost = root ; } else { leftMost -> right = root ; root -> left = leftMost ; leftMost = root ; } inOrder ( root -> right , leftMost ); } } };","title":"26. \u4e8c\u53c9\u641c\u7d22\u6811\u4e0e\u53cc\u5411\u94fe\u8868"},{"location":"algo/jsoffer/#28","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6570\u7ec4\u4e2d\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u8bf7\u627e\u51fa\u8fd9\u4e2a\u6570\u5b57\u3002\u4f8b\u5982\u8f93\u5165\u4e00\u4e2a\u957f\u5ea6\u4e3a9\u7684\u6570\u7ec4{1,2,3,2,2,2,5,4,2}\u3002\u7531\u4e8e\u6570\u5b572\u5728\u6570\u7ec4\u4e2d\u51fa\u73b0\u4e865\u6b21\uff0c\u8d85\u8fc7\u6570\u7ec4\u957f\u5ea6\u7684\u4e00\u534a\uff0c\u56e0\u6b64\u8f93\u51fa2\u3002\u5982\u679c\u4e0d\u5b58\u5728\u5219\u8f93\u51fa0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i - 1 ); quickSort ( arr , j + 1 , end ); } } int MoreThanHalfNum_Solution ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return numbers [ 0 ]; } quickSort ( numbers , 0 , n - 1 ); if ( n % 2 && numbers [ n / 2 ] != numbers [ n / 2 - 1 ]) { return 0 ; } int res = numbers [ n / 2 ]; int count = 1 ; int pos = n / 2 - 1 ; while ( pos >= 0 ) { if ( numbers [ pos ] != res ) { break ; } pos -- ; count ++ ; } pos = n / 2 + 1 ; while ( pos < n ) { if ( numbers [ pos ] != res ) { break ; } pos ++ ; count ++ ; } if ( count > n / 2 ) { return res ; } return 0 ; } };","title":"28. \u6570\u7ec4\u4e2d\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\u7684\u6570\u5b57"},{"location":"algo/jsoffer/#29-k","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165n\u4e2a\u6574\u6570\uff0c\u627e\u51fa\u5176\u4e2d\u6700\u5c0f\u7684K\u4e2a\u6570\u3002\u4f8b\u5982\u8f93\u51654,5,1,6,2,7,3,8\u8fd98\u4e2a\u6570\u5b57\uff0c\u5219\u6700\u5c0f\u76844\u4e2a\u6570\u5b57\u662f1,2,3,4,\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int > & arr , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] <= arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] <= arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i - 1 ); quickSort ( arr , j + 1 , end ); } } vector < int > GetLeastNumbers_Solution ( vector < int > input , int k ) { int n = int ( input . size ()); vector < int > res ; if ( n == 0 || k <= 0 || k > n ) { return res ; } quickSort ( input , 0 , n - 1 ); input . resize ( k ); return input ; } };","title":"29. \u6700\u5c0f\u7684K\u4e2a\u6570"},{"location":"algo/jsoffer/#31-11n1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6c42\u51fa1-13\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570,\u5e76\u7b97\u51fa100~1300\u7684\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff1f\u4e3a\u6b64\u4ed6\u7279\u522b\u6570\u4e86\u4e00\u4e0b1-13\u4e2d\u5305\u542b1\u7684\u6570\u5b57\u67091\u300110\u300111\u300112\u300113\u56e0\u6b64\u5171\u51fa\u73b06\u6b21,\u4f46\u662f\u5bf9\u4e8e\u540e\u9762\u95ee\u9898\u4ed6\u5c31\u6ca1\u8f99\u4e86\u3002ACMer\u5e0c\u671b\u4f60\u4eec\u5e2e\u5e2e\u4ed6,\u5e76\u628a\u95ee\u9898\u66f4\u52a0\u666e\u904d\u5316,\u53ef\u4ee5\u5f88\u5feb\u7684\u6c42\u51fa\u4efb\u610f\u975e\u8d1f\u6574\u6570\u533a\u95f4\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1 \u5230 n \u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09\u3002 Solution\uff1aTake 2593 as an example, how many '5' does it contain? i = 1, Quotient = 2593 / (10 * i) = 258, Mod = 2593 % (10 * i) = 3. Number of '5'\uff1a 259 * i + (3 > 5) * i = 259. i = 10, Quotient = 2593 / (10 * i) = 25, Mod = 2593 % (10 * i) = 93. Number of '5'\uff1a 25 * i + (9 > 5) * i = 260. i = 100, Quotient = 2593 / (10 * i) = 2, Mod = 2593 % (10 * i) = 593. Number of '5'\uff1a 2 * i + (5 == 5) * (93 + 1) = 294. i = 1000, Quotient = 2593 / (10 * i) = 0 end.Total number of '5'\uff1a 259 + 260 + 294 = 813. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { res += count1 ( i ); } return res ; } int count1 ( int num ) { int res = 0 ; while ( num ) { if ( num % 10 == 1 ) { res ++ ; } num /= 10 ; } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public \uff1a int NumberOf1Between1AndN_Solution ( int n ) { int count = 0 , digit = 1 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int a = n / ( 10 * i ), b = n % ( 10 * i ); count += a * i ; if ( b / i > digit ) { count += i ; } if ( b / i == digit ) { count += b % i + 1 ; } } return count ; } };","title":"31. \u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff08\u4ece1\u5230n\u6574\u6570\u4e2d1\u51fa\u73b0\u7684\u6b21\u6570\uff09*"},{"location":"algo/jsoffer/#33","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u628a\u53ea\u5305\u542b\u8d28\u56e0\u5b502\u30013\u548c5\u7684\u6570\u79f0\u4f5c\u4e11\u6570\uff08Ugly Number\uff09\u3002\u4f8b\u59826\u30018\u90fd\u662f\u4e11\u6570\uff0c\u4f4614\u4e0d\u662f\uff0c\u56e0\u4e3a\u5b83\u5305\u542b\u8d28\u56e0\u5b507\u3002 \u4e60\u60ef\u4e0a\u6211\u4eec\u628a1\u5f53\u505a\u662f\u7b2c\u4e00\u4e2a\u4e11\u6570\u3002\u6c42\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u7684\u7b2cN\u4e2a\u4e11\u6570\u3002 Solution\uff1aUgly numbers\uff1a 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15...Some ugly number is from a multiplaction of previous number by 2, 3 or 5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a int min ( int a , int b , int c ) { int temp = a < b ? a \uff1a b ; return temp < c ? temp \uff1a c ; } int GetUglyNumber_Solution ( int index ) { if ( index < 2 ) { return index ; } int * arr = new int [ index ]{}; arr [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < index ; i ++ ) { arr [ i ] = min ( arr [ f2 ] * 2 , arr [ f3 ] * 3 , arr [ f5 ] * 5 ); while ( arr [ f2 ] * 2 <= arr [ i ]) { f2 ++ ; } while ( arr [ f3 ] * 3 <= arr [ i ]) { f3 ++ ; } while ( arr [ f5 ] * 5 <= arr [ i ]) { f5 ++ ; } } int res = arr [ index - 1 ]; delete [] arr ; return res ; } };","title":"33. \u4e11\u6570*"},{"location":"algo/jsoffer/#34","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u5b57\u7b26\u4e32(0<=\u5b57\u7b26\u4e32\u957f\u5ea6<=10000\uff0c\u5168\u90e8\u7531\u5b57\u6bcd\u7ec4\u6210)\u4e2d\u627e\u5230\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26,\u5e76\u8fd4\u56de\u5b83\u7684\u4f4d\u7f6e, \u5982\u679c\u6ca1\u6709\u5219\u8fd4\u56de -1\uff08\u9700\u8981\u533a\u5206\u5927\u5c0f\u5199\uff09.\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public \uff1a int FirstNotRepeatingChar ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return - 1 ; } int N = 256 , pos = n + 1 ; int * ascii = new int [ N ]{}; for ( int i = 0 ; i < n ; i ++ ) { int id = int ( str [ i ]); if ( ascii [ id ] == 0 ) { ascii [ id ] = i + 1 ; } else { ascii [ id ] = - 1 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] > 0 && ascii [ i ] < pos ) { pos = ascii [ i ]; } } delete [] ascii ; if ( pos == n + 1 ) { return - 1 ; } return pos - 1 ; } };","title":"34. \u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u4f4d\u7f6e"},{"location":"algo/jsoffer/#35","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4,\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570P\u3002\u5e76\u5c06P\u5bf91000000007\u53d6\u6a21\u7684\u7ed3\u679c\u8f93\u51fa\u3002 \u5373\u8f93\u51faP%1000000007 \u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u7684\u6570\u7ec4\u4e2d\u6ca1\u6709\u7684\u76f8\u540c\u7684\u6570\u5b57\u6570\u636e\u8303\u56f4\uff1a\u5bf9\u4e8e%50\u7684\u6570\u636e,size<=10 4\u5bf9\u4e8e%75\u7684\u6570\u636e,size<=10 5\u5bf9\u4e8e%100\u7684\u6570\u636e,size<=2*10^5 \u8f93\u51651,2,3,4,5,6,7,0\u8f93\u51fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public \uff1a int InversePairs ( vector < int > data ) { int n = int ( data . size ()); if ( n < 2 ) { return 0 ; } long count = 0 ; mergeSort ( data , 0 , n - 1 , count ); return ( count % 1000000007 ); } void mergeSort ( vector < int > & arr , int b , int e , long & count ) { if ( b >= e ) { return ; } int m = ( b + e ) / 2 ; mergeSort ( arr , b , m , count ); mergeSort ( arr , m + 1 , e , count ); merge ( arr , b , m , e , count ); } void merge ( vector < int > & arr , int b , int m , int e , long & count ) { int * temp = new int [ e - b + 1 ]{}; int i = b , j = m + 1 , right = 0 , pos = 0 ; while ( i <= m && j <= e ) { if ( arr [ i ] < arr [ j ]) { temp [ pos ++ ] = arr [ i ++ ]; count += right ; } else { temp [ pos ++ ] = arr [ j ++ ]; right ++ ; } } count += ( m - i + 1 ) * right ; while ( i <= m ) { temp [ pos ++ ] = arr [ i ++ ]; } while ( j <= e ) { temp [ pos ++ ] = arr [ j ++ ]; } for ( int i = b ; i <= e ; i ++ ) { arr [ i ] = temp [ i - b ]; } delete [] temp ; } };","title":"35. \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9*"},{"location":"algo/jsoffer/#36","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e24\u4e2a\u94fe\u8868\uff0c\u627e\u51fa\u5b83\u4eec\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9\u3002\uff08\u6ce8\u610f\u56e0\u4e3a\u4f20\u5165\u6570\u636e\u662f\u94fe\u8868\uff0c\u6240\u4ee5\u9519\u8bef\u6d4b\u8bd5\u6570\u636e\u7684\u63d0\u793a\u662f\u7528\u5176\u4ed6\u65b9\u5f0f\u663e\u793a\u7684\uff0c\u4fdd\u8bc1\u4f20\u5165\u6570\u636e\u662f\u6b63\u786e\u7684\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } };*/ class Solution { public \uff1a ListNode * FindFirstCommonNode ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL || pHead2 == NULL ) { return NULL ; } ListNode * p1 = pHead1 , * p2 = pHead2 ; stack < ListNode *> s1 , s2 ; while ( p1 != NULL ) { s1 . push ( p1 ); p1 = p1 -> next ; } while ( p2 != NULL ) { s2 . push ( p2 ); p2 = p2 -> next ; } while ( ! s1 . empty () && ! s2 . empty ()) { if ( s1 . top () != s2 . top ()) { return s1 . top () -> next ; } s1 . pop (); s2 . pop (); } if ( s1 . empty ()) { return pHead1 ; } if ( s2 . empty ()) { return pHead2 ; } return s1 . top () -> next ; } };","title":"36. \u4e24\u4e2a\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u516c\u5171\u7ed3\u70b9"},{"location":"algo/jsoffer/#37","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7edf\u8ba1\u4e00\u4e2a\u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 class Solution { public \uff1a int GetNumberOfK ( vector < int > data , int k ) { int count = 0 ; for ( int i = 0 ; i < int ( data . size ()); i ++ ) { if ( data [ i ] == k ) { count ++ ; } } return count ; } };","title":"37. \u6570\u5b57\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6b21\u6570"},{"location":"algo/jsoffer/#38","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6c42\u8be5\u6811\u7684\u6df1\u5ea6\u3002\u4ece\u6839\u7ed3\u70b9\u5230\u53f6\u7ed3\u70b9\u4f9d\u6b21\u7ecf\u8fc7\u7684\u7ed3\u70b9\uff08\u542b\u6839\u3001\u53f6\u7ed3\u70b9\uff09\u5f62\u6210\u6811\u7684\u4e00\u6761\u8def\u5f84\uff0c\u6700\u957f\u8def\u5f84\u7684\u957f\u5ea6\u4e3a\u6811\u7684\u6df1\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int dep = 0 ; queue < TreeNode *> qTree ; qTree . push ( pRoot ); TreeNode * front = pRoot , * last = pRoot , * nextLast = pRoot ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); if ( front -> left != NULL ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != NULL ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { dep ++ ; last = nextLast ; } } return dep ; } }; ``` C ++ /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } };*/ class Solution { public \uff1a int TreeDepth ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return 0 ; } int leftDep = TreeDepth ( pRoot -> left ); int rightDep = TreeDepth ( pRoot -> right ); return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } };","title":"38. \u4e8c\u53c9\u6811\u7684\u6df1\u5ea6"},{"location":"algo/jsoffer/#39","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u5224\u65ad\u8be5\u4e8c\u53c9\u6811\u662f\u5426\u662f\u5e73\u8861\u4e8c\u53c9\u6811\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8003\u8651\u5176\u5e73\u8861\u6027\uff0c\u4e0d\u9700\u8981\u8003\u8651\u5176\u662f\u4e0d\u662f\u6392\u5e8f\u4e8c\u53c9\u6811\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a bool IsBalanced_Solution ( TreeNode * pRoot ) { bool res = true ; postOrder ( pRoot , res ); return res ; } int postOrder ( TreeNode * root , bool & res ) { if ( root == NULL ) { return 0 ; } int leftDep = postOrder ( root -> left , res ); int rightDep = postOrder ( root -> right , res ); int diff = abs ( leftDep - rightDep ); if ( diff > 1 ) { res = false ; } return ( leftDep > rightDep ? leftDep \uff1a rightDep ) + 1 ; } };","title":"39. \u5e73\u8861\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#40","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\u91cc\u9664\u4e86\u4e24\u4e2a\u6570\u5b57\u4e4b\u5916\uff0c\u5176\u4ed6\u7684\u6570\u5b57\u90fd\u51fa\u73b0\u4e86\u4e24\u6b21\u3002\u8bf7\u5199\u7a0b\u5e8f\u627e\u51fa\u8fd9\u4e24\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57\u3002 Solution\uff1anum XOR num = 0\uff1a one number XOR itself is 0.We XOR all entire array to get a result of the two single numbers. Then locate the first 1's position, e.g. 6 = 0110, first 1's position is 2 (starting 0 from right to left). We classify the array into two parts by checking if one integer is 1 at its first 1's position. Then do XOR once again for the two parts to find the two single numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a void FindNumsAppearOnce ( vector < int > data , int * num1 , int * num2 ) { int n = int ( data . size ()); if ( n < 2 ) { return ; } int XOR = 0 , pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR ^= data [ i ]; } while ( XOR >> 1 ) { XOR = XOR >> 1 ; pos ++ ; } bool is1Ok = false , is2Ok = false ; int n1 = 0 , n2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if (( data [ i ] >> pos ) & 1 ) { if ( is1Ok ) { n1 ^= data [ i ]; } else { is1Ok = true ; n1 = data [ i ]; } } else { if ( is2Ok ) { n2 ^= data [ i ]; } else { is2Ok = true ; n2 = data [ i ]; } } * num1 = n1 < n2 ? n1 \uff1a n2 ; * num2 = n1 >= n2 ? n1 \uff1a n2 ; } } };","title":"40. \u6570\u7ec4\u4e2d\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57*"},{"location":"algo/jsoffer/#41-s","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5c0f\u660e\u5f88\u559c\u6b22\u6570\u5b66,\u6709\u4e00\u5929\u4ed6\u5728\u505a\u6570\u5b66\u4f5c\u4e1a\u65f6,\u8981\u6c42\u8ba1\u7b97\u51fa9~16\u7684\u548c,\u4ed6\u9a6c\u4e0a\u5c31\u5199\u51fa\u4e86\u6b63\u786e\u7b54\u6848\u662f100\u3002\u4f46\u662f\u4ed6\u5e76\u4e0d\u6ee1\u8db3\u4e8e\u6b64,\u4ed6\u5728\u60f3\u7a76\u7adf\u6709\u591a\u5c11\u79cd\u8fde\u7eed\u7684\u6b63\u6570\u5e8f\u5217\u7684\u548c\u4e3a100(\u81f3\u5c11\u5305\u62ec\u4e24\u4e2a\u6570)\u3002\u6ca1\u591a\u4e45,\u4ed6\u5c31\u5f97\u5230\u53e6\u4e00\u7ec4\u8fde\u7eed\u6b63\u6570\u548c\u4e3a100\u7684\u5e8f\u5217\uff1a18,19,20,21,22\u3002\u73b0\u5728\u628a\u95ee\u9898\u4ea4\u7ed9\u4f60,\u4f60\u80fd\u4e0d\u80fd\u4e5f\u5f88\u5feb\u7684\u627e\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217? Good Luck!\u8f93\u51fa\u6240\u6709\u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217\u3002\u5e8f\u5217\u5185\u6309\u7167\u4ece\u5c0f\u81f3\u5927\u7684\u987a\u5e8f\uff0c\u5e8f\u5217\u95f4\u6309\u7167\u5f00\u59cb\u6570\u5b57\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < vector < int > > FindContinuousSequence ( int sum ) { vector < vector < int >> res ; if ( sum < 3 ) { return res ; } for ( int n = sum ; n >= 2 ; n -- ) { int numerator = 2 * sum + n - n * n ; int denominator = 2 * n ; if ( numerator % denominator == 0 ) { int a = numerator / denominator ; if ( a < 1 ) { continue ; } vector < int > arr ; for ( int i = a ; i <= a + n - 1 ; i ++ ) { arr . push_back ( i ); } res . push_back ( arr ); } } return res ; } };","title":"41. \u548c\u4e3aS\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217"},{"location":"algo/jsoffer/#42-s","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8f93\u5165\u4e00\u4e2a\u9012\u589e\u6392\u5e8f\u7684\u6570\u7ec4\u548c\u4e00\u4e2a\u6570\u5b57S\uff0c\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u4e24\u4e2a\u6570\uff0c\u4f7f\u5f97\u4ed6\u4eec\u7684\u548c\u6b63\u597d\u662fS\uff0c\u5982\u679c\u6709\u591a\u5bf9\u6570\u5b57\u7684\u548c\u7b49\u4e8eS\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\u7684\u4e58\u79ef\u6700\u5c0f\u7684\u3002\u5bf9\u5e94\u6bcf\u4e2a\u6d4b\u8bd5\u6848\u4f8b\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\uff0c\u5c0f\u7684\u5148\u8f93\u51fa\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public \uff1a vector < int > FindNumbersWithSum ( vector < int > array , int sum ) { vector < int > res ; int n = int ( array . size ()); if ( n == 0 ) { return res ; } int i = 0 , j = n - 1 ; while ( i < j ) { if ( array [ i ] + array [ j ] < sum ) { i ++ ; } else if ( array [ i ] + array [ j ] > sum ) { j -- ; } else { res . push_back ( array [ i ]); res . push_back ( array [ j ]); break ; } } return res ; } };","title":"42. \u548c\u4e3aS\u7684\u4e24\u4e2a\u6570\u5b57"},{"location":"algo/jsoffer/#43","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6c47\u7f16\u8bed\u8a00\u4e2d\u6709\u4e00\u79cd\u79fb\u4f4d\u6307\u4ee4\u53eb\u505a\u5faa\u73af\u5de6\u79fb\uff08ROL\uff09\uff0c\u73b0\u5728\u6709\u4e2a\u7b80\u5355\u7684\u4efb\u52a1\uff0c\u5c31\u662f\u7528\u5b57\u7b26\u4e32\u6a21\u62df\u8fd9\u4e2a\u6307\u4ee4\u7684\u8fd0\u7b97\u7ed3\u679c\u3002\u5bf9\u4e8e\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5b57\u7b26\u5e8f\u5217S\uff0c\u8bf7\u4f60\u628a\u5176\u5faa\u73af\u5de6\u79fbK\u4f4d\u540e\u7684\u5e8f\u5217\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u5e8f\u5217S=\u201dabcXYZdef\u201d,\u8981\u6c42\u8f93\u51fa\u5faa\u73af\u5de6\u79fb3\u4f4d\u540e\u7684\u7ed3\u679c\uff0c\u5373\u201cXYZdefabc\u201d\u3002\u662f\u4e0d\u662f\u5f88\u7b80\u5355\uff1fOK\uff0c\u641e\u5b9a\u5b83\uff01 1 2 3 4 5 6 7 8 9 10 class Solution { public \uff1a string LeftRotateString ( string str , int n ) { int len = int ( str . length ()); if ( len == 0 || n == 0 || len <= n ) { return str ; } string firtN ( str , 0 , n ); string rest ( str , n , len ); return rest + firtN ; } };","title":"43. \u5de6\u65cb\u8f6c\u5b57\u7b26\u4e32"},{"location":"algo/jsoffer/#44","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u725b\u5ba2\u6700\u8fd1\u6765\u4e86\u4e00\u4e2a\u65b0\u5458\u5de5Fish\uff0c\u6bcf\u5929\u65e9\u6668\u603b\u662f\u4f1a\u62ff\u7740\u4e00\u672c\u82f1\u6587\u6742\u5fd7\uff0c\u5199\u4e9b\u53e5\u5b50\u5728\u672c\u5b50\u4e0a\u3002\u540c\u4e8bCat\u5bf9Fish\u5199\u7684\u5185\u5bb9\u9887\u611f\u5174\u8da3\uff0c\u6709\u4e00\u5929\u4ed6\u5411Fish\u501f\u6765\u7ffb\u770b\uff0c\u4f46\u5374\u8bfb\u4e0d\u61c2\u5b83\u7684\u610f\u601d\u3002\u4f8b\u5982\uff0c\u201cstudent. a am I\u201d\u3002\u540e\u6765\u624d\u610f\u8bc6\u5230\uff0c\u8fd9\u5bb6\u4f19\u539f\u6765\u628a\u53e5\u5b50\u5355\u8bcd\u7684\u987a\u5e8f\u7ffb\u8f6c\u4e86\uff0c\u6b63\u786e\u7684\u53e5\u5b50\u5e94\u8be5\u662f\u201cI am a student.\u201d\u3002Cat\u5bf9\u4e00\u4e00\u7684\u7ffb\u8f6c\u8fd9\u4e9b\u5355\u8bcd\u987a\u5e8f\u53ef\u4e0d\u5728\u884c\uff0c\u4f60\u80fd\u5e2e\u52a9\u4ed6\u4e48\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } string res = \"\" , word = \"\" ; stack < string > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { s . push ( word ); word = \"\" ; continue ; } word . push_back ( str [ i ]); } s . push ( word ); while ( ! s . empty ()) { res += s . top (); s . pop (); if ( ! s . empty ()) { res . push_back ( ' ' ); } } return res ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public \uff1a string ReverseSentence ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return str ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { char temp = str [ i ]; str [ i ] = str [ n - 1 - i ]; str [ n - 1 - i ] = temp ; } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int n = i - 1 , m = j ; while ( m < n ) { char temp = str [ m ]; str [ m ] = str [ n ]; str [ n ] = temp ; m ++ ; n -- ; } j = i + 1 ; } } str [ n ] = '\\0' ; return str ; } };","title":"44. \u7ffb\u8f6c\u5355\u8bcd\u987a\u5e8f\u5217"},{"location":"algo/jsoffer/#45","text":"\u9898\u76ee\u63cf\u8ff0\uff1aLL\u4eca\u5929\u5fc3\u60c5\u7279\u522b\u597d,\u56e0\u4e3a\u4ed6\u53bb\u4e70\u4e86\u4e00\u526f\u6251\u514b\u724c,\u53d1\u73b0\u91cc\u9762\u5c45\u7136\u67092\u4e2a\u5927\u738b,2\u4e2a\u5c0f\u738b(\u4e00\u526f\u724c\u539f\u672c\u662f54\u5f20 _ )...\u4ed6\u968f\u673a\u4ece\u4e2d\u62bd\u51fa\u4e865\u5f20\u724c,\u60f3\u6d4b\u6d4b\u81ea\u5df1\u7684\u624b\u6c14,\u770b\u770b\u80fd\u4e0d\u80fd\u62bd\u5230\u987a\u5b50,\u5982\u679c\u62bd\u5230\u7684\u8bdd,\u4ed6\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968,\u563f\u563f\uff01\uff01\u201c\u7ea2\u5fc3A,\u9ed1\u68433,\u5c0f\u738b,\u5927\u738b,\u65b9\u72475\u201d,\u201cOh My God!\u201d\u4e0d\u662f\u987a\u5b50.....LL\u4e0d\u9ad8\u5174\u4e86,\u4ed6\u60f3\u4e86\u60f3,\u51b3\u5b9a\u5927\\\u5c0f \u738b\u53ef\u4ee5\u770b\u6210\u4efb\u4f55\u6570\u5b57,\u5e76\u4e14A\u770b\u4f5c1,J\u4e3a11,Q\u4e3a12,K\u4e3a13\u3002\u4e0a\u9762\u76845\u5f20\u724c\u5c31\u53ef\u4ee5\u53d8\u6210\u201c1,2,3,4,5\u201d(\u5927\u5c0f\u738b\u5206\u522b\u770b\u4f5c2\u548c4),\u201cSo Lucky!\u201d\u3002LL\u51b3\u5b9a\u53bb\u4e70\u4f53\u80b2\u5f69\u7968\u5566\u3002 \u73b0\u5728,\u8981\u6c42\u4f60\u4f7f\u7528\u8fd9\u5e45\u724c\u6a21\u62df\u4e0a\u9762\u7684\u8fc7\u7a0b,\u7136\u540e\u544a\u8bc9\u6211\u4eecLL\u7684\u8fd0\u6c14\u5982\u4f55\uff0c \u5982\u679c\u724c\u80fd\u7ec4\u6210\u987a\u5b50\u5c31\u8f93\u51fatrue\uff0c\u5426\u5219\u5c31\u8f93\u51fafalse\u3002\u4e3a\u4e86\u65b9\u4fbf\u8d77\u89c1,\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u5927\u5c0f\u738b\u662f0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public \uff1a bool IsContinuous ( vector < int > numbers ) { int n = int ( numbers . size ()); if ( n == 0 ) { return 0 ; } //sort(numbers.begin(), numbers.end()); quickSort ( numbers , 0 , n - 1 ); int num0 = 0 , head = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( numbers [ i ] == 0 ) { num0 ++ ; continue ; } if ( head == 0 ) { head = numbers [ i ]; } else { if ( numbers [ i ] == numbers [ i - 1 ]) { return false ; } if ( numbers [ i ] == head + 1 ) { head ++ ; } else { num0 -= numbers [ i ] - head - 1 ; if ( num0 < 0 ) { return false ; } head = numbers [ i ]; } } } return true ; } void quickSort ( vector < int > & arr , int b , int e ) { if ( b < e ) { int i = b , j = e ; while ( i < j ) { while ( i < j && arr [ i ] <= arr [ j ]) { j -- ; } swap ( arr , i , j ); while ( i < j && arr [ i ] <= arr [ j ]) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , b , i - 1 ); quickSort ( arr , j + 1 , e ); } } void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } };","title":"45. \u6251\u514b\u724c\u987a\u5b50"},{"location":"algo/jsoffer/#46","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6bcf\u5e74\u516d\u4e00\u513f\u7ae5\u8282,\u725b\u5ba2\u90fd\u4f1a\u51c6\u5907\u4e00\u4e9b\u5c0f\u793c\u7269\u53bb\u770b\u671b\u5b64\u513f\u9662\u7684\u5c0f\u670b\u53cb,\u4eca\u5e74\u4ea6\u662f\u5982\u6b64\u3002HF\u4f5c\u4e3a\u725b\u5ba2\u7684\u8d44\u6df1\u5143\u8001,\u81ea\u7136\u4e5f\u51c6\u5907\u4e86\u4e00\u4e9b\u5c0f\u6e38\u620f\u3002\u5176\u4e2d,\u6709\u4e2a\u6e38\u620f\u662f\u8fd9\u6837\u7684\uff1a\u9996\u5148,\u8ba9\u5c0f\u670b\u53cb\u4eec\u56f4\u6210\u4e00\u4e2a\u5927\u5708\u3002\u7136\u540e,\u4ed6\u968f\u673a\u6307\u5b9a\u4e00\u4e2a\u6570m,\u8ba9\u7f16\u53f7\u4e3a0\u7684\u5c0f\u670b\u53cb\u5f00\u59cb\u62a5\u6570\u3002\u6bcf\u6b21\u558a\u5230m-1\u7684\u90a3\u4e2a\u5c0f\u670b\u53cb\u8981\u51fa\u5217\u5531\u9996\u6b4c,\u7136\u540e\u53ef\u4ee5\u5728\u793c\u54c1\u7bb1\u4e2d\u4efb\u610f\u7684\u6311\u9009\u793c\u7269,\u5e76\u4e14\u4e0d\u518d\u56de\u5230\u5708\u4e2d,\u4ece\u4ed6\u7684\u4e0b\u4e00\u4e2a\u5c0f\u670b\u53cb\u5f00\u59cb,\u7ee7\u7eed0...m-1\u62a5\u6570....\u8fd9\u6837\u4e0b\u53bb....\u76f4\u5230\u5269\u4e0b\u6700\u540e\u4e00\u4e2a\u5c0f\u670b\u53cb,\u53ef\u4ee5\u4e0d\u7528\u8868\u6f14,\u5e76\u4e14\u62ff\u5230\u725b\u5ba2\u540d\u8d35\u7684\u201c\u540d\u4fa6\u63a2\u67ef\u5357\u201d\u5178\u85cf\u7248(\u540d\u989d\u6709\u9650\u54e6!! _ )\u3002\u8bf7\u4f60\u8bd5\u7740\u60f3\u4e0b,\u54ea\u4e2a\u5c0f\u670b\u53cb\u4f1a\u5f97\u5230\u8fd9\u4efd\u793c\u54c1\u5462\uff1f(\u6ce8\uff1a\u5c0f\u670b\u53cb\u7684\u7f16\u53f7\u662f\u4ece0\u5230n-1)\u3002\u5982\u679c\u6ca1\u6709\u5c0f\u670b\u53cb\uff0c\u8bf7\u8fd4\u56de-1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public \uff1a int LastRemaining_Solution ( int n , int m ) { int i = 0 , j = 0 , numOut = 0 , * out = new int [ n ]{}; while ( numOut < n - 1 ) { while ( out [ i ]) { i ++ ; if ( i == n ) { i = 0 ; } } if ( j == m - 1 ) { out [ i ] = true ; numOut ++ ; } i ++ ; j ++ ; if ( i == n ) { i = 0 ; } if ( j == m ) { j = 0 ; } } int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! out [ i ]) { res = i ; } } delete [] out ; return res ; } };","title":"46. \u5b69\u5b50\u4eec\u7684\u6e38\u620f(\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570)"},{"location":"algo/jsoffer/#47-123n","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u6c421+2+3+...+n\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u4e58\u9664\u6cd5\u3001for\u3001while\u3001if\u3001else\u3001switch\u3001case\u7b49\u5173\u952e\u5b57\u53ca\u6761\u4ef6\u5224\u65ad\u8bed\u53e5\uff08A?B\uff1aC\uff09\u3002 1 2 3 4 5 6 class Solution { public \uff1a int Sum_Solution ( int n ) { return ( n + 1 ) * n / 2 ; } };","title":"47. \u6c421+2+3+...+n"},{"location":"algo/jsoffer/#48","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u6c42\u4e24\u4e2a\u6574\u6570\u4e4b\u548c\uff0c\u8981\u6c42\u5728\u51fd\u6570\u4f53\u5185\u4e0d\u5f97\u4f7f\u7528+\u3001-\u3001*\u3001/\u56db\u5219\u8fd0\u7b97\u7b26\u53f7\u3002 Solution\uff1aXOR + &A = 000101 = 5, B = 010001 = 17 1) sum = 000101 XOR 010001 = 010100 = 20, pos = 000101 & 010001 = 000001 = 1. We have to move left for 000001 at 0-th position (starting from rightmost). 2) if pos is not 0, A = sum, B = (pos << 1) then continue 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public \uff1a int Add ( int num1 , int num2 ) { int res = num1 ; int pos = num2 ; while ( true ) { res = num1 ^ num2 ; pos = num1 & num2 ; if ( pos == 0 ) { break ; } num1 = res ; num2 = pos << 1 ; } return res ; } };","title":"48. \u4e0d\u7528\u52a0\u51cf\u4e58\u9664\u505a\u52a0\u6cd5*"},{"location":"algo/jsoffer/#49","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u4e00\u4e2a\u6574\u6570\uff0c\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u5b57\u7b26\u4e32\u8f6c\u6362\u6574\u6570\u7684\u5e93\u51fd\u6570\u3002\u6570\u503c\u4e3a0\u6216\u8005\u5b57\u7b26\u4e32\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u6570\u503c\u5219\u8fd4\u56de0\u3002\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32,\u5305\u62ec\u6570\u5b57\u5b57\u6bcd\u7b26\u53f7,\u53ef\u4ee5\u4e3a\u7a7a\u3002\u5982\u679c\u662f\u5408\u6cd5\u7684\u6570\u503c\u8868\u8fbe\u5219\u8fd4\u56de\u8be5\u6570\u5b57\uff0c\u5426\u5219\u8fd4\u56de0\u3002 \u8f93\u5165+21474836471a33 \u8f93\u51fa21474836470 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public \uff1a int StrToInt ( string str ) { int n = int ( str . length ()); if ( n == 0 ) { return 0 ; } int num = 0 ; bool isPlus = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 && str [ 0 ] == '-' ) { isPlus = false ; continue ; } if ( i == 0 && str [ 0 ] == '+' ) { continue ; } if ( str [ i ] > '9' || str [ i ] < '0' ) { return 0 ; } num = num * 10 + str [ i ] - '0' ; } if ( ! isPlus ) { return - num ; } return num ; } };","title":"49. \u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570"},{"location":"algo/jsoffer/#50","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4\u91cc\u7684\u6240\u6709\u6570\u5b57\u90fd\u57280\u5230n-1\u7684\u8303\u56f4\u5185\u3002 \u6570\u7ec4\u4e2d\u67d0\u4e9b\u6570\u5b57\u662f\u91cd\u590d\u7684\uff0c\u4f46\u4e0d\u77e5\u9053\u6709\u51e0\u4e2a\u6570\u5b57\u662f\u91cd\u590d\u7684\u3002\u4e5f\u4e0d\u77e5\u9053\u6bcf\u4e2a\u6570\u5b57\u91cd\u590d\u51e0\u6b21\u3002\u8bf7\u627e\u51fa\u6570\u7ec4\u4e2d\u4efb\u610f\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b57\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u957f\u5ea6\u4e3a7\u7684\u6570\u7ec4{2,3,1,0,2,5,3}\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u8f93\u51fa\u662f\u7b2c\u4e00\u4e2a\u91cd\u590d\u7684\u6570\u5b572\u3002\u8fd4\u56de\u63cf\u8ff0\uff1a\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u51fd\u6570\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u7684\u6570\u5b57\uff0c\u628a\u91cd\u590d\u7684\u6570\u5b57\u653e\u5230\u53c2\u6570duplication[0]\u4e2d\u3002\uff08ps\uff1aduplication\u5df2\u7ecf\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u76f4\u63a5\u8d4b\u503c\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public \uff1a // Parameters\uff1a // numbers\uff1a an array of integers // length\uff1a the length of array numbers // duplication\uff1a (Output) the duplicated number in the array number // Return value\uff1a true if the input is valid, and there are some // duplications in the array number // otherwise false bool duplicate ( int numbers [], int length , int * duplication ) { if ( length == 0 ) { return false ; } int * arr = new int [ length ]{}; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ numbers [ i ]] == length ) { arr [ numbers [ i ]] = i ; } if ( arr [ numbers [ i ]] == 0 ) { arr [ numbers [ i ]] = length ; } } int idx = length ; for ( int i = 0 ; i < length ; i ++ ) { if ( arr [ i ] == 0 ) { continue ; } if ( idx > arr [ i ]) { idx = arr [ i ]; } } delete [] arr ; if ( idx == length ) { return false ; } * duplication = numbers [ idx ]; return true ; } };","title":"50. \u6570\u7ec4\u4e2d\u91cd\u590d\u7684\u6570\u5b57"},{"location":"algo/jsoffer/#51","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4A[0,1,...,n-1], \u8bf7\u6784\u5efa\u4e00\u4e2a\u6570\u7ec4B[0,1,...,n-1], \u5176\u4e2dB\u4e2d\u7684\u5143\u7d20 B[i] = A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]\u3002\u4e0d\u80fd\u4f7f\u7528\u9664\u6cd5\u3002\uff08\u6ce8\u610f\uff1a\u89c4\u5b9aB[0] = A[1] * A[2] * ... * A[n-1]\uff0cB[n-1] = A[0] * A[1] * ... * A[n-2];\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public \uff1a vector < int > multiply ( const vector < int >& A ) { vector < int > res ; int n = int ( A . size ()); if ( n == 0 ) { return res ; } for ( int i = 0 ; i < n ; i ++ ) { int mul = A [ 0 ]; for ( int j = 1 ; j < n ; j ++ ) { if ( j == i ) { continue ; } if ( A [ j ] == 0 ) { mul = 0 ; break ; } mul *= A [ j ]; } res . push_back ( mul ); } return res ; } };","title":"51. \u6784\u5efa\u4e58\u79ef\u6570\u7ec4"},{"location":"algo/jsoffer/#52","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5339\u914d\u5305\u62ec'.'\u548c' '\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\u6a21\u5f0f\u4e2d\u7684\u5b57\u7b26'.'\u8868\u793a\u4efb\u610f\u4e00\u4e2a\u5b57\u7b26\uff0c\u800c' '\u8868\u793a\u5b83\u524d\u9762\u7684\u5b57\u7b26\u53ef\u4ee5\u51fa\u73b0\u4efb\u610f\u6b21\uff08\u5305\u542b0\u6b21\uff09\u3002\u5728\u672c\u9898\u4e2d\uff0c\u5339\u914d\u662f\u6307\u5b57\u7b26\u4e32\u7684\u6240\u6709\u5b57\u7b26\u5339\u914d\u6574\u4e2a\u6a21\u5f0f\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"aaa\"\u4e0e\u6a21\u5f0f\"a.a\"\u548c\"ab ac a\"\u5339\u914d\uff0c\u4f46\u662f\u4e0e\"aa.a\"\u548c\"ab*a\"\u5747\u4e0d\u5339\u914d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a bool match ( char * str , char * pattern ) { size_t ns = strlen ( str ), np = strlen ( pattern ); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = ( i < ns ) && ( str [ i ] == pattern [ j ] || pattern [ j ] == '.' ); if ( j < np - 1 && pattern [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } bool res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } };","title":"52. \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d*"},{"location":"algo/jsoffer/#53","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u8868\u793a\u6570\u503c\uff08\u5305\u62ec\u6574\u6570\u548c\u5c0f\u6570\uff09\u3002\u4f8b\u5982\uff0c\u5b57\u7b26\u4e32\"+100\", \"5e2\", \"-123\", \"3.1416\" \u548c \"-1E-16\" \u90fd\u8868\u793a\u6570\u503c\u3002 \u4f46\u662f \"12e\", \"1a3.14\", \"1.2.3\", \"+-5\" \u548c \"12e+4.3\" \u90fd\u4e0d\u662f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a bool isNumeric ( char * string ) { size_t n = strlen ( string ); if ( n == 0 ) { return false ; } bool isEx = false , isPt = false ; for ( int i = 0 ; i < n ; i ++ ) { if (( string [ i ] == '+' || string [ i ] == '-' )) { if ( i == 0 ) { continue ; } if ( string [ i - 1 ] == 'E' || string [ i - 1 ] == 'e' ) { continue ; } return false ; } if ( string [ i ] == 'e' || string [ i ] == 'E' ) { if ( isEx || i == n - 1 ) { return false ; } isEx = true ; continue ; } if ( string [ i ] == '.' ) { if ( isPt || isEx || i == n - 1 ) { return false ; } isPt = true ; continue ; } if ( string [ i ] > '9' || string [ i ] < '0' ) { return false ; } } return true ; } };","title":"53. \u8868\u793a\u6570\u503c\u7684\u5b57\u7b26\u4e32*"},{"location":"algo/jsoffer/#54","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u7528\u6765\u627e\u51fa\u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5f53\u4ece\u5b57\u7b26\u6d41\u4e2d\u53ea\u8bfb\u51fa\u524d\u4e24\u4e2a\u5b57\u7b26\"go\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"g\"\u3002\u5f53\u4ece\u8be5\u5b57\u7b26\u6d41\u4e2d\u8bfb\u51fa\u524d\u516d\u4e2a\u5b57\u7b26\u201cgoogle\"\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\u662f\"l\"\u3002\u5982\u679c\u5f53\u524d\u5b57\u7b26\u6d41\u6ca1\u6709\u5b58\u5728\u51fa\u73b0\u4e00\u6b21\u7684\u5b57\u7b26\uff0c\u8fd4\u56de#\u5b57\u7b26\u3002 Solution\uff1aint[0\uff1a256] = 0Give each ACSII a position index in the char flow starting from 1.If repeat appears, set int[i] = -1Return ACSII with minimum position index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { int * ascii ; int N ; int flow ; public \uff1a Solution () { N = 256 ; ascii = new int [ N ]{}; flow = 1 ; } ~ Solution () { delete [] ascii ; } //Insert one char from stringstream void Insert ( char ch ) { int idx = int ( ch ); if ( ascii [ idx ] == 0 ) { ascii [ idx ] = flow ; } else { ascii [ idx ] = - 1 ; } flow ++ ; } //return the first appearence once char in current stringstream char FirstAppearingOnce () { int pos = flow , ch = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ascii [ i ] < 1 ) { continue ; } if ( pos > ascii [ i ]) { pos = ascii [ i ]; ch = i ; } } if ( pos == flow ) { return '#' ; } return char ( ch ); } };","title":"54. \u5b57\u7b26\u6d41\u4e2d\u7b2c\u4e00\u4e2a\u4e0d\u91cd\u590d\u7684\u5b57\u7b26*"},{"location":"algo/jsoffer/#55","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4e00\u4e2a\u94fe\u8868\uff0c\u82e5\u5176\u4e2d\u5305\u542b\u73af\uff0c\u8bf7\u627e\u51fa\u8be5\u94fe\u8868\u7684\u73af\u7684\u5165\u53e3\u7ed3\u70b9\uff0c\u5426\u5219\uff0c\u8f93\u51fanull\u3002 For the case of circle. Set two pointors p1 and p2 staring from head. p1 moves one step each time; p2 moves 2 steps each time. Because of a loop, p1 and p2 will definitely come across at some node in the loop. Suppose p1 moves x steps, then p2 moves evidently 2x steps. Besides, p2 has covered at least one circile. 2x - x = kn, \\quad k = 1, 2, 3, ... 2x - x = kn, \\quad k = 1, 2, 3, ... where n denotes the length of loop. We can also see both p1 and p2 have covered the part beyond the loop, says L1. x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... x = L1 + L2 + k_{1}n = k_{2}n, \\quad k_{1} = 0, 1, 2, ...; k_{2} = 1, 2, 3, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... L1 + L2 = kn, \\quad k = 0, 1, 2, ... So, we one pointor moves starting from M and the other moves starting from head and both of them move with 1 step. Then they will meet again at the statrt of loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * EntryNodeOfLoop ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * p1 = pHead , * p2 = pHead ; while ( p1 != NULL && p2 != NULL ) { p1 = p1 -> next ; p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p1 == p2 ) { break ; } } p2 = pHead ; while ( p2 != p1 ) { p1 = p1 -> next ; p2 = p2 -> next ; } return p1 ; } };","title":"55. \u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u7ed3\u70b9*"},{"location":"algo/jsoffer/#56","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5728\u4e00\u4e2a\u6392\u5e8f\u7684\u94fe\u8868\u4e2d\uff0c\u5b58\u5728\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u8bf7\u5220\u9664\u8be5\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9\uff0c\u91cd\u590d\u7684\u7ed3\u70b9\u4e0d\u4fdd\u7559\uff0c\u8fd4\u56de\u94fe\u8868\u5934\u6307\u9488\u3002 \u4f8b\u5982\uff0c\u94fe\u88681->2->3->3->4->4->5 \u5904\u7406\u540e\u4e3a 1->2->5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) \uff1a val(x), next(NULL) { } }; */ class Solution { public \uff1a ListNode * deleteDuplication ( ListNode * pHead ) { if ( pHead == NULL ) { return NULL ; } ListNode * pre = new ListNode ( 0 ); pre -> next = pHead ; ListNode * par = pre , * cur = pHead ; bool isDup = false ; while ( cur != NULL ) { while ( cur -> next != NULL && cur -> next -> val == cur -> val ) { cur = cur -> next ; isDup = true ; } cur = cur -> next ; if ( isDup ) { par -> next = cur ; isDup = false ; } else { par = par -> next ; } } pHead = pre -> next ; delete pre ; return pHead ; } };","title":"56. \u5220\u9664\u94fe\u8868\u4e2d\u91cd\u590d\u7684\u7ed3\u70b9"},{"location":"algo/jsoffer/#57","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\u548c\u5176\u4e2d\u7684\u4e00\u4e2a\u7ed3\u70b9\uff0c\u8bf7\u627e\u51fa\u4e2d\u5e8f\u904d\u5386\u987a\u5e8f\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u5e76\u4e14\u8fd4\u56de\u3002\u6ce8\u610f\uff0c\u6811\u4e2d\u7684\u7ed3\u70b9\u4e0d\u4ec5\u5305\u542b\u5de6\u53f3\u5b50\u7ed3\u70b9\uff0c\u540c\u65f6\u5305\u542b\u6307\u5411\u7236\u7ed3\u70b9\u7684\u6307\u9488\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) \uff1aval(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public \uff1a TreeLinkNode * GetNext ( TreeLinkNode * pNode ) { if ( pNode == NULL ) { return NULL ; } if ( pNode -> right != NULL ) { TreeLinkNode * curNode = pNode -> right ; while ( curNode -> left != NULL ) { curNode = curNode -> left ; } return curNode ; } if ( pNode -> next == NULL ) { return NULL ; } if ( pNode -> next -> left == pNode ) { return pNode -> next ; } if ( pNode -> next -> next != NULL && pNode -> next -> next -> left == pNode -> next ) { return pNode -> next -> next ; } return NULL ; } };","title":"57. \u4e8c\u53c9\u6811\u7684\u4e0b\u4e00\u4e2a\u7ed3\u70b9"},{"location":"algo/jsoffer/#58","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u4e00\u9897\u4e8c\u53c9\u6811\u662f\u4e0d\u662f\u5bf9\u79f0\u7684\u3002\u6ce8\u610f\uff0c\u5982\u679c\u4e00\u4e2a\u4e8c\u53c9\u6811\u540c\u6b64\u4e8c\u53c9\u6811\u7684\u955c\u50cf\u662f\u540c\u6837\u7684\uff0c\u5b9a\u4e49\u5176\u4e3a\u5bf9\u79f0\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a bool isSymmetrical ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return true ; } return isSymmetricalSubtree ( pRoot -> left , pRoot -> right ); } bool isSymmetricalSubtree ( TreeNode * left , TreeNode * right ) { if ( left == NULL && right == NULL ) { return true ; } if ( left == NULL || right == NULL ) { return false ; } if ( left -> val != right -> val ) { return false ; } bool L = isSymmetricalSubtree ( left -> left , right -> right ); bool R = isSymmetricalSubtree ( left -> right , right -> left ); return ( L && R ); } };","title":"58. \u5bf9\u79f0\u7684\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#59","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570\u6309\u7167\u4e4b\u5b57\u5f62\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u5373\u7b2c\u4e00\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e8c\u5c42\u6309\u7167\u4ece\u53f3\u81f3\u5de6\u7684\u987a\u5e8f\u6253\u5370\uff0c\u7b2c\u4e09\u884c\u6309\u7167\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6253\u5370\uff0c\u5176\u4ed6\u884c\u4ee5\u6b64\u7c7b\u63a8\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a void inverse ( vector < int >& arr ) { int len = int ( arr . size ()); for ( int i = 0 ; i < len / 2 ; i ++ ) { int temp = arr [ i ]; arr [ i ] = arr [ len - 1 - i ]; arr [ len - 1 - i ] = temp ; } } vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int >> res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; int count = 1 ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { if ( count % 2 == 0 ) { inverse ( temp ); } count ++ ; res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } };","title":"59. \u6309\u4e4b\u5b57\u5f62\u987a\u5e8f\u6253\u5370\u4e8c\u53c9\u6811"},{"location":"algo/jsoffer/#60","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u4ece\u4e0a\u5230\u4e0b\u6309\u5c42\u6253\u5370\u4e8c\u53c9\u6811\uff0c\u540c\u4e00\u5c42\u7ed3\u70b9\u4ece\u5de6\u81f3\u53f3\u8f93\u51fa\u3002\u6bcf\u4e00\u5c42\u8f93\u51fa\u4e00\u884c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int > > res ; if ( pRoot == NULL ) { return res ; } queue < TreeNode *> tree ; TreeNode * last , * nextlast , * front ; tree . push ( pRoot ); last = nextlast = front = pRoot ; vector < int > temp ; while ( ! tree . empty ()) { front = tree . front (); tree . pop (); temp . push_back ( front -> val ); if ( front -> left != NULL ) { tree . push ( front -> left ); nextlast = front -> left ; } if ( front -> right != NULL ) { tree . push ( front -> right ); nextlast = front -> right ; } if ( last == front ) { res . push_back ( temp ); temp . clear (); last = nextlast ; } } return res ; } };","title":"60. \u628a\u4e8c\u53c9\u6811\u6253\u5370\u6210\u591a\u884c"},{"location":"algo/jsoffer/#61","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8bf7\u5b9e\u73b0\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u6765\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u4e8c\u53c9\u6811 \u4e8c\u53c9\u6811\u7684\u5e8f\u5217\u5316\u662f\u6307\uff1a\u628a\u4e00\u68f5\u4e8c\u53c9\u6811\u6309\u7167\u67d0\u79cd\u904d\u5386\u65b9\u5f0f\u7684\u7ed3\u679c\u4ee5\u67d0\u79cd\u683c\u5f0f\u4fdd\u5b58\u4e3a\u5b57\u7b26\u4e32\uff0c\u4ece\u800c\u4f7f\u5f97\u5185\u5b58\u4e2d\u5efa\u7acb\u8d77\u6765\u7684\u4e8c\u53c9\u6811\u53ef\u4ee5\u6301\u4e45\u4fdd\u5b58\u3002\u5e8f\u5217\u5316\u53ef\u4ee5\u57fa\u4e8e\u5148\u5e8f\u3001\u4e2d\u5e8f\u3001\u540e\u5e8f\u3001\u5c42\u5e8f\u7684\u4e8c\u53c9\u6811\u904d\u5386\u65b9\u5f0f\u6765\u8fdb\u884c\u4fee\u6539\uff0c\u5e8f\u5217\u5316\u7684\u7ed3\u679c\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5e8f\u5217\u5316\u65f6\u901a\u8fc7 \u67d0\u79cd\u7b26\u53f7\u8868\u793a\u7a7a\u8282\u70b9\uff08#\uff09\uff0c\u4ee5 \uff01 \u8868\u793a\u4e00\u4e2a\u7ed3\u70b9\u503c\u7684\u7ed3\u675f\uff08value!\uff09\u3002\u4e8c\u53c9\u6811\u7684\u53cd\u5e8f\u5217\u5316\u662f\u6307\uff1a\u6839\u636e\u67d0\u79cd\u904d\u5386\u987a\u5e8f\u5f97\u5230\u7684\u5e8f\u5217\u5316\u5b57\u7b26\u4e32\u7ed3\u679cstr\uff0c\u91cd\u6784\u4e8c\u53c9\u6811\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u4e00\u4e2a\u53ea\u6709\u6839\u8282\u70b9\u4e3a1\u7684\u4e8c\u53c9\u6811\u5e8f\u5217\u5316\u4e3a\"1,\"\uff0c\u7136\u540e\u901a\u8fc7\u81ea\u5df1\u7684\u51fd\u6570\u6765\u89e3\u6790\u56de\u8fd9\u4e2a\u4e8c\u53c9\u6811 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a char * Serialize ( TreeNode * root ) { string pre = \"\" , in = \"\" ; preOrder ( root , pre ); inOrder ( root , in ); pre . push_back ( '#' ); pre += in ; int n = int ( pre . length ()); char * str = new char [ n + 1 ]{}; for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = pre [ i ]; } str [ n ] = '\\0' ; return str ; } void preOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { str += to_string ( root -> val ); str . push_back ( ',' ); preOrder ( root -> left , str ); preOrder ( root -> right , str ); } } void inOrder ( TreeNode * root , string & str ) { if ( root != NULL ) { inOrder ( root -> left , str ); str += to_string ( root -> val ); str . push_back ( ',' ); inOrder ( root -> right , str ); } } TreeNode * Deserialize ( char * str ) { vector < int > pre , in ; bool isPre = true ; int val = 0 ; for ( int i = 0 ; i < strlen ( str ); i ++ ) { if ( str [ i ] == '#' ) { isPre = false ; continue ; } if ( str [ i ] == ',' ) { if ( isPre ) { pre . push_back ( val ); } else { in . push_back ( val ); } val = 0 ; continue ; } val = val * 10 + ( str [ i ] - '0' ); } int n = int ( pre . size ()); if ( n == 0 ) { return NULL ; } return constructTree ( pre , in , 0 , n - 1 , 0 , n - 1 ); } TreeNode * constructTree ( vector < int > pre , vector < int > in , int b1 , int e1 , int b2 , int e2 ) { if ( b1 > e1 || b2 > e2 ) { return NULL ; } TreeNode * root = new TreeNode ( pre [ b1 ]); int numLeft = 0 ; for ( int i = b2 ; i <= e2 ; i ++ , numLeft ++ ) { if ( in [ i ] == pre [ b1 ]) { break ; } } root -> left = constructTree ( pre , in , b1 + 1 , b1 + numLeft , b2 , b2 + numLeft - 1 ); root -> right = constructTree ( pre , in , b1 + numLeft + 1 , e1 , b2 + numLeft + 1 , e2 ); return root ; } };","title":"61. \u5e8f\u5217\u5316\u4e8c\u53c9\u6811*"},{"location":"algo/jsoffer/#62-k","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u8bf7\u627e\u51fa\u5176\u4e2d\u7684\u7b2ck\u5c0f\u7684\u7ed3\u70b9\u3002\u4f8b\u5982\uff0c\uff085\uff0c3\uff0c7\uff0c2\uff0c4\uff0c6\uff0c8\uff09\u4e2d\uff0c\u6309\u7ed3\u70b9\u6570\u503c\u5927\u5c0f\u987a\u5e8f\u7b2c\u4e09\u5c0f\u7ed3\u70b9\u7684\u503c\u4e3a4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) \uff1a val(x), left(NULL), right(NULL) { } }; */ class Solution { public \uff1a TreeNode * KthNode ( TreeNode * pRoot , int k ) { TreeNode * res = NULL ; inOrder ( pRoot , k , res ); return res ; } void inOrder ( TreeNode * root , int & k , TreeNode *& res ) { if ( root != NULL ) { inOrder ( root -> left , k , res ); k -- ; if ( k == 0 ) { res = root ; } inOrder ( root -> right , k , res ); } } };","title":"62. \u4e8c\u53c9\u6811\u7684\u7b2ck\u4e2a\u7ed3\u70b9*"},{"location":"algo/jsoffer/#63","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5982\u4f55\u5f97\u5230\u4e00\u4e2a\u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570\uff1f\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5947\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4f4d\u4e8e\u4e2d\u95f4\u7684\u6570\u503c\u3002\u5982\u679c\u4ece\u6570\u636e\u6d41\u4e2d\u8bfb\u51fa\u5076\u6570\u4e2a\u6570\u503c\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u503c\u6392\u5e8f\u4e4b\u540e\u4e2d\u95f4\u4e24\u4e2a\u6570\u7684\u5e73\u5747\u503c\u3002\u6211\u4eec\u4f7f\u7528Insert()\u65b9\u6cd5\u8bfb\u53d6\u6570\u636e\u6d41\uff0c\u4f7f\u7528GetMedian()\u65b9\u6cd5\u83b7\u53d6\u5f53\u524d\u8bfb\u53d6\u6570\u636e\u7684\u4e2d\u4f4d\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { vector < int > arr ; public \uff1a void Insert ( int num ) { arr . push_back ( num ); } void swap ( vector < int >& arr , int i , int j ) { int temp = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = temp ; } void quickSort ( vector < int >& arr , int begin , int end , int n ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( arr [ i ] > arr [ j ] && i < j ) { j -- ; } swap ( arr , i , j ); while ( arr [ i ] > arr [ j ] && i < j ) { i ++ ; } swap ( arr , i , j ); } quickSort ( arr , begin , i - 1 , n ); quickSort ( arr , j + 1 , end , n ); } } double GetMedian () { int n = int ( arr . size ()); quickSort ( arr , 0 , n - 1 , n ); if ( n % 2 ) { return arr [ n / 2 ]; } else { return ( arr [( n - 1 ) / 2 ] + arr [ n / 2 ]) / 2.0 ; } } };","title":"63. \u6570\u636e\u6d41\u4e2d\u7684\u4e2d\u4f4d\u6570"},{"location":"algo/jsoffer/#64","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u548c\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f\uff0c\u627e\u51fa\u6240\u6709\u6ed1\u52a8\u7a97\u53e3\u91cc\u6570\u503c\u7684\u6700\u5927\u503c\u3002\u4f8b\u5982\uff0c\u5982\u679c\u8f93\u5165\u6570\u7ec4{2,3,4,2,6,2,5,1}\u53ca\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f3\uff0c\u90a3\u4e48\u4e00\u5171\u5b58\u57286\u4e2a\u6ed1\u52a8\u7a97\u53e3\uff0c\u4ed6\u4eec\u7684\u6700\u5927\u503c\u5206\u522b\u4e3a{4,4,6,6,6,5}\uff1b \u9488\u5bf9\u6570\u7ec4{2,3,4,2,6,2,5,1}\u7684\u6ed1\u52a8\u7a97\u53e3\u6709\u4ee5\u4e0b6\u4e2a\uff1a {[2,3,4],2,6,2,5,1}\uff0c {2,[3,4,2],6,2,5,1}\uff0c {2,3,[4,2,6],2,5,1}\uff0c {2,3,4,[2,6,2],5,1}\uff0c {2,3,4,2,[6,2,5],1}\uff0c {2,3,4,2,6,[2,5,1]}\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public \uff1a vector < int > maxInWindows ( const vector < int >& num , unsigned int size ) { vector < int > res ; int n = int ( num . size ()); if ( n < size || size < 1 ) { return res ; } for ( int i = 0 ; i < n - size + 1 ; i ++ ) { int max = num [ i ]; for ( int j = i + 1 ; j <= i + size - 1 ; j ++ ) { if ( max < num [ j ]) { max = num [ j ]; } } res . push_back ( max ); } return res ; } };","title":"64. \u6ed1\u52a8\u7a97\u53e3\u7684\u6700\u5927\u503c"},{"location":"algo/jsoffer/#65","text":"\u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6765\u5224\u65ad\u5728\u4e00\u4e2a\u77e9\u9635\u4e2d\u662f\u5426\u5b58\u5728\u4e00\u6761\u5305\u542b\u67d0\u5b57\u7b26\u4e32\u6240\u6709\u5b57\u7b26\u7684\u8def\u5f84\u3002\u8def\u5f84\u53ef\u4ee5\u4ece\u77e9\u9635\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u683c\u5b50\u5f00\u59cb\uff0c\u6bcf\u4e00\u6b65\u53ef\u4ee5\u5728\u77e9\u9635\u4e2d\u5411\u5de6\uff0c\u5411\u53f3\uff0c\u5411\u4e0a\uff0c\u5411\u4e0b\u79fb\u52a8\u4e00\u4e2a\u683c\u5b50\u3002\u5982\u679c\u4e00\u6761\u8def\u5f84\u7ecf\u8fc7\u4e86\u77e9\u9635\u4e2d\u7684\u67d0\u4e00\u4e2a\u683c\u5b50\uff0c\u5219\u8be5\u8def\u5f84\u4e0d\u80fd\u518d\u8fdb\u5165\u8be5\u683c\u5b50\u3002 \u4f8b\u5982 \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} \\begin{bmatrix} a & b & c & e\\\\ s & f & c & s\\\\ a & d & e & e \\end{bmatrix} (stock in an array [a, b, c, e, s, f, c, s, a, d, e, e])\u3002 \u77e9\u9635\u4e2d\u5305\u542b\u4e00\u6761\u5b57\u7b26\u4e32\"bcced\"\u7684\u8def\u5f84\uff0c\u4f46\u662f\u77e9\u9635\u4e2d\u4e0d\u5305\u542b\"abcb\"\u8def\u5f84\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26b\u5360\u636e\u4e86\u77e9\u9635\u4e2d\u7684\u7b2c\u4e00\u884c\u7b2c\u4e8c\u4e2a\u683c\u5b50\u4e4b\u540e\uff0c\u8def\u5f84\u4e0d\u80fd\u518d\u6b21\u8fdb\u5165\u8be5\u683c\u5b50\u3002 Solution\uff1aBacktracking\uff1a if we can find one character matched, we continue to explore next one (up, down, left, right); if one character doesn't match, we reset all previous positions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public \uff1a bool hasPath ( char * matrix , int rows , int cols , char * str ) { bool * dp = new bool [ rows * cols ]{}, res = false ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( isPath ( i , j , rows , cols , matrix , str , dp , 0 )) { res = true ; break ; } } } delete [] dp ; return res ; } bool isPath ( int i , int j , int nRow , int nCol , char * mat , char * str , bool * dp , int k ) { int idx = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ idx ] || mat [ idx ] != str [ k ]) { return false ; } if ( str [ k + 1 ] == '\\0' ) { return true ; } dp [ idx ] = true ; bool u = isPath ( i - 1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool d = isPath ( i + 1 , j , nRow , nCol , mat , str , dp , k + 1 ); bool l = isPath ( i , j - 1 , nRow , nCol , mat , str , dp , k + 1 ); bool r = isPath ( i , j + 1 , nRow , nCol , mat , str , dp , k + 1 ); dp [ idx ] = false ; return u || d || l || r ; } };","title":"65. \u77e9\u9635\u4e2d\u7684\u8def\u5f84"},{"location":"algo/jsoffer/#66","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5730\u4e0a\u6709\u4e00\u4e2am\u884c\u548cn\u5217\u7684\u65b9\u683c\u3002\u4e00\u4e2a\u673a\u5668\u4eba\u4ece\u5750\u68070,0\u7684\u683c\u5b50\u5f00\u59cb\u79fb\u52a8\uff0c\u6bcf\u4e00\u6b21\u53ea\u80fd\u5411\u5de6\uff0c\u53f3\uff0c\u4e0a\uff0c\u4e0b\u56db\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u4e0d\u80fd\u8fdb\u5165\u884c\u5750\u6807\u548c\u5217\u5750\u6807\u7684\u6570\u4f4d\u4e4b\u548c\u5927\u4e8ek\u7684\u683c\u5b50\u3002 \u4f8b\u5982\uff0c\u5f53k\u4e3a18\u65f6\uff0c\u673a\u5668\u4eba\u80fd\u591f\u8fdb\u5165\u65b9\u683c\uff0835,37\uff09\uff0c\u56e0\u4e3a3+5+3+7 = 18\u3002\u4f46\u662f\uff0c\u5b83\u4e0d\u80fd\u8fdb\u5165\u65b9\u683c\uff0835,38\uff09\uff0c\u56e0\u4e3a3+5+3+8 = 19\u3002\u8bf7\u95ee\u8be5\u673a\u5668\u4eba\u80fd\u591f\u8fbe\u5230\u591a\u5c11\u4e2a\u683c\u5b50\uff1f Solution\uff1aBacktracking is one of brutal force method in searching. We cannot simply count how many grids which are illegal because the robot can only move one cell once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public \uff1a int movingCount ( int threshold , int rows , int cols ) { bool * dp = new bool [ rows * cols ]{}; int count = move ( threshold , rows , cols , 0 , 0 , dp ); delete [] dp ; return count ; } int move ( int threshold , int nRow , int nCol , int i , int j , bool * dp ) { int pos = i * nCol + j ; if ( i < 0 || i >= nRow || j < 0 || j >= nCol || dp [ pos ] || toSum ( i ) + toSum ( j ) > threshold ) { return 0 ; } dp [ pos ] = true ; int u = move ( threshold , nRow , nCol , i - 1 , j , dp ); int d = move ( threshold , nRow , nCol , i + 1 , j , dp ); int l = move ( threshold , nRow , nCol , i , j - 1 , dp ); int r = move ( threshold , nRow , nCol , i , j + 1 , dp ); return 1 + u + d + l + r ; } int toSum ( int num ) { int sum = 0 ; while ( num ) { sum += num % 10 ; num /= 10 ; } return sum ; } };","title":"66. \u673a\u5668\u4eba\u7684\u8fd0\u52a8\u8303\u56f4*"},{"location":"algo/jsoffer/#67","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u4f60\u4e00\u6839\u957f\u5ea6\u4e3an\u7684\u7ef3\u5b50\uff0c\u8bf7\u628a\u7ef3\u5b50\u526a\u6210\u6574\u6570\u957f\u7684m\u6bb5\uff08m\u3001n\u90fd\u662f\u6574\u6570\uff0cn>1\u5e76\u4e14m>1\uff09\uff0c\u6bcf\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u8bb0\u4e3ak[0],k[1],...,k[m]\u3002\u8bf7\u95eek[0]xk[1]x...xk[m]\u53ef\u80fd\u7684\u6700\u5927\u4e58\u79ef\u662f\u591a\u5c11\uff1f\u4f8b\u5982\uff0c\u5f53\u7ef3\u5b50\u7684\u957f\u5ea6\u662f8\u65f6\uff0c\u6211\u4eec\u628a\u5b83\u526a\u6210\u957f\u5ea6\u5206\u522b\u4e3a2\u30013\u30013\u7684\u4e09\u6bb5\uff0c\u6b64\u65f6\u5f97\u5230\u7684\u6700\u5927\u4e58\u79ef\u662f18\u3002 \u793a\u4f8b1\uff1a\u8f93\u51658\u8f93\u51fa18 Solution\uff1aSuppose f(n) denote the max product. We have an interative equation f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} f(n) = \\begin{cases} n, \\quad 0 < n < 4 \\\\ \\max_{i} f(i)f(n-i), \\quad i = 1, 2, ..., \\left \\lfloor \\frac{n}{2} \\right \\rfloor, \\quad \\text{otherwise} \\end{cases} Attention, there is some special case, when n = 2, we should return 1. In iterative equation, f(2) denotes length of the rope. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public \uff1a int cutRope ( int number ) { int n = number ; if ( n < 2 ) { return 0 ; } if ( n == 2 ) { return 1 ; } if ( n == 3 ) { return 2 ; } int * f = new int [ n + 1 ]{}; f [ 1 ] = 1 ; f [ 2 ] = 2 ; f [ 3 ] = 3 ; int prod = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { int max_prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { prod = f [ j ] * f [ i - j ]; if ( max_prod < prod ) { max_prod = prod ; } } f [ i ] = max_prod ; } int res = f [ n ]; delete [] f ; return res ; } };","title":"67. \u526a\u7ef3\u5b50*"},{"location":"algo/jsoffer/#68-oj","text":"","title":"68. OJ\u5728\u7ebf\u7f16\u7a0b\u5e38\u89c1\u8f93\u5165\u8f93\u51fa\u7ec3\u4e60\u573a"},{"location":"algo/jsoffer/#681-ab1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { cout << a + b << endl ; } return 0 ; }","title":"68.1 A+B(1)"},{"location":"algo/jsoffer/#682-ab2","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6570\u636e\u7ec4\u6570t(1 <= t <= 100)\u63a5\u4e0b\u6765\u6bcf\u884c\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9)\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516521 510 20 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> using namespace std ; int main () { int t ; long a , b ; cin >> t ; while ( t -- ) { cin >> a >> b ; cout << ( a + b ) << endl ; } return 0 ; }","title":"68.2 A+B(2)"},{"location":"algo/jsoffer/#683-ab3","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97a+b\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u5305\u62ec\u4e24\u4e2a\u6b63\u6574\u6570a,b(1 <= a, b <= 10^9),\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u5982\u679c\u8f93\u5165\u4e3a0 0\u5219\u7ed3\u675f\u8f93\u5165\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51faa+b\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 510 200 0 \u8f93\u51fa630 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> using namespace std ; int main () { long a , b ; while ( cin >> a >> b ) { if ( a == 0 && b == 0 ) { break ; } cout << ( a + b ) << endl ; } return 0 ; }","title":"68.3 A+B(3)"},{"location":"algo/jsoffer/#684-ab4","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u5305\u62ec\u591a\u7ec4\u3002\u6bcf\u7ec4\u6570\u636e\u4e00\u884c,\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100), n\u4e3a0\u7684\u65f6\u5019\u7ed3\u675f\u8f93\u5165\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570,\u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 50 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { long sum , a ; int n ; while ( true ) { sum = 0 ; cin >> n ; if ( n == 0 ) { break ; } while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; }","title":"68.4 A+B(4)"},{"location":"algo/jsoffer/#685-ab5","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u7684\u7b2c\u4e00\u884c\u5305\u62ec\u4e00\u4e2a\u6b63\u6574\u6570t(1 <= t <= 100), \u8868\u793a\u6570\u636e\u7ec4\u6570\u3002\u63a5\u4e0b\u6765t\u884c, \u6bcf\u884c\u4e00\u7ec4\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u516524 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> using namespace std ; int main () { int t , n ; long sum , a ; cin >> t ; while ( t -- ) { cin >> n ; sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; }","title":"68.5 A+B(5)"},{"location":"algo/jsoffer/#686-ab6","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6574\u6570\u4e3a\u6574\u6570\u7684\u4e2a\u6570n(1 <= n <= 100)\u3002\u63a5\u4e0b\u6765n\u4e2a\u6b63\u6574\u6570, \u5373\u9700\u8981\u6c42\u548c\u7684\u6bcf\u4e2a\u6b63\u6574\u6570\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51654 1 2 3 45 1 2 3 4 5 \u8f93\u51fa1015 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> using namespace std ; int main () { int n ; long sum , a ; while ( cin >> n ) { sum = 0 ; while ( n -- ) { cin >> a ; sum += a ; } cout << sum << endl ; } return 0 ; }","title":"68.6 A+B(6)"},{"location":"algo/jsoffer/#687-ab7","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u8ba1\u7b97\u4e00\u7cfb\u5217\u6570\u7684\u548c\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6570\u636e\u6709\u591a\u7ec4, \u6bcf\u884c\u8868\u793a\u4e00\u7ec4\u8f93\u5165\u6570\u636e\u3002\u6bcf\u884c\u4e0d\u5b9a\u6709n\u4e2a\u6574\u6570\uff0c\u7a7a\u683c\u9694\u5f00\u3002(1 <= n <= 100)\u3002\u8f93\u51fa\u63cf\u8ff0\uff1a\u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u6c42\u548c\u7684\u7ed3\u679c \u793a\u4f8b1 \u8f93\u51651 2 34 50 0 0 0 0 \u8f93\u51fa690 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> using namespace std ; int main () { long sum , a ; sum = 0 ; while ( cin >> a ) { sum += a ; if ( cin . get () == '\\n' ) { cout << sum << endl ; sum = 0 ; } } return 0 ; }","title":"68.7 A+B(7)"},{"location":"algo/jsoffer/#688-1","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u8f93\u5165\u6709\u4e24\u884c\uff0c\u7b2c\u4e00\u884cn\u7b2c\u4e8c\u884c\u662fn\u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u5b57\u7b26\u4e32\u8f93\u51fa\u63cf\u8ff0\uff1a\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7a7a\u683c\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u51655c d a bb e \u8f93\u51faa bb c d e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <string> using namespace std ; void swap ( string * str , int i , int j ) { string temp = str [ i ]; str [ i ] = str [ j ]; str [ j ] = temp ; } void quickSort ( string * str , int begin , int end ) { if ( begin < end ) { int i = begin , j = end ; while ( i < j ) { while ( i < j && str [ i ] <= str [ j ]) { j -- ; } swap ( str , i , j ); while ( i < j && str [ i ] <= str [ j ]) { i ++ ; } swap ( str , i , j ); } quickSort ( str , begin , i - 1 ); quickSort ( str , j + 1 , end ); } } int main () { int n ; cin >> n ; string * str = new string [ n ]; for ( int i = 0 ; i < n ; i ++ ) { cin >> str [ i ]; } quickSort ( str , 0 , n - 1 ); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n - 1 ] << endl ; delete [] str ; return 0 ; }","title":"68.8 \u5b57\u7b26\u4e32\u6392\u5e8f(1)"},{"location":"algo/jsoffer/#689-2","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7\u7a7a\u683c\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u8fc7\u7684\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4e32\u901a\u8fc7\u7a7a\u683c\u9694\u5f00 \u793a\u4f8b1 \u8f93\u5165a c bbf ddddnowcoder \u8f93\u51faa bb cdddd fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <iostream> #include <string> #include <algorithm> #include <vector> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { str . push_back ( temp ); if ( cin . get () == '\\n' ) { sort ( str . begin (), str . end ()); int n = int ( str . size ()); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ' ' ; } cout << str [ n - 1 ] << endl ; str . clear (); } } }","title":"68.9 \u5b57\u7b26\u4e32\u6392\u5e8f(2)"},{"location":"algo/jsoffer/#6810-3","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u6392\u5e8f\u540e\u8f93\u51fa\u8f93\u5165\u63cf\u8ff0\uff1a\u591a\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e00\u884c\u3002\u6bcf\u884c\u901a\u8fc7,\u9694\u5f00\uff0c\u6709n\u4e2a\u5b57\u7b26\uff0cn\uff1c100\u8f93\u51fa\u63cf\u8ff0\uff1a\u5bf9\u4e8e\u6bcf\u7ec4\u7528\u4f8b\u8f93\u51fa\u4e00\u884c\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7528','\u9694\u5f00\uff0c\u65e0\u7ed3\u5c3e\u7a7a\u683c \u793a\u4f8b1 \u8f93\u5165a,c,bbf,ddddnowcoder \u8f93\u51faa,bb,cdddd,fnowcoder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> #include <string> #include <vector> #include <algorithm> using namespace std ; int main () { string temp ; vector < string > str ; while ( cin >> temp ) { int n = int ( temp . length ()); string s = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp [ i ] == ',' ) { str . push_back ( s ); s = \"\" ; continue ; } s . push_back ( temp [ i ]); } str . push_back ( s ); sort ( str . begin (), str . end ()); n = int ( str . size ()); for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << str [ i ] << ',' ; } cout << str [ n - 1 ] << endl ; str . clear (); } }","title":"68.10 \u5b57\u7b26\u4e32\u6392\u5e8f(3)"},{"location":"algo/jsoffer/#69","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570N\u548c\u957f\u5ea6L\uff0c\u627e\u51fa\u4e00\u6bb5\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8eL\u7684\u8fde\u7eed\u975e\u8d1f\u6574\u6570\uff0c\u4ed6\u4eec\u7684\u548c\u6070\u597d\u4e3aN\u3002\u7b54\u6848\u53ef\u80fd\u6709\u591a\u4e2a\uff0c\u6211\u6211\u4eec\u9700\u8981\u627e\u51fa\u957f\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u4f8b\u5982 N = 18 L = 2\uff1a5 + 6 + 7 = 183 + 4 + 5 + 6 = 18\u90fd\u662f\u6ee1\u8db3\u8981\u6c42\u7684\uff0c\u4f46\u662f\u6211\u4eec\u8f93\u51fa\u66f4\u77ed\u7684 5 6 7 \u793a\u4f8b1\uff1a \u8f93\u516518 2 \u8f93\u51fa5 6 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> using namespace std ; void solution ( int N , int L ) { for ( int m = L ; m <= 100 ; m ++ ) { int x = N / m + ( 1 - m ) / 2 ; //cout << x << endl; if (( 2 * x + m - 1 ) * m != 2 * N ) { continue ; } for ( int i = 0 ; i < m - 1 ; i ++ ) { cout << ( x + i ) << ' ' ; } cout << ( x + m - 1 ) << endl ; return ; } cout << \"No\" << endl ; } int main ( int argc , const char * argv []) { // insert code here... int N , L ; scanf ( \"%d%d\" , & N , & L ); solution ( N , L ); return 0 ; }","title":"69. \u5e8f\u5217\u548c"},{"location":"algo/leetcode/","text":"0001. Two Sum \u00b6 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. */ class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { vector < int > res ; int n = int ( nums . size ()); if ( n < 2 ) { return res ; } unordered_map < int , int > M ; unordered_map < int , int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { int diff = target - nums [ i ]; iter = M . find ( diff ); if ( iter != M . end ()) { res . push_back ( i ); res . push_back ( iter -> second ); return res ; } else { M [ nums [ i ]] = i ; } } return res ; } }; 0004. Median of Two Sorted Arrays* \u00b6 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example: nums1 = [1, 3] nums2 = [2] The median is 2.0 nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Solution: This problem requires a time complexity in O(log(m+n)), which determines that we cannot merge sort the twos arrays then get a median value because of o(m+n). A faisible solution is to find k-th value in two sorted arrays based on binary search. \\bigstar \\bigstar Cut two sorted arrays In fact, median is a statistique term, which means a value in middle position. If we want acquire a median value in one sorted array, it is easy to take the value in middlle position. \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad For example, the cutting line split an array into two parts with same size, l1 and r1 are left value and right value of cut postion. Left example is odd array, l1 = r1 = 3, while right example is even array, l1 = 3, r1 = 4. Similarly, we can generalize this to two arrays. If we can find such a cut for two arrays that the number of left cut and the number of right cut are equal, we can determine a median value for the 2 arrays. For example, we determine cut position k1, k2 for A, B respectively. \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\bigstar \\bigstar Unify odd and even number According to traditional way, we have to treat case-by-case: it is different to calculate median value for odd array and even array. In order to conquer this problem, we introuce a virtual placeholder. For example, an original array A is 1 2 3 4 5 and we insert a virtual placeholder # into A, which becomes A' = #1#2#3#4#5#. We see, lenghth of the original array is 5, while length of the new array is 5*2+1. If we cut A' at position 4(5 th character from left). With this method, it's easy to get value in the original. Cut position c = 4 \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} If cut position for A' is in first # or last #, it will cause a overflow problem. \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} As the example shows, if cut position at first #, left = min(A[0], B[0]), while cut position at last #, right = max(A[-1], B[-1]). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = int ( nums1 . size ()), n2 = int ( nums2 . size ()); if ( n1 == 0 ) { return ( nums2 [( n2 - 1 ) / 2 ] + nums2 [ n2 / 2 ]) / 2.0 ; } if ( n2 == 0 ) { return ( nums1 [( n1 - 1 ) / 2 ] + nums1 [ n1 / 2 ]) / 2.0 ; } int MAX = nums1 [ n1 - 1 ] > nums2 [ n2 - 1 ] ? nums1 [ n1 - 1 ] : nums2 [ n2 - 1 ]; int MIN = nums1 [ 0 ] < nums2 [ 0 ] ? nums1 [ 0 ] : nums2 [ 0 ]; if ( n1 < n2 ) { return findK ( nums1 , nums2 , 0 , 2 * n1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums2 , nums1 , 0 , 2 * n2 , n2 , n1 , MAX , MIN ); } } double findK ( vector < int > nums1 , vector < int > nums2 , int b , int e , int n1 , int n2 , int MAX , int MIN ) { int l1 = 0 , l2 = 0 , r1 = 0 , r2 = 0 ; int k1 = ( b + e ) / 2 , k2 = ( n1 + n2 - k1 ); if ( k1 == 0 ) { l1 = MIN ; r1 = nums1 [ 0 ]; } else if ( k1 >= 2 * n1 ) { l1 = nums1 [ n1 - 1 ]; r1 = MAX ; } else { l1 = nums1 [( k1 - 1 ) / 2 ]; r1 = nums1 [ k1 / 2 ]; } if ( k2 == 0 ) { l2 = MIN ; r2 = nums2 [ 0 ]; } else if ( k2 >= 2 * n2 ) { l2 = nums2 [ n2 - 1 ]; r2 = MAX ; } else { l2 = nums2 [( k2 - 1 ) / 2 ]; r2 = nums2 [ k2 / 2 ]; } if ( l1 <= r2 && l2 <= r1 ) { return (( l1 > l2 ? l1 : l2 ) + ( r1 < r2 ? r1 : r2 )) / 2.0 ; } else if ( l1 > r2 ) { return findK ( nums1 , nums2 , b , k1 - 1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums1 , nums2 , k1 + 1 , e , n1 , n2 , MAX , MIN ); } } }; 0005. Longest Palindromic Substring* \u00b6 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\" Output: \"bb\" Solution: Dynamic programming: We construct a table, such that table[i][j] represent a substring fron s[i] to s[j] is palindromic or not. Note that, each single character is palindromic, namely table[i][i] is true. We also assignment table[i][i+1] = true if two adjacent characters are same. Then we visit other substirngs to find the longest one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : string longestPalindrome ( string s ) { int n = int ( s . length ()), pos = 0 , len = 1 ; if ( n < 2 ) { return s ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; pos = i ; len = 2 ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { pos = i ; len = k + 1 ; dp [ i ][ j ] = true ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return s . substr ( pos , len ); } }; 0006. ZigZag Conversion \u00b6 The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : string convert ( string s , int numRows ) { int n = int ( s . length ()); if ( n == 0 || numRows < 2 ) { return s ; } string res = \"\" ; int nRow = numRows , num = 2 * numRows - 2 ; int nCol = ( n / num ) * ( num - nRow + 1 ); if ( n % num < nRow ) { nCol ++ ; } else { nCol += ( n % num ) - nRow + 1 ; } char * mat = new char [ nRow * nCol ]{}; for ( int k = 0 ; k < n ; k ++ ) { int quo = k / num , mod = k % num ; int i = - 1 , j = quo * ( num - nRow + 1 ); if ( mod < nRow ) { i = mod ; } else { i = nRow - 2 - ( mod - nRow ); j += mod - nRow + 1 ; } mat [ i * nCol + j ] = s [ k ]; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( mat [ i * nCol + j ]) { res . push_back ( mat [ i * nCol + j ]); } } } delete [] mat ; return res ; } }; 0007. \u6574\u6570\u53cd\u8f6c \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u7ed9\u4f60\u4e00\u4e2a 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570 x \uff0c\u8fd4\u56de\u5c06 x \u4e2d\u7684\u6570\u5b57\u90e8\u5206\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\u3002 \u5982\u679c\u53cd\u8f6c\u540e\u6574\u6570\u8d85\u8fc7 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570\u7684\u8303\u56f4 [\u2212231, 231 \u2212 1] \uff0c\u5c31\u8fd4\u56de 0\u3002 \u5047\u8bbe\u73af\u5883\u4e0d\u5141\u8bb8\u5b58\u50a8 64 \u4f4d\u6574\u6570\uff08\u6709\u7b26\u53f7\u6216\u65e0\u7b26\u53f7\uff09\u3002 \u8f93\u5165\uff1ax = 123 \u8f93\u51fa\uff1a321 \u8f93\u5165\uff1ax = -123 \u8f93\u51fa\uff1a-321 \u8f93\u5165\uff1ax = 120 \u8f93\u51fa\uff1a21 \u8f93\u5165\uff1ax = 0 \u8f93\u51fa\uff1a0 */ class Solution { public : int reverse ( int x ) { int ans = 0 ; if ( x == INT_MIN ) { return 0 ; } while ( x ) { if ( ans > INT_MAX / 10 || ans < INT_MIN / 10 ) { return 0 ; } ans = ans * 10 + ( x % 10 ); x /= 10 ; } return ans ; } }; 0008. String to Integer (atoi) \u00b6 Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [ -2^{31} -2^{31} , 2^{31} 2^{31} \u22121]. If the numerical value is out of the range of representable values, INT_MAX ( 2^{31} 2^{31} \u2212 1) or INT_MIN (- 2^{31} 2^{31} ) is returned. Example: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a \u00b1 sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (\u2212 2^{31} 2^{31} ) is returned. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int myAtoi ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } bool isNeg = false ; long res = 0 ; int pos = 0 ; while ( s [ pos ] == ' ' ) { pos ++ ; } if ( s [ pos ] == '-' ) { isNeg = true ; } else if ( s [ pos ] == '+' ) { isNeg = false ; } else if ( s [ pos ] >= '0' && s [ pos ] <= '9' ) { res += s [ pos ] - '0' ; } else { return 0 ; } for ( ++ pos ; pos < n ; pos ++ ) { if ( s [ pos ] < '0' || s [ pos ] > '9' ) { break ; } res = res * 10 + s [ pos ] - '0' ; if ( res >= ( 1ll << 31 )) { if ( isNeg ) { return - ( 1ll << 31 ); } else { return ( 1ll << 31 ) - 1 ; } } } if ( isNeg ) { return - res ; } return res ; } }; 0010. Regular Expression Matching* \u00b6 Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"a \" Output: true Explanation: ' ' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\" p = \". \" Output: true Explanation: \". \" means \"zero or more (*) of any character (.)\". Example: 4 Input: s = \"aab\" p = \"c a b\" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\". Example 5: Input: s = \"mississippi\" p = \"mis is p*.\" Output: false Solution: Consider two string s, p. i, j denote some position in s and p. We use dynamic programming with a matrix dp (ns+1) \\times (np+1) (ns+1) \\times (np+1) . ns and np are length of s and p. dp[i][j] denote if s[i:] and p[j:] match. The last entry dp[ns][np] is true. because '' and '' match. Firstly, we check if s[i] and p[j] match ij_match is false or true. Secondly, if p[j+1] is , dp[i][j] has two independent sources: dp[i][j+2] and dp[i+1][j]. In detail, dp[i][j+2] represents we jump over * to check dp[i][j+2]. Similarly, dp[i+1][j] influences dp[i][j] but we have to consider ij_match. Both ij_match and dp[i+1][j] are true, dp[i][j] is true. Otherwise, p[j+1] is not , dp[i][j] is dependent of ij_match and dp[i+1][j+1]. Finally, return dp[0][0] Remark: why we don't consider ij_match for dp[i][j+2]? Because we jump over *. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '.' ); if ( j < np - 1 && p [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } int res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } }; 0011. Container With Most Water* \u00b6 Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 Solution: Brutal force cause Time Limit Exceeded. We use two points method. 1) Firstly, we set two extremities as initial values. 2) Then we move the shorter side towards the longer side one step, e.g. moving 1 towards 7. 3) We repeat 2) until two side are adjacent. During this process, we calculate the max area. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. */ class Solution { public : int maxArea ( vector < int >& height ) { int n = int ( height . size ()); if ( n < 2 ) { return 0 ; } int i = 0 , j = n - 1 , res = 0 ; while ( i < j ) { int a = height [ i ], b = height [ j ]; int B = a < b ? a : b , H = j - i ; if ( B * H > res ) { res = B * H ; } if ( a < b ) { i ++ ; } else { j -- ; } } return res ; } }; 0014. Longest Common Prefix \u00b6 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { int n = int ( strs . size ()); if ( n == 0 ) { return \"\" ; } string str = \"\" ; for ( int j = 0 ; j < int ( strs [ 0 ]. length ()); j ++ ) { char flag = strs [ 0 ][ j ]; for ( int i = 1 ; i < n ; i ++ ) { if ( strs [ i ][ j ] != flag ) { return str ; } } str . push_back ( flag ); } return str ; } }; 0018. 4Sum \u00b6 Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] */ class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < vector < int >> res ; if ( n < 4 ) { return res ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { int b = j + 1 , e = n - 1 ; while ( b < e ) { int sum = nums [ i ] + nums [ j ] + nums [ b ] + nums [ e ]; if ( sum < target ) { b ++ ; } else if ( sum > target ) { e -- ; } else { while ( i < n - 3 && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < n - 2 && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( b < e && nums [ b ] == nums [ b + 1 ]) { b ++ ; } while ( b < e && nums [ e ] == nums [ e - 1 ]) { e -- ; } vector < int > arr ; arr . push_back ( nums [ i ]); arr . push_back ( nums [ j ]); arr . push_back ( nums [ b ]); arr . push_back ( nums [ e ]); res . push_back ( arr ); b ++ ; e -- ; } } } } return res ; } }; 0019. Remove Nth Node From End of List* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. */ // Two pointers class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { if ( n < 1 || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 , head ); ListNode * p1 = pre , * p2 = head , * p3 = head ; while ( n -- ) { if ( p3 == nullptr ) { return head ; } p3 = p3 -> next ; } while ( p3 != nullptr ) { p3 = p3 -> next ; p2 = p2 -> next ; p1 = p1 -> next ; } p1 -> next = p2 -> next ; delete p2 ; head = pre -> next ; delete pre ; return head ; } }; 0020. Valid Parentheses \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: s = \"()\" Output: true Input: s = \"()[]{}\" Output: true Input: s = \"(]\" Output: false Input: s = \"([)]\" Output: false Input: s = \"{[]}\" Output: true */ class Solution { public : bool isValid ( string s ) { int n = int ( s . length ()); stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '[' || s [ i ] == '{' || s [ i ] == '(' ) { st . push ( s [ i ]); } else if (( s [ i ] == ')' && ! st . empty () && st . top () == '(' ) || ( s [ i ] == ']' && ! st . empty () && st . top () == '[' ) || ( s [ i ] == '}' && ! st . empty () && st . top () == '{' )) { st . pop (); } else { return false ; } } return st . empty (); } }; 0021. Merge Two Sorted Lists \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 */ class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( l1 == nullptr ) { return l2 ; } if ( l2 == nullptr ) { return l1 ; } ListNode * head = new ListNode ( 0 ); ListNode * curNode = head ; while ( l1 != nullptr && l2 != nullptr ) { if ( l1 -> val < l2 -> val ) { curNode -> next = l1 ; l1 = l1 -> next ; } else { curNode -> next = l2 ; l2 = l2 -> next ; } curNode = curNode -> next ; } if ( l1 != nullptr ) { curNode -> next = l1 ; } if ( l2 != nullptr ) { curNode -> next = l2 ; } curNode = head -> next ; delete head ; return curNode ; } }; 0022. Generate Parentheses \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] */ class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > res ; if ( n == 0 ) { return res ; } string str = \"\" ; append ( res , str , n , 0 , 0 , 0 ); return res ; } void append ( vector < string > & res , string str , int n , int idx , int nLeft , int nRight ) { if ( idx == 2 * n ) { if ( nRight == nLeft ) { res . push_back ( str ); } return ; } if ( nLeft >= nRight && nLeft < n ) { append ( res , str + '(' , n , idx + 1 , nLeft + 1 , nRight ); } append ( res , str + ')' , n , idx + 1 , nLeft , nRight + 1 ); } }; 0023. Merge k Sorted Lists \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { int n = int ( lists . size ()); if ( n == 0 ) { return nullptr ; } ListNode * pre = new ListNode ( 0 ), * head = pre , * cur = pre ; while ( true ) { int idx = - 1 , min = ( 1ll << 31 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( lists [ i ] == nullptr ) { continue ; } if ( lists [ i ] -> val < min ) { idx = i ; min = lists [ i ] -> val ; } } if ( idx == - 1 ) { break ; } cur -> next = lists [ idx ]; lists [ idx ] = lists [ idx ] -> next ; cur = cur -> next ; } head = pre -> next ; delete pre ; return head ; } }; 0024. Swap Nodes in Pairs \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Given 1->2->3->4, you should return the list as 2->1->4->3. */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); ListNode * par = head , * son = head -> next , * gra = pre ; pre -> next = head ; while ( son != nullptr ) { par -> next = son -> next ; son -> next = par ; gra -> next = son ; gra = par ; par = par -> next ; if ( par == nullptr ) { break ; } son = par -> next ; } head = pre -> next ; delete pre ; return head ; } }; 0025. Reverse Nodes in k-Group \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k < 2 ) { return head ; } ListNode * front = head ; for ( int i = 0 ; i < k ; i ++ ) { if ( front == nullptr ) { return head ; } front = front -> next ; } bool isEnd = false ; ListNode * pre = new ListNode ( 0 , head ); ListNode * gra = pre , * par = head , * son = head -> next ; while ( true ) { ListNode * temp = front , * p1 = gra , * p2 = par , * p3 = son ; while ( p2 != temp ) { if ( front == nullptr ) { isEnd = true ; } else { front = front -> next ; } p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { break ; } p3 = p3 -> next ; } par -> next = p2 ; gra -> next = p1 ; gra = par ; par = p2 ; son = p3 ; if ( isEnd || p3 == nullptr ) { break ; } } head = pre -> next ; delete pre ; return head ; } }; 0026. Remove Duplicates from Sorted Array \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Given nums = [0,0,1,1,1,2,2,3,3,4] Your function should return length = 5 */ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 2 ) { return n ; } int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { continue ; } nums [ len ++ ] = nums [ i ]; } return len ; } }; 0027. Remove Element \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, */ class Solution { public : int removeElement ( vector < int >& nums , int val ) { int n = int ( nums . size ()), len = 0 ; if ( n == 0 ) { return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] != val ) { nums [ len ++ ] = nums [ i ]; } } return len ; } }; 0028. Implement strStr()* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: haystack = \"hello\", needle = \"ll\" Output: 2 */ class Solution { public : int strStr ( string haystack , string needle ) { string T = haystack , P = needle ; int nT = int ( T . length ()), nP = int ( P . length ()); if ( nP == 0 ) { return 0 ; } if ( nT == 0 ) { return - 1 ; } int * next = new int [ nP ]{}; int i = 0 , j = 0 , t = next [ 0 ] = - 1 , k = 0 ; while ( k < nP - 1 ) { if ( t < 0 || P [ t ] == P [ k ]) { next [ ++ k ] = ++ t ; } else { t = next [ t ]; } } while ( i < nT && j < nP ) { if ( j < 0 || T [ i ] == P [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } delete [] next ; if ( i - j <= nT - nP ) { return i - j ; } else { return - 1 ; } } }; 0029. Divide Two Integers* \u00b6 Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = truncate(3.33333..) = 3. Example 2: Input: dividend = 7, divisor = -3 Output: -2 Explanation: 7/-3 = truncate(-2.33333..) = -2. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int divide ( int dividend , int divisor ) { int MAX = ( 1ll << 31 ) - 1 ; long m = abs ( long ( dividend )), n = abs ( long ( divisor )), quo = 0 ; while ( m >= n ) { long s = n , incre = 1 ; while (( s << 1 ) <= m ) { s <<= 1 ; incre <<= 1 ; } quo += incre ; m -= s ; } if (( dividend < 0 ) ^ ( divisor < 0 )) { quo *= - 1 ; } return quo > MAX ? MAX : int ( quo ); } }; 0030. Substring with Concatenation of All Words* \u00b6 You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order. Example: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"] Output: [6,9,12] Constraints: 1 <= s.length <= 10^{4} 10^{4} s consists of lower-case English letters. 1 <= words.length <= 5000 1 <= words[i].length <= 30 words[i] consists of lower-case English letters. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { vector < int > res ; int n = int ( words . size ()), sLen = int ( s . length ()); if ( n == 0 || n * words [ 0 ]. length () > sLen ) { return res ; } sort ( words . begin (), words . end ()); int i = 0 , wordLen = int ( words [ 0 ]. length ()), wordsLen = n * wordLen ; while ( i + wordsLen <= sLen ) { string subStr = s . substr ( i , wordsLen ); vector < string > tmp ; for ( int j = 0 ; j < wordsLen ; j += wordLen ) { tmp . push_back ( subStr . substr ( j , wordLen )); } sort ( tmp . begin (), tmp . end ()); bool isOk = true ; for ( int k = 0 ; k < n ; k ++ ) { if ( tmp [ k ] != words [ k ]) { isOk = false ; break ; } } if ( isOk ) { res . push_back ( i ); } i ++ ; } return res ; } }; 0031. Next Permutation* \u00b6 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. Example: 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1 Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = int ( nums . size ()), idx = - 1 ; if ( n < 2 ) { return ; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( nums [ i - 1 ] < nums [ i ]) { idx = i - 1 ; break ; } } if ( idx == - 1 ) { sort ( nums . begin (), nums . end ()); return ; } for ( int i = n - 1 ; i > idx ; i -- ) { if ( nums [ i ] > nums [ idx ]) { swap ( nums [ i ], nums [ idx ]); sort ( nums . begin () + idx + 1 , nums . end ()); return ; } } } }; 0032. Longest Valid Parentheses* \u00b6 Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int longestValidParentheses ( string s ) { int maxLen = 0 , n = int ( s . length ()), leftCount = 0 ; if ( n < 2 ) { return maxLen ; } int * dp = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { if ( leftCount == 0 && s [ i ] == ')' ) { continue ; } if ( s [ i ] == '(' ) { leftCount ++ ; } else { leftCount -- ; dp [ i ] = dp [ i - 1 ] + 1 ; if ( i - dp [ i ] * 2 >= 0 ) { dp [ i ] += dp [ i - dp [ i ] * 2 ]; } } maxLen = maxLen > dp [ i ] ? maxLen : dp [ i ]; } delete [] dp ; return maxLen * 2 ; } }; 0034. Find First and Last Position of Element in Sorted Array \u00b6 Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. Follow up: Could you write an algorithm with O(log n) runtime complexity? Example: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Input: nums = [], target = 0 Output: [-1,-1] Constraints: 0 <= nums.length <= 10^{5} 10^{5} - 10^{9} 10^{9} <= nums[i] <= 10^{9} 10^{9} nums is a non-decreasing array. - 10^{9} 10^{9} <= target <= 10^{9} 10^{9} Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < int > res ; res . push_back ( - 1 ); res . push_back ( - 1 ); if ( n < 1 ) { return res ; } res [ 0 ] = binSearFir ( nums , target , 0 , n - 1 ); res [ 1 ] = binSearSec ( nums , target , 0 , n ); return res ; } int binSearFir ( vector < int > & nums , int target , int b , int e ) { if ( b == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] < target ) { return binSearFir ( nums , target , m + 1 , e ); } else { return binSearFir ( nums , target , b , m ); } } int binSearSec ( vector < int > & nums , int target , int b , int e ) { if ( b + 1 == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] <= target ) { return binSearSec ( nums , target , m , e ); } else { return binSearSec ( nums , target , b , m ); } } }; 0035. \u641c\u7d22\u63d2\u5165\u4f4d\u7f6e \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* \u7ed9\u5b9a\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\u548c\u4e00\u4e2a\u76ee\u6807\u503c\uff0c\u5728\u6570\u7ec4\u4e2d\u627e\u5230\u76ee\u6807\u503c\uff0c\u5e76\u8fd4\u56de\u5176\u7d22\u5f15\u3002 \u5982\u679c\u76ee\u6807\u503c\u4e0d\u5b58\u5728\u4e8e\u6570\u7ec4\u4e2d\uff0c\u8fd4\u56de\u5b83\u5c06\u4f1a\u88ab\u6309\u987a\u5e8f\u63d2\u5165\u7684\u4f4d\u7f6e\u3002 \u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u4e2d\u65e0\u91cd\u590d\u5143\u7d20\u3002 \u793a\u4f8b 1: \u8f93\u5165: [1,3,5,6], 5 \u8f93\u51fa: 2 \u793a\u4f8b 2: \u8f93\u5165: [1,3,5,6], 2 \u8f93\u51fa: 1 \u793a\u4f8b 3: \u8f93\u5165: [1,3,5,6], 7 \u8f93\u51fa: 4 */ class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m ; } } return l ; } }; 0036. Valid Sudoku* \u00b6 Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { continue ; } if ( ! isValidForij ( board , i , j )) { return false ; } } } return true ; } bool isValidForij ( vector < vector < char >> board , int i , int j ) { int dupRow = 0 , dupCol = 0 ; for ( int k = 0 ; k < 9 ; k ++ ) { if ( board [ k ][ j ] == board [ i ][ j ]) { dupRow ++ ; } if ( board [ i ][ k ] == board [ i ][ j ]) { dupCol ++ ; } } if ( dupRow > 1 || dupCol > 1 ) { return false ; } int m = i / 3 , n = j / 3 , dupSubBox = 0 ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 3 ; y ++ ) { if ( board [ m * 3 + x ][ n * 3 + y ] == board [ i ][ j ]) { dupSubBox ++ ; } } } if ( dupSubBox > 1 ) { return false ; } return true ; } }; 0037. Sudoku Solver* \u00b6 Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells. $$ \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\ 6 & . & . & 1 & 9 & 5 & . & . & . \\ . & 9 & 8 & . & . & . & . & 6 & . \\ 8 & . & . & . & 6 & . & . & . & 3 \\ 4 & . & . & 8 & . & 3 & . & . & 1 \\ 7 & . & . & . & 2 & . & . & . & 6 \\ . & 6 & . & . & . & . & 2 & 8 & . \\ . & . & . & 4 & 1 & 9 & . & . & 5 \\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { isSolver ( board ); } bool isSolver ( vector < vector < char >> & board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { for ( char c = '1' ; c <= '9' ; c ++ ) { if ( isFeasible ( board , i , j , c )) { board [ i ][ j ] = c ; if ( isSolver ( board )) { return true ; } else { board [ i ][ j ] = '.' ; } } } // No feasible number return false ; } } } return true ; } bool isFeasible ( vector < vector < char >> board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ row ][ i ] == c ) { return false ; } if ( board [ i ][ col ] == c ) { return false ; } if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) { return false ; } } return true ; } }; 0038. Count and Say \u00b6 The count-and-say sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = \"1\" countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you \"say\" a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying. Example: Input: n = 1 Output: \"1\" Explanation: This is the base case. Input: n = 4 Output: \"1211\" Explanation: countAndSay(1) = \"1\" countAndSay(2) = say \"1\" = one 1 = \"11\" countAndSay(3) = say \"11\" = two 1's = \"21\" countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" Constraints: 1 <= n <= 30 Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string countAndSay ( int n ) { string res = \"1\" ; if ( n == 1 ) { return res ; } for ( int i = 2 ; i <= n ; i ++ ) { string cur = \"\" ; res . push_back ( '0' ); int len = int ( res . length ()), count = 1 ; char ch = res [ 0 ]; for ( int i = 1 ; i < len ; i ++ ) { if ( res [ i ] == res [ i - 1 ]) { count ++ ; } else { cur += to_string ( count ); cur . push_back ( ch ); count = 1 ; ch = res [ i ]; } } res = cur ; } return res ; } }; 0041. First Missing Positive* \u00b6 Given an unsorted integer array, find the smallest missing positive integer. Example: Input: [1,2,0] Output: 3 Input: [3,4,-1,1] Output: 2 Input: [7,8,9,11,12] Output: 1 Follow up: Your algorithm should run in O(n) time and uses constant extra space. Solution: \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { int n = int ( nums . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] <= 0 ) { nums [ i ] = n + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { int num = abs ( nums [ i ]); if ( num <= n ) { nums [ num - 1 ] = - abs ( nums [ num - 1 ]); } } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] > 0 ) { return i + 1 ; } } return n + 1 ; } }; 0042. Trapping Rain Water* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. */ class Solution { public : int trap ( vector < int >& height ) { int ans = 0 , n = int ( height . size ()); if ( n < 3 ) { return ans ; } int i = 0 , j = n - 1 ; int leftMax = 0 , rightMax = 0 ; while ( i < j ) { if ( height [ i ] < height [ j ]) { if ( height [ i ] >= leftMax ) { leftMax = height [ i ]; } else { ans += leftMax - height [ i ]; } i ++ ; } else { if ( height [ j ] >= rightMax ) { rightMax = height [ j ]; } else { ans += rightMax - height [ j ]; } j -- ; } } return ans ; } }; 0043. Multiply Strings \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /* Input: num1 = \"123\", num2 = \"456\" Output: \"56088\" */ class Solution { public : string multiply ( string num1 , string num2 ) { string ans = \"\" ; if ( num1 == \"0\" || num2 == \"0\" ) { return \"0\" ; } int n2 = int ( num2 . length ()); for ( int j = n2 - 1 ; j >= 0 ; j -- ) { string str = strMultiChar ( num1 , num2 [ j ]); str . insert ( str . length (), n2 - 1 - j , '0' ); ans = strAdd ( ans , str ); } return ans ; } string strAdd ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); if ( n1 < n2 ) { swap ( s1 , s2 ); swap ( n1 , n2 ); } string ans = \"\" ; int i = n1 - 1 , j = n2 - 1 , add1 = 0 ; while ( i >= 0 && j >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + ( s2 [ j -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } while ( i >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans . insert ( 0 , 1 , '1' ); } return ans ; } string strMultiChar ( string str , char c ) { string ans = \"\" ; int n = int ( str . length ()), add1 = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int res = ( str [ i ] - '0' ) * ( c - '0' ) + add1 ; add1 = 0 ; if ( res > 9 ) { add1 = res / 10 ; res = res % 10 ; } char insertChar = '0' + res ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans = to_string ( add1 ) + ans ; } return ans ; } }; 0044. Wildcard Matching \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Input: s = \"adceb\", p = \"*a*b\" Output: true */ class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); int ** dp = new int * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new int [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMat = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '?' || p [ j ] == '*' ); if ( p [ j ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 1 ] || ( ijMat && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMat && dp [ i + 1 ][ j + 1 ]; } } } bool ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0048. Rotate Image \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 1 2 3 7 4 1 4 5 6 -> 8 5 2 7 8 9 9 6 3 */ class Solution { public : void rotate ( vector < vector < int >>& matrix ) { int n = int ( matrix . size ()); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - 1 - i ; j ++ ) { int b = i , e = n - 1 - i ; int first = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ b + e - j ][ b ]; matrix [ b + e - j ][ b ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ b + j - i ][ e ]; matrix [ b + j - i ][ e ] = first ; } } } }; 0049. Group Anagrams \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] */ class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; int n = int ( strs . size ()); if ( n == 0 ) { return ans ; } unordered_map < string , vector < string >> dict ; for ( string & str : strs ) { string tmp = str ; sort ( tmp . begin (), tmp . end ()); dict [ tmp ]. emplace_back ( str ); } unordered_map < string , vector < string >>:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { ans . emplace_back ( iter -> second ); } return ans ; } }; 0050. Pow(x, n) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 */ class Solution { public : double myPow ( double x , int n ) { double ans = 1.0 , tmp = x ; bool isNeg = false ; long pow = n ; if ( n < 0 ) { pow = - pow ; isNeg = true ; } long k = 1 ; while ( pow > 0 ) { if ( pow == 1 ) { ans *= x ; break ; } tmp *= tmp ; k *= 2 ; if ( k * 2 > pow ) { ans *= tmp ; tmp = x ; pow = pow - k ; k = 1 ; } } if ( isNeg ) { return 1 / ans ; } return ans ; } }; 0051. N-Queens \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: n = 4 Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"], [\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] */ class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; string str = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { str += \".\" ; } vector < string > res ( n , str ); unordered_set < int > col , diag1 , diag2 ; DFS ( col , diag1 , diag2 , n , 0 , ans , res ); return ans ; } void DFS ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int n , int i , vector < vector < string >> & ans , vector < string > & res ) { if ( i == n ) { ans . emplace_back ( res ); return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkPos ( col , diag1 , diag2 , i , j )) { res [ i ][ j ] = 'Q' ; col . insert ( j ); diag1 . insert ( i - j ); diag2 . insert ( i + j ); DFS ( col , diag1 , diag2 , n , i + 1 , ans , res ); res [ i ][ j ] = '.' ; col . erase ( j ); diag1 . erase ( i - j ); diag2 . erase ( i + j ); } } } bool isOkPos ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int i , int j ) { if ( col . find ( j ) != col . end () || diag1 . find ( i - j ) != diag1 . end () || diag2 . find ( i + j ) != diag2 . end ()) { return false ; } return true ; } }; 0052. N-Queens II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* Input: n = 4 Output: 2 */ class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; unordered_set < int > col , dg1 , dg2 ; DFS ( col , dg1 , dg2 , 0 , n , ans ); return ans ; } void DFS ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int n , int & ans ) { if ( i == n ) { ans ++ ; return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkQueenPos ( col , dg1 , dg2 , i , j )) { col . insert ( j ); dg1 . insert ( i - j ); dg2 . insert ( i + j ); DFS ( col , dg1 , dg2 , i + 1 , n , ans ); col . erase ( j ); dg1 . erase ( i - j ); dg2 . erase ( i + j ); } } } bool isOkQueenPos ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int j ) { if ( col . find ( j ) != col . end () || dg1 . find ( i - j ) != dg1 . end () || dg2 . find ( i + j ) != dg2 . end ()) { return false ; } return true ; } }; 0054. Spiral Matrix \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* 1 -> 2 -> 3 | v 4 -> 5 6 ^ | | v 7 <- 8 <- 9 */ class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { vector < int > ans ; int m = int ( matrix . size ()); if ( m == 0 ) { return ans ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return ans ; } bool * vis = new bool [ m * n ]{}; int i = 0 , j = 0 ; while ( true ) { bool updated = false ; while ( true ) { if ( j >= n || vis [ i * n + j ]) { j -- ; i ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j ++ ; } while ( true ) { if ( i >= m || vis [ i * n + j ]) { i -- ; j -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i ++ ; } while ( true ) { if ( j < 0 || vis [ i * n + j ]) { j ++ ; i -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j -- ; } while ( true ) { if ( i < 0 || vis [ i * n + j ]) { i ++ ; j ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i -- ; } if ( ! updated ) { break ; } } delete [] vis ; return ans ; } }; 0056. Merge Intervals \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. */ class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); sort ( intervals . begin (), intervals . end ()); int b = 0 , rightMax = intervals [ b ][ 1 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( rightMax < intervals [ i - 1 ][ 1 ]) { rightMax = intervals [ i - 1 ][ 1 ]; } if ( rightMax < intervals [ i ][ 0 ]) { ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], rightMax }); b = i ; rightMax = intervals [ i ][ 1 ]; } } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ n - 1 ][ 1 ], rightMax ) }); return ans ; } }; 0057. Insert Interval \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. */ class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); if ( n == 0 || ( intervals [ 0 ][ 0 ] >= newInterval [ 0 ] && intervals [ n - 1 ][ 1 ] <= newInterval [ 1 ])) { ans . emplace_back ( newInterval ); return ans ; } int b = 0 , e = - 1 ; while ( b < n ) { if ( intervals [ b ][ 0 ] > newInterval [ 1 ]) { ans . emplace_back ( newInterval ); for ( int i = b ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 1 ]) { return intervals ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 0 ]) { break ; } if ( intervals [ b ][ 0 ] > newInterval [ 0 ]) { intervals [ b ][ 0 ] = newInterval [ 0 ]; break ; } ans . emplace_back ( intervals [ b ++ ]); } if ( b == n ) { ans . emplace_back ( newInterval ); return ans ; } e = b + 1 ; while ( e < n && ( ( intervals [ e ][ 0 ] <= newInterval [ 1 ] && intervals [ e ][ 1 ] >= newInterval [ 1 ]) || ( intervals [ e ][ 0 ] >= newInterval [ 0 ] && intervals [ e ][ 1 ] <= newInterval [ 1 ]) ) ) { e ++ ; } if ( e == n ) { ans . emplace_back ( vector < int > { min ( newInterval [ 0 ], intervals [ b ][ 0 ]), max ( newInterval [ 1 ], intervals [ n - 1 ][ 1 ]) }); return ans ; } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ e - 1 ][ 1 ], newInterval [ 1 ]) }); for ( int i = e ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } }; 0058. Length of Last Word \u00b6 Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0. A word is a maximal substring consisting of non-space characters only. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: s = \"Hello World\" Output: 5 */ class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 , n = int ( s . length ()); if ( n == 0 ) { return ans ; } bool isCount = false ; int i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' && isCount ) { break ; } if ( s [ i ] == ' ' ) { i -- ; continue ; } ans ++ ; i -- ; isCount = true ; } return ans ; } }; 0059. Spiral Matrix II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] 1 -> 2 -> 3 | v 8 -> 9 4 ^ | | v 7 <- 6 <- 5 */ class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n , 0 )); int i = 0 , j = 0 , num = 1 ; while ( num <= n * n ) { while ( true ) { if ( j >= n || ans [ i ][ j ]) { j -- ; i ++ ; break ; } ans [ i ][ j ++ ] = num ++ ; } while ( true ) { if ( i >= n || ans [ i ][ j ]) { i -- ; j -- ; break ; } ans [ i ++ ][ j ] = num ++ ; } while ( true ) { if ( j < 0 || ans [ i ][ j ]) { j ++ ; i -- ; break ; } ans [ i ][ j -- ] = num ++ ; } while ( true ) { if ( i <= 0 || ans [ i ][ j ]) { i ++ ; j ++ ; break ; } ans [ i -- ][ j ] = num ++ ; } } return ans ; } }; 0061. Rotate List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k <= 0 ) { return head ; } int cnt = 0 ; ListNode * curNode = head , * tail = head ; while ( curNode != nullptr ) { cnt ++ ; if ( curNode -> next == nullptr ) { tail = curNode ; } curNode = curNode -> next ; } k %= cnt ; k = cnt - k ; ListNode * p1 = head ; for ( int i = 1 ; i < k ; i ++ ) { p1 = p1 -> next ; } tail -> next = head ; head = p1 -> next ; p1 -> next = nullptr ; return head ; } }; 0066. Plus One \u00b6 Given a non-empty array of decimal digits representing a non-negative integer, increment one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Input: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Input: digits = [0] Output: [1] */ class Solution { public : vector < int > plusOne ( vector < int >& digits ) { vector < int > ans ; vector < int >:: iterator iter ; int n = int ( digits . size ()), add = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int res = digits [ i ] + add ; iter = ans . begin (); if ( res >= 10 ) { ans . insert ( iter , res - 10 ); add = 1 ; } else { ans . insert ( iter , res ); add = 0 ; } } iter = ans . begin (); if ( add ) { ans . insert ( iter , 1 ); } return ans ; } }; 0067. Add Binary \u00b6 Given two binary strings a and b, return their sum as a binary string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* Input: a = \"11\", b = \"1\" Output: \"100\" Input: a = \"1010\", b = \"1011\" Output: \"10101\" */ class Solution { public : string addBinary ( string a , string b ) { string str = \"\" ; int aLen = int ( a . length ()), bLen = int ( b . length ()); int i = aLen - 1 , j = bLen - 1 , add = 0 ; if ( aLen < bLen ) { swap ( a , b ); swap ( aLen , bLen ); swap ( i , j ); } while ( i >= 0 && j >= 0 ) { int sum = a [ i ] - '0' + b [ j ] - '0' + add ; if ( sum >= 2 ) { char tempChar = '0' + sum - 2 ; str . insert ( 0 , 1 , tempChar ); add = 1 ; } else { char tempChar = '0' + sum ; str . insert ( 0 , 1 , tempChar ); add = 0 ; } i -- ; j -- ; } while ( i >= 0 ) { int sum = a [ i ] - '0' + add ; if ( sum >= 2 ) { char tempChar = '0' + sum - 2 ; str . insert ( 0 , 1 , tempChar ); add = 1 ; } else { char tempChar = '0' + sum ; str . insert ( 0 , 1 , tempChar ); add = 0 ; } i -- ; } if ( add == 1 ) { str . insert ( 0 , 1 , '1' ); } return str ; } }; 0069 Sqrt(x)* \u00b6 Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Input: x = 4 Output: 2 Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. */ class Solution { public : int mySqrt ( int x ) { // Binary search long lo = 1 , hi = x ; while ( lo <= hi ) { long mi = ( lo + hi ) / 2 ; if ( mi * mi < x ) { lo = mi + 1 ; } else if ( mi * mi > x ) { hi = mi - 1 ; } else { return int ( mi ); } } return int ( hi ); } }; 0070. Climbing Stairs \u00b6 You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Example: Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step Constraints: 1 <= n <= 45 */ class Solution { public : int climbStairs ( int n ) { int a = 1 , b = 2 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } }; 0071. Simplify Path \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* Input: path = \"/a/./b/../../c/\" Output: \"/c\" */ class Solution { public : string simplifyPath ( string path ) { int n = int ( path . length ()); if ( n <= 1 ) { return \"/\" ; } stack < string > stk ; int i = 0 ; string file = \"\" ; path . push_back ( '/' ); while ( i <= n ) { if ( path [ i ] == '/' ) { if ( file . length () == 0 ) { i ++ ; continue ; } if ( file == \"..\" ) { if ( ! stk . empty ()) { stk . pop (); } } else if ( file != \".\" ) { stk . push ( file ); } file = \"\" ; i ++ ; continue ; } if ( path [ i ] != '/' ) { file . push_back ( path [ i ]); } i ++ ; } if ( stk . empty ()) { return \"/\" ; } file = stk . top (); stk . pop (); while ( ! stk . empty ()) { file = stk . top () + \"/\" + file ; stk . pop (); } file = \"/\" + file ; return file ; } }; 0073. Set Matrix Zeroes \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 0 1 2 0 0 0 0 0 3 4 5 2 -> 0 4 5 0 1 3 1 5 0 3 1 0 */ class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { int nRow = int ( matrix . size ()); int nCol = int ( matrix [ 0 ]. size ()); unordered_set < int > cols , rows ; for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( matrix [ i ][ j ] == 0 ) { rows . insert ( i ); cols . insert ( j ); } } } unordered_set < int >:: iterator iter ; for ( iter = rows . begin (); iter != rows . end (); iter ++ ) { int i = * iter ; for ( int j = 0 ; j < nCol ; j ++ ) { matrix [ i ][ j ] = 0 ; } } for ( iter = cols . begin (); iter != cols . end (); iter ++ ) { int j = * iter ; for ( int i = 0 ; i < nRow ; i ++ ) { matrix [ i ][ j ] = 0 ; } } } }; 0075. Sort Colors* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] */ class Solution { public : void sortColors ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return ; } int p0 = 0 , p1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] == 0 ) { swap ( nums [ i ], nums [ p0 ]); if ( p0 < p1 ) { swap ( nums [ i ], nums [ p1 ]); } p0 ++ ; p1 ++ ; } else if ( nums [ i ] == 1 ) { swap ( nums [ i ], nums [ p1 ++ ]); } } } }; 0076. Minimum Window Substring* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" */ class Solution { public : string minWindow ( string s , string t ) { unordered_map < char , int > tDict , sDict ; for ( const auto & c : t ) { tDict [ c ] ++ ; } int ns = int ( s . length ()); int l = 0 , r = - 1 , ansL = - 1 , minLen = INT_MAX ; while ( r < ns ) { if ( tDict . find ( s [ ++ r ]) != tDict . end ()) { sDict [ s [ r ]] ++ ; } while ( isCover ( tDict , sDict ) && l <= r ) { if ( r - l + 1 < minLen ) { minLen = r - l + 1 ; ansL = l ; } if ( tDict . find ( s [ l ]) != tDict . end ()) { sDict [ s [ l ]] -- ; } l ++ ; } } return - 1 == ansL ? string () : s . substr ( ansL , minLen ); } bool isCover ( unordered_map < char , int > & tDict , unordered_map < char , int > & sDict ) { for ( const auto & item : tDict ) { if ( sDict [ item . first ] < item . second ) { return false ; } } return true ; } }; 0077. Combinations \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: n = 4, k = 2 Output: 1, 4 3, 4 2, 3 1, 2 1, 3 1, 4 */ class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; if ( n < 0 || k < 0 || n < k ) { return ans ; } vector < int > arr ; combination ( ans , arr , n , k , 1 ); return ans ; } void combination ( vector < vector < int >> & ans , vector < int > & arr , int n , int k , int idx ) { if ( k == 0 ) { ans . emplace_back ( arr ); return ; } for ( int i = idx ; i <= n ; i ++ ) { arr . emplace_back ( i ); combination ( ans , arr , n , k - 1 , i + 1 ); arr . pop_back (); } } }; 0078. Subsets \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); vector < int > arr ; dfs ( ans , arr , nums , n , 0 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int n , int idx ) { if ( idx == n ) { ans . emplace_back ( arr ); } else { arr . emplace_back ( nums [ idx ]); dfs ( ans , arr , nums , n , idx + 1 ); arr . pop_back (); dfs ( ans , arr , nums , n , idx + 1 ); } } }; 0079. Word Search \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* board = A B C E S F C S A D E E word = \"ABCCED\", return true */ class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { int nRow = int ( board . size ()); if ( nRow == 0 ) { return false ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return false ; } int len = int ( word . length ()); bool ans = false ; bool * vis = new bool [ nRow * nCol ]{}; for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] != word [ 0 ]) { continue ; } ans = isExistWord ( board , word , nRow , nCol , i , j , vis , len , 0 ); if ( ans ) { break ; } } if ( ans ) { break ; } } delete [] vis ; return ans ; } bool isExistWord ( vector < vector < char >> & board , string word , int nRow , int nCol , int i , int j , bool * vis , int len , int k ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || vis [ i * nCol + j ] || board [ i ][ j ] != word [ k ]) { return false ; } if ( k == len - 1 ) { return true ; } vis [ i * nCol + j ] = true ; bool u = isExistWord ( board , word , nRow , nCol , i - 1 , j , vis , len , k + 1 ); if ( u ) { return true ; } bool d = isExistWord ( board , word , nRow , nCol , i + 1 , j , vis , len , k + 1 ); if ( d ) { return true ; } bool l = isExistWord ( board , word , nRow , nCol , i , j - 1 , vis , len , k + 1 ); if ( l ) { return true ; } bool r = isExistWord ( board , word , nRow , nCol , i , j + 1 , vis , len , k + 1 ); if ( r ) { return true ; } vis [ i * nCol + j ] = false ; return false ; } }; 0080. Remove Duplicates from Sorted Array II* \u00b6 Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3] Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3] */ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 3 ) { return n ; } int len = 1 , count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { count ++ ; } else { count = 1 ; } if ( count <= 2 ) { nums [ len ++ ] = nums [ i ]; } } return len ; } }; 0082. Remove Duplicates from Sorted List II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5 1 -> 2 -> 5 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = pre , * p2 = head ; while ( p2 != nullptr ) { bool isDup = false ; while ( p2 -> next != nullptr && p2 -> next -> val == p2 -> val ) { p2 = p2 -> next ; isDup = true ; } p2 = p2 -> next ; if ( isDup ) { p1 -> next = p2 ; } else { p1 = p1 -> next ; } } head = pre -> next ; delete pre ; return head ; } }; 0083. Remove Duplicates from Sorted List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: 1 -> 1 -> 2 Output: 1 -> 2 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next ; while ( true ) { while ( p2 != nullptr && p1 -> val == p2 -> val ) { p2 = p2 -> next ; } p1 -> next = p2 ; p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } return head ; } }; 0084. Largest Rectangle in Histogram* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. */ class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 , n = int ( heights . size ()); if ( n == 0 ) { return ans ; } heights . emplace_back ( 0 ); stack < int > stk ; for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } int area = H * W ; if ( ans < area ) { ans = area ; } } stk . push ( i ); } heights . pop_back (); return ans ; } }; 0085. Maximal Rectangle* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 max area = 6 */ class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { int ans = 0 ; int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( matrix [ 0 ]. size ()); vector < int > heights ( nCol , 0 ); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { heights [ j ] = ( heights [ j ] + 1 ) * ( matrix [ i ][ j ] - '0' ); } ans = max ( ans , getRecArea ( heights )); } return ans ; } int getRecArea ( vector < int > heights ) { int ans = 0 , n = int ( heights . size ()); stack < int > stk ; heights . emplace_back ( 0 ); for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } ans = max ( ans , W * H ); } stk . push ( i ); } return ans ; } }; 0086. Partition List \u00b6 Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* from 1 -> 4 -> 3 -> 2 -> 5 -> 2 to 1 -> 2 -> 2 -> 4 -> 3 -> 5 */ Input : head = [ 1 , 4 , 3 , 2 , 5 , 2 ], x = 3 Output : [ 1 , 2 , 2 , 4 , 3 , 5 ] class Solution { public : ListNode * partition ( ListNode * head , int x ) { if ( head == nullptr ) { return head ; } ListNode * h1 = new ListNode ( 0 ), * h2 = new ListNode ( 0 ); ListNode * p1 = head , * p2 = head -> next , * cur1 = h1 , * cur2 = h2 ; while ( p1 != nullptr ) { if ( p1 -> val < x ) { cur1 -> next = p1 ; cur1 = p1 ; } else { cur2 -> next = p1 ; cur2 = p1 ; } p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } cur2 -> next = nullptr ; cur1 -> next = h2 -> next ; head = h1 -> next ; delete h1 ; delete h2 ; return head ; } }; 0087. Scramble String* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y. Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x. Apply step 1 recursively on each of the two substrings x and y. Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. Input: s1 = \"great\", s2 = \"rgeat\" Output: true */ class Solution { public : bool isScramble ( string s1 , string s2 ) { int n = int ( s1 . length ()); if ( n != int ( s2 . length ())) { return false ; } if ( n == 0 ) { return true ; } bool *** dp = new bool ** [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool * [ n ]; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ] = new bool [ n + 1 ]{}; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ][ 1 ] = s1 [ i ] == s2 [ j ]; } } for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { for ( int j = 0 ; j < n - len + 1 ; j ++ ) { for ( int k = 1 ; k < len ; k ++ ) { dp [ i ][ j ][ len ] = ( ( dp [ i ][ j ][ k ] && dp [ i + k ][ j + k ][ len - k ]) || ( dp [ i + k ][ j ][ len - k ] && dp [ i ][ j + len - k ][ k ]) ); if ( dp [ i ][ j ][ len ]) { break ; } } } } } bool ans = dp [ 0 ][ 0 ][ n ]; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { delete [] dp [ i ][ j ]; } delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0088. Merge Sorted Array \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] */ class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int pos = int ( nums1 . size ()) - 1 ; if ( pos < 0 ) { return ; } int i = m - 1 , j = n - 1 ; while ( i >= 0 && j >= 0 ) { if ( nums1 [ i ] > nums2 [ j ]) { nums1 [ pos -- ] = nums1 [ i -- ]; } else { nums1 [ pos -- ] = nums2 [ j -- ]; } } while ( i >= 0 ) { nums1 [ pos -- ] = nums1 [ i -- ]; } while ( j >= 0 ) { nums1 [ pos -- ] = nums2 [ j -- ]; } } }; 0090. Subsets II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] */ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); sort ( nums . begin (), nums . end ()); vector < int > arr ; dfs ( ans , arr , nums , 0 , n ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int idx , int n ) { for ( int i = idx ; i < n ; i ++ ) { if ( i > idx && nums [ i ] == nums [ i - 1 ]) { continue ; } arr . emplace_back ( nums [ i ]); dfs ( ans , arr , nums , i + 1 , n ); arr . pop_back (); } ans . emplace_back ( arr ); } }; 0091. Decode Ways \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 'A' -> \"1\" 'B' -> \"2\" ... 'Z' -> \"26\" Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). */ class Solution { public : int numDecodings ( string s ) { int n = ( int ) s . length (); if ( n == 0 || s [ 0 ] == '0' ) { return 0 ; } if ( n == 1 ) { return 1 ; } int a = ( s [ n - 1 ] != '0' ); int b = 0 ; if ( s [ n - 2 ] != '0' ) { b = a + (( s [ n - 2 ] - '0' ) * 10 + s [ n - 1 ] - '0' <= 26 ); } if ( n == 2 ) { return b ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { int c = 0 ; if ( s [ i ] == '0' ) { a = b ; b = c ; continue ; } c += b ; if ( i < n - 1 && ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) <= 26 ) { c += a ; } a = b ; b = c ; } return b ; } }; 0092. Reverse Linked List II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] 1 -> 2 -> 3 -> 4 -> 5 | v 1 -> 4 -> 3 -> 2 -> 5 */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int left , int right ) { if ( left >= right || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = head , * p0 = pre ; int i = 1 ; while ( i < left ) { p1 = p1 -> next ; p0 = p0 -> next ; i ++ ; if ( p1 == nullptr ) { delete pre ; return head ; } } ListNode * tail = p1 , * p2 = p1 -> next ; if ( p2 == nullptr ) { delete pre ; return head ; } ListNode * p3 = p2 -> next ; while ( i < right ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } p3 = p3 -> next ; i ++ ; } p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } }; 0093. Restore IP Addresses \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] */ class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; int n = int ( s . length ()); if ( n < 4 || n > 12 ) { return ans ; } unordered_map < string , bool > dict ; vector < string > sol ; find ( ans , s , 0 , n , dict , sol ); return ans ; } void find ( vector < string > & ans , string & s , int i , int n , unordered_map < string , bool > & dict , vector < string > & sol ) { if ( sol . size () > 4 ) { return ; } if ( i >= n ) { if ( sol . size () != 4 ) { return ; } string res = \"\" ; for ( int i = 0 ; i < 3 ; i ++ ) { res += sol [ i ]; res . push_back ( '.' ); } res += sol [ 3 ]; ans . emplace_back ( res ); return ; } for ( int k = 1 ; k <= 3 ; k ++ ) { if ( i + k > n ) { continue ; } string str = s . substr ( i , k ); if ( dict . find ( str ) == dict . end ()) { dict [ str ] = isLegalIp ( str ); } if ( ! dict [ str ]) { continue ; } sol . emplace_back ( str ); find ( ans , s , i + k , n , dict , sol ); sol . pop_back (); } } bool isLegalIp ( string str ) { int len = int ( str . length ()); if ( len > 1 && str [ 0 ] == '0' ) { return false ; } int val = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] > '9' || str [ i ] < '0' ) { return false ; } val = val * 10 + ( str [ i ] - '0' ); } return val < 256 ; } }; 0094. Binary Tree Inorder Traversal* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; stack < TreeNode *> st ; TreeNode * curNode = root ; while ( curNode != nullptr ) { while ( curNode != nullptr ) { if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } st . push ( curNode ); curNode = curNode -> left ; } curNode = st . top (); st . pop (); while ( ! st . empty () && curNode -> right == nullptr ) { res . push_back ( curNode -> val ); curNode = st . top (); st . pop (); } res . push_back ( curNode -> val ); if ( ! st . empty ()) { curNode = st . top (); st . pop (); } else { curNode = nullptr ; } } return res ; } }; 0096. Unique Binary Search Trees \u00b6 Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: n = 3 Output: 5 Input: n = 1 Output: 1 */ class Solution { public : int numTrees ( int n ) { long C = 1 ; for ( int i = 0 ; i < n ; i ++ ) { C = C * 2 * ( 2 * i + 1 ) / ( i + 2 ) ; } return int ( C ); } }; 0098. Validate Binary Search Tree \u00b6 Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 2 / \\ 1 3 is a BST 5 / \\ 1 4 / \\ 3 6 is not a BST */ class Solution { public : bool isValidBST ( TreeNode * root ) { TreeNode * prec = nullptr ; return isBST ( root , prec ); } bool isBST ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { bool left = isBST ( root -> left , prec ); if ( left == false ) { return false ; } if ( prec == nullptr ) { prec = root ; } else if ( prec -> val >= root -> val ) { return false ; } prec = root ; bool right = isBST ( root -> right , prec ); if ( right == false ) { return false ; } } return true ; } }; 0100. Same Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: p = [1,2,3], q = [1,2,3] Output: true */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( p == nullptr && q == nullptr ) { return true ; } if (( p == nullptr && q != nullptr ) || ( p != nullptr && q == nullptr ) || ( p -> val != q -> val )) { return false ; } bool left = isSameTree ( p -> left , q -> left ); if ( ! left ) { return false ; } bool right = isSameTree ( p -> right , q -> right ); if ( ! right ) { return false ; } return true ; } }; 0101. Symmetric Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1 / \\ 2 2 / \\ / \\ 3 4 4 3 */ class Solution { public : bool isSymmetric ( TreeNode * root ) { if ( root == nullptr ) { return true ; } return isSymmetricTree ( root -> left , root -> right ); } bool isSymmetricTree ( TreeNode * leftTree , TreeNode * rightTree ) { if ( leftTree == nullptr && rightTree == nullptr ) { return true ; } if (( leftTree != nullptr && rightTree == nullptr ) || ( leftTree == nullptr && rightTree != nullptr ) || leftTree -> val != rightTree -> val ) { return false ; } bool left = isSymmetricTree ( leftTree -> left , rightTree -> right ); if ( ! left ) { return false ; } bool right = isSymmetricTree ( leftTree -> right , rightTree -> left ); if ( ! right ) { return false ; } return true ; } }; 0102. Binary Tree Level Order Traversal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { ans . emplace_back ( arr ); arr . clear (); last = nextLast ; } } return ans ; } }; 0103. Binary Tree Zigzag Level Order Traversal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* 3 / \\ 9 20 / \\ 15 7 [ [3], [20,9], [15,7] ] */ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; int level = 1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { if ( level % 2 == 0 ) { int n = int ( arr . size ()); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr [ i ], arr [ n - 1 - i ]); } } ans . emplace_back ( arr ); arr . clear (); last = nextLast ; level ++ ; } } return ans ; } }; 0104. Maximum Depth of Binary Tree \u00b6 Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 3 / \\ 9 20 / \\ 15 7 max depth = 3 */ class Solution { public : int maxDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = maxDepth ( root -> left ); int rightDep = maxDepth ( root -> right ); return 1 + max ( leftDep , rightDep ); } }; 0110. Balanced Binary Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( root == nullptr ) { return true ; } bool ans = true ; getDepth ( root , ans ); return ans ; } int getDepth ( TreeNode * root , bool & isBal ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDepth ( root -> left , isBal ); int rightDep = getDepth ( root -> right , isBal ); if ( abs ( leftDep - rightDep ) > 1 ) { isBal = false ; } return 1 + max ( leftDep , rightDep ); } }; 0111. Minimum Depth of Binary Tree \u00b6 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 3 / \\ 9 20 / \\ 15 7 min depth = 2 */ class Solution { public : int minDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = minDepth ( root -> left ); int rightDep = minDepth ( root -> right ); if ( leftDep != 0 && rightDep != 0 ) { return 1 + min ( leftDep , rightDep ); } else { return 1 + max ( leftDep , rightDep ); } } }; 0112. Path Sum \u00b6 Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true 1 / \\ 2 3 Input: root = [1,2,3], targetSum = 5 Output: false */ class Solution { public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( root == nullptr ) { return false ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( root -> val == targetSum ) { return true ; } return false ; } bool isInLeft = hasPathSum ( root -> left , targetSum - root -> val ); if ( isInLeft ) { return true ; } bool isInRight = hasPathSum ( root -> right , targetSum - root -> val ); if ( isInRight ) { return true ; } return false ; } }; 0113. Path Sum II \u00b6 Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path's sum equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int targetSum ) { vector < vector < int >> ans ; if ( root == nullptr ) { return ans ; } vector < int > arr ; findPaths ( root , targetSum , ans , arr ); return ans ; } void findPaths ( TreeNode * root , int resVal , vector < vector < int >> & ans , vector < int > & arr ) { if ( root == nullptr ) { return ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( resVal == root -> val ) { arr . emplace_back ( root -> val ); ans . emplace_back ( arr ); arr . pop_back (); } return ; } arr . emplace_back ( root -> val ); findPaths ( root -> left , resVal - root -> val , ans , arr ); findPaths ( root -> right , resVal - root -> val , ans , arr ); arr . pop_back (); } }; 0114. Flatten Binary Tree to Linked List \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 1 1 / \\ \\ 2 5 -> 2 / \\ \\ \\ 3 4 6 3 \\ 4 \\ 5 \\ 6 */ class Solution { public : void flatten ( TreeNode * root ) { TreeNode * prec = nullptr ; preOrder ( root , prec ); } void preOrder ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { TreeNode * left = root -> left , * right = root -> right ; if ( prec != nullptr ) { prec -> left = nullptr ; prec -> right = root ; } prec = root ; preOrder ( left , prec ); preOrder ( right , prec ); } } }; 0115. Distinct Subsequences* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag */ class Solution { public : int numDistinct ( string s , string t ) { int ns = int ( s . length ()), nt = int ( t . length ()); if ( ns < nt ) { return 0 ; } long ** dp = new long * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new long [ nt + 1 ]{}; } for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = nt ; j >= 0 ; j -- ) { if ( j == nt ) { dp [ i ][ j ] = 1 ; } else if ( i == ns ) { dp [ i ][ j ] = 0 ; } else { if ( s [ i ] == t [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + dp [ i + 1 ][ j ]; } else { dp [ i ][ j ] = dp [ i + 1 ][ j ]; } } } } int ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0126. Word Ladder II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] Output: [ [\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"] ] Explanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\" */ class Solution { public : unordered_map < string , int > wordId ; vector < string > idWord ; vector < vector < int >> edges ; unordered_set < string > dict ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; idWord . emplace_back ( word ); edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } void dfs ( vector < vector < string >> & ans , int & maxDep , int dep , vector < string > & arr , int id , int & t , vector < int > & level ) { if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . emplace_back ( idWord [ id ]); } if ( id == t ) { ans . emplace_back ( arr ); } for ( int & nextId : edges [ id ]) { if ( level [ nextId ] > level [ id ]) { dfs ( ans , maxDep , dep + 1 , arr , nextId , t , level ); } } if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . pop_back (); } } vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; for ( string & word : wordList ) { addEdge ( word ); dict . insert ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return ans ; } if ( dict . find ( beginWord ) == dict . end ()) { addEdge ( beginWord ); dict . insert ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { break ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } if ( level [ t ] == INT_MAX ) { return ans ; } vector < string > arr ; dfs ( ans , level [ t ], 0 , arr , s , t , level ); return ans ; } }; 0127. Word Ladder* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = \"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\" Output: 5 Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long. */ class Solution { public : unordered_map < string , int > wordId ; vector < vector < int >> edges ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { for ( string & word : wordList ) { addEdge ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return 0 ; } if ( wordId . find ( beginWord ) == wordId . end ()) { addEdge ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { return level [ t ] / 2 + 1 ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } return 0 ; } }; 0128. Longest Consecutive Sequence* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. */ class Solution { public : int longestConsecutive ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int ans = 1 ; unordered_set < int > hash ; for ( const auto & ele : nums ) { hash . insert ( ele ); } for ( const int & ele : nums ) { if ( hash . find ( ele - 1 ) != hash . end ()) { int curNum = ele ; int len = 1 ; while ( hash . find ( curNum ) != hash . end ()) { curNum ++ ; len ++ ; } ans = max ( ans , len ); } } return ans ; } }; 0129. Sum Root to Leaf Numbers \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 4 / \\ 9 0 / \\ 5 1 sum = 495 + 491 + 40 = 1026 */ class Solution { public : int sumNumbers ( TreeNode * root ) { int num = 0 ; return dfs ( root , num ); } int dfs ( TreeNode * root , int num ) { if ( root == nullptr ) { return 0 ; } if ( root -> left == nullptr && root -> right == nullptr ) { return num * 10 + root -> val ;; } int left = dfs ( root -> left , num * 10 + root -> val ); int right = dfs ( root -> right , num * 10 + root -> val ); return left + right ; } }; 0130. Surrounded Regions* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* X X X X X X X X X O O X -> X X X X X X O X X X X X X O X X X O X X */ class Solution { public : void solve ( vector < vector < char >>& board ) { int nRow = ( int ) board . size (); if ( nRow <= 2 ) { return ; } int nCol = ( int ) board [ 0 ]. size (); if ( nCol <= 2 ) { return ; } for ( int i = 0 ; i < nRow ; i ++ ) { if ( board [ i ][ 0 ] == 'O' ) { dfs ( board , nRow , nCol , i , 0 ); } if ( board [ i ][ nCol - 1 ] == 'O' ) { dfs ( board , nRow , nCol , i , nCol - 1 ); } } for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ 0 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , 0 , j ); } if ( board [ nRow - 1 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , nRow - 1 , j ); } } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] == 'O' ) { board [ i ][ j ] = 'X' ; } if ( board [ i ][ j ] == 'A' ) { board [ i ][ j ] = 'O' ; } } } } void dfs ( vector < vector < char >> & board , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || board [ i ][ j ] == 'A' || board [ i ][ j ] == 'X' ) { return ; } board [ i ][ j ] = 'A' ; dfs ( board , nRow , nCol , i + 1 , j ); dfs ( board , nRow , nCol , i - 1 , j ); dfs ( board , nRow , nCol , i , j + 1 ); dfs ( board , nRow , nCol , i , j - 1 ); } }; 0131. Palindrome Partitioning \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: s = \"aab\" Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]] */ class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; int n = ( int ) s . length (); if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } vector < string > arr ; move ( ans , arr , dp , n , 0 , s ); for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } void move ( vector < vector < string >> & ans , vector < string > & arr , bool ** dp , int n , int pos , string & s ) { if ( pos >= n ) { if ( ! arr . empty ()) { ans . emplace_back ( arr ); } return ; } for ( int len = 0 ; len < n - pos ; len ++ ) { if ( dp [ pos ][ pos + len ]) { arr . emplace_back ( s . substr ( pos , len + 1 )); move ( ans , arr , dp , n , pos + len + 1 , s ); arr . pop_back (); } } } }; 0132. Palindrome Partitioning II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /* Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. */ class Solution { public : int minCut ( string s ) { int n = int ( s . length ()); if ( n < 2 ) { return 0 ; } bool ** dp = new bool * [ n ]; int * cut = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ 0 ][ j ]) { cut [ j ] = 0 ; continue ; } int cutNum = INT_MAX ; for ( int i = j ; i > 0 ; i -- ) { if ( dp [ i ][ j ] && cutNum > cut [ i - 1 ] + 1 ) { cutNum = cut [ i - 1 ] + 1 ; } } cut [ j ] = cutNum ; } int ans = cut [ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; delete [] cut ; return ans ; } }; 0136. Single Number \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* Input: nums = [4,1,2,1,2] Output: 4 */ class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int & ele : nums ) { ans ^= ele ; } return ans ; } }; 0137. \u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u9664\u67d0\u4e2a\u5143\u7d20\u4ec5\u51fa\u73b0 \u4e00\u6b21 \u5916\uff0c\u5176\u4f59\u6bcf\u4e2a\u5143\u7d20\u90fd \u6070\u51fa\u73b0 \u4e09\u6b21 \u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u90a3\u4e2a\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\u7684\u5143\u7d20\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [2,2,3,2] \u8f93\u51fa\uff1a3 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [0,1,0,1,0,1,99] \u8f93\u51fa\uff1a99 */ class Solution { public : int singleNumber ( vector < int >& nums ) { unordered_map < int , int > dict ; for ( int ele : nums ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter = dict . begin (); for (; iter != dict . end (); iter ++ ) { if ( iter -> second == 1 ) { return iter -> first ; } } return - 1 ; } }; 0142. Linked List Cycle II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) { return head ; } ListNode * p1 = head , * p2 = head ; while ( true ) { if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; p1 = p1 -> next ; if ( p1 == p2 ) { break ; } } p1 = head ; while ( p1 != p2 ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } }; 0144. Binary Tree Preorder Traversal \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { curNode = st . top (); st . pop (); ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { st . push ( curNode -> left ); } } return ans ; } }; class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; while ( true ) { while ( curNode != nullptr ) { ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } curNode = curNode -> left ; } if ( st . empty ()) { break ; } curNode = st . top (); st . pop (); } return ans ; } }; 0150. Evaluate Reverse Polish Notation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* Input: tokens = [ \"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\" ] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 */ class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stk ; int num1 = 0 , num2 = 0 ; for ( string & token : tokens ) { if ( token == \"+\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 + num2 ); } else if ( token == \"-\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 - num2 ); } else if ( token == \"*\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 * num2 ); } else if ( token == \"/\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 / num2 ); } else { stk . push ( stringToInt ( token )); } } return stk . top (); } int stringToInt ( string num ) { int n = int ( num . length ()); int ans = 0 ; if ( num [ 0 ] != '-' ) { ans = num [ 0 ] - '0' ; } for ( int i = 1 ; i < n ; i ++ ) { ans = ans * 10 + ( num [ i ] - '0' ); } if ( num [ 0 ] == '-' ) { ans = - ans ; } return ans ; } }; 0151. Reverse Words in a String \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: s = \" hello world \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces. */ class Solution { public : string reverseWords ( string s ) { int pos = 0 ; for ( int i = 0 ; i < ( int ) s . length (); i ++ , pos ++ ) { if ( s [ i ] != ' ' ) { break ; } } string str = \"\" ; for ( int i = pos ; i < ( int ) s . length (); i ++ ) { if ( i > 0 && s [ i ] == ' ' && s [ i - 1 ] == ' ' ) { continue ; } str . push_back ( s [ i ]); } int n = int ( str . length ()); if ( str [ n - 1 ] == ' ' ) { n -- ; } str . resize ( n ); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( str [ i ], str [ n - 1 - i ]); } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int b = j , e = i - 1 ; while ( b < e ) { swap ( str [ b ++ ], str [ e -- ]); } j = i + 1 ; } } str . resize ( n ); return str ; } }; 0153. Find Minimum in Rotated Sorted Array \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: nums = [3,4,5,1,2] Output: 1 */ class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 , r = int ( nums . size ()) - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } return nums [ r ]; } }; 0154. Find Minimum in Rotated Sorted Array II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [2,2,2,0,1] Output: 0 */ class Solution { public : int findMin ( vector < int >& nums ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ l ] == nums [ r ]) { while ( l < r && nums [ l ] == nums [ l + 1 ]) { l ++ ; } while ( l < r && nums [ r ] == nums [ r - 1 ]) { r -- ; } if (( l + 1 <= r && nums [ l ] < nums [ l + 1 ] && nums [ r ] < nums [ r - 1 ]) || l == r ) { return nums [ l ]; } l ++ ; } else { if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } } return nums [ r ]; } }; 0155. Min Stack \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 */ class MinStack { vector < int > arr1 , arr2 ; public : /** initialize your data structure here. */ MinStack () { } void push ( int val ) { arr1 . emplace_back ( val ); if ( arr2 . empty () || arr2 . back () > val ) { arr2 . emplace_back ( val ); } else { arr2 . emplace_back ( arr2 . back ()); } } void pop () { arr1 . pop_back (); arr2 . pop_back (); } int top () { return arr1 . back (); } int getMin () { return arr2 . back (); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(val); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */ 0173. Binary Search Tree Iterator \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /* Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { vector < int > arr ; vector < int > :: iterator iter ; public : BSTIterator ( TreeNode * root ) { inOrder ( root ); iter = arr . begin (); } void inOrder ( TreeNode * root ) { if ( root != nullptr ) { inOrder ( root -> left ); arr . emplace_back ( root -> val ); inOrder ( root -> right ); } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return 0 ; } } bool hasNext () { return iter != arr . end (); } }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */ 0174. Dungeon Game* \u00b6 The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* -2(K) -3 3 -5 -10 1 10 30 -5(P) For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN. */ class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { int m = int ( dungeon . size ()); if ( m == 0 ) { return 1 ; } int n = int ( dungeon [ 0 ]. size ()); if ( n == 0 ) { return 1 ; } vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { int minVal = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); dp [ i ][ j ] = max ( minVal - dungeon [ i ][ j ], 1 ); } } int ans = dp [ 0 ][ 0 ]; return ans ; } }; 0179. Largest Number* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [3,30,34,5,9] Output: \"9534330\" */ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans = \"\" ; if ( nums . empty ()) { return ans ; } sort ( nums . begin (), nums . end (), []( const int & x , const int & y ) { long i = 10 , j = 10 ; while ( i <= x ) { i *= 10 ; } while ( j <= y ) { j *= 10 ; } return j * x + y > i * y + x ; }); if ( nums [ 0 ] == 0 ) { return \"0\" ; } for ( const int & ele : nums ) { ans += to_string ( ele ); } return ans ; } }; 0190. Reverse Bits* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. */ class Solution { public : uint32_t reverseBits ( uint32_t n ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { ans |= ( n & 1 ) << ( 31 - i ); n = n >> 1 ; } return ans ; } }; class Solution { public : uint32_t reverseBits ( uint32_t n ) { const uint32_t M1 = 0x55555555 ; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333 ; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f ; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff ; // 00000000111111110000000011111111 n = ( n >> 1 & M1 ) | ( n & M1 ) << 1 ; n = ( n >> 2 & M2 ) | ( n & M2 ) << 2 ; n = ( n >> 4 & M4 ) | ( n & M4 ) << 4 ; n = ( n >> 8 & M8 ) | ( n & M8 ) << 8 ; return n >> 16 | n << 16 ; } }; 0191. Number of 1 Bits \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. */ class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; while ( n ) { n &= n - 1 ; ans ++ ; } return ans ; //return __builtin_popcount(n); } }; 0199. Binary Tree Right Side View \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } int maxLevel = - 1 ; rightOrder ( root , ans , 0 , maxLevel ); return ans ; } void rightOrder ( TreeNode * root , vector < int > & ans , int level , int & maxLevel ) { if ( root != nullptr ) { if ( level > maxLevel ) { ans . emplace_back ( root -> val ); maxLevel = level ; } rightOrder ( root -> right , ans , level + 1 , maxLevel ); rightOrder ( root -> left , ans , level + 1 , maxLevel ); } } }; 0200. Number of Islands \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* grid = { {'1', '1', '0', '0', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '1', '0', '0'}, {'0', '0', '0', '1', '1'} } number of islands is 3 */ class Solution { public : int numIslands ( vector < vector < char >>& grid ) { int ans = 0 ; int nRow = int ( grid . size ()); if ( nRow == 0 ) { return 0 ; } int nCol = int ( grid [ 0 ]. size ()); if ( nCol == 0 ) { return 0 ; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( grid [ i ][ j ] == '0' ) { continue ; } if ( isIsland ( grid , nRow , nCol , i , j )) { ans ++ ; } } } return ans ; } bool isIsland ( vector < vector < char >> & grid , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || grid [ i ][ j ] == '0' ) { return false ; } bool res = true ; grid [ i ][ j ] = '0' ; bool u = isIsland ( grid , nRow , nCol , i - 1 , j ); bool d = isIsland ( grid , nRow , nCol , i + 1 , j ); bool l = isIsland ( grid , nRow , nCol , i , j - 1 ); bool r = isIsland ( grid , nRow , nCol , i , j + 1 ); return res || u || d || l || r ; } }; 0201. Bitwise AND of Numbers Range* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* Input: left = 5, right = 7 Output: 4 */ class Solution { public : int rangeBitwiseAnd ( int left , int right ) { while ( left < right ) { right &= right - 1 ; } return right ; } }; 0209. Minimum Size Subarray Sum \u00b6 Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 */ class Solution { public : int minSubArrayLen ( int target , vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int minLen = INT_MAX , l = 0 , r = 0 , sum = nums [ 0 ]; while ( r < n && l <= r ) { if ( sum < target ) { if ( r + 1 < n ) { sum += nums [ r + 1 ]; } r ++ ; } else { if ( minLen > r - l + 1 ) { minLen = r - l + 1 ; } sum -= nums [ l ++ ]; } } return minLen == INT_MAX ? 0 : minLen ; } }; 0212. Word Search II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* board = o a a n e t a e i h k r i f l v words = \"oath\",\"pea\",\"eat\",\"rain\" Output: \"eat\",\"oath\" */ class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { vector < string > ans ; int nRow = int ( board . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return ans ; } unordered_set < string > hash ; unordered_set < string > res ; int maxLen = 0 ; for ( string & word : words ) { hash . insert ( word ); maxLen = max ( maxLen , int ( word . length ())); } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { bool * vis = new bool [ nRow * nCol ]{}; string str = \"\" ; collect ( board , str , nRow , nCol , i , j , 0 , maxLen , hash , res , vis ); delete [] vis ; } } unordered_set < string >:: iterator iter ; for ( iter = res . begin (); iter != res . end (); iter ++ ) { ans . emplace_back ( * iter ); } return ans ; } void collect ( vector < vector < char >> & board , string & str , int nRow , int nCol , int i , int j , int len , int maxLen , unordered_set < string > & hash , unordered_set < string > & res , bool * vis ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || len > maxLen || vis [ i * nCol + j ]) { return ; } str . push_back ( board [ i ][ j ]); vis [ i * nCol + j ] = true ; if ( hash . find ( str ) != hash . end () && res . find ( str ) == res . end ()) { res . insert ( str ); } collect ( board , str , nRow , nCol , i - 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i + 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j - 1 , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j + 1 , len + 1 , maxLen , hash , res , vis ); str . pop_back (); vis [ i * nCol + j ] = false ; } }; 0215. Kth Largest Element in an Array \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 */ class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { int n = int ( nums . size ()); k = n - k ; int b = 0 , e = n - 1 ; while ( true ) { int i = b , j = e ; while ( i < j ) { while ( i < j && nums [ i ] <= nums [ j ]) { j -- ; } swap ( nums [ i ], nums [ j ]); while ( i < j && nums [ i ] <= nums [ j ]) { i ++ ; } swap ( nums [ i ], nums [ j ]); } if ( i == k ) { return nums [ i ]; } else if ( i > k ) { e = i - 1 ; } else { b = i + 1 ; } } return 0 ; } }; 0216. Combination Sum III \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. */ class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; if ( k == 0 || n > 45 ) { return ans ; } vector < int > arr ; dfs ( ans , arr , k , n , 1 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , int k , int n , int idx ) { if ( k <= 0 || n <= 0 || idx > 9 ) { if ( k == 0 && n == 0 ) { ans . emplace_back ( arr ); } return ; } for ( int i = idx ; i < 10 ; i ++ ) { arr . emplace_back ( i ); dfs ( ans , arr , k - 1 , n - i , i + 1 ); arr . pop_back (); } } }; 0219. Contains Duplicate II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: nums = [1,2,3,1,2,3], k = 2 Output: false */ class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( nums [ i ]) != hash . end ()) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } }; 0220. Contains Duplicate III* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false */ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; set < int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { iter = hash . lower_bound ( max ( nums [ i ], INT_MIN + t ) - t ); if ( iter != hash . end () && * iter <= min ( nums [ i ], INT_MAX - t ) + t ) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } }; 0222. \u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u4e2a\u6570* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* 1 / \\ 2 3 / \\ / 4 5 6 */ class Solution { public : int countNodes ( TreeNode * root ) { int ans = 0 ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; while ( curNode != nullptr ) { TreeNode * ll = curNode -> left , * lr = curNode -> left ; TreeNode * rl = curNode -> right , * rr = curNode -> right ; int lCnt = 1 , rCnt = 1 ; while ( ll != nullptr && lr != nullptr && rl != nullptr && rr != nullptr ) { ll = ll -> left ; lr = lr -> right ; rl = rl -> left ; rr = rr -> right ; lCnt <<= 1 ; rCnt <<= 1 ; } if ( ll == nullptr && rl == nullptr ) { ans += lCnt - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr != nullptr && rl == nullptr ) { ans += ( lCnt * 2 ) - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr == nullptr ) { ans += rCnt - 1 + 1 ; curNode = curNode -> left ; } else { ans += lCnt * 2 - 1 + 1 ; curNode = curNode -> right ; } } return ans ; } }; 0224. Basic Calculator \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23 */ class Solution { public : int calculate ( string s ) { stack < int > sn ; stack < char > so ; int num = 0 , n = int ( s . length ()), i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' ) { i -- ; continue ; } if ( s [ i ] == ')' ) { so . push ( ')' ); } else if ( s [ i ] == '(' ) { while ( so . top () != ')' ) { int n1 = sn . top (); sn . pop (); int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"wrong operator: %c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } so . pop (); } else if ( s [ i ] == '+' || s [ i ] == '-' ) { so . push ( s [ i ]); } else { long times = 1 ; while ( i >= 0 && s [ i ] >= '0' && s [ i ] <= '9' ) { num += ( s [ i -- ] - '0' ) * times ; times *= 10 ; } sn . push ( num ); //printf(\"num=%d\\n\", num); num = 0 ; continue ; } i -- ; } if ( s [ 0 ] == '-' ) { sn . push ( 0 ); } while ( ! so . empty ()) { int n1 = sn . top (); sn . pop (); if ( sn . empty ()) { sn . push ( n1 ); break ; } int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"%c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } if ( ! so . empty () && so . top () == '-' ) { return - sn . top (); } return sn . top (); } }; 0227. Basic Calculator II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /* Input: s = \" 3+5 / 2 \" Output: 5 */ class Solution { public : int calculate ( string s ) { stack < int > sn ; stack < char > so ; int n = int ( s . length ()), i = n - 1 ; long num = 0 ; while ( i >= 0 ) { if ( s [ i ] == ' ' ) { i -- ; continue ; } if ( s [ i ] == '*' || s [ i ] == '/' ) { so . push ( s [ i ]); } else if ( s [ i ] == '+' || s [ i ] == '-' ) { while ( ! so . empty () && ( so . top () == '*' || so . top () == '/' )) { int n1 = sn . top (); sn . pop (); int n2 = sn . top (); sn . pop (); if ( so . top () == '*' ) { n1 *= n2 ; } else { n1 /= n2 ; } sn . push ( n1 ); so . pop (); } so . push ( s [ i ]); } else { long times = 1 ; while ( i >= 0 && s [ i ] >= '0' && s [ i ] <= '9' ) { num += ( s [ i ] - '0' ) * times ; times *= 10 ; i -- ; } sn . push ( int ( num )); num = 0 ; continue ; } i -- ; } while ( ! so . empty ()) { int n1 = sn . top (); sn . pop (); if ( sn . empty ()) { sn . push ( n1 ); break ; } int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else if ( so . top () == '*' ) { n1 *= n2 ; } else if ( so . top () == '/' ) { n1 /= n2 ; } else { printf ( \"wrong operator %c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } if ( ! so . empty () && so . top () == '-' ) { return - sn . top (); } return sn . top (); } }; 0230. Kth Smallest Element in a BST \u00b6 Given the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* 3 / \\ 1 4 \\ 2 k = 1, kth min = 1 */ class Solution { public : int kthSmallest ( TreeNode * root , int & k ) { if ( root != nullptr ) { int left = kthSmallest ( root -> left , k ); if ( left >= 0 ) { return left ; } if ( k == 1 ) { return root -> val ; } k -- ; int right = kthSmallest ( root -> right , k ); if ( right >= 0 ) { return right ; } } return - 1 ; } }; 0232. Implement Queue using Stacks \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false */ // s1 is input stack, s2 is output stack class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () { } /** Push element x to the back of queue. */ void push ( int x ) { s1 . push ( x ); } /** Removes the element from in front of queue and returns that element. */ int pop () { int ans = peek (); s2 . pop (); return ans ; } /** Get the front element. */ int peek () { if ( s2 . empty ()) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } } return s2 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty () && s2 . empty (); } }; 0236. Lowest Common Ancestor of a Binary Tree \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* 3 / \\ 5 1 / \\ / \\ 6 2 0 8 / \\ 7 4 p = 5, q = 1 nearest common ancester is 3 */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { vector < TreeNode *> t1 , t2 , tmp ; dfs ( root , p , tmp , t1 ); tmp . clear (); dfs ( root , q , tmp , t2 ); int n1 = ( int ) t1 . size (), n2 = ( int ) t2 . size (); int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( t1 [ i ] != t2 [ j ]) { break ; } i ++ ; j ++ ; } if ( i == n1 ) { return t1 [ i - 1 ]; } if ( j == n2 ) { return t2 [ j - 1 ]; } return t1 [ i - 1 ]; } void dfs ( TreeNode * root , TreeNode *& node , vector < TreeNode *> & t , vector < TreeNode *> & res ) { if ( root == nullptr ) { return ; } t . emplace_back ( root ); if ( root == node ) { res = t ; return ; } dfs ( root -> left , node , t , res ); dfs ( root -> right , node , t , res ); t . pop_back (); } }; 0239. Sliding Window Maximum \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 */ class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; multiset < int > hash ; int n = ( int ) nums . size (); for ( int i = 0 ; i < k ; i ++ ) { hash . insert ( nums [ i ]); } for ( int i = k ; i < n ; i ++ ) { ans . emplace_back ( *-- hash . end ()); hash . erase ( hash . find ( nums [ i - k ])); hash . insert ( nums [ i ]); } ans . emplace_back ( *-- hash . end ()); return ans ; } }; class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; int n = ( int ) nums . size (); priority_queue < pair < int , int >> pq ; for ( int i = 0 ; i < k ; i ++ ) { pq . emplace ( nums [ i ], i ); } for ( int i = k ; i <= n ; i ++ ) { while ( pq . top (). second + k < i ) { pq . pop (); } ans . emplace_back ( pq . top (). first ); if ( i < n ) { pq . emplace ( nums [ i ], i ); } } return ans ; } }; 0257. Binary Tree Paths \u00b6 Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Input: 1 / \\ 2 3 \\ 5 Output: [\"1->2->5\", \"1->3\"] Explanation: All root-to-leaf paths are: 1->2->5, 1->3 */ class Solution { public : vector < string > binaryTreePaths ( TreeNode * root ) { vector < int > arr ; vector < string > ans ; if ( root == nullptr ) { return ans ; } getPaths ( root , ans , arr ); return ans ; } void getPaths ( TreeNode * root , vector < string > & ans , vector < int > & arr ) { if ( root == nullptr ) { return ; } if ( root -> left == nullptr && root -> right == nullptr ) { string str = \"\" ; for ( int ele : arr ) { str += to_string ( ele ) + \"->\" ; } str += to_string ( root -> val ); ans . emplace_back ( str ); return ; } arr . emplace_back ( root -> val ); getPaths ( root -> left , ans , arr ); getPaths ( root -> right , ans , arr ); arr . pop_back (); } }; 0263. Ugly Number \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: n = 6 Output: true Explanation: 6 = 2 \u00d7 3 */ class Solution { public : bool isUgly ( int n ) { if ( n <= 0 ) { return false ; } while ( n % 2 == 0 ) { n /= 2 ; } while ( n % 3 == 0 ) { n /= 3 ; } while ( n % 5 == 0 ) { n /= 5 ; } return n == 1 ; } }; 0264. Ugly Number II \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. */ class Solution { public : int nthUglyNumber ( int n ) { int ans = 0 ; if ( n <= 6 ) { return n ; } int * dp = new int [ n ]{}; dp [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ f2 ] * 2 , min ( dp [ f3 ] * 3 , dp [ f5 ] * 5 )); while ( dp [ f2 ] * 2 <= dp [ i ]) { f2 ++ ; } while ( dp [ f3 ] * 3 <= dp [ i ]) { f3 ++ ; } while ( dp [ f5 ] * 5 <= dp [ i ]) { f5 ++ ; } } ans = dp [ n - 1 ]; delete [] dp ; return ans ; } }; 0300. Longest Increasing Subsequence* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 /* Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. */ class Solution { public : int lengthOfLIS ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n <= 1 ) { return n ; } int * dp = new int [ n + 1 ]{}, len = 1 ; dp [ 1 ] = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] > dp [ len ]) { dp [ ++ len ] = nums [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ] >= nums [ i ]) { r = m - 1 ; } else { l = m + 1 ; } } dp [ l ] = nums [ i ]; } } delete [] dp ; return len ; } }; /* \u7ed9\u5b9a\u6570\u7ec4arr\uff0c\u8bbe\u957f\u5ea6\u4e3an\uff0c\u8f93\u51faarr\u7684\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\u3002 \uff08\u5982\u679c\u6709\u591a\u4e2a\u7b54\u6848\uff0c\u8bf7\u8f93\u51fa\u5176\u4e2d\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\uff09 input: 1,2,8,6,4 output: 1,2,4 */ class Solution { public : /** * retrun the longest increasing subsequence * @param arr int\u6574\u578bvector the array * @return int\u6574\u578bvector */ vector < int > LIS ( vector < int >& arr ) { // write code here vector < int > ans ; int n = ( int ) arr . size (); if ( n == 0 ) { return ans ; } vector < int > dp ( n , 1 ); int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ele = arr [ i ]; if ( ans . empty () || ans . back () < ele ) { ans . emplace_back ( ele ); len ++ ; dp [ i ] = len ; } else { int l = 0 , r = len - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( ans [ m ] >= ele ) { r = m - 1 ; } else { l = m + 1 ; } } ans [ l ] = ele ; dp [ i ] = l + 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( dp [ i ] == len ) { ans [ -- len ] = arr [ i ]; } } return ans ; } }; 0303. Range Sum Query - Immutable \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* Input [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] Output [null, 1, -1, -3] Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3) numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) */ class NumArray { vector < int > arr ; public : NumArray ( vector < int >& nums ) { int n = int ( nums . size ()); arr . resize ( n + 1 ); for ( int i = 0 ; i < n ; i ++ ) { arr [ i + 1 ] = arr [ i ] + nums [ i ]; } } int sumRange ( int i , int j ) { return arr [ j + 1 ] - arr [ i ]; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj->sumRange(i,j); */ 0304. Range Sum Query 2D - Immutable* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12 */ class NumMatrix { vector < vector < int >> accum ; public : NumMatrix ( vector < vector < int >>& matrix ) { int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ; } int nCol = int ( matrix [ 0 ]. size ()); if ( nCol == 0 ) { return ; } accum . resize ( nRow , vector < int > ( nCol + 1 , 0 )); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { accum [ i ][ j + 1 ] = accum [ i ][ j ] + matrix [ i ][ j ]; } } } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { int ans = 0 ; for ( int i = row1 ; i <= row2 ; i ++ ) { ans += accum [ i ][ col2 + 1 ] - accum [ i ][ col1 ]; } return ans ; } }; /** * Your NumMatrix object will be instantiated and called as such: * NumMatrix* obj = new NumMatrix(matrix); * int param_1 = obj->sumRegion(row1,col1,row2,col2); */ 0312. Burst Balloons* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 */ class Solution { public : int maxCoins ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ n + 2 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { dp [ i ] = new int [ n + 2 ]{}; } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i + 2 ; j <= n + 1 ; j ++ ) { int MAX = 0 ; for ( int k = i + 1 ; k < j ; k ++ ) { int left = ( i == 0 ? 1 : nums [ i - 1 ]); int mid = nums [ k - 1 ]; int right = ( j == n + 1 ? 1 : nums [ j - 1 ]); int prod = left * mid * right ; MAX = max ( MAX , dp [ i ][ k ] + prod + dp [ k ][ j ]); } dp [ i ][ j ] = MAX ; } } int ans = dp [ 0 ][ n + 1 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0331. Verify Preorder Serialization of a Binary Tree* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # */ class Solution { public : bool isValidSerialization ( string preorder ) { int n = int ( preorder . length ()), i = 0 , numNull = 1 ; if ( n == 0 ) { return true ; } while ( i < n ) { if ( numNull <= 0 ) { return false ; } if ( preorder [ i ] == '#' ) { numNull -- ; i ++ ; } else if ( preorder [ i ] == ',' ) { i ++ ; } else { while ( i < n && preorder [ i ] >= '0' && preorder [ i ] <= '9' ) { i ++ ; } numNull ++ ; } } return numNull == 0 ; } }; 0338. Counting Bits \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: 5 Output: [0,1,1,2,1,2] */ class Solution { public : vector < int > countBits ( int num ) { vector < int > ans ( num + 1 , 0 ); for ( int i = 1 ; i <= num ; i ++ ) { ans [ i ] = ans [ i / 2 ] + i % 2 ; } return ans ; } }; 0341. Flatten Nested List Iterator* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. */ /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector<NestedInteger> &getList() const; * }; */ class NestedIterator { vector < int > vals ; vector < int >:: iterator iter ; public : NestedIterator ( vector < NestedInteger > & nestedList ) { dfs ( nestedList ); iter = vals . begin (); } void dfs ( const vector < NestedInteger > & nestedList ) { for ( auto & ni : nestedList ) { if ( ni . isInteger ()) { vals . emplace_back ( ni . getInteger ()); } else { dfs ( ni . getList ()); } } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return - 1 ; } } bool hasNext () { return iter != vals . end (); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout << i.next(); */ 0343. Integer Break \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36. */ class Solution { public : int integerBreak ( int n ) { if ( n < 2 ) { return n ; } if ( n == 2 || n == 3 ) { return n - 1 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { int prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( prod < dp [ j ] * dp [ i - j ]) { prod = dp [ j ] * dp [ i - j ]; } } dp [ i ] = prod ; } int ans = dp [ n ]; delete [] dp ; return ans ; } }; 0354. Russian Doll Envelopes* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). */ class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { int n = int ( envelopes . size ()), len = 1 ; if ( n <= 1 ) { return n ; } sort ( envelopes . begin (), envelopes . end (), []( const auto & e1 , const auto & e2 ) { return e1 [ 0 ] < e2 [ 0 ] || ( e1 [ 0 ] == e2 [ 0 ] && e1 [ 1 ] > e2 [ 1 ]); }); vector < vector < int >> dp ( n + 1 , vector < int > { 0 , 0 }); dp [ len ] = envelopes [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( envelopes [ i ][ 0 ] > dp [ len ][ 0 ] && envelopes [ i ][ 1 ] > dp [ len ][ 1 ]) { dp [ ++ len ] = envelopes [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ][ 0 ] < envelopes [ i ][ 0 ] && dp [ m ][ 1 ] < envelopes [ i ][ 1 ]) { l = m + 1 ; } else { r = m - 1 ; } } dp [ l ] = envelopes [ i ]; } } return len ; } }; 0365. Water and Jug Problem \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs. If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty. Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 Output: true Explanation: The famous Die Hard example */ class Solution { public : bool canMeasureWater ( int jug1Capacity , int jug2Capacity , int targetCapacity ) { int x = jug1Capacity ; int y = jug2Capacity ; int z = targetCapacity ; if ( z > x + y ) { return false ; } if ( z == x || z == y ) { return true ; } if ( x > y ) { swap ( x , y ); } int diff = y % x ; if ( diff == 0 ) { return z % x == 0 ; } for ( int i = 0 ; i < x ; i ++ ) { if ( diff == z || x + diff == z || y + diff == z || y - x + diff == z ) { return true ; } diff = ( y - ( x - diff )) % x ; } return false ; } }; 0367. Valid Perfect Square \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: num = 16 Output: true Input: num = 14 Output: false */ class Solution { public : bool isPerfectSquare ( int num ) { long l = 1 , r = num ; while ( l <= r ) { long m = ( l + r ) >> 1 ; long res = m * m ; if ( res == num ) { return true ; } else if ( res < num ) { l = m + 1 ; } else { r = m - 1 ; } } return false ; } }; 0368. Largest Divisible Subset \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies: answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them. Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. */ class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { vector < int > ans ; int n = ( int ) nums . size (); if ( n < 2 ) { return nums ; } sort ( nums . begin (), nums . end ()); vector < int > dp ( n , 1 ); vector < int > par ( n , - 1 ); int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( nums [ i ] % nums [ j ] == 0 && dp [ j ] + 1 > dp [ i ]) { dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); par [ i ] = j ; } } len = max ( len , dp [ i ]); } ans . resize ( len ); for ( int i = n - 1 ; i >= 0 ;) { if ( dp [ i ] == len ) { ans [ -- len ] = nums [ i ]; i = par [ i ]; } else { i -- ; } } return ans ; } }; 0395. Longest Substring with At Least K Repeating Characters* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* Input: s = \"ababbc\", k = 2 Output: 5 Explanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times. */ class Solution { public : int longestSubstring ( string s , int k ) { int n = int ( s . length ()), ans = 0 ; for ( int t = 1 ; t <= 26 ; t ++ ) { int l = 0 , r = 0 , tot = 0 , numLessK = 0 ; int * count = new int [ 26 ]{}; while ( r < n ) { count [ s [ r ] - 'a' ] ++ ; if ( count [ s [ r ] - 'a' ] == 1 ) { tot ++ ; numLessK ++ ; } if ( count [ s [ r ] - 'a' ] == k ) { numLessK -- ; } while ( tot > t ) { count [ s [ l ] - 'a' ] -- ; if ( count [ s [ l ] - 'a' ] == k - 1 ) { numLessK ++ ; } if ( count [ s [ l ] - 'a' ] == 0 ) { numLessK -- ; tot -- ; } l ++ ; } if ( numLessK == 0 ) { ans = max ( ans , r - l + 1 ); } r ++ ; } delete [] count ; } return ans ; } }; 0403. \u9752\u86d9\u8fc7\u6cb3* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* \u4e00\u53ea\u9752\u86d9\u60f3\u8981\u8fc7\u6cb3\u3002 \u5047\u5b9a\u6cb3\u6d41\u88ab\u7b49\u5206\u4e3a\u82e5\u5e72\u4e2a\u5355\u5143\u683c\uff0c\u5e76\u4e14\u5728\u6bcf\u4e00\u4e2a\u5355\u5143\u683c\u5185 \u90fd\u6709\u53ef\u80fd\u653e\u6709\u4e00\u5757\u77f3\u5b50\uff08\u4e5f\u6709\u53ef\u80fd\u6ca1\u6709\uff09\u3002 \u9752\u86d9\u53ef\u4ee5\u8df3\u4e0a\u77f3\u5b50\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8df3 \u5165\u6c34\u4e2d\u3002 \u7ed9\u4f60\u77f3\u5b50\u7684\u4f4d\u7f6e\u5217\u8868 stones\uff08\u7528\u5355\u5143\u683c\u5e8f\u53f7 \u5347\u5e8f \u8868\u793a\uff09\uff0c \u8bf7\u5224\u5b9a\u9752\u86d9\u80fd \u5426\u6210\u529f\u8fc7\u6cb3\uff08\u5373\u80fd\u5426\u5728\u6700\u540e\u4e00\u6b65\u8df3\u81f3\u6700\u540e\u4e00\u5757\u77f3\u5b50\u4e0a\uff09\u3002 \u5f00\u59cb\u65f6\uff0c \u9752\u86d9\u9ed8\u8ba4\u5df2\u7ad9\u5728\u7b2c\u4e00\u5757\u77f3\u5b50\u4e0a\uff0c\u5e76\u53ef\u4ee5\u5047\u5b9a\u5b83\u7b2c\u4e00\u6b65\u53ea\u80fd\u8df3\u8dc3\u4e00\u4e2a\u5355 \u4f4d\uff08\u5373\u53ea\u80fd\u4ece\u5355\u5143\u683c 1 \u8df3\u81f3\u5355\u5143\u683c 2 \uff09\u3002 \u5982\u679c\u9752\u86d9\u4e0a\u4e00\u6b65\u8df3\u8dc3\u4e86 k \u4e2a\u5355\u4f4d\uff0c\u90a3\u4e48\u5b83\u63a5\u4e0b\u6765\u7684\u8df3\u8dc3\u8ddd\u79bb\u53ea\u80fd\u9009\u62e9\u4e3a k - 1\u3001 k \u6216 k + 1 \u4e2a\u5355\u4f4d\u3002 \u53e6\u8bf7\u6ce8\u610f\uff0c\u9752\u86d9\u53ea\u80fd\u5411\u524d\u65b9\uff08\u7ec8\u70b9\u7684\u65b9\u5411\uff09\u8df3\u8dc3\u3002 \u8f93\u5165\uff1astones = [0,1,3,5,6,8,12,17] \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a\u9752\u86d9\u53ef\u4ee5\u6210\u529f\u8fc7\u6cb3\uff0c\u6309\u7167\u5982\u4e0b\u65b9\u6848\u8df3\u8dc3\uff1a\u8df3 1 \u4e2a\u5355\u4f4d\u5230\u7b2c 2 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 3 \u5757\u77f3\u5b50, \u63a5\u7740 \u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 4 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 3 \u4e2a\u5355\u4f4d\u5230\u7b2c 6 \u5757\u77f3\u5b50, \u8df3 4 \u4e2a\u5355\u4f4d\u5230\u7b2c 7 \u5757\u77f3\u5b50, \u6700\u540e\uff0c\u8df3 5 \u4e2a\u5355\u4f4d\u5230\u7b2c 8 \u4e2a\u77f3\u5b50\uff08\u5373\u6700\u540e\u4e00\u5757\u77f3\u5b50\uff09\u3002 \u8f93\u5165\uff1astones = [0,1,2,3,4,8,9,11] \u8f93\u51fa\uff1afalse \u89e3\u91ca\uff1a\u8fd9\u662f\u56e0\u4e3a\u7b2c 5 \u548c\u7b2c 6 \u4e2a\u77f3\u5b50\u4e4b\u95f4\u7684\u95f4\u8ddd\u592a\u5927\uff0c\u6ca1\u6709\u53ef\u9009\u7684\u65b9\u6848\u4f9b\u9752\u86d9\u8df3 \u8dc3\u8fc7\u53bb\u3002 */ class Solution { public : bool canCross ( vector < int >& stones ) { unordered_map < int , int > dict ; int n = ( int ) stones . size (); if ( n <= 1 ) { return true ; } vector < vector < int >> dp ( n , vector < int > ( n , 0 )); dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( stones [ i ] - stones [ i - 1 ] > i ) { return false ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { int k = stones [ i ] - stones [ j ]; if ( k > j + 1 ) { break ; } dp [ i ][ k ] = dp [ j ][ k - 1 ] || dp [ j ][ k ] || dp [ j ][ k + 1 ]; if ( i == n - 1 && dp [ i ][ k ]) { return true ; } } } return false ; } }; 0407. \u63a5\u96e8\u6c34 II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /* \u7ed9\u4f60\u4e00\u4e2a m x n \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u7684\u503c\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u4e8c\u7ef4\u9ad8\u5ea6\u56fe\u6bcf\u4e2a\u5355 \u5143\u7684\u9ad8\u5ea6\uff0c\u8bf7\u8ba1\u7b97\u56fe\u4e2d\u5f62\u72b6\u6700\u591a\u80fd\u63a5\u591a\u5c11\u4f53\u79ef\u7684\u96e8\u6c34\u3002 \u793a\u4f8b\uff1a \u7ed9\u51fa\u5982\u4e0b 3x6 \u7684\u9ad8\u5ea6\u56fe: [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] \u8fd4\u56de 4 \u3002 */ class Solution { public : int trapRainWater ( vector < vector < int >>& heightMap ) { int nRow = ( int ) heightMap . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) heightMap [ 0 ]. size (); if ( nCol < 3 ) { return 0 ; } typedef pair < int , pair < int , int >> PIII ; priority_queue < PIII , vector < PIII > , greater < PIII >> heap ; bool ** vis = new bool * [ nRow ]; for ( int i = 0 ; i < nRow ; i ++ ) { vis [ i ] = new bool [ nCol ]{}; heap . push ({ heightMap [ i ][ 0 ], { i , 0 }}); heap . push ({ heightMap [ i ][ nCol - 1 ], { i , nCol - 1 }}); vis [ i ][ 0 ] = vis [ i ][ nCol - 1 ] = true ; } for ( int j = 0 ; j < nCol ; j ++ ) { heap . push ({ heightMap [ 0 ][ j ], { 0 , j }}); heap . push ({ heightMap [ nRow - 1 ][ j ], { nRow - 1 , j }}); vis [ 0 ][ j ] = vis [ nRow - 1 ][ j ] = true ; } int dx [ 4 ] = { - 1 , 0 , 1 , 0 }, dy [ 4 ] = { 0 , - 1 , 0 , 1 }; int ans = 0 ; while ( ! heap . empty ()) { auto cur = heap . top (); heap . pop (); int x = cur . second . first , y = cur . second . second ; int h = cur . first ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx >= 0 && xx < nRow && yy >= 0 && yy < nCol && ! vis [ xx ][ yy ]) { vis [ xx ][ yy ] = true ; ans += max ( h - heightMap [ xx ][ yy ], 0 ); heap . push ({ max ( h , heightMap [ xx ][ yy ]), { xx , yy }}); } } } for ( int i = 0 ; i < nRow ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } }; 0415. Add Strings \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* Input: num1 = \"456\", num2 = \"77\" Output: \"533\" */ class Solution { public : string addStrings ( string num1 , string num2 ) { string ans = \"\" ; int len1 = ( int ) num1 . length (), len2 = ( int ) num2 . length (); if ( len1 < len2 ) { swap ( len1 , len2 ); swap ( num1 , num2 ); } int i = len1 - 1 , j = len2 - 1 ; int res = 0 ; while ( j >= 0 ) { int sum = ( num1 [ i ] - '0' ) + ( num2 [ j ] - '0' ) + res ; res = 0 ; if ( sum >= 10 ) { res = 1 ; sum -= 10 ; } char sumChar = sum + '0' ; ans . insert ( 0 , 1 , sumChar ); i -- ; j -- ; } while ( i >= 0 ) { int sum = ( num1 [ i ] - '0' ) + res ; res = 0 ; if ( sum >= 10 ) { res = 1 ; sum -= 10 ; } char sumChar = sum + '0' ; ans . insert ( 0 , 1 , sumChar ); i -- ; } if ( res ) { ans . insert ( 0 , 1 , '1' ); } return ans ; } }; 0470. Implement Rand10() Using Rand7()* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: n = 3 Output: [3,8,10] */ // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 class Solution { public : int rand10 () { int ans = 0 , i = 0 , j = 0 ; do { i = rand7 (); j = rand7 (); ans = ( i - 1 ) * 7 + j ; } while ( ans > 40 ); return ans % 10 + 1 ; } }; 0503. Next Greater Element II* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. */ class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return vector < int > {}; } vector < int > ans ( n , - 1 ); stack < int > st ; for ( int i = 0 ; i < 2 * n - 1 ; i ++ ) { while ( ! st . empty () && nums [ st . top ()] < nums [ i % n ]) { ans [ st . top ()] = nums [ i % n ]; st . pop (); } st . push ( i % n ); } return ans ; } }; 0516. Longest Palindromic Subsequence* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000. Input: \"bbbab\" Output: 4 */ class Solution { public : int longestPalindromeSubseq ( string s ) { int n = int ( s . length ()); if ( n <= 1 ) { return n ; } int ** dp = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new int [ n ]{}; dp [ i ][ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] + 2 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } } } int ans = dp [ 0 ][ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0530. Minimum Absolute Difference in BST \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 1 \\ 3 / 2 output: 1 */ class Solution { public : int getMinimumDifference ( TreeNode * root ) { TreeNode * last = nullptr ; int ans = INT_MAX ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & diff ) { if ( root != nullptr ) { inOrder ( root -> left , last , diff ); if ( last == nullptr ) { last = root ; } else { diff = min ( diff , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , diff ); } } }; 0543. Diameter of Binary Tree \u00b6 Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. */ class Solution { public : int diameterOfBinaryTree ( TreeNode * root ) { int max = 0 ; getDep ( root , max ); return max ; } int getDep ( TreeNode * root , int & maxLen ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDep ( root -> left , maxLen ); int rightDep = getDep ( root -> right , maxLen ); int curLen = leftDep + rightDep ; maxLen = maxLen > curLen ? maxLen : curLen ; return ( leftDep > rightDep ? leftDep : rightDep ) + 1 ; } }; 0554. \u7816\u5899* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u4f60\u7684\u9762\u524d\u6709\u4e00\u5835\u77e9\u5f62\u7684\u3001\u7531 n \u884c\u7816\u5757\u7ec4\u6210\u7684\u7816\u5899\u3002\u8fd9\u4e9b\u7816\u5757\u9ad8\u5ea6\u76f8\u540c\uff08\u4e5f\u5c31\u662f\u4e00\u4e2a\u5355\u4f4d\u9ad8\uff09 \u4f46\u662f\u5bbd\u5ea6\u4e0d\u540c\u3002\u6bcf\u4e00\u884c\u7816\u5757\u7684\u5bbd\u5ea6\u4e4b\u548c\u5e94\u8be5\u76f8\u7b49\u3002 \u4f60\u73b0\u5728\u8981\u753b\u4e00\u6761 \u81ea\u9876\u5411\u4e0b \u7684\u3001\u7a7f\u8fc7 \u6700\u5c11 \u7816\u5757\u7684\u5782\u7ebf\u3002\u5982\u679c\u4f60\u753b\u7684\u7ebf\u53ea\u662f\u4ece\u7816\u5757\u7684\u8fb9\u7f18\u7ecf\u8fc7\uff0c \u5c31\u4e0d\u7b97\u7a7f\u8fc7\u8fd9\u5757\u7816\u3002\u4f60\u4e0d\u80fd\u6cbf\u7740\u5899\u7684\u4e24\u4e2a\u5782\u76f4\u8fb9\u7f18\u4e4b\u4e00\u753b\u7ebf\uff0c\u8fd9\u6837\u663e\u7136\u662f\u6ca1\u6709\u7a7f\u8fc7\u4e00\u5757\u7816\u7684\u3002 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 wall \uff0c\u8be5\u6570\u7ec4\u5305\u542b\u8fd9\u5835\u5899\u7684\u76f8\u5173\u4fe1\u606f\u3002\u5176\u4e2d\uff0cwall[i] \u662f\u4e00\u4e2a\u4ee3\u8868\u4ece\u5de6 \u81f3\u53f3\u6bcf\u5757\u7816\u7684\u5bbd\u5ea6\u7684\u6570\u7ec4\u3002\u4f60\u9700\u8981\u627e\u51fa\u600e\u6837\u753b\u624d\u80fd\u4f7f\u8fd9\u6761\u7ebf \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf\u6700\u5c11 \uff0c\u5e76\u4e14\u8fd4\u56de \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf \u3002 \u8f93\u5165\uff1awall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] \u8f93\u51fa\uff1a2 \u8f93\u5165\uff1awall = [[1],[1],[1]] \u8f93\u51fa\uff1a3 */ class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int n = ( int ) wall . size (); if ( n == 0 ) { return 0 ; } int ans = 0 ; unordered_map < int , int > cnt ; for ( auto arr : wall ) { int len = ( int ) arr . size (); int sum = 0 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { sum += arr [ i ]; cnt [ sum ] ++ ; } } unordered_map < int , int >:: iterator iter ; for ( iter = cnt . begin (); iter != cnt . end (); iter ++ ) { ans = max ( ans , iter -> second ); } return n - ans ; } }; 0633. \u5e73\u65b9\u6570\u4e4b\u548c* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 c \uff0c\u4f60\u8981\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6574\u6570 a \u548c b\uff0c\u4f7f\u5f97 a^2 + b^2 = c \u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ac = 5 \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a1 * 1 + 2 * 2 = 5 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ac = 3 \u8f93\u51fa\uff1afalse \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ac = 4 \u8f93\u51fa\uff1atrue \u793a\u4f8b 4\uff1a \u8f93\u5165\uff1ac = 2 \u8f93\u51fa\uff1atrue \u793a\u4f8b 5\uff1a \u8f93\u5165\uff1ac = 1 \u8f93\u51fa\uff1atrue */ class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 , r = ( long ) sqrt ( c ); while ( l <= r ) { long sqaureSum = l * l + r * r ; if ( sqaureSum == c ) { return true ; } else if ( sqaureSum < c ) { l ++ ; } else { r -- ; } } return false ; } }; 0647. Palindromic Substrings \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". */ class Solution { public : int countSubstrings ( string s ) { int n = int ( s . length ()), ans = n ; if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i - 1 ] == s [ i ]) { dp [ i - 1 ][ i ] = true ; ans ++ ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; ans ++ ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } }; 0690. \u5458\u5de5\u7684\u91cd\u8981\u6027 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* \u7ed9\u5b9a\u4e00\u4e2a\u4fdd\u5b58\u5458\u5de5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u5305\u542b\u4e86\u5458\u5de5 \u552f\u4e00\u7684 id \uff0c\u91cd\u8981\u5ea6\u548c\u76f4\u7cfb\u4e0b\u5c5e\u7684 id \u3002 \u6bd4\u5982\uff0c\u5458\u5de5 1 \u662f\u5458\u5de5 2 \u7684\u9886\u5bfc\uff0c\u5458\u5de5 2 \u662f\u5458\u5de5 3 \u7684\u9886\u5bfc\u3002\u4ed6\u4eec\u76f8\u5e94\u7684\u91cd\u8981\u5ea6\u4e3a 15 , 10 , 5 \u3002 \u90a3\u4e48\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u662f [1, 15, [2]] \uff0c\u5458\u5de5 2\u7684 \u6570\u636e\u7ed3\u6784\u662f [2, 10, [3]] \uff0c\u5458\u5de53 \u7684\u6570\u636e\u7ed3\u6784\u662f [3, 5, []] \u3002\u6ce8\u610f\u867d\u7136\u5458\u5de5 3 \u4e5f\u662f\u5458\u5de5 1 \u7684\u4e00\u4e2a\u4e0b\u5c5e\uff0c\u4f46\u662f\u7531\u4e8e \u5e76\u4e0d\u662f\u76f4\u7cfb \u4e0b\u5c5e\uff0c\u56e0\u6b64\u6ca1\u6709\u4f53\u73b0\u5728\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 \u73b0\u5728\u8f93\u5165\u4e00\u4e2a\u516c\u53f8\u7684\u6240\u6709\u5458\u5de5\u4fe1\u606f\uff0c\u4ee5\u53ca\u5355\u4e2a\u5458\u5de5 id \uff0c\u8fd4\u56de\u8fd9\u4e2a\u5458\u5de5\u548c\u4ed6\u6240\u6709\u4e0b\u5c5e\u7684\u91cd\u8981\u5ea6\u4e4b\u548c\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 \u8f93\u51fa\uff1a11 \u89e3\u91ca\uff1a \u5458\u5de5 1 \u81ea\u8eab\u7684\u91cd\u8981\u5ea6\u662f 5 \uff0c\u4ed6\u6709\u4e24\u4e2a\u76f4\u7cfb\u4e0b\u5c5e 2 \u548c 3 \uff0c\u800c\u4e14 2 \u548c 3 \u7684\u91cd\u8981\u5ea6\u5747\u4e3a 3 \u3002 \u56e0\u6b64\u5458\u5de5 1 \u7684\u603b\u91cd\u8981\u5ea6\u662f 5 + 3 + 3 = 11 \u3002 */ /* // Definition for Employee. class Employee { public: int id; int importance; vector< int> subordinates; }; */ class Solution { public : int dfs ( unordered_set < int > & vis , unordered_map < int , int > & dict , unordered_map < int , vector < int >> & next , int id ) { int ans = 0 ; for ( int sub : next [ id ]) { if ( vis . find ( sub ) == vis . end ()) { vis . insert ( sub ); ans += dfs ( vis , dict , next , sub ); } } return ans + dict [ id ]; } int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , int > dict ; unordered_map < int , vector < int >> next ; unordered_set < int > vis ; for ( auto employee : employees ) { dict [ employee -> id ] = employee -> importance ; next [ employee -> id ] = employee -> subordinates ; } return dfs ( vis , dict , next , id ); } }; 0704. Binary Search \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 */ class Solution { public : int search ( vector < int >& nums , int target ) { int n = ( int ) nums . size (); if ( n == 0 ) { return - 1 ; } int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return m ; } else if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m - 1 ; } } return - 1 ; } }; 0738. Monotone Increasing Digits* \u00b6 Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits. (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: N = 10 Output: 9 Input: N = 1234 Output: 1234 Input: N = 332 Output: 299 */ class Solution { public : int monotoneIncreasingDigits ( int N ) { int ans = 0 ; string str = to_string ( N ); int len = int ( str . length ()), idx = - 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] < str [ i - 1 ]) { idx = i ; break ; } } if ( idx == - 1 ) { return N ; } int pos = idx - 1 ; while ( pos >= 1 && str [ pos ] == str [ pos - 1 ]) { pos -- ; } str [ pos ] -- ; // current position decrease by 1 for ( int i = pos + 1 ; i < len ; i ++ ) { str [ i ] = '9' ; } for ( int i = len - 1 , pow = 1 ; i >= 0 ; i -- , pow *= 10 ) { ans += ( str [ i ] - '0' ) * pow ; } return ans ; } }; 0741. Cherry Pickup* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect by following the rules below: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells. When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0. If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected. Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]] Output: 5 Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible. Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 */ class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { int n = int ( grid . size ()); if ( n == 0 ) { return 0 ; } vector < vector < vector < int >>> dp ( n , vector < vector < int >> ( n , vector < int > ( n , - 1 ))); int ans = move ( dp , grid , 0 , 0 , 0 , n ); return max ( 0 , ans ); } int move ( vector < vector < vector < int >>> & dp , vector < vector < int >> & grid , int r1 , int c1 , int c2 , int n ) { int r2 = r1 + c1 - c2 ; if ( r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid [ r1 ][ c1 ] == - 1 || grid [ r2 ][ c2 ] == - 1 ) { return - 2 ; } if ( r1 == n - 1 && c1 == n - 1 ) { return grid [ r1 ][ c1 ]; } if ( dp [ r1 ][ c1 ][ c2 ] != - 1 ) { return dp [ r1 ][ c1 ][ c2 ]; } int ans = move ( dp , grid , r1 , c1 + 1 , c2 + 1 , n ); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 + 1 , n )); ans = max ( ans , move ( dp , grid , r1 , c1 + 1 , c2 , n )); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 , n )); if ( ans >= 0 ) { ans += grid [ r1 ][ c1 ] + ( c1 != c2 || r1 != r2 ) * grid [ r2 ][ c2 ]; } dp [ r1 ][ c1 ][ c2 ] = ans ; return ans ; } }; 0752. Open the Lock* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\" Output: 6 Explanation: A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\". Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \"0102\". */ class Solution { public : int openLock ( vector < string >& deadends , string target ) { string init = \"0000\" ; int n = int ( init . length ()), ans = 0 ; unordered_set < string > vis ; for ( string & str : deadends ) { vis . insert ( str ); } if ( vis . find ( init ) != vis . end ()) { return - 1 ; } queue < string > qLock ; qLock . push ( init ); while ( ! qLock . empty ()) { int num = int ( qLock . size ()); while ( num -- ) { string str = qLock . front (); qLock . pop (); if ( str == target ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { string tmp = str ; for ( int d = - 1 ; d <= 1 ; d += 2 ) { tmp [ i ] = ( str [ i ] - '0' + 10 + d ) % 10 + '0' ; if ( vis . find ( tmp ) == vis . end ()) { vis . insert ( tmp ); qLock . push ( tmp ); } } } } ans ++ ; } return - 1 ; } }; 0766. Toeplitz Matrix \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 1 2 3 4 5 1 2 3 9 5 1 2 */ class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { int m = int ( matrix . size ()); if ( m == 0 ) { return false ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return false ; } for ( int j = 0 ; j < n ; j ++ ) { int first = matrix [ 0 ][ j ]; for ( int i = 0 ; i < min ( m , n - j ); i ++ ) { if ( first != matrix [ i ][ i + j ]) { return false ; } } } for ( int i = 1 ; i < m ; i ++ ) { int first = matrix [ i ][ 0 ]; for ( int j = 0 ; j < min ( n , m - i ); j ++ ) { if ( first != matrix [ i + j ][ j ]) { return false ; } } } return true ; } }; 0769. Max Chunks To Make Sorted* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. */ class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 1 , n = ( int ) arr . size (); if ( n <= 1 ) { return ans ; } vector < int > rightMin ( n , 0 ); rightMin [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; i -- ) { rightMin [ i ] = min ( rightMin [ i + 1 ], arr [ i ]); } int leftMax = arr [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( leftMax <= rightMin [ i ]) { ans ++ ; } leftMax = max ( leftMax , arr [ i ]); } return ans ; } }; 0781. Rabbits in Forest \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered \"1\" could both be the same color, say red. The rabbit than answered \"2\" can't be red or the answers would be inconsistent. Say the rabbit that answered \"2\" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't. Input: answers = [10, 10, 10] Output: 11 Input: answers = [] Output: 0 */ class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; unordered_map < int , int > dict ; for ( int & ele : answers ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { if ( iter -> first == 0 ) { ans += iter -> second ; } else { if ( iter -> first + 1 >= iter -> second ) { ans += iter -> first + 1 ; } else { if ( iter -> second % ( iter -> first + 1 ) == 0 ) { ans += iter -> second ; } else { ans += ( iter -> second / ( iter -> first + 1 ) + 1 ) * ( iter -> first + 1 ); } } } } return ans ; } }; 0783. Minimum Distance Between BST Nodes \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 4 / \\ 2 6 / \\ 1 5 output: 1 */ class Solution { public : int minDiffInBST ( TreeNode * root ) { int ans = INT_MAX ; TreeNode * last = nullptr ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & ans ) { if ( root != nullptr ) { inOrder ( root -> left , last , ans ); if ( last == nullptr ) { last = root ; } else { ans = min ( ans , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , ans ); } } }; 0832. Flipping an Image \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] */ class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { int m = int ( A . size ()), n = int ( A [ 0 ]. size ()); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { swap ( A [ i ][ j ], A [ i ][ n - 1 - j ]); } for ( int j = 0 ; j < n ; j ++ ) { A [ i ][ j ] = 1 - A [ i ][ j ]; } } return A ; } }; 0845. Longest Mountain in Array* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5. */ class Solution { public : int longestMountain ( vector < int >& arr ) { int ans = 0 , n = int ( arr . size ()); if ( n < 3 ) { return 0 ; } vector < int > left ( n , 0 ), right ( n , 0 ); for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ]) { left [ i ] = left [ i - 1 ] + 1 ; } if ( arr [ n - 1 - i ] > arr [ n - i ]) { right [ n - 1 - i ] = right [ n - i ] + 1 ; } } if ( arr [ n - 1 ] > arr [ n - 2 ]) { left [ n - 1 ] = left [ n - 2 ] + 1 ; } if ( arr [ 0 ] > arr [ 1 ]) { right [ 0 ] = right [ 1 ] + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( left [ i ] && right [ i ]) { ans = max ( left [ i ] + right [ i ] + 1 , ans ); } } return ans ; } }; 0897. Increasing Order Search Tree* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 5 1 / \\ \\ 1 7 5 \\ 7 */ class Solution { public : TreeNode * increasingBST ( TreeNode * root ) { TreeNode * last = nullptr ; TreeNode * head = nullptr ; inOrder ( root , last , head ); return head ; } void inOrder ( TreeNode * root , TreeNode *& last , TreeNode *& head ) { if ( root != nullptr ) { inOrder ( root -> left , last , head ); if ( last != nullptr ) { last -> right = root ; last -> left = nullptr ; root -> left = nullptr ; } else { head = root ; } last = root ; inOrder ( root -> right , last , head ); } } }; 0921. Minimum Add to Make Parentheses Valid* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: \"()))((\" Output: 4 */ class Solution { public : int minAddToMakeValid ( string S ) { int left = 0 , ans = 0 ; for ( const char & c : S ) { if ( c == '(' ) { left ++ ; } else { if ( left > 0 ) { left -- ; } else { ans ++ ; } } } return ans + left ; } }; 0938. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u8303\u56f4\u548c \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 10 / \\ 5 15 / \\ \\ 3 7 18 \u8f93\u5165\uff1aroot = [10,5,15,3,7,null,18], low = 7, high = 15 \u8f93\u51fa\uff1a32 */ class Solution { public : int rangeSumBST ( TreeNode * root , int low , int high ) { if ( root == nullptr ) { return 0 ; } int left = rangeSumBST ( root -> left , low , high ); int val = 0 ; if ( root -> val >= low && root -> val <= high ) { val = root -> val ; } int right = rangeSumBST ( root -> right , low , high ); return left + val + right ; } }; 1006. Clumsy Factorial* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 */ class Solution { public : int clumsy ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 ) { return 2 ; } else if ( N == 3 ) { return 6 ; } else if ( N == 4 ) { return 7 ; } else { if ( N % 4 == 0 ) { return N + 1 ; } else if ( N % 4 == 1 ) { return N + 2 ; } else if ( N % 4 == 2 ) { return N + 2 ; } else { return N - 1 ; } } } }; 1047. Remove All Adjacent Duplicates In String \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". */ class Solution { public : string removeDuplicates ( string S ) { int n = int ( S . length ()); if ( n <= 1 ) { return S ; } string ans = \"\" ; for ( const char & c : S ) { if ( ! ans . empty () && ans . back () == c ) { ans . pop_back (); } else { ans . push_back ( c ); } } return ans ; } }; 1052. Grumpy Bookstore Owner \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16. */ class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int ans = 0 , n = int ( customers . size ()); if ( n == 0 ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { if ( grumpy [ i ] == 0 ) { ans += customers [ i ]; } } int add = 0 , maxAdd = 0 ; for ( int i = 0 ; i < X ; i ++ ) { ans += customers [ i ] * grumpy [ i ]; } for ( int i = 1 ; i < n - X + 1 ; i ++ ) { add += - customers [ i - 1 ] * grumpy [ i - 1 ] + customers [ i + X - 1 ] * grumpy [ i + X - 1 ]; if ( maxAdd < add ) { maxAdd = add ; } } return ans + maxAdd ; } }; 1178. Number of Valid Words for Each Puzzle* \u00b6 With respect to a given puzzle string, a word is valid if both the following conditions are satisfied: word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\"; while invalid words are \"beefed\" (doesn't include \"a\") and \"based\" (includes \"s\" which isn't in the puzzle). Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"] Output: [1,1,3,2,4,0] Explanation: 1 valid word for \"aboveyz\" : \"aaaa\" 1 valid word for \"abrodyz\" : \"aaaa\" 3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\" 2 valid words for \"absoryz\" : \"aaaa\", \"asas\" 4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\" There're no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'. */ class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { int n = int ( puzzles . size ()); unordered_map < int , int > dict ; for ( const string & word : words ) { int mask = 0 ; for ( const char & c : word ) { mask |= ( 1 << ( c - 'a' )); } if ( __builtin_popcount ( mask ) <= 7 ) { dict [ mask ] ++ ; } } vector < int > ans ; for ( const string & puzzle : puzzles ) { int tot = 0 ; for ( int choose = 0 ; choose < ( 1 << 6 ); choose ++ ) { int mask = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( choose & ( 1 << i )) { mask |= ( 1 << ( puzzle [ i + 1 ] - 'a' )); } } mask |= ( 1 << ( puzzle [ 0 ] - 'a' )); tot += dict [ mask ]; } ans . emplace_back ( tot ); } return ans ; } }; 1411. Number of Ways to Paint N \u00d7 3 Grid \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. */ class Solution { public : int numOfWays ( int n ) { int aba = 6 , abc = 6 ; /* aba = aba * 3 + abc * 2 abc = aba * 2 + abc * 2; */ const int MOD = 1000000007 ; for ( int i = 1 ; i < n ; i ++ ) { int new_aba = ( aba * 3ll + abc * 2ll ) % MOD ; int new_abc = ( aba * 2ll + abc * 2ll ) % MOD ; aba = new_aba ; abc = new_abc ; } return ( aba + abc ) % MOD ; } }; 1553. \u5403\u6389 N \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570* \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* \u53a8\u623f\u91cc\u603b\u5171\u6709 n \u4e2a\u6a58\u5b50\uff0c\u4f60\u51b3\u5b9a\u6bcf\u4e00\u5929\u9009\u62e9\u5982\u4e0b\u65b9\u5f0f\u4e4b\u4e00\u5403\u8fd9\u4e9b\u6a58\u5b50\uff1a \u5403\u6389\u4e00\u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 2 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 n/2 \u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 3 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 2*(n/3) \u4e2a\u6a58\u5b50\u3002 \u6bcf\u5929\u4f60\u53ea\u80fd\u4ece\u4ee5\u4e0a 3 \u79cd\u65b9\u6848\u4e2d\u9009\u62e9\u4e00\u79cd\u65b9\u6848\u3002 \u8bf7\u4f60\u8fd4\u56de\u5403\u6389\u6240\u6709 n \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1an = 10 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u4f60\u603b\u5171\u6709 10 \u4e2a\u6a58\u5b50\u3002 \u7b2c 1 \u5929\uff1a\u5403 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 10 - 1 = 9\u3002 \u7b2c 2 \u5929\uff1a\u5403 6 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 9 - 2*(9/3) = 9 - 6 = 3\u3002\uff089 \u53ef\u4ee5\u88ab 3 \u6574\u9664\uff09 \u7b2c 3 \u5929\uff1a\u5403 2 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 3 - 2*(3/3) = 3 - 2 = 1\u3002 \u7b2c 4 \u5929\uff1a\u5403\u6389\u6700\u540e 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 1 - 1 = 0\u3002 \u4f60\u9700\u8981\u81f3\u5c11 4 \u5929\u5403\u6389 10 \u4e2a\u6a58\u5b50\u3002 */ class Solution { public : unordered_map < int , int > dict ; int minDays ( int n ) { if ( n <= 1 ) { return 1 ; } if ( dict . find ( n ) != dict . end ()) { return dict [ n ]; } else { return dict [ n ] = min ( n % 2 + 1 + minDays ( n / 2 ), n % 3 + 1 + minDays ( n / 3 )); } } }; 1585. Check If String Is Transformable With Substring Sort Operations* \u00b6 Given two strings s and t, you want to transform string s into string t using the following operation any number of times: Choose a non-empty substring in s and sort it in-place so the characters are in ascending order. For example, applying the operation on the underlined substring in \"14234\" results in \"12344\". Return true if it is possible to transform string s into string t. Otherwise, return false. A substring is a contiguous sequence of characters within a string. Example: Input: s = \"84532\", t = \"34852\" Output: true Explanation: You can transform s into t using the following sort operations: \"84532\" (from index 2 to 3) -> \"84352\" \"84352\" (from index 0 to 2) -> \"34852\" Input: s = \"34521\", t = \"23415\" Output: true Explanation: You can transform s into t using the following sort operations: \"34521\" -> \"23451\" \"23451\" -> \"23415\" Input: s = \"12345\", t = \"12435\" Output: false Input: s = \"1\", t = \"2\" Output: false Constraints: s.length == t.length 1 <= s.length <= 105 s and t only contain digits from '0' to '9'. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isTransformable ( string s , string t ) { vector < vector < int >> idx ( 10 ); vector < int > count ( 10 ); for ( int i = 0 ; i < int ( s . length ()); i ++ ) { idx [ s [ i ] - '0' ]. push_back ( i ); } for ( int i = 0 ; i < int ( t . length ()); i ++ ) { int digit = t [ i ] - '0' ; if ( count [ digit ] == idx [ digit ]. size ()) { return false ; } for ( int j = 0 ; j < digit ; j ++ ) { if ( count [ j ] != idx [ j ]. size () && idx [ j ][ count [ j ]] < idx [ digit ][ count [ digit ]]) { return false ; } } count [ digit ] ++ ; } return true ; } };","title":"Leetcode"},{"location":"algo/leetcode/#0001-two-sum","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. */ class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { vector < int > res ; int n = int ( nums . size ()); if ( n < 2 ) { return res ; } unordered_map < int , int > M ; unordered_map < int , int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { int diff = target - nums [ i ]; iter = M . find ( diff ); if ( iter != M . end ()) { res . push_back ( i ); res . push_back ( iter -> second ); return res ; } else { M [ nums [ i ]] = i ; } } return res ; } };","title":"0001. Two Sum"},{"location":"algo/leetcode/#0004-median-of-two-sorted-arrays","text":"There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example: nums1 = [1, 3] nums2 = [2] The median is 2.0 nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Solution: This problem requires a time complexity in O(log(m+n)), which determines that we cannot merge sort the twos arrays then get a median value because of o(m+n). A faisible solution is to find k-th value in two sorted arrays based on binary search. \\bigstar \\bigstar Cut two sorted arrays In fact, median is a statistique term, which means a value in middle position. If we want acquire a median value in one sorted array, it is easy to take the value in middlle position. \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad \\begin{matrix} & & & & \\text{cut} & & & & \\\\ & & & & \\Downarrow & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 \\\\ & & & & \\Uparrow & & & & \\\\ & & & & \\text{cut} & & & & \\end{matrix} \\quad \\quad \\quad \\text{or} \\quad \\quad \\quad \\begin{matrix} & & & & & \\text{cut} & & & & & \\\\ & & & & & \\Downarrow & & & & & \\\\ 1 & & 2 & & 3 & & 4 & & 5 & & 6\\\\ & & & & & \\Uparrow & & & & & \\\\ & & & & & \\text{cut} & & & & & \\end{matrix} \\quad For example, the cutting line split an array into two parts with same size, l1 and r1 are left value and right value of cut postion. Left example is odd array, l1 = r1 = 3, while right example is even array, l1 = 3, r1 = 4. Similarly, we can generalize this to two arrays. If we can find such a cut for two arrays that the number of left cut and the number of right cut are equal, we can determine a median value for the 2 arrays. For example, we determine cut position k1, k2 for A, B respectively. \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\begin{matrix} & & & \\text{cut} & & & \\\\ & & & \\Downarrow & & & \\\\ 1 & & 3 & & 5 & & 7\\\\ \\\\ & 2 & & 4 & & 6 \\\\ & & & \\Uparrow & & \\\\ & & & \\text{cut} & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 5} \\\\ \\\\ l_{2} \\text{ = 4, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\Rightarrow \\text{Median} = \\frac{\\max(l_{1}, l_{2}) + \\min(r_{1}, r_{2})}{2} = 4 \\bigstar \\bigstar Unify odd and even number According to traditional way, we have to treat case-by-case: it is different to calculate median value for odd array and even array. In order to conquer this problem, we introuce a virtual placeholder. For example, an original array A is 1 2 3 4 5 and we insert a virtual placeholder # into A, which becomes A' = #1#2#3#4#5#. We see, lenghth of the original array is 5, while length of the new array is 5*2+1. If we cut A' at position 4(5 th character from left). With this method, it's easy to get value in the original. Cut position c = 4 \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} \\begin{aligned} & \\begin{matrix} & & & & \\text{cut} & & & & & \\\\ & & & & \\Downarrow & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & 4 & \\# & 5 & \\# \\\\ & & & & \\Uparrow & & & & & \\\\ & & & & \\text{cut} & & & & & \\end{matrix} \\\\ & l_{1} = A[\\frac{c-1}{2}] = A[1] = 2 \\\\ & r_{1} = A[\\frac{c}{2}] = A[2] = 3 \\end{aligned} If cut position for A' is in first # or last #, it will cause a overflow problem. \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} \\begin{matrix} & & & & & & \\text{cut} & & & & & & \\\\ & & & & & & \\Downarrow & & & & & & \\\\ \\# & 1 & \\# & 2 & \\# & 3 & \\# & & & & & & \\\\ \\\\ & & & & & & \\# & 4 & \\# & 5 & \\# & 6 & \\# \\\\ & & & & & & \\Uparrow & & & & & & \\\\ & & & & & & \\text{cut} & & & & & & \\end{matrix} \\quad \\quad \\begin{matrix} l_{1} \\text{ = 3, } r_{1} \\text{ = 6} \\\\ \\\\ l_{2} \\text{ = 1, } r_{2} \\text{ = 4} \\\\ \\end{matrix} As the example shows, if cut position at first #, left = min(A[0], B[0]), while cut position at last #, right = max(A[-1], B[-1]). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = int ( nums1 . size ()), n2 = int ( nums2 . size ()); if ( n1 == 0 ) { return ( nums2 [( n2 - 1 ) / 2 ] + nums2 [ n2 / 2 ]) / 2.0 ; } if ( n2 == 0 ) { return ( nums1 [( n1 - 1 ) / 2 ] + nums1 [ n1 / 2 ]) / 2.0 ; } int MAX = nums1 [ n1 - 1 ] > nums2 [ n2 - 1 ] ? nums1 [ n1 - 1 ] : nums2 [ n2 - 1 ]; int MIN = nums1 [ 0 ] < nums2 [ 0 ] ? nums1 [ 0 ] : nums2 [ 0 ]; if ( n1 < n2 ) { return findK ( nums1 , nums2 , 0 , 2 * n1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums2 , nums1 , 0 , 2 * n2 , n2 , n1 , MAX , MIN ); } } double findK ( vector < int > nums1 , vector < int > nums2 , int b , int e , int n1 , int n2 , int MAX , int MIN ) { int l1 = 0 , l2 = 0 , r1 = 0 , r2 = 0 ; int k1 = ( b + e ) / 2 , k2 = ( n1 + n2 - k1 ); if ( k1 == 0 ) { l1 = MIN ; r1 = nums1 [ 0 ]; } else if ( k1 >= 2 * n1 ) { l1 = nums1 [ n1 - 1 ]; r1 = MAX ; } else { l1 = nums1 [( k1 - 1 ) / 2 ]; r1 = nums1 [ k1 / 2 ]; } if ( k2 == 0 ) { l2 = MIN ; r2 = nums2 [ 0 ]; } else if ( k2 >= 2 * n2 ) { l2 = nums2 [ n2 - 1 ]; r2 = MAX ; } else { l2 = nums2 [( k2 - 1 ) / 2 ]; r2 = nums2 [ k2 / 2 ]; } if ( l1 <= r2 && l2 <= r1 ) { return (( l1 > l2 ? l1 : l2 ) + ( r1 < r2 ? r1 : r2 )) / 2.0 ; } else if ( l1 > r2 ) { return findK ( nums1 , nums2 , b , k1 - 1 , n1 , n2 , MAX , MIN ); } else { return findK ( nums1 , nums2 , k1 + 1 , e , n1 , n2 , MAX , MIN ); } } };","title":"0004. Median of Two Sorted Arrays*"},{"location":"algo/leetcode/#0005-longest-palindromic-substring","text":"Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\" Output: \"bb\" Solution: Dynamic programming: We construct a table, such that table[i][j] represent a substring fron s[i] to s[j] is palindromic or not. Note that, each single character is palindromic, namely table[i][i] is true. We also assignment table[i][i+1] = true if two adjacent characters are same. Then we visit other substirngs to find the longest one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : string longestPalindrome ( string s ) { int n = int ( s . length ()), pos = 0 , len = 1 ; if ( n < 2 ) { return s ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; pos = i ; len = 2 ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { pos = i ; len = k + 1 ; dp [ i ][ j ] = true ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return s . substr ( pos , len ); } };","title":"0005. Longest Palindromic Substring*"},{"location":"algo/leetcode/#0006-zigzag-conversion","text":"The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : string convert ( string s , int numRows ) { int n = int ( s . length ()); if ( n == 0 || numRows < 2 ) { return s ; } string res = \"\" ; int nRow = numRows , num = 2 * numRows - 2 ; int nCol = ( n / num ) * ( num - nRow + 1 ); if ( n % num < nRow ) { nCol ++ ; } else { nCol += ( n % num ) - nRow + 1 ; } char * mat = new char [ nRow * nCol ]{}; for ( int k = 0 ; k < n ; k ++ ) { int quo = k / num , mod = k % num ; int i = - 1 , j = quo * ( num - nRow + 1 ); if ( mod < nRow ) { i = mod ; } else { i = nRow - 2 - ( mod - nRow ); j += mod - nRow + 1 ; } mat [ i * nCol + j ] = s [ k ]; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( mat [ i * nCol + j ]) { res . push_back ( mat [ i * nCol + j ]); } } } delete [] mat ; return res ; } };","title":"0006. ZigZag Conversion"},{"location":"algo/leetcode/#0007","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* \u7ed9\u4f60\u4e00\u4e2a 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570 x \uff0c\u8fd4\u56de\u5c06 x \u4e2d\u7684\u6570\u5b57\u90e8\u5206\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\u3002 \u5982\u679c\u53cd\u8f6c\u540e\u6574\u6570\u8d85\u8fc7 32 \u4f4d\u7684\u6709\u7b26\u53f7\u6574\u6570\u7684\u8303\u56f4 [\u2212231, 231 \u2212 1] \uff0c\u5c31\u8fd4\u56de 0\u3002 \u5047\u8bbe\u73af\u5883\u4e0d\u5141\u8bb8\u5b58\u50a8 64 \u4f4d\u6574\u6570\uff08\u6709\u7b26\u53f7\u6216\u65e0\u7b26\u53f7\uff09\u3002 \u8f93\u5165\uff1ax = 123 \u8f93\u51fa\uff1a321 \u8f93\u5165\uff1ax = -123 \u8f93\u51fa\uff1a-321 \u8f93\u5165\uff1ax = 120 \u8f93\u51fa\uff1a21 \u8f93\u5165\uff1ax = 0 \u8f93\u51fa\uff1a0 */ class Solution { public : int reverse ( int x ) { int ans = 0 ; if ( x == INT_MIN ) { return 0 ; } while ( x ) { if ( ans > INT_MAX / 10 || ans < INT_MIN / 10 ) { return 0 ; } ans = ans * 10 + ( x % 10 ); x /= 10 ; } return ans ; } };","title":"0007. \u6574\u6570\u53cd\u8f6c"},{"location":"algo/leetcode/#0008-string-to-integer-atoi","text":"Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [ -2^{31} -2^{31} , 2^{31} 2^{31} \u22121]. If the numerical value is out of the range of representable values, INT_MAX ( 2^{31} 2^{31} \u2212 1) or INT_MIN (- 2^{31} 2^{31} ) is returned. Example: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a \u00b1 sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (\u2212 2^{31} 2^{31} ) is returned. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int myAtoi ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } bool isNeg = false ; long res = 0 ; int pos = 0 ; while ( s [ pos ] == ' ' ) { pos ++ ; } if ( s [ pos ] == '-' ) { isNeg = true ; } else if ( s [ pos ] == '+' ) { isNeg = false ; } else if ( s [ pos ] >= '0' && s [ pos ] <= '9' ) { res += s [ pos ] - '0' ; } else { return 0 ; } for ( ++ pos ; pos < n ; pos ++ ) { if ( s [ pos ] < '0' || s [ pos ] > '9' ) { break ; } res = res * 10 + s [ pos ] - '0' ; if ( res >= ( 1ll << 31 )) { if ( isNeg ) { return - ( 1ll << 31 ); } else { return ( 1ll << 31 ) - 1 ; } } } if ( isNeg ) { return - res ; } return res ; } };","title":"0008. String to Integer (atoi)"},{"location":"algo/leetcode/#0010-regular-expression-matching","text":"Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"a \" Output: true Explanation: ' ' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\" p = \". \" Output: true Explanation: \". \" means \"zero or more (*) of any character (.)\". Example: 4 Input: s = \"aab\" p = \"c a b\" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\". Example 5: Input: s = \"mississippi\" p = \"mis is p*.\" Output: false Solution: Consider two string s, p. i, j denote some position in s and p. We use dynamic programming with a matrix dp (ns+1) \\times (np+1) (ns+1) \\times (np+1) . ns and np are length of s and p. dp[i][j] denote if s[i:] and p[j:] match. The last entry dp[ns][np] is true. because '' and '' match. Firstly, we check if s[i] and p[j] match ij_match is false or true. Secondly, if p[j+1] is , dp[i][j] has two independent sources: dp[i][j+2] and dp[i+1][j]. In detail, dp[i][j+2] represents we jump over * to check dp[i][j+2]. Similarly, dp[i+1][j] influences dp[i][j] but we have to consider ij_match. Both ij_match and dp[i+1][j] are true, dp[i][j] is true. Otherwise, p[j+1] is not , dp[i][j] is dependent of ij_match and dp[i+1][j+1]. Finally, return dp[0][0] Remark: why we don't consider ij_match for dp[i][j+2]? Because we jump over *. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); bool ** dp = new bool * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new bool [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMatch = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '.' ); if ( j < np - 1 && p [ j + 1 ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( ijMatch && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMatch && dp [ i + 1 ][ j + 1 ]; } } } int res = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return res ; } };","title":"0010. Regular Expression Matching*"},{"location":"algo/leetcode/#0011-container-with-most-water","text":"Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 Solution: Brutal force cause Time Limit Exceeded. We use two points method. 1) Firstly, we set two extremities as initial values. 2) Then we move the shorter side towards the longer side one step, e.g. moving 1 towards 7. 3) We repeat 2) until two side are adjacent. During this process, we calculate the max area. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. */ class Solution { public : int maxArea ( vector < int >& height ) { int n = int ( height . size ()); if ( n < 2 ) { return 0 ; } int i = 0 , j = n - 1 , res = 0 ; while ( i < j ) { int a = height [ i ], b = height [ j ]; int B = a < b ? a : b , H = j - i ; if ( B * H > res ) { res = B * H ; } if ( a < b ) { i ++ ; } else { j -- ; } } return res ; } };","title":"0011. Container With Most Water*"},{"location":"algo/leetcode/#0014-longest-common-prefix","text":"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { int n = int ( strs . size ()); if ( n == 0 ) { return \"\" ; } string str = \"\" ; for ( int j = 0 ; j < int ( strs [ 0 ]. length ()); j ++ ) { char flag = strs [ 0 ][ j ]; for ( int i = 1 ; i < n ; i ++ ) { if ( strs [ i ][ j ] != flag ) { return str ; } } str . push_back ( flag ); } return str ; } };","title":"0014. Longest Common Prefix"},{"location":"algo/leetcode/#0018-4sum","text":"Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] */ class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < vector < int >> res ; if ( n < 4 ) { return res ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { int b = j + 1 , e = n - 1 ; while ( b < e ) { int sum = nums [ i ] + nums [ j ] + nums [ b ] + nums [ e ]; if ( sum < target ) { b ++ ; } else if ( sum > target ) { e -- ; } else { while ( i < n - 3 && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < n - 2 && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( b < e && nums [ b ] == nums [ b + 1 ]) { b ++ ; } while ( b < e && nums [ e ] == nums [ e - 1 ]) { e -- ; } vector < int > arr ; arr . push_back ( nums [ i ]); arr . push_back ( nums [ j ]); arr . push_back ( nums [ b ]); arr . push_back ( nums [ e ]); res . push_back ( arr ); b ++ ; e -- ; } } } } return res ; } };","title":"0018. 4Sum"},{"location":"algo/leetcode/#0019-remove-nth-node-from-end-of-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. */ // Two pointers class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { if ( n < 1 || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 , head ); ListNode * p1 = pre , * p2 = head , * p3 = head ; while ( n -- ) { if ( p3 == nullptr ) { return head ; } p3 = p3 -> next ; } while ( p3 != nullptr ) { p3 = p3 -> next ; p2 = p2 -> next ; p1 = p1 -> next ; } p1 -> next = p2 -> next ; delete p2 ; head = pre -> next ; delete pre ; return head ; } };","title":"0019. Remove Nth Node From End of List*"},{"location":"algo/leetcode/#0020-valid-parentheses","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: s = \"()\" Output: true Input: s = \"()[]{}\" Output: true Input: s = \"(]\" Output: false Input: s = \"([)]\" Output: false Input: s = \"{[]}\" Output: true */ class Solution { public : bool isValid ( string s ) { int n = int ( s . length ()); stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '[' || s [ i ] == '{' || s [ i ] == '(' ) { st . push ( s [ i ]); } else if (( s [ i ] == ')' && ! st . empty () && st . top () == '(' ) || ( s [ i ] == ']' && ! st . empty () && st . top () == '[' ) || ( s [ i ] == '}' && ! st . empty () && st . top () == '{' )) { st . pop (); } else { return false ; } } return st . empty (); } };","title":"0020. Valid Parentheses"},{"location":"algo/leetcode/#0021-merge-two-sorted-lists","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 */ class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( l1 == nullptr ) { return l2 ; } if ( l2 == nullptr ) { return l1 ; } ListNode * head = new ListNode ( 0 ); ListNode * curNode = head ; while ( l1 != nullptr && l2 != nullptr ) { if ( l1 -> val < l2 -> val ) { curNode -> next = l1 ; l1 = l1 -> next ; } else { curNode -> next = l2 ; l2 = l2 -> next ; } curNode = curNode -> next ; } if ( l1 != nullptr ) { curNode -> next = l1 ; } if ( l2 != nullptr ) { curNode -> next = l2 ; } curNode = head -> next ; delete head ; return curNode ; } };","title":"0021. Merge Two Sorted Lists"},{"location":"algo/leetcode/#0022-generate-parentheses","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] */ class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > res ; if ( n == 0 ) { return res ; } string str = \"\" ; append ( res , str , n , 0 , 0 , 0 ); return res ; } void append ( vector < string > & res , string str , int n , int idx , int nLeft , int nRight ) { if ( idx == 2 * n ) { if ( nRight == nLeft ) { res . push_back ( str ); } return ; } if ( nLeft >= nRight && nLeft < n ) { append ( res , str + '(' , n , idx + 1 , nLeft + 1 , nRight ); } append ( res , str + ')' , n , idx + 1 , nLeft , nRight + 1 ); } };","title":"0022. Generate Parentheses"},{"location":"algo/leetcode/#0023-merge-k-sorted-lists","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { int n = int ( lists . size ()); if ( n == 0 ) { return nullptr ; } ListNode * pre = new ListNode ( 0 ), * head = pre , * cur = pre ; while ( true ) { int idx = - 1 , min = ( 1ll << 31 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( lists [ i ] == nullptr ) { continue ; } if ( lists [ i ] -> val < min ) { idx = i ; min = lists [ i ] -> val ; } } if ( idx == - 1 ) { break ; } cur -> next = lists [ idx ]; lists [ idx ] = lists [ idx ] -> next ; cur = cur -> next ; } head = pre -> next ; delete pre ; return head ; } };","title":"0023. Merge k Sorted Lists"},{"location":"algo/leetcode/#0024-swap-nodes-in-pairs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Given 1->2->3->4, you should return the list as 2->1->4->3. */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); ListNode * par = head , * son = head -> next , * gra = pre ; pre -> next = head ; while ( son != nullptr ) { par -> next = son -> next ; son -> next = par ; gra -> next = son ; gra = par ; par = par -> next ; if ( par == nullptr ) { break ; } son = par -> next ; } head = pre -> next ; delete pre ; return head ; } };","title":"0024. Swap Nodes in Pairs"},{"location":"algo/leetcode/#0025-reverse-nodes-in-k-group","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k < 2 ) { return head ; } ListNode * front = head ; for ( int i = 0 ; i < k ; i ++ ) { if ( front == nullptr ) { return head ; } front = front -> next ; } bool isEnd = false ; ListNode * pre = new ListNode ( 0 , head ); ListNode * gra = pre , * par = head , * son = head -> next ; while ( true ) { ListNode * temp = front , * p1 = gra , * p2 = par , * p3 = son ; while ( p2 != temp ) { if ( front == nullptr ) { isEnd = true ; } else { front = front -> next ; } p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { break ; } p3 = p3 -> next ; } par -> next = p2 ; gra -> next = p1 ; gra = par ; par = p2 ; son = p3 ; if ( isEnd || p3 == nullptr ) { break ; } } head = pre -> next ; delete pre ; return head ; } };","title":"0025. Reverse Nodes in k-Group"},{"location":"algo/leetcode/#0026-remove-duplicates-from-sorted-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Given nums = [0,0,1,1,1,2,2,3,3,4] Your function should return length = 5 */ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 2 ) { return n ; } int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { continue ; } nums [ len ++ ] = nums [ i ]; } return len ; } };","title":"0026. Remove Duplicates from Sorted Array"},{"location":"algo/leetcode/#0027-remove-element","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, */ class Solution { public : int removeElement ( vector < int >& nums , int val ) { int n = int ( nums . size ()), len = 0 ; if ( n == 0 ) { return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] != val ) { nums [ len ++ ] = nums [ i ]; } } return len ; } };","title":"0027. Remove Element"},{"location":"algo/leetcode/#0028-implement-strstr","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: haystack = \"hello\", needle = \"ll\" Output: 2 */ class Solution { public : int strStr ( string haystack , string needle ) { string T = haystack , P = needle ; int nT = int ( T . length ()), nP = int ( P . length ()); if ( nP == 0 ) { return 0 ; } if ( nT == 0 ) { return - 1 ; } int * next = new int [ nP ]{}; int i = 0 , j = 0 , t = next [ 0 ] = - 1 , k = 0 ; while ( k < nP - 1 ) { if ( t < 0 || P [ t ] == P [ k ]) { next [ ++ k ] = ++ t ; } else { t = next [ t ]; } } while ( i < nT && j < nP ) { if ( j < 0 || T [ i ] == P [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } delete [] next ; if ( i - j <= nT - nP ) { return i - j ; } else { return - 1 ; } } };","title":"0028. Implement strStr()*"},{"location":"algo/leetcode/#0029-divide-two-integers","text":"Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = truncate(3.33333..) = 3. Example 2: Input: dividend = 7, divisor = -3 Output: -2 Explanation: 7/-3 = truncate(-2.33333..) = -2. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int divide ( int dividend , int divisor ) { int MAX = ( 1ll << 31 ) - 1 ; long m = abs ( long ( dividend )), n = abs ( long ( divisor )), quo = 0 ; while ( m >= n ) { long s = n , incre = 1 ; while (( s << 1 ) <= m ) { s <<= 1 ; incre <<= 1 ; } quo += incre ; m -= s ; } if (( dividend < 0 ) ^ ( divisor < 0 )) { quo *= - 1 ; } return quo > MAX ? MAX : int ( quo ); } };","title":"0029. Divide Two Integers*"},{"location":"algo/leetcode/#0030-substring-with-concatenation-of-all-words","text":"You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order. Example: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"] Output: [6,9,12] Constraints: 1 <= s.length <= 10^{4} 10^{4} s consists of lower-case English letters. 1 <= words.length <= 5000 1 <= words[i].length <= 30 words[i] consists of lower-case English letters. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { vector < int > res ; int n = int ( words . size ()), sLen = int ( s . length ()); if ( n == 0 || n * words [ 0 ]. length () > sLen ) { return res ; } sort ( words . begin (), words . end ()); int i = 0 , wordLen = int ( words [ 0 ]. length ()), wordsLen = n * wordLen ; while ( i + wordsLen <= sLen ) { string subStr = s . substr ( i , wordsLen ); vector < string > tmp ; for ( int j = 0 ; j < wordsLen ; j += wordLen ) { tmp . push_back ( subStr . substr ( j , wordLen )); } sort ( tmp . begin (), tmp . end ()); bool isOk = true ; for ( int k = 0 ; k < n ; k ++ ) { if ( tmp [ k ] != words [ k ]) { isOk = false ; break ; } } if ( isOk ) { res . push_back ( i ); } i ++ ; } return res ; } };","title":"0030. Substring with Concatenation of All Words*"},{"location":"algo/leetcode/#0031-next-permutation","text":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. Example: 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1 Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = int ( nums . size ()), idx = - 1 ; if ( n < 2 ) { return ; } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( nums [ i - 1 ] < nums [ i ]) { idx = i - 1 ; break ; } } if ( idx == - 1 ) { sort ( nums . begin (), nums . end ()); return ; } for ( int i = n - 1 ; i > idx ; i -- ) { if ( nums [ i ] > nums [ idx ]) { swap ( nums [ i ], nums [ idx ]); sort ( nums . begin () + idx + 1 , nums . end ()); return ; } } } };","title":"0031. Next Permutation*"},{"location":"algo/leetcode/#0032-longest-valid-parentheses","text":"Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int longestValidParentheses ( string s ) { int maxLen = 0 , n = int ( s . length ()), leftCount = 0 ; if ( n < 2 ) { return maxLen ; } int * dp = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { if ( leftCount == 0 && s [ i ] == ')' ) { continue ; } if ( s [ i ] == '(' ) { leftCount ++ ; } else { leftCount -- ; dp [ i ] = dp [ i - 1 ] + 1 ; if ( i - dp [ i ] * 2 >= 0 ) { dp [ i ] += dp [ i - dp [ i ] * 2 ]; } } maxLen = maxLen > dp [ i ] ? maxLen : dp [ i ]; } delete [] dp ; return maxLen * 2 ; } };","title":"0032. Longest Valid Parentheses*"},{"location":"algo/leetcode/#0034-find-first-and-last-position-of-element-in-sorted-array","text":"Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. Follow up: Could you write an algorithm with O(log n) runtime complexity? Example: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Input: nums = [], target = 0 Output: [-1,-1] Constraints: 0 <= nums.length <= 10^{5} 10^{5} - 10^{9} 10^{9} <= nums[i] <= 10^{9} 10^{9} nums is a non-decreasing array. - 10^{9} 10^{9} <= target <= 10^{9} 10^{9} Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int n = int ( nums . size ()); vector < int > res ; res . push_back ( - 1 ); res . push_back ( - 1 ); if ( n < 1 ) { return res ; } res [ 0 ] = binSearFir ( nums , target , 0 , n - 1 ); res [ 1 ] = binSearSec ( nums , target , 0 , n ); return res ; } int binSearFir ( vector < int > & nums , int target , int b , int e ) { if ( b == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] < target ) { return binSearFir ( nums , target , m + 1 , e ); } else { return binSearFir ( nums , target , b , m ); } } int binSearSec ( vector < int > & nums , int target , int b , int e ) { if ( b + 1 == e ) { if ( nums [ b ] == target ) { return b ; } else { return - 1 ; } } int m = ( b + e ) / 2 ; if ( nums [ m ] <= target ) { return binSearSec ( nums , target , m , e ); } else { return binSearSec ( nums , target , b , m ); } } };","title":"0034. Find First and Last Position of Element in Sorted Array"},{"location":"algo/leetcode/#0035","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* \u7ed9\u5b9a\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4\u548c\u4e00\u4e2a\u76ee\u6807\u503c\uff0c\u5728\u6570\u7ec4\u4e2d\u627e\u5230\u76ee\u6807\u503c\uff0c\u5e76\u8fd4\u56de\u5176\u7d22\u5f15\u3002 \u5982\u679c\u76ee\u6807\u503c\u4e0d\u5b58\u5728\u4e8e\u6570\u7ec4\u4e2d\uff0c\u8fd4\u56de\u5b83\u5c06\u4f1a\u88ab\u6309\u987a\u5e8f\u63d2\u5165\u7684\u4f4d\u7f6e\u3002 \u4f60\u53ef\u4ee5\u5047\u8bbe\u6570\u7ec4\u4e2d\u65e0\u91cd\u590d\u5143\u7d20\u3002 \u793a\u4f8b 1: \u8f93\u5165: [1,3,5,6], 5 \u8f93\u51fa: 2 \u793a\u4f8b 2: \u8f93\u5165: [1,3,5,6], 2 \u8f93\u51fa: 1 \u793a\u4f8b 3: \u8f93\u5165: [1,3,5,6], 7 \u8f93\u51fa: 4 */ class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 , r = ( int ) nums . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m ; } } return l ; } };","title":"0035. \u641c\u7d22\u63d2\u5165\u4f4d\u7f6e"},{"location":"algo/leetcode/#0036-valid-sudoku","text":"Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\\\ 6 & . & . & 1 & 9 & 5 & . & . & . \\\\ . & 9 & 8 & . & . & . & . & 6 & . \\\\ 8 & . & . & . & 6 & . & . & . & 3 \\\\ 4 & . & . & 8 & . & 3 & . & . & 1 \\\\ 7 & . & . & . & 2 & . & . & . & 6 \\\\ . & 6 & . & . & . & . & 2 & 8 & . \\\\ . & . & . & 4 & 1 & 9 & . & . & 5 \\\\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { continue ; } if ( ! isValidForij ( board , i , j )) { return false ; } } } return true ; } bool isValidForij ( vector < vector < char >> board , int i , int j ) { int dupRow = 0 , dupCol = 0 ; for ( int k = 0 ; k < 9 ; k ++ ) { if ( board [ k ][ j ] == board [ i ][ j ]) { dupRow ++ ; } if ( board [ i ][ k ] == board [ i ][ j ]) { dupCol ++ ; } } if ( dupRow > 1 || dupCol > 1 ) { return false ; } int m = i / 3 , n = j / 3 , dupSubBox = 0 ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 3 ; y ++ ) { if ( board [ m * 3 + x ][ n * 3 + y ] == board [ i ][ j ]) { dupSubBox ++ ; } } } if ( dupSubBox > 1 ) { return false ; } return true ; } };","title":"0036. Valid Sudoku*"},{"location":"algo/leetcode/#0037-sudoku-solver","text":"Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells. $$ \\begin{bmatrix} 5 & 3 & . & . & 7 & . & . & . & . \\ 6 & . & . & 1 & 9 & 5 & . & . & . \\ . & 9 & 8 & . & . & . & . & 6 & . \\ 8 & . & . & . & 6 & . & . & . & 3 \\ 4 & . & . & 8 & . & 3 & . & . & 1 \\ 7 & . & . & . & 2 & . & . & . & 6 \\ . & 6 & . & . & . & . & 2 & 8 & . \\ . & . & . & 4 & 1 & 9 & . & . & 5 \\ . & . & . & . & 8 & . & . & 7 & 9 \\end{bmatrix} \\Rightarrow \\begin{bmatrix} 5 & 3 & {\\color{Red} 4} & {\\color{Red} 6} & 7 & {\\color{Red} 8} & {\\color{Red} 9} & {\\color{Red} 1} & {\\color{Red} 2} \\ 6 & {\\color{Red} 7} & {\\color{Red} 2} & 1 & 9 & 5 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 8} \\ {\\color{Red} 1} & 9 & 8 & {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 2} & {\\color{Red} 5} & 6 & {\\color{Red} 7} \\ 8 & {\\color{Red} 5} & {\\color{Red} 9} & {\\color{Red} 7} & 6 & {\\color{Red} 1} & {\\color{Red} 4} & {\\color{Red} 2} & 3 \\ 4 & {\\color{Red} 2} & {\\color{Red} 6} & 8 & {\\color{Red} 5} & 3 & {\\color{Red} 7} & {\\color{Red} 9} & 1 \\ 7 & {\\color{Red} 1} & {\\color{Red} 3} & {\\color{Red} 9} & 2 & {\\color{Red} 4} & {\\color{Red} 8} & {\\color{Red} 5} & 6 \\ {\\color{Red} 9} & 6 & {\\color{Red} 1} & {\\color{Red} 5} & {\\color{Red} 3} & {\\color{Red} 7} & 2 & 8 & {\\color{Red} 4} \\ {\\color{Red} 2} & {\\color{Red} 8} & {\\color{Red} 7} & 4 & 1 & 9 & {\\color{Red} 6} & {\\color{Red} 3} & 5 \\ {\\color{Red} 3} & {\\color{Red} 4} & {\\color{Red} 5} & {\\color{Red} 2} & 8 & {\\color{Red} 6} & {\\color{Red} 1} & 7 & 9 \\end{bmatrix} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { isSolver ( board ); } bool isSolver ( vector < vector < char >> & board ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] == '.' ) { for ( char c = '1' ; c <= '9' ; c ++ ) { if ( isFeasible ( board , i , j , c )) { board [ i ][ j ] = c ; if ( isSolver ( board )) { return true ; } else { board [ i ][ j ] = '.' ; } } } // No feasible number return false ; } } } return true ; } bool isFeasible ( vector < vector < char >> board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ row ][ i ] == c ) { return false ; } if ( board [ i ][ col ] == c ) { return false ; } if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) { return false ; } } return true ; } };","title":"0037. Sudoku Solver*"},{"location":"algo/leetcode/#0038-count-and-say","text":"The count-and-say sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = \"1\" countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you \"say\" a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying. Example: Input: n = 1 Output: \"1\" Explanation: This is the base case. Input: n = 4 Output: \"1211\" Explanation: countAndSay(1) = \"1\" countAndSay(2) = say \"1\" = one 1 = \"11\" countAndSay(3) = say \"11\" = two 1's = \"21\" countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" Constraints: 1 <= n <= 30 Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string countAndSay ( int n ) { string res = \"1\" ; if ( n == 1 ) { return res ; } for ( int i = 2 ; i <= n ; i ++ ) { string cur = \"\" ; res . push_back ( '0' ); int len = int ( res . length ()), count = 1 ; char ch = res [ 0 ]; for ( int i = 1 ; i < len ; i ++ ) { if ( res [ i ] == res [ i - 1 ]) { count ++ ; } else { cur += to_string ( count ); cur . push_back ( ch ); count = 1 ; ch = res [ i ]; } } res = cur ; } return res ; } };","title":"0038. Count and Say"},{"location":"algo/leetcode/#0041-first-missing-positive","text":"Given an unsorted integer array, find the smallest missing positive integer. Example: Input: [1,2,0] Output: 3 Input: [3,4,-1,1] Output: 2 Input: [7,8,9,11,12] Output: 1 Follow up: Your algorithm should run in O(n) time and uses constant extra space. Solution: \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} \\begin{matrix} 3 & 4 & -1 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & 5 & 1 \\\\ & & \\Downarrow & \\\\ 3 & 4 & -5 & 1 \\\\ 3 & 4 & -5 & -1 \\\\ -3 & 4 & -5 & -1 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { int n = int ( nums . size ()); for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] <= 0 ) { nums [ i ] = n + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { int num = abs ( nums [ i ]); if ( num <= n ) { nums [ num - 1 ] = - abs ( nums [ num - 1 ]); } } for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] > 0 ) { return i + 1 ; } } return n + 1 ; } };","title":"0041. First Missing Positive*"},{"location":"algo/leetcode/#0042-trapping-rain-water","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. */ class Solution { public : int trap ( vector < int >& height ) { int ans = 0 , n = int ( height . size ()); if ( n < 3 ) { return ans ; } int i = 0 , j = n - 1 ; int leftMax = 0 , rightMax = 0 ; while ( i < j ) { if ( height [ i ] < height [ j ]) { if ( height [ i ] >= leftMax ) { leftMax = height [ i ]; } else { ans += leftMax - height [ i ]; } i ++ ; } else { if ( height [ j ] >= rightMax ) { rightMax = height [ j ]; } else { ans += rightMax - height [ j ]; } j -- ; } } return ans ; } };","title":"0042. Trapping Rain Water*"},{"location":"algo/leetcode/#0043-multiply-strings","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /* Input: num1 = \"123\", num2 = \"456\" Output: \"56088\" */ class Solution { public : string multiply ( string num1 , string num2 ) { string ans = \"\" ; if ( num1 == \"0\" || num2 == \"0\" ) { return \"0\" ; } int n2 = int ( num2 . length ()); for ( int j = n2 - 1 ; j >= 0 ; j -- ) { string str = strMultiChar ( num1 , num2 [ j ]); str . insert ( str . length (), n2 - 1 - j , '0' ); ans = strAdd ( ans , str ); } return ans ; } string strAdd ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); if ( n1 < n2 ) { swap ( s1 , s2 ); swap ( n1 , n2 ); } string ans = \"\" ; int i = n1 - 1 , j = n2 - 1 , add1 = 0 ; while ( i >= 0 && j >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + ( s2 [ j -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } while ( i >= 0 ) { int sum = ( s1 [ i -- ] - '0' ) + add1 ; add1 = 0 ; if ( sum > 9 ) { sum -= 10 ; add1 = 1 ; } char insertChar = '0' + sum ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans . insert ( 0 , 1 , '1' ); } return ans ; } string strMultiChar ( string str , char c ) { string ans = \"\" ; int n = int ( str . length ()), add1 = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int res = ( str [ i ] - '0' ) * ( c - '0' ) + add1 ; add1 = 0 ; if ( res > 9 ) { add1 = res / 10 ; res = res % 10 ; } char insertChar = '0' + res ; ans . insert ( 0 , 1 , insertChar ); } if ( add1 ) { ans = to_string ( add1 ) + ans ; } return ans ; } };","title":"0043. Multiply Strings"},{"location":"algo/leetcode/#0044-wildcard-matching","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Input: s = \"adceb\", p = \"*a*b\" Output: true */ class Solution { public : bool isMatch ( string s , string p ) { int ns = int ( s . length ()), np = int ( p . length ()); int ** dp = new int * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new int [ np + 1 ]{}; } dp [ ns ][ np ] = true ; for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = np - 1 ; j >= 0 ; j -- ) { bool ijMat = i < ns && ( s [ i ] == p [ j ] || p [ j ] == '?' || p [ j ] == '*' ); if ( p [ j ] == '*' ) { dp [ i ][ j ] = dp [ i ][ j + 1 ] || ( ijMat && dp [ i + 1 ][ j ]); } else { dp [ i ][ j ] = ijMat && dp [ i + 1 ][ j + 1 ]; } } } bool ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0044. Wildcard Matching"},{"location":"algo/leetcode/#0048-rotate-image","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 1 2 3 7 4 1 4 5 6 -> 8 5 2 7 8 9 9 6 3 */ class Solution { public : void rotate ( vector < vector < int >>& matrix ) { int n = int ( matrix . size ()); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - 1 - i ; j ++ ) { int b = i , e = n - 1 - i ; int first = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ b + e - j ][ b ]; matrix [ b + e - j ][ b ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ b + j - i ][ e ]; matrix [ b + j - i ][ e ] = first ; } } } };","title":"0048. Rotate Image"},{"location":"algo/leetcode/#0049-group-anagrams","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] */ class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; int n = int ( strs . size ()); if ( n == 0 ) { return ans ; } unordered_map < string , vector < string >> dict ; for ( string & str : strs ) { string tmp = str ; sort ( tmp . begin (), tmp . end ()); dict [ tmp ]. emplace_back ( str ); } unordered_map < string , vector < string >>:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { ans . emplace_back ( iter -> second ); } return ans ; } };","title":"0049. Group Anagrams"},{"location":"algo/leetcode/#0050-powx-n","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 */ class Solution { public : double myPow ( double x , int n ) { double ans = 1.0 , tmp = x ; bool isNeg = false ; long pow = n ; if ( n < 0 ) { pow = - pow ; isNeg = true ; } long k = 1 ; while ( pow > 0 ) { if ( pow == 1 ) { ans *= x ; break ; } tmp *= tmp ; k *= 2 ; if ( k * 2 > pow ) { ans *= tmp ; tmp = x ; pow = pow - k ; k = 1 ; } } if ( isNeg ) { return 1 / ans ; } return ans ; } };","title":"0050. Pow(x, n)"},{"location":"algo/leetcode/#0051-n-queens","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: n = 4 Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"], [\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] */ class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; string str = \"\" ; for ( int i = 0 ; i < n ; i ++ ) { str += \".\" ; } vector < string > res ( n , str ); unordered_set < int > col , diag1 , diag2 ; DFS ( col , diag1 , diag2 , n , 0 , ans , res ); return ans ; } void DFS ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int n , int i , vector < vector < string >> & ans , vector < string > & res ) { if ( i == n ) { ans . emplace_back ( res ); return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkPos ( col , diag1 , diag2 , i , j )) { res [ i ][ j ] = 'Q' ; col . insert ( j ); diag1 . insert ( i - j ); diag2 . insert ( i + j ); DFS ( col , diag1 , diag2 , n , i + 1 , ans , res ); res [ i ][ j ] = '.' ; col . erase ( j ); diag1 . erase ( i - j ); diag2 . erase ( i + j ); } } } bool isOkPos ( unordered_set < int > & col , unordered_set < int > & diag1 , unordered_set < int > & diag2 , int i , int j ) { if ( col . find ( j ) != col . end () || diag1 . find ( i - j ) != diag1 . end () || diag2 . find ( i + j ) != diag2 . end ()) { return false ; } return true ; } };","title":"0051. N-Queens"},{"location":"algo/leetcode/#0052-n-queens-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* Input: n = 4 Output: 2 */ class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; unordered_set < int > col , dg1 , dg2 ; DFS ( col , dg1 , dg2 , 0 , n , ans ); return ans ; } void DFS ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int n , int & ans ) { if ( i == n ) { ans ++ ; return ; } for ( int j = 0 ; j < n ; j ++ ) { if ( isOkQueenPos ( col , dg1 , dg2 , i , j )) { col . insert ( j ); dg1 . insert ( i - j ); dg2 . insert ( i + j ); DFS ( col , dg1 , dg2 , i + 1 , n , ans ); col . erase ( j ); dg1 . erase ( i - j ); dg2 . erase ( i + j ); } } } bool isOkQueenPos ( unordered_set < int > col , unordered_set < int > dg1 , unordered_set < int > dg2 , int i , int j ) { if ( col . find ( j ) != col . end () || dg1 . find ( i - j ) != dg1 . end () || dg2 . find ( i + j ) != dg2 . end ()) { return false ; } return true ; } };","title":"0052. N-Queens II"},{"location":"algo/leetcode/#0054-spiral-matrix","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* 1 -> 2 -> 3 | v 4 -> 5 6 ^ | | v 7 <- 8 <- 9 */ class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { vector < int > ans ; int m = int ( matrix . size ()); if ( m == 0 ) { return ans ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return ans ; } bool * vis = new bool [ m * n ]{}; int i = 0 , j = 0 ; while ( true ) { bool updated = false ; while ( true ) { if ( j >= n || vis [ i * n + j ]) { j -- ; i ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j ++ ; } while ( true ) { if ( i >= m || vis [ i * n + j ]) { i -- ; j -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i ++ ; } while ( true ) { if ( j < 0 || vis [ i * n + j ]) { j ++ ; i -- ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; j -- ; } while ( true ) { if ( i < 0 || vis [ i * n + j ]) { i ++ ; j ++ ; break ; } ans . emplace_back ( matrix [ i ][ j ]); vis [ i * n + j ] = true ; updated = true ; i -- ; } if ( ! updated ) { break ; } } delete [] vis ; return ans ; } };","title":"0054. Spiral Matrix"},{"location":"algo/leetcode/#0056-merge-intervals","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. */ class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); sort ( intervals . begin (), intervals . end ()); int b = 0 , rightMax = intervals [ b ][ 1 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( rightMax < intervals [ i - 1 ][ 1 ]) { rightMax = intervals [ i - 1 ][ 1 ]; } if ( rightMax < intervals [ i ][ 0 ]) { ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], rightMax }); b = i ; rightMax = intervals [ i ][ 1 ]; } } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ n - 1 ][ 1 ], rightMax ) }); return ans ; } };","title":"0056. Merge Intervals"},{"location":"algo/leetcode/#0057-insert-interval","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. */ class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; int n = int ( intervals . size ()); if ( n == 0 || ( intervals [ 0 ][ 0 ] >= newInterval [ 0 ] && intervals [ n - 1 ][ 1 ] <= newInterval [ 1 ])) { ans . emplace_back ( newInterval ); return ans ; } int b = 0 , e = - 1 ; while ( b < n ) { if ( intervals [ b ][ 0 ] > newInterval [ 1 ]) { ans . emplace_back ( newInterval ); for ( int i = b ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 1 ]) { return intervals ; } if ( intervals [ b ][ 0 ] <= newInterval [ 0 ] && intervals [ b ][ 1 ] >= newInterval [ 0 ]) { break ; } if ( intervals [ b ][ 0 ] > newInterval [ 0 ]) { intervals [ b ][ 0 ] = newInterval [ 0 ]; break ; } ans . emplace_back ( intervals [ b ++ ]); } if ( b == n ) { ans . emplace_back ( newInterval ); return ans ; } e = b + 1 ; while ( e < n && ( ( intervals [ e ][ 0 ] <= newInterval [ 1 ] && intervals [ e ][ 1 ] >= newInterval [ 1 ]) || ( intervals [ e ][ 0 ] >= newInterval [ 0 ] && intervals [ e ][ 1 ] <= newInterval [ 1 ]) ) ) { e ++ ; } if ( e == n ) { ans . emplace_back ( vector < int > { min ( newInterval [ 0 ], intervals [ b ][ 0 ]), max ( newInterval [ 1 ], intervals [ n - 1 ][ 1 ]) }); return ans ; } ans . emplace_back ( vector < int > { intervals [ b ][ 0 ], max ( intervals [ e - 1 ][ 1 ], newInterval [ 1 ]) }); for ( int i = e ; i < n ; i ++ ) { ans . emplace_back ( intervals [ i ]); } return ans ; } };","title":"0057. Insert Interval"},{"location":"algo/leetcode/#0058-length-of-last-word","text":"Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0. A word is a maximal substring consisting of non-space characters only. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: s = \"Hello World\" Output: 5 */ class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 , n = int ( s . length ()); if ( n == 0 ) { return ans ; } bool isCount = false ; int i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' && isCount ) { break ; } if ( s [ i ] == ' ' ) { i -- ; continue ; } ans ++ ; i -- ; isCount = true ; } return ans ; } };","title":"0058. Length of Last Word"},{"location":"algo/leetcode/#0059-spiral-matrix-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] 1 -> 2 -> 3 | v 8 -> 9 4 ^ | | v 7 <- 6 <- 5 */ class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n , 0 )); int i = 0 , j = 0 , num = 1 ; while ( num <= n * n ) { while ( true ) { if ( j >= n || ans [ i ][ j ]) { j -- ; i ++ ; break ; } ans [ i ][ j ++ ] = num ++ ; } while ( true ) { if ( i >= n || ans [ i ][ j ]) { i -- ; j -- ; break ; } ans [ i ++ ][ j ] = num ++ ; } while ( true ) { if ( j < 0 || ans [ i ][ j ]) { j ++ ; i -- ; break ; } ans [ i ][ j -- ] = num ++ ; } while ( true ) { if ( i <= 0 || ans [ i ][ j ]) { i ++ ; j ++ ; break ; } ans [ i -- ][ j ] = num ++ ; } } return ans ; } };","title":"0059. Spiral Matrix II"},{"location":"algo/leetcode/#0061-rotate-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == nullptr || head -> next == nullptr || k <= 0 ) { return head ; } int cnt = 0 ; ListNode * curNode = head , * tail = head ; while ( curNode != nullptr ) { cnt ++ ; if ( curNode -> next == nullptr ) { tail = curNode ; } curNode = curNode -> next ; } k %= cnt ; k = cnt - k ; ListNode * p1 = head ; for ( int i = 1 ; i < k ; i ++ ) { p1 = p1 -> next ; } tail -> next = head ; head = p1 -> next ; p1 -> next = nullptr ; return head ; } };","title":"0061. Rotate List"},{"location":"algo/leetcode/#0066-plus-one","text":"Given a non-empty array of decimal digits representing a non-negative integer, increment one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Input: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Input: digits = [0] Output: [1] */ class Solution { public : vector < int > plusOne ( vector < int >& digits ) { vector < int > ans ; vector < int >:: iterator iter ; int n = int ( digits . size ()), add = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int res = digits [ i ] + add ; iter = ans . begin (); if ( res >= 10 ) { ans . insert ( iter , res - 10 ); add = 1 ; } else { ans . insert ( iter , res ); add = 0 ; } } iter = ans . begin (); if ( add ) { ans . insert ( iter , 1 ); } return ans ; } };","title":"0066. Plus One"},{"location":"algo/leetcode/#0067-add-binary","text":"Given two binary strings a and b, return their sum as a binary string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /* Input: a = \"11\", b = \"1\" Output: \"100\" Input: a = \"1010\", b = \"1011\" Output: \"10101\" */ class Solution { public : string addBinary ( string a , string b ) { string str = \"\" ; int aLen = int ( a . length ()), bLen = int ( b . length ()); int i = aLen - 1 , j = bLen - 1 , add = 0 ; if ( aLen < bLen ) { swap ( a , b ); swap ( aLen , bLen ); swap ( i , j ); } while ( i >= 0 && j >= 0 ) { int sum = a [ i ] - '0' + b [ j ] - '0' + add ; if ( sum >= 2 ) { char tempChar = '0' + sum - 2 ; str . insert ( 0 , 1 , tempChar ); add = 1 ; } else { char tempChar = '0' + sum ; str . insert ( 0 , 1 , tempChar ); add = 0 ; } i -- ; j -- ; } while ( i >= 0 ) { int sum = a [ i ] - '0' + add ; if ( sum >= 2 ) { char tempChar = '0' + sum - 2 ; str . insert ( 0 , 1 , tempChar ); add = 1 ; } else { char tempChar = '0' + sum ; str . insert ( 0 , 1 , tempChar ); add = 0 ; } i -- ; } if ( add == 1 ) { str . insert ( 0 , 1 , '1' ); } return str ; } };","title":"0067. Add Binary"},{"location":"algo/leetcode/#0069-sqrtx","text":"Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Input: x = 4 Output: 2 Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. */ class Solution { public : int mySqrt ( int x ) { // Binary search long lo = 1 , hi = x ; while ( lo <= hi ) { long mi = ( lo + hi ) / 2 ; if ( mi * mi < x ) { lo = mi + 1 ; } else if ( mi * mi > x ) { hi = mi - 1 ; } else { return int ( mi ); } } return int ( hi ); } };","title":"0069 Sqrt(x)*"},{"location":"algo/leetcode/#0070-climbing-stairs","text":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Example: Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step Constraints: 1 <= n <= 45 */ class Solution { public : int climbStairs ( int n ) { int a = 1 , b = 2 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } };","title":"0070. Climbing Stairs"},{"location":"algo/leetcode/#0071-simplify-path","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* Input: path = \"/a/./b/../../c/\" Output: \"/c\" */ class Solution { public : string simplifyPath ( string path ) { int n = int ( path . length ()); if ( n <= 1 ) { return \"/\" ; } stack < string > stk ; int i = 0 ; string file = \"\" ; path . push_back ( '/' ); while ( i <= n ) { if ( path [ i ] == '/' ) { if ( file . length () == 0 ) { i ++ ; continue ; } if ( file == \"..\" ) { if ( ! stk . empty ()) { stk . pop (); } } else if ( file != \".\" ) { stk . push ( file ); } file = \"\" ; i ++ ; continue ; } if ( path [ i ] != '/' ) { file . push_back ( path [ i ]); } i ++ ; } if ( stk . empty ()) { return \"/\" ; } file = stk . top (); stk . pop (); while ( ! stk . empty ()) { file = stk . top () + \"/\" + file ; stk . pop (); } file = \"/\" + file ; return file ; } };","title":"0071. Simplify Path"},{"location":"algo/leetcode/#0073-set-matrix-zeroes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 0 1 2 0 0 0 0 0 3 4 5 2 -> 0 4 5 0 1 3 1 5 0 3 1 0 */ class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { int nRow = int ( matrix . size ()); int nCol = int ( matrix [ 0 ]. size ()); unordered_set < int > cols , rows ; for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( matrix [ i ][ j ] == 0 ) { rows . insert ( i ); cols . insert ( j ); } } } unordered_set < int >:: iterator iter ; for ( iter = rows . begin (); iter != rows . end (); iter ++ ) { int i = * iter ; for ( int j = 0 ; j < nCol ; j ++ ) { matrix [ i ][ j ] = 0 ; } } for ( iter = cols . begin (); iter != cols . end (); iter ++ ) { int j = * iter ; for ( int i = 0 ; i < nRow ; i ++ ) { matrix [ i ][ j ] = 0 ; } } } };","title":"0073. Set Matrix Zeroes"},{"location":"algo/leetcode/#0075-sort-colors","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] */ class Solution { public : void sortColors ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return ; } int p0 = 0 , p1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( nums [ i ] == 0 ) { swap ( nums [ i ], nums [ p0 ]); if ( p0 < p1 ) { swap ( nums [ i ], nums [ p1 ]); } p0 ++ ; p1 ++ ; } else if ( nums [ i ] == 1 ) { swap ( nums [ i ], nums [ p1 ++ ]); } } } };","title":"0075. Sort Colors*"},{"location":"algo/leetcode/#0076-minimum-window-substring","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" */ class Solution { public : string minWindow ( string s , string t ) { unordered_map < char , int > tDict , sDict ; for ( const auto & c : t ) { tDict [ c ] ++ ; } int ns = int ( s . length ()); int l = 0 , r = - 1 , ansL = - 1 , minLen = INT_MAX ; while ( r < ns ) { if ( tDict . find ( s [ ++ r ]) != tDict . end ()) { sDict [ s [ r ]] ++ ; } while ( isCover ( tDict , sDict ) && l <= r ) { if ( r - l + 1 < minLen ) { minLen = r - l + 1 ; ansL = l ; } if ( tDict . find ( s [ l ]) != tDict . end ()) { sDict [ s [ l ]] -- ; } l ++ ; } } return - 1 == ansL ? string () : s . substr ( ansL , minLen ); } bool isCover ( unordered_map < char , int > & tDict , unordered_map < char , int > & sDict ) { for ( const auto & item : tDict ) { if ( sDict [ item . first ] < item . second ) { return false ; } } return true ; } };","title":"0076. Minimum Window Substring*"},{"location":"algo/leetcode/#0077-combinations","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Input: n = 4, k = 2 Output: 1, 4 3, 4 2, 3 1, 2 1, 3 1, 4 */ class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; if ( n < 0 || k < 0 || n < k ) { return ans ; } vector < int > arr ; combination ( ans , arr , n , k , 1 ); return ans ; } void combination ( vector < vector < int >> & ans , vector < int > & arr , int n , int k , int idx ) { if ( k == 0 ) { ans . emplace_back ( arr ); return ; } for ( int i = idx ; i <= n ; i ++ ) { arr . emplace_back ( i ); combination ( ans , arr , n , k - 1 , i + 1 ); arr . pop_back (); } } };","title":"0077. Combinations"},{"location":"algo/leetcode/#0078-subsets","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] */ class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); vector < int > arr ; dfs ( ans , arr , nums , n , 0 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int n , int idx ) { if ( idx == n ) { ans . emplace_back ( arr ); } else { arr . emplace_back ( nums [ idx ]); dfs ( ans , arr , nums , n , idx + 1 ); arr . pop_back (); dfs ( ans , arr , nums , n , idx + 1 ); } } };","title":"0078. Subsets"},{"location":"algo/leetcode/#0079-word-search","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* board = A B C E S F C S A D E E word = \"ABCCED\", return true */ class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { int nRow = int ( board . size ()); if ( nRow == 0 ) { return false ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return false ; } int len = int ( word . length ()); bool ans = false ; bool * vis = new bool [ nRow * nCol ]{}; for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] != word [ 0 ]) { continue ; } ans = isExistWord ( board , word , nRow , nCol , i , j , vis , len , 0 ); if ( ans ) { break ; } } if ( ans ) { break ; } } delete [] vis ; return ans ; } bool isExistWord ( vector < vector < char >> & board , string word , int nRow , int nCol , int i , int j , bool * vis , int len , int k ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || vis [ i * nCol + j ] || board [ i ][ j ] != word [ k ]) { return false ; } if ( k == len - 1 ) { return true ; } vis [ i * nCol + j ] = true ; bool u = isExistWord ( board , word , nRow , nCol , i - 1 , j , vis , len , k + 1 ); if ( u ) { return true ; } bool d = isExistWord ( board , word , nRow , nCol , i + 1 , j , vis , len , k + 1 ); if ( d ) { return true ; } bool l = isExistWord ( board , word , nRow , nCol , i , j - 1 , vis , len , k + 1 ); if ( l ) { return true ; } bool r = isExistWord ( board , word , nRow , nCol , i , j + 1 , vis , len , k + 1 ); if ( r ) { return true ; } vis [ i * nCol + j ] = false ; return false ; } };","title":"0079. Word Search"},{"location":"algo/leetcode/#0080-remove-duplicates-from-sorted-array-ii","text":"Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3] Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3] */ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n < 3 ) { return n ; } int len = 1 , count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] == nums [ i - 1 ]) { count ++ ; } else { count = 1 ; } if ( count <= 2 ) { nums [ len ++ ] = nums [ i ]; } } return len ; } };","title":"0080. Remove Duplicates from Sorted Array II*"},{"location":"algo/leetcode/#0082-remove-duplicates-from-sorted-list-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5 1 -> 2 -> 5 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr || head -> next == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = pre , * p2 = head ; while ( p2 != nullptr ) { bool isDup = false ; while ( p2 -> next != nullptr && p2 -> next -> val == p2 -> val ) { p2 = p2 -> next ; isDup = true ; } p2 = p2 -> next ; if ( isDup ) { p1 -> next = p2 ; } else { p1 = p1 -> next ; } } head = pre -> next ; delete pre ; return head ; } };","title":"0082. Remove Duplicates from Sorted List II*"},{"location":"algo/leetcode/#0083-remove-duplicates-from-sorted-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: 1 -> 1 -> 2 Output: 1 -> 2 */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == nullptr ) { return head ; } ListNode * p1 = head , * p2 = head -> next ; while ( true ) { while ( p2 != nullptr && p1 -> val == p2 -> val ) { p2 = p2 -> next ; } p1 -> next = p2 ; p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } return head ; } };","title":"0083. Remove Duplicates from Sorted List"},{"location":"algo/leetcode/#0084-largest-rectangle-in-histogram","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. */ class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 , n = int ( heights . size ()); if ( n == 0 ) { return ans ; } heights . emplace_back ( 0 ); stack < int > stk ; for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } int area = H * W ; if ( ans < area ) { ans = area ; } } stk . push ( i ); } heights . pop_back (); return ans ; } };","title":"0084. Largest Rectangle in Histogram*"},{"location":"algo/leetcode/#0085-maximal-rectangle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 max area = 6 */ class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { int ans = 0 ; int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( matrix [ 0 ]. size ()); vector < int > heights ( nCol , 0 ); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { heights [ j ] = ( heights [ j ] + 1 ) * ( matrix [ i ][ j ] - '0' ); } ans = max ( ans , getRecArea ( heights )); } return ans ; } int getRecArea ( vector < int > heights ) { int ans = 0 , n = int ( heights . size ()); stack < int > stk ; heights . emplace_back ( 0 ); for ( int i = 0 ; i <= n ; i ++ ) { while ( ! stk . empty () && heights [ stk . top ()] > heights [ i ]) { int H = heights [ stk . top ()]; int W = i ; stk . pop (); if ( ! stk . empty ()) { W = i - stk . top () - 1 ; } ans = max ( ans , W * H ); } stk . push ( i ); } return ans ; } };","title":"0085. Maximal Rectangle*"},{"location":"algo/leetcode/#0086-partition-list","text":"Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* from 1 -> 4 -> 3 -> 2 -> 5 -> 2 to 1 -> 2 -> 2 -> 4 -> 3 -> 5 */ Input : head = [ 1 , 4 , 3 , 2 , 5 , 2 ], x = 3 Output : [ 1 , 2 , 2 , 4 , 3 , 5 ] class Solution { public : ListNode * partition ( ListNode * head , int x ) { if ( head == nullptr ) { return head ; } ListNode * h1 = new ListNode ( 0 ), * h2 = new ListNode ( 0 ); ListNode * p1 = head , * p2 = head -> next , * cur1 = h1 , * cur2 = h2 ; while ( p1 != nullptr ) { if ( p1 -> val < x ) { cur1 -> next = p1 ; cur1 = p1 ; } else { cur2 -> next = p1 ; cur2 = p1 ; } p1 = p2 ; if ( p2 == nullptr ) { break ; } p2 = p2 -> next ; } cur2 -> next = nullptr ; cur1 -> next = h2 -> next ; head = h1 -> next ; delete h1 ; delete h2 ; return head ; } };","title":"0086. Partition List"},{"location":"algo/leetcode/#0087-scramble-string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y. Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x. Apply step 1 recursively on each of the two substrings x and y. Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. Input: s1 = \"great\", s2 = \"rgeat\" Output: true */ class Solution { public : bool isScramble ( string s1 , string s2 ) { int n = int ( s1 . length ()); if ( n != int ( s2 . length ())) { return false ; } if ( n == 0 ) { return true ; } bool *** dp = new bool ** [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool * [ n ]; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ] = new bool [ n + 1 ]{}; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ][ j ][ 1 ] = s1 [ i ] == s2 [ j ]; } } for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { for ( int j = 0 ; j < n - len + 1 ; j ++ ) { for ( int k = 1 ; k < len ; k ++ ) { dp [ i ][ j ][ len ] = ( ( dp [ i ][ j ][ k ] && dp [ i + k ][ j + k ][ len - k ]) || ( dp [ i + k ][ j ][ len - k ] && dp [ i ][ j + len - k ][ k ]) ); if ( dp [ i ][ j ][ len ]) { break ; } } } } } bool ans = dp [ 0 ][ 0 ][ n ]; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { delete [] dp [ i ][ j ]; } delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0087. Scramble String*"},{"location":"algo/leetcode/#0088-merge-sorted-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] */ class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int pos = int ( nums1 . size ()) - 1 ; if ( pos < 0 ) { return ; } int i = m - 1 , j = n - 1 ; while ( i >= 0 && j >= 0 ) { if ( nums1 [ i ] > nums2 [ j ]) { nums1 [ pos -- ] = nums1 [ i -- ]; } else { nums1 [ pos -- ] = nums2 [ j -- ]; } } while ( i >= 0 ) { nums1 [ pos -- ] = nums1 [ i -- ]; } while ( j >= 0 ) { nums1 [ pos -- ] = nums2 [ j -- ]; } } };","title":"0088. Merge Sorted Array"},{"location":"algo/leetcode/#0090-subsets-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] */ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; int n = int ( nums . size ()); sort ( nums . begin (), nums . end ()); vector < int > arr ; dfs ( ans , arr , nums , 0 , n ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , vector < int > & nums , int idx , int n ) { for ( int i = idx ; i < n ; i ++ ) { if ( i > idx && nums [ i ] == nums [ i - 1 ]) { continue ; } arr . emplace_back ( nums [ i ]); dfs ( ans , arr , nums , i + 1 , n ); arr . pop_back (); } ans . emplace_back ( arr ); } };","title":"0090. Subsets II*"},{"location":"algo/leetcode/#0091-decode-ways","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 'A' -> \"1\" 'B' -> \"2\" ... 'Z' -> \"26\" Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). */ class Solution { public : int numDecodings ( string s ) { int n = ( int ) s . length (); if ( n == 0 || s [ 0 ] == '0' ) { return 0 ; } if ( n == 1 ) { return 1 ; } int a = ( s [ n - 1 ] != '0' ); int b = 0 ; if ( s [ n - 2 ] != '0' ) { b = a + (( s [ n - 2 ] - '0' ) * 10 + s [ n - 1 ] - '0' <= 26 ); } if ( n == 2 ) { return b ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { int c = 0 ; if ( s [ i ] == '0' ) { a = b ; b = c ; continue ; } c += b ; if ( i < n - 1 && ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) <= 26 ) { c += a ; } a = b ; b = c ; } return b ; } };","title":"0091. Decode Ways"},{"location":"algo/leetcode/#0092-reverse-linked-list-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] 1 -> 2 -> 3 -> 4 -> 5 | v 1 -> 4 -> 3 -> 2 -> 5 */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int left , int right ) { if ( left >= right || head == nullptr ) { return head ; } ListNode * pre = new ListNode ( 0 ); pre -> next = head ; ListNode * p1 = head , * p0 = pre ; int i = 1 ; while ( i < left ) { p1 = p1 -> next ; p0 = p0 -> next ; i ++ ; if ( p1 == nullptr ) { delete pre ; return head ; } } ListNode * tail = p1 , * p2 = p1 -> next ; if ( p2 == nullptr ) { delete pre ; return head ; } ListNode * p3 = p2 -> next ; while ( i < right ) { p2 -> next = p1 ; p1 = p2 ; p2 = p3 ; if ( p3 == nullptr ) { p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } p3 = p3 -> next ; i ++ ; } p0 -> next = p1 ; tail -> next = p2 ; head = pre -> next ; delete pre ; return head ; } };","title":"0092. Reverse Linked List II"},{"location":"algo/leetcode/#0093-restore-ip-addresses","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] */ class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; int n = int ( s . length ()); if ( n < 4 || n > 12 ) { return ans ; } unordered_map < string , bool > dict ; vector < string > sol ; find ( ans , s , 0 , n , dict , sol ); return ans ; } void find ( vector < string > & ans , string & s , int i , int n , unordered_map < string , bool > & dict , vector < string > & sol ) { if ( sol . size () > 4 ) { return ; } if ( i >= n ) { if ( sol . size () != 4 ) { return ; } string res = \"\" ; for ( int i = 0 ; i < 3 ; i ++ ) { res += sol [ i ]; res . push_back ( '.' ); } res += sol [ 3 ]; ans . emplace_back ( res ); return ; } for ( int k = 1 ; k <= 3 ; k ++ ) { if ( i + k > n ) { continue ; } string str = s . substr ( i , k ); if ( dict . find ( str ) == dict . end ()) { dict [ str ] = isLegalIp ( str ); } if ( ! dict [ str ]) { continue ; } sol . emplace_back ( str ); find ( ans , s , i + k , n , dict , sol ); sol . pop_back (); } } bool isLegalIp ( string str ) { int len = int ( str . length ()); if ( len > 1 && str [ 0 ] == '0' ) { return false ; } int val = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] > '9' || str [ i ] < '0' ) { return false ; } val = val * 10 + ( str [ i ] - '0' ); } return val < 256 ; } };","title":"0093. Restore IP Addresses"},{"location":"algo/leetcode/#0094-binary-tree-inorder-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; stack < TreeNode *> st ; TreeNode * curNode = root ; while ( curNode != nullptr ) { while ( curNode != nullptr ) { if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } st . push ( curNode ); curNode = curNode -> left ; } curNode = st . top (); st . pop (); while ( ! st . empty () && curNode -> right == nullptr ) { res . push_back ( curNode -> val ); curNode = st . top (); st . pop (); } res . push_back ( curNode -> val ); if ( ! st . empty ()) { curNode = st . top (); st . pop (); } else { curNode = nullptr ; } } return res ; } };","title":"0094. Binary Tree Inorder Traversal*"},{"location":"algo/leetcode/#0096-unique-binary-search-trees","text":"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} \\begin{aligned} & C_{n} = \\begin{cases} 1, &\\quad n = 0 \\\\ \\frac{2(2n+1)}{n+2} C_{n-1}, &\\quad n = 1, 2, 3, ... \\end{cases} \\\\ & C_{n} = \\frac{(2n)!}{(n+1)! n!} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: n = 3 Output: 5 Input: n = 1 Output: 1 */ class Solution { public : int numTrees ( int n ) { long C = 1 ; for ( int i = 0 ; i < n ; i ++ ) { C = C * 2 * ( 2 * i + 1 ) / ( i + 2 ) ; } return int ( C ); } };","title":"0096. Unique Binary Search Trees"},{"location":"algo/leetcode/#0098-validate-binary-search-tree","text":"Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 2 / \\ 1 3 is a BST 5 / \\ 1 4 / \\ 3 6 is not a BST */ class Solution { public : bool isValidBST ( TreeNode * root ) { TreeNode * prec = nullptr ; return isBST ( root , prec ); } bool isBST ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { bool left = isBST ( root -> left , prec ); if ( left == false ) { return false ; } if ( prec == nullptr ) { prec = root ; } else if ( prec -> val >= root -> val ) { return false ; } prec = root ; bool right = isBST ( root -> right , prec ); if ( right == false ) { return false ; } } return true ; } };","title":"0098. Validate Binary Search Tree"},{"location":"algo/leetcode/#0100-same-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: p = [1,2,3], q = [1,2,3] Output: true */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( p == nullptr && q == nullptr ) { return true ; } if (( p == nullptr && q != nullptr ) || ( p != nullptr && q == nullptr ) || ( p -> val != q -> val )) { return false ; } bool left = isSameTree ( p -> left , q -> left ); if ( ! left ) { return false ; } bool right = isSameTree ( p -> right , q -> right ); if ( ! right ) { return false ; } return true ; } };","title":"0100. Same Tree"},{"location":"algo/leetcode/#0101-symmetric-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1 / \\ 2 2 / \\ / \\ 3 4 4 3 */ class Solution { public : bool isSymmetric ( TreeNode * root ) { if ( root == nullptr ) { return true ; } return isSymmetricTree ( root -> left , root -> right ); } bool isSymmetricTree ( TreeNode * leftTree , TreeNode * rightTree ) { if ( leftTree == nullptr && rightTree == nullptr ) { return true ; } if (( leftTree != nullptr && rightTree == nullptr ) || ( leftTree == nullptr && rightTree != nullptr ) || leftTree -> val != rightTree -> val ) { return false ; } bool left = isSymmetricTree ( leftTree -> left , rightTree -> right ); if ( ! left ) { return false ; } bool right = isSymmetricTree ( leftTree -> right , rightTree -> left ); if ( ! right ) { return false ; } return true ; } };","title":"0101. Symmetric Tree"},{"location":"algo/leetcode/#0102-binary-tree-level-order-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { ans . emplace_back ( arr ); arr . clear (); last = nextLast ; } } return ans ; } };","title":"0102. Binary Tree Level Order Traversal"},{"location":"algo/leetcode/#0103-binary-tree-zigzag-level-order-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* 3 / \\ 9 20 / \\ 15 7 [ [3], [20,9], [15,7] ] */ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> ans ; vector < int > arr ; if ( root == nullptr ) { return ans ; } queue < TreeNode *> qTree ; qTree . push ( root ); TreeNode * front = root , * last = root , * nextLast = root ; int level = 1 ; while ( ! qTree . empty ()) { front = qTree . front (); qTree . pop (); arr . emplace_back ( front -> val ); if ( front -> left != nullptr ) { qTree . push ( front -> left ); nextLast = front -> left ; } if ( front -> right != nullptr ) { qTree . push ( front -> right ); nextLast = front -> right ; } if ( front == last ) { if ( level % 2 == 0 ) { int n = int ( arr . size ()); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr [ i ], arr [ n - 1 - i ]); } } ans . emplace_back ( arr ); arr . clear (); last = nextLast ; level ++ ; } } return ans ; } };","title":"0103. Binary Tree Zigzag Level Order Traversal"},{"location":"algo/leetcode/#0104-maximum-depth-of-binary-tree","text":"Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 3 / \\ 9 20 / \\ 15 7 max depth = 3 */ class Solution { public : int maxDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = maxDepth ( root -> left ); int rightDep = maxDepth ( root -> right ); return 1 + max ( leftDep , rightDep ); } };","title":"0104. Maximum Depth of Binary Tree"},{"location":"algo/leetcode/#0110-balanced-binary-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( root == nullptr ) { return true ; } bool ans = true ; getDepth ( root , ans ); return ans ; } int getDepth ( TreeNode * root , bool & isBal ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDepth ( root -> left , isBal ); int rightDep = getDepth ( root -> right , isBal ); if ( abs ( leftDep - rightDep ) > 1 ) { isBal = false ; } return 1 + max ( leftDep , rightDep ); } };","title":"0110. Balanced Binary Tree"},{"location":"algo/leetcode/#0111-minimum-depth-of-binary-tree","text":"Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 3 / \\ 9 20 / \\ 15 7 min depth = 2 */ class Solution { public : int minDepth ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } int leftDep = minDepth ( root -> left ); int rightDep = minDepth ( root -> right ); if ( leftDep != 0 && rightDep != 0 ) { return 1 + min ( leftDep , rightDep ); } else { return 1 + max ( leftDep , rightDep ); } } };","title":"0111. Minimum Depth of Binary Tree"},{"location":"algo/leetcode/#0112-path-sum","text":"Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true 1 / \\ 2 3 Input: root = [1,2,3], targetSum = 5 Output: false */ class Solution { public : bool hasPathSum ( TreeNode * root , int targetSum ) { if ( root == nullptr ) { return false ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( root -> val == targetSum ) { return true ; } return false ; } bool isInLeft = hasPathSum ( root -> left , targetSum - root -> val ); if ( isInLeft ) { return true ; } bool isInRight = hasPathSum ( root -> right , targetSum - root -> val ); if ( isInRight ) { return true ; } return false ; } };","title":"0112. Path Sum"},{"location":"algo/leetcode/#0113-path-sum-ii","text":"Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path's sum equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int targetSum ) { vector < vector < int >> ans ; if ( root == nullptr ) { return ans ; } vector < int > arr ; findPaths ( root , targetSum , ans , arr ); return ans ; } void findPaths ( TreeNode * root , int resVal , vector < vector < int >> & ans , vector < int > & arr ) { if ( root == nullptr ) { return ; } if ( root -> left == nullptr && root -> right == nullptr ) { if ( resVal == root -> val ) { arr . emplace_back ( root -> val ); ans . emplace_back ( arr ); arr . pop_back (); } return ; } arr . emplace_back ( root -> val ); findPaths ( root -> left , resVal - root -> val , ans , arr ); findPaths ( root -> right , resVal - root -> val , ans , arr ); arr . pop_back (); } };","title":"0113. Path Sum II"},{"location":"algo/leetcode/#0114-flatten-binary-tree-to-linked-list","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 1 1 / \\ \\ 2 5 -> 2 / \\ \\ \\ 3 4 6 3 \\ 4 \\ 5 \\ 6 */ class Solution { public : void flatten ( TreeNode * root ) { TreeNode * prec = nullptr ; preOrder ( root , prec ); } void preOrder ( TreeNode * root , TreeNode *& prec ) { if ( root != nullptr ) { TreeNode * left = root -> left , * right = root -> right ; if ( prec != nullptr ) { prec -> left = nullptr ; prec -> right = root ; } prec = root ; preOrder ( left , prec ); preOrder ( right , prec ); } } };","title":"0114. Flatten Binary Tree to Linked List"},{"location":"algo/leetcode/#0115-distinct-subsequences","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag */ class Solution { public : int numDistinct ( string s , string t ) { int ns = int ( s . length ()), nt = int ( t . length ()); if ( ns < nt ) { return 0 ; } long ** dp = new long * [ ns + 1 ]; for ( int i = 0 ; i <= ns ; i ++ ) { dp [ i ] = new long [ nt + 1 ]{}; } for ( int i = ns ; i >= 0 ; i -- ) { for ( int j = nt ; j >= 0 ; j -- ) { if ( j == nt ) { dp [ i ][ j ] = 1 ; } else if ( i == ns ) { dp [ i ][ j ] = 0 ; } else { if ( s [ i ] == t [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + dp [ i + 1 ][ j ]; } else { dp [ i ][ j ] = dp [ i + 1 ][ j ]; } } } } int ans = dp [ 0 ][ 0 ]; for ( int i = 0 ; i <= ns ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0115. Distinct Subsequences*"},{"location":"algo/leetcode/#0126-word-ladder-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] Output: [ [\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"] ] Explanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\" */ class Solution { public : unordered_map < string , int > wordId ; vector < string > idWord ; vector < vector < int >> edges ; unordered_set < string > dict ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; idWord . emplace_back ( word ); edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } void dfs ( vector < vector < string >> & ans , int & maxDep , int dep , vector < string > & arr , int id , int & t , vector < int > & level ) { if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . emplace_back ( idWord [ id ]); } if ( id == t ) { ans . emplace_back ( arr ); } for ( int & nextId : edges [ id ]) { if ( level [ nextId ] > level [ id ]) { dfs ( ans , maxDep , dep + 1 , arr , nextId , t , level ); } } if ( dict . find ( idWord [ id ]) != dict . end ()) { arr . pop_back (); } } vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; for ( string & word : wordList ) { addEdge ( word ); dict . insert ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return ans ; } if ( dict . find ( beginWord ) == dict . end ()) { addEdge ( beginWord ); dict . insert ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { break ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } if ( level [ t ] == INT_MAX ) { return ans ; } vector < string > arr ; dfs ( ans , level [ t ], 0 , arr , s , t , level ); return ans ; } };","title":"0126. Word Ladder II*"},{"location":"algo/leetcode/#0127-word-ladder","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* Input: beginWord = \"hit\", endWord = \"cog\", wordList = \"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\" Output: 5 Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long. */ class Solution { public : unordered_map < string , int > wordId ; vector < vector < int >> edges ; int numNode = 0 ; void addWord ( string & word ) { if ( wordId . find ( word ) == wordId . end ()) { wordId [ word ] = numNode ++ ; edges . emplace_back (); } } void addEdge ( string & word ) { addWord ( word ); int i = wordId [ word ]; for ( char & c : word ) { char tmp = c ; c = '*' ; addWord ( word ); int j = wordId [ word ]; edges [ i ]. emplace_back ( j ); edges [ j ]. emplace_back ( i ); c = tmp ; } } int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { for ( string & word : wordList ) { addEdge ( word ); } if ( wordId . find ( endWord ) == wordId . end ()) { return 0 ; } if ( wordId . find ( beginWord ) == wordId . end ()) { addEdge ( beginWord ); } vector < int > level ( numNode , INT_MAX ); int s = wordId [ beginWord ], t = wordId [ endWord ]; queue < int > qWord ; qWord . push ( s ); level [ s ] = 0 ; while ( ! qWord . empty ()) { int front = qWord . front (); qWord . pop (); if ( front == t ) { return level [ t ] / 2 + 1 ; } else { for ( int nextId : edges [ front ]) { if ( level [ nextId ] >= level [ front ] + 1 ) { qWord . push ( nextId ); level [ nextId ] = level [ front ] + 1 ; } } } } return 0 ; } };","title":"0127. Word Ladder*"},{"location":"algo/leetcode/#0128-longest-consecutive-sequence","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. */ class Solution { public : int longestConsecutive ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } int ans = 1 ; unordered_set < int > hash ; for ( const auto & ele : nums ) { hash . insert ( ele ); } for ( const int & ele : nums ) { if ( hash . find ( ele - 1 ) != hash . end ()) { int curNum = ele ; int len = 1 ; while ( hash . find ( curNum ) != hash . end ()) { curNum ++ ; len ++ ; } ans = max ( ans , len ); } } return ans ; } };","title":"0128. Longest Consecutive Sequence*"},{"location":"algo/leetcode/#0129-sum-root-to-leaf-numbers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* 4 / \\ 9 0 / \\ 5 1 sum = 495 + 491 + 40 = 1026 */ class Solution { public : int sumNumbers ( TreeNode * root ) { int num = 0 ; return dfs ( root , num ); } int dfs ( TreeNode * root , int num ) { if ( root == nullptr ) { return 0 ; } if ( root -> left == nullptr && root -> right == nullptr ) { return num * 10 + root -> val ;; } int left = dfs ( root -> left , num * 10 + root -> val ); int right = dfs ( root -> right , num * 10 + root -> val ); return left + right ; } };","title":"0129. Sum Root to Leaf Numbers"},{"location":"algo/leetcode/#0130-surrounded-regions","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* X X X X X X X X X O O X -> X X X X X X O X X X X X X O X X X O X X */ class Solution { public : void solve ( vector < vector < char >>& board ) { int nRow = ( int ) board . size (); if ( nRow <= 2 ) { return ; } int nCol = ( int ) board [ 0 ]. size (); if ( nCol <= 2 ) { return ; } for ( int i = 0 ; i < nRow ; i ++ ) { if ( board [ i ][ 0 ] == 'O' ) { dfs ( board , nRow , nCol , i , 0 ); } if ( board [ i ][ nCol - 1 ] == 'O' ) { dfs ( board , nRow , nCol , i , nCol - 1 ); } } for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ 0 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , 0 , j ); } if ( board [ nRow - 1 ][ j ] == 'O' ) { dfs ( board , nRow , nCol , nRow - 1 , j ); } } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( board [ i ][ j ] == 'O' ) { board [ i ][ j ] = 'X' ; } if ( board [ i ][ j ] == 'A' ) { board [ i ][ j ] = 'O' ; } } } } void dfs ( vector < vector < char >> & board , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || board [ i ][ j ] == 'A' || board [ i ][ j ] == 'X' ) { return ; } board [ i ][ j ] = 'A' ; dfs ( board , nRow , nCol , i + 1 , j ); dfs ( board , nRow , nCol , i - 1 , j ); dfs ( board , nRow , nCol , i , j + 1 ); dfs ( board , nRow , nCol , i , j - 1 ); } };","title":"0130. Surrounded Regions*"},{"location":"algo/leetcode/#0131-palindrome-partitioning","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Input: s = \"aab\" Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]] */ class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; int n = ( int ) s . length (); if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } vector < string > arr ; move ( ans , arr , dp , n , 0 , s ); for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } void move ( vector < vector < string >> & ans , vector < string > & arr , bool ** dp , int n , int pos , string & s ) { if ( pos >= n ) { if ( ! arr . empty ()) { ans . emplace_back ( arr ); } return ; } for ( int len = 0 ; len < n - pos ; len ++ ) { if ( dp [ pos ][ pos + len ]) { arr . emplace_back ( s . substr ( pos , len + 1 )); move ( ans , arr , dp , n , pos + len + 1 , s ); arr . pop_back (); } } } };","title":"0131. Palindrome Partitioning"},{"location":"algo/leetcode/#0132-palindrome-partitioning-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /* Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. */ class Solution { public : int minCut ( string s ) { int n = int ( s . length ()); if ( n < 2 ) { return 0 ; } bool ** dp = new bool * [ n ]; int * cut = new int [ n ]{}; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ i + 1 ] = true ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; } } } for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ 0 ][ j ]) { cut [ j ] = 0 ; continue ; } int cutNum = INT_MAX ; for ( int i = j ; i > 0 ; i -- ) { if ( dp [ i ][ j ] && cutNum > cut [ i - 1 ] + 1 ) { cutNum = cut [ i - 1 ] + 1 ; } } cut [ j ] = cutNum ; } int ans = cut [ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; delete [] cut ; return ans ; } };","title":"0132. Palindrome Partitioning II*"},{"location":"algo/leetcode/#0136-single-number","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* Input: nums = [4,1,2,1,2] Output: 4 */ class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int & ele : nums ) { ans ^= ele ; } return ans ; } };","title":"0136. Single Number"},{"location":"algo/leetcode/#0137-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u9664\u67d0\u4e2a\u5143\u7d20\u4ec5\u51fa\u73b0 \u4e00\u6b21 \u5916\uff0c\u5176\u4f59\u6bcf\u4e2a\u5143\u7d20\u90fd \u6070\u51fa\u73b0 \u4e09\u6b21 \u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de\u90a3\u4e2a\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\u7684\u5143\u7d20\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [2,2,3,2] \u8f93\u51fa\uff1a3 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [0,1,0,1,0,1,99] \u8f93\u51fa\uff1a99 */ class Solution { public : int singleNumber ( vector < int >& nums ) { unordered_map < int , int > dict ; for ( int ele : nums ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter = dict . begin (); for (; iter != dict . end (); iter ++ ) { if ( iter -> second == 1 ) { return iter -> first ; } } return - 1 ; } };","title":"0137. \u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 II"},{"location":"algo/leetcode/#0142-linked-list-cycle-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) { return head ; } ListNode * p1 = head , * p2 = head ; while ( true ) { if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; if ( p2 == NULL ) { return NULL ; } p2 = p2 -> next ; p1 = p1 -> next ; if ( p1 == p2 ) { break ; } } p1 = head ; while ( p1 != p2 ) { p2 = p2 -> next ; p1 = p1 -> next ; } return p1 ; } };","title":"0142. Linked List Cycle II"},{"location":"algo/leetcode/#0144-binary-tree-preorder-traversal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { curNode = st . top (); st . pop (); ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } if ( curNode -> left != nullptr ) { st . push ( curNode -> left ); } } return ans ; } }; class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; stack < TreeNode *> st ; while ( true ) { while ( curNode != nullptr ) { ans . push_back ( curNode -> val ); if ( curNode -> right != nullptr ) { st . push ( curNode -> right ); } curNode = curNode -> left ; } if ( st . empty ()) { break ; } curNode = st . top (); st . pop (); } return ans ; } };","title":"0144. Binary Tree Preorder Traversal"},{"location":"algo/leetcode/#0150-evaluate-reverse-polish-notation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* Input: tokens = [ \"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\" ] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 */ class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stk ; int num1 = 0 , num2 = 0 ; for ( string & token : tokens ) { if ( token == \"+\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 + num2 ); } else if ( token == \"-\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 - num2 ); } else if ( token == \"*\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 * num2 ); } else if ( token == \"/\" ) { num2 = stk . top (); stk . pop (); num1 = stk . top (); stk . pop (); stk . push ( num1 / num2 ); } else { stk . push ( stringToInt ( token )); } } return stk . top (); } int stringToInt ( string num ) { int n = int ( num . length ()); int ans = 0 ; if ( num [ 0 ] != '-' ) { ans = num [ 0 ] - '0' ; } for ( int i = 1 ; i < n ; i ++ ) { ans = ans * 10 + ( num [ i ] - '0' ); } if ( num [ 0 ] == '-' ) { ans = - ans ; } return ans ; } };","title":"0150. Evaluate Reverse Polish Notation"},{"location":"algo/leetcode/#0151-reverse-words-in-a-string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* Input: s = \" hello world \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces. */ class Solution { public : string reverseWords ( string s ) { int pos = 0 ; for ( int i = 0 ; i < ( int ) s . length (); i ++ , pos ++ ) { if ( s [ i ] != ' ' ) { break ; } } string str = \"\" ; for ( int i = pos ; i < ( int ) s . length (); i ++ ) { if ( i > 0 && s [ i ] == ' ' && s [ i - 1 ] == ' ' ) { continue ; } str . push_back ( s [ i ]); } int n = int ( str . length ()); if ( str [ n - 1 ] == ' ' ) { n -- ; } str . resize ( n ); for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( str [ i ], str [ n - 1 - i ]); } str . push_back ( ' ' ); for ( int i = 0 , j = 0 ; i <= n ; i ++ ) { if ( str [ i ] == ' ' ) { int b = j , e = i - 1 ; while ( b < e ) { swap ( str [ b ++ ], str [ e -- ]); } j = i + 1 ; } } str . resize ( n ); return str ; } };","title":"0151. Reverse Words in a String"},{"location":"algo/leetcode/#0153-find-minimum-in-rotated-sorted-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: nums = [3,4,5,1,2] Output: 1 */ class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 , r = int ( nums . size ()) - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } return nums [ r ]; } };","title":"0153. Find Minimum in Rotated Sorted Array"},{"location":"algo/leetcode/#0154-find-minimum-in-rotated-sorted-array-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Input: nums = [2,2,2,0,1] Output: 0 */ class Solution { public : int findMin ( vector < int >& nums ) { int n = int ( nums . size ()); int l = 0 , r = n - 1 ; while ( l <= r ) { if ( nums [ l ] < nums [ r ]) { return nums [ l ]; } int m = ( l + r ) >> 1 ; if ( nums [ l ] == nums [ r ]) { while ( l < r && nums [ l ] == nums [ l + 1 ]) { l ++ ; } while ( l < r && nums [ r ] == nums [ r - 1 ]) { r -- ; } if (( l + 1 <= r && nums [ l ] < nums [ l + 1 ] && nums [ r ] < nums [ r - 1 ]) || l == r ) { return nums [ l ]; } l ++ ; } else { if ( nums [ m ] >= nums [ l ]) { l = m + 1 ; } else { r = m ; } } } return nums [ r ]; } };","title":"0154. Find Minimum in Rotated Sorted Array II"},{"location":"algo/leetcode/#0155-min-stack","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 */ class MinStack { vector < int > arr1 , arr2 ; public : /** initialize your data structure here. */ MinStack () { } void push ( int val ) { arr1 . emplace_back ( val ); if ( arr2 . empty () || arr2 . back () > val ) { arr2 . emplace_back ( val ); } else { arr2 . emplace_back ( arr2 . back ()); } } void pop () { arr1 . pop_back (); arr2 . pop_back (); } int top () { return arr1 . back (); } int getMin () { return arr2 . back (); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(val); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */","title":"0155. Min Stack"},{"location":"algo/leetcode/#0173-binary-search-tree-iterator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /* Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { vector < int > arr ; vector < int > :: iterator iter ; public : BSTIterator ( TreeNode * root ) { inOrder ( root ); iter = arr . begin (); } void inOrder ( TreeNode * root ) { if ( root != nullptr ) { inOrder ( root -> left ); arr . emplace_back ( root -> val ); inOrder ( root -> right ); } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return 0 ; } } bool hasNext () { return iter != arr . end (); } }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */","title":"0173. Binary Search Tree Iterator"},{"location":"algo/leetcode/#0174-dungeon-game","text":"The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* -2(K) -3 3 -5 -10 1 10 30 -5(P) For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN. */ class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { int m = int ( dungeon . size ()); if ( m == 0 ) { return 1 ; } int n = int ( dungeon [ 0 ]. size ()); if ( n == 0 ) { return 1 ; } vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { int minVal = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); dp [ i ][ j ] = max ( minVal - dungeon [ i ][ j ], 1 ); } } int ans = dp [ 0 ][ 0 ]; return ans ; } };","title":"0174. Dungeon Game*"},{"location":"algo/leetcode/#0179-largest-number","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: nums = [3,30,34,5,9] Output: \"9534330\" */ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans = \"\" ; if ( nums . empty ()) { return ans ; } sort ( nums . begin (), nums . end (), []( const int & x , const int & y ) { long i = 10 , j = 10 ; while ( i <= x ) { i *= 10 ; } while ( j <= y ) { j *= 10 ; } return j * x + y > i * y + x ; }); if ( nums [ 0 ] == 0 ) { return \"0\" ; } for ( const int & ele : nums ) { ans += to_string ( ele ); } return ans ; } };","title":"0179. Largest Number*"},{"location":"algo/leetcode/#0190-reverse-bits","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. */ class Solution { public : uint32_t reverseBits ( uint32_t n ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { ans |= ( n & 1 ) << ( 31 - i ); n = n >> 1 ; } return ans ; } }; class Solution { public : uint32_t reverseBits ( uint32_t n ) { const uint32_t M1 = 0x55555555 ; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333 ; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f ; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff ; // 00000000111111110000000011111111 n = ( n >> 1 & M1 ) | ( n & M1 ) << 1 ; n = ( n >> 2 & M2 ) | ( n & M2 ) << 2 ; n = ( n >> 4 & M4 ) | ( n & M4 ) << 4 ; n = ( n >> 8 & M8 ) | ( n & M8 ) << 8 ; return n >> 16 | n << 16 ; } };","title":"0190. Reverse Bits*"},{"location":"algo/leetcode/#0191-number-of-1-bits","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. */ class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; while ( n ) { n &= n - 1 ; ans ++ ; } return ans ; //return __builtin_popcount(n); } };","title":"0191. Number of 1 Bits"},{"location":"algo/leetcode/#0199-binary-tree-right-side-view","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; if ( root == nullptr ) { return ans ; } int maxLevel = - 1 ; rightOrder ( root , ans , 0 , maxLevel ); return ans ; } void rightOrder ( TreeNode * root , vector < int > & ans , int level , int & maxLevel ) { if ( root != nullptr ) { if ( level > maxLevel ) { ans . emplace_back ( root -> val ); maxLevel = level ; } rightOrder ( root -> right , ans , level + 1 , maxLevel ); rightOrder ( root -> left , ans , level + 1 , maxLevel ); } } };","title":"0199. Binary Tree Right Side View"},{"location":"algo/leetcode/#0200-number-of-islands","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* grid = { {'1', '1', '0', '0', '0'}, {'1', '1', '0', '0', '0'}, {'0', '0', '1', '0', '0'}, {'0', '0', '0', '1', '1'} } number of islands is 3 */ class Solution { public : int numIslands ( vector < vector < char >>& grid ) { int ans = 0 ; int nRow = int ( grid . size ()); if ( nRow == 0 ) { return 0 ; } int nCol = int ( grid [ 0 ]. size ()); if ( nCol == 0 ) { return 0 ; } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { if ( grid [ i ][ j ] == '0' ) { continue ; } if ( isIsland ( grid , nRow , nCol , i , j )) { ans ++ ; } } } return ans ; } bool isIsland ( vector < vector < char >> & grid , int nRow , int nCol , int i , int j ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || grid [ i ][ j ] == '0' ) { return false ; } bool res = true ; grid [ i ][ j ] = '0' ; bool u = isIsland ( grid , nRow , nCol , i - 1 , j ); bool d = isIsland ( grid , nRow , nCol , i + 1 , j ); bool l = isIsland ( grid , nRow , nCol , i , j - 1 ); bool r = isIsland ( grid , nRow , nCol , i , j + 1 ); return res || u || d || l || r ; } };","title":"0200. Number of Islands"},{"location":"algo/leetcode/#0201-bitwise-and-of-numbers-range","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* Input: left = 5, right = 7 Output: 4 */ class Solution { public : int rangeBitwiseAnd ( int left , int right ) { while ( left < right ) { right &= right - 1 ; } return right ; } };","title":"0201. Bitwise AND of Numbers Range*"},{"location":"algo/leetcode/#0209-minimum-size-subarray-sum","text":"Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 */ class Solution { public : int minSubArrayLen ( int target , vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int minLen = INT_MAX , l = 0 , r = 0 , sum = nums [ 0 ]; while ( r < n && l <= r ) { if ( sum < target ) { if ( r + 1 < n ) { sum += nums [ r + 1 ]; } r ++ ; } else { if ( minLen > r - l + 1 ) { minLen = r - l + 1 ; } sum -= nums [ l ++ ]; } } return minLen == INT_MAX ? 0 : minLen ; } };","title":"0209. Minimum Size Subarray Sum"},{"location":"algo/leetcode/#0212-word-search-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* board = o a a n e t a e i h k r i f l v words = \"oath\",\"pea\",\"eat\",\"rain\" Output: \"eat\",\"oath\" */ class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { vector < string > ans ; int nRow = int ( board . size ()); if ( nRow == 0 ) { return ans ; } int nCol = int ( board [ 0 ]. size ()); if ( nCol == 0 ) { return ans ; } unordered_set < string > hash ; unordered_set < string > res ; int maxLen = 0 ; for ( string & word : words ) { hash . insert ( word ); maxLen = max ( maxLen , int ( word . length ())); } for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { bool * vis = new bool [ nRow * nCol ]{}; string str = \"\" ; collect ( board , str , nRow , nCol , i , j , 0 , maxLen , hash , res , vis ); delete [] vis ; } } unordered_set < string >:: iterator iter ; for ( iter = res . begin (); iter != res . end (); iter ++ ) { ans . emplace_back ( * iter ); } return ans ; } void collect ( vector < vector < char >> & board , string & str , int nRow , int nCol , int i , int j , int len , int maxLen , unordered_set < string > & hash , unordered_set < string > & res , bool * vis ) { if ( i < 0 || i >= nRow || j < 0 || j >= nCol || len > maxLen || vis [ i * nCol + j ]) { return ; } str . push_back ( board [ i ][ j ]); vis [ i * nCol + j ] = true ; if ( hash . find ( str ) != hash . end () && res . find ( str ) == res . end ()) { res . insert ( str ); } collect ( board , str , nRow , nCol , i - 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i + 1 , j , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j - 1 , len + 1 , maxLen , hash , res , vis ); collect ( board , str , nRow , nCol , i , j + 1 , len + 1 , maxLen , hash , res , vis ); str . pop_back (); vis [ i * nCol + j ] = false ; } };","title":"0212. Word Search II"},{"location":"algo/leetcode/#0215-kth-largest-element-in-an-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 */ class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { int n = int ( nums . size ()); k = n - k ; int b = 0 , e = n - 1 ; while ( true ) { int i = b , j = e ; while ( i < j ) { while ( i < j && nums [ i ] <= nums [ j ]) { j -- ; } swap ( nums [ i ], nums [ j ]); while ( i < j && nums [ i ] <= nums [ j ]) { i ++ ; } swap ( nums [ i ], nums [ j ]); } if ( i == k ) { return nums [ i ]; } else if ( i > k ) { e = i - 1 ; } else { b = i + 1 ; } } return 0 ; } };","title":"0215. Kth Largest Element in an Array"},{"location":"algo/leetcode/#0216-combination-sum-iii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. */ class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; if ( k == 0 || n > 45 ) { return ans ; } vector < int > arr ; dfs ( ans , arr , k , n , 1 ); return ans ; } void dfs ( vector < vector < int >> & ans , vector < int > & arr , int k , int n , int idx ) { if ( k <= 0 || n <= 0 || idx > 9 ) { if ( k == 0 && n == 0 ) { ans . emplace_back ( arr ); } return ; } for ( int i = idx ; i < 10 ; i ++ ) { arr . emplace_back ( i ); dfs ( ans , arr , k - 1 , n - i , i + 1 ); arr . pop_back (); } } };","title":"0216. Combination Sum III"},{"location":"algo/leetcode/#0219-contains-duplicate-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Input: nums = [1,2,3,1,2,3], k = 2 Output: false */ class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( nums [ i ]) != hash . end ()) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } };","title":"0219. Contains Duplicate II"},{"location":"algo/leetcode/#0220-contains-duplicate-iii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* Input: nums = [1,5,9,1,5,9], k = 2, t = 3 Output: false */ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { int n = ( int ) nums . size (); if ( n <= 1 ) { return false ; } set < int > hash ; set < int >:: iterator iter ; for ( int i = 0 ; i < n ; i ++ ) { iter = hash . lower_bound ( max ( nums [ i ], INT_MIN + t ) - t ); if ( iter != hash . end () && * iter <= min ( nums [ i ], INT_MAX - t ) + t ) { return true ; } hash . insert ( nums [ i ]); if ( i >= k ) { hash . erase ( nums [ i - k ]); } } return false ; } };","title":"0220. Contains Duplicate III*"},{"location":"algo/leetcode/#0222","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* 1 / \\ 2 3 / \\ / 4 5 6 */ class Solution { public : int countNodes ( TreeNode * root ) { int ans = 0 ; if ( root == nullptr ) { return ans ; } TreeNode * curNode = root ; while ( curNode != nullptr ) { TreeNode * ll = curNode -> left , * lr = curNode -> left ; TreeNode * rl = curNode -> right , * rr = curNode -> right ; int lCnt = 1 , rCnt = 1 ; while ( ll != nullptr && lr != nullptr && rl != nullptr && rr != nullptr ) { ll = ll -> left ; lr = lr -> right ; rl = rl -> left ; rr = rr -> right ; lCnt <<= 1 ; rCnt <<= 1 ; } if ( ll == nullptr && rl == nullptr ) { ans += lCnt - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr != nullptr && rl == nullptr ) { ans += ( lCnt * 2 ) - 1 + rCnt - 1 + 1 ; return ans ; } if ( lr == nullptr ) { ans += rCnt - 1 + 1 ; curNode = curNode -> left ; } else { ans += lCnt * 2 - 1 + 1 ; curNode = curNode -> right ; } } return ans ; } };","title":"0222. \u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u4e2a\u6570*"},{"location":"algo/leetcode/#0224-basic-calculator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /* Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23 */ class Solution { public : int calculate ( string s ) { stack < int > sn ; stack < char > so ; int num = 0 , n = int ( s . length ()), i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] == ' ' ) { i -- ; continue ; } if ( s [ i ] == ')' ) { so . push ( ')' ); } else if ( s [ i ] == '(' ) { while ( so . top () != ')' ) { int n1 = sn . top (); sn . pop (); int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"wrong operator: %c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } so . pop (); } else if ( s [ i ] == '+' || s [ i ] == '-' ) { so . push ( s [ i ]); } else { long times = 1 ; while ( i >= 0 && s [ i ] >= '0' && s [ i ] <= '9' ) { num += ( s [ i -- ] - '0' ) * times ; times *= 10 ; } sn . push ( num ); //printf(\"num=%d\\n\", num); num = 0 ; continue ; } i -- ; } if ( s [ 0 ] == '-' ) { sn . push ( 0 ); } while ( ! so . empty ()) { int n1 = sn . top (); sn . pop (); if ( sn . empty ()) { sn . push ( n1 ); break ; } int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else { printf ( \"%c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } if ( ! so . empty () && so . top () == '-' ) { return - sn . top (); } return sn . top (); } };","title":"0224. Basic Calculator"},{"location":"algo/leetcode/#0227-basic-calculator-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /* Input: s = \" 3+5 / 2 \" Output: 5 */ class Solution { public : int calculate ( string s ) { stack < int > sn ; stack < char > so ; int n = int ( s . length ()), i = n - 1 ; long num = 0 ; while ( i >= 0 ) { if ( s [ i ] == ' ' ) { i -- ; continue ; } if ( s [ i ] == '*' || s [ i ] == '/' ) { so . push ( s [ i ]); } else if ( s [ i ] == '+' || s [ i ] == '-' ) { while ( ! so . empty () && ( so . top () == '*' || so . top () == '/' )) { int n1 = sn . top (); sn . pop (); int n2 = sn . top (); sn . pop (); if ( so . top () == '*' ) { n1 *= n2 ; } else { n1 /= n2 ; } sn . push ( n1 ); so . pop (); } so . push ( s [ i ]); } else { long times = 1 ; while ( i >= 0 && s [ i ] >= '0' && s [ i ] <= '9' ) { num += ( s [ i ] - '0' ) * times ; times *= 10 ; i -- ; } sn . push ( int ( num )); num = 0 ; continue ; } i -- ; } while ( ! so . empty ()) { int n1 = sn . top (); sn . pop (); if ( sn . empty ()) { sn . push ( n1 ); break ; } int n2 = sn . top (); sn . pop (); if ( so . top () == '+' ) { n1 += n2 ; } else if ( so . top () == '-' ) { n1 -= n2 ; } else if ( so . top () == '*' ) { n1 *= n2 ; } else if ( so . top () == '/' ) { n1 /= n2 ; } else { printf ( \"wrong operator %c \\n \" , so . top ()); } so . pop (); sn . push ( n1 ); } if ( ! so . empty () && so . top () == '-' ) { return - sn . top (); } return sn . top (); } };","title":"0227. Basic Calculator II"},{"location":"algo/leetcode/#0230-kth-smallest-element-in-a-bst","text":"Given the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* 3 / \\ 1 4 \\ 2 k = 1, kth min = 1 */ class Solution { public : int kthSmallest ( TreeNode * root , int & k ) { if ( root != nullptr ) { int left = kthSmallest ( root -> left , k ); if ( left >= 0 ) { return left ; } if ( k == 1 ) { return root -> val ; } k -- ; int right = kthSmallest ( root -> right , k ); if ( right >= 0 ) { return right ; } } return - 1 ; } };","title":"0230. Kth Smallest Element in a BST"},{"location":"algo/leetcode/#0232-implement-queue-using-stacks","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false */ // s1 is input stack, s2 is output stack class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () { } /** Push element x to the back of queue. */ void push ( int x ) { s1 . push ( x ); } /** Removes the element from in front of queue and returns that element. */ int pop () { int ans = peek (); s2 . pop (); return ans ; } /** Get the front element. */ int peek () { if ( s2 . empty ()) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } } return s2 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty () && s2 . empty (); } };","title":"0232. Implement Queue using Stacks"},{"location":"algo/leetcode/#0236-lowest-common-ancestor-of-a-binary-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* 3 / \\ 5 1 / \\ / \\ 6 2 0 8 / \\ 7 4 p = 5, q = 1 nearest common ancester is 3 */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { vector < TreeNode *> t1 , t2 , tmp ; dfs ( root , p , tmp , t1 ); tmp . clear (); dfs ( root , q , tmp , t2 ); int n1 = ( int ) t1 . size (), n2 = ( int ) t2 . size (); int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( t1 [ i ] != t2 [ j ]) { break ; } i ++ ; j ++ ; } if ( i == n1 ) { return t1 [ i - 1 ]; } if ( j == n2 ) { return t2 [ j - 1 ]; } return t1 [ i - 1 ]; } void dfs ( TreeNode * root , TreeNode *& node , vector < TreeNode *> & t , vector < TreeNode *> & res ) { if ( root == nullptr ) { return ; } t . emplace_back ( root ); if ( root == node ) { res = t ; return ; } dfs ( root -> left , node , t , res ); dfs ( root -> right , node , t , res ); t . pop_back (); } };","title":"0236. Lowest Common Ancestor of a Binary Tree"},{"location":"algo/leetcode/#0239-sliding-window-maximum","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 */ class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; multiset < int > hash ; int n = ( int ) nums . size (); for ( int i = 0 ; i < k ; i ++ ) { hash . insert ( nums [ i ]); } for ( int i = k ; i < n ; i ++ ) { ans . emplace_back ( *-- hash . end ()); hash . erase ( hash . find ( nums [ i - k ])); hash . insert ( nums [ i ]); } ans . emplace_back ( *-- hash . end ()); return ans ; } }; class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; int n = ( int ) nums . size (); priority_queue < pair < int , int >> pq ; for ( int i = 0 ; i < k ; i ++ ) { pq . emplace ( nums [ i ], i ); } for ( int i = k ; i <= n ; i ++ ) { while ( pq . top (). second + k < i ) { pq . pop (); } ans . emplace_back ( pq . top (). first ); if ( i < n ) { pq . emplace ( nums [ i ], i ); } } return ans ; } };","title":"0239. Sliding Window Maximum"},{"location":"algo/leetcode/#0257-binary-tree-paths","text":"Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Input: 1 / \\ 2 3 \\ 5 Output: [\"1->2->5\", \"1->3\"] Explanation: All root-to-leaf paths are: 1->2->5, 1->3 */ class Solution { public : vector < string > binaryTreePaths ( TreeNode * root ) { vector < int > arr ; vector < string > ans ; if ( root == nullptr ) { return ans ; } getPaths ( root , ans , arr ); return ans ; } void getPaths ( TreeNode * root , vector < string > & ans , vector < int > & arr ) { if ( root == nullptr ) { return ; } if ( root -> left == nullptr && root -> right == nullptr ) { string str = \"\" ; for ( int ele : arr ) { str += to_string ( ele ) + \"->\" ; } str += to_string ( root -> val ); ans . emplace_back ( str ); return ; } arr . emplace_back ( root -> val ); getPaths ( root -> left , ans , arr ); getPaths ( root -> right , ans , arr ); arr . pop_back (); } };","title":"0257. Binary Tree Paths"},{"location":"algo/leetcode/#0263-ugly-number","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: n = 6 Output: true Explanation: 6 = 2 \u00d7 3 */ class Solution { public : bool isUgly ( int n ) { if ( n <= 0 ) { return false ; } while ( n % 2 == 0 ) { n /= 2 ; } while ( n % 3 == 0 ) { n /= 3 ; } while ( n % 5 == 0 ) { n /= 5 ; } return n == 1 ; } };","title":"0263. Ugly Number"},{"location":"algo/leetcode/#0264-ugly-number-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. */ class Solution { public : int nthUglyNumber ( int n ) { int ans = 0 ; if ( n <= 6 ) { return n ; } int * dp = new int [ n ]{}; dp [ 0 ] = 1 ; int f2 = 0 , f3 = 0 , f5 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ f2 ] * 2 , min ( dp [ f3 ] * 3 , dp [ f5 ] * 5 )); while ( dp [ f2 ] * 2 <= dp [ i ]) { f2 ++ ; } while ( dp [ f3 ] * 3 <= dp [ i ]) { f3 ++ ; } while ( dp [ f5 ] * 5 <= dp [ i ]) { f5 ++ ; } } ans = dp [ n - 1 ]; delete [] dp ; return ans ; } };","title":"0264. Ugly Number II"},{"location":"algo/leetcode/#0300-longest-increasing-subsequence","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 /* Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. */ class Solution { public : int lengthOfLIS ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n <= 1 ) { return n ; } int * dp = new int [ n + 1 ]{}, len = 1 ; dp [ 1 ] = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( nums [ i ] > dp [ len ]) { dp [ ++ len ] = nums [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ] >= nums [ i ]) { r = m - 1 ; } else { l = m + 1 ; } } dp [ l ] = nums [ i ]; } } delete [] dp ; return len ; } }; /* \u7ed9\u5b9a\u6570\u7ec4arr\uff0c\u8bbe\u957f\u5ea6\u4e3an\uff0c\u8f93\u51faarr\u7684\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\u3002 \uff08\u5982\u679c\u6709\u591a\u4e2a\u7b54\u6848\uff0c\u8bf7\u8f93\u51fa\u5176\u4e2d\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\uff09 input: 1,2,8,6,4 output: 1,2,4 */ class Solution { public : /** * retrun the longest increasing subsequence * @param arr int\u6574\u578bvector the array * @return int\u6574\u578bvector */ vector < int > LIS ( vector < int >& arr ) { // write code here vector < int > ans ; int n = ( int ) arr . size (); if ( n == 0 ) { return ans ; } vector < int > dp ( n , 1 ); int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ele = arr [ i ]; if ( ans . empty () || ans . back () < ele ) { ans . emplace_back ( ele ); len ++ ; dp [ i ] = len ; } else { int l = 0 , r = len - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( ans [ m ] >= ele ) { r = m - 1 ; } else { l = m + 1 ; } } ans [ l ] = ele ; dp [ i ] = l + 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( dp [ i ] == len ) { ans [ -- len ] = arr [ i ]; } } return ans ; } };","title":"0300. Longest Increasing Subsequence*"},{"location":"algo/leetcode/#0303-range-sum-query-immutable","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* Input [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] Output [null, 1, -1, -3] Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3) numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) */ class NumArray { vector < int > arr ; public : NumArray ( vector < int >& nums ) { int n = int ( nums . size ()); arr . resize ( n + 1 ); for ( int i = 0 ; i < n ; i ++ ) { arr [ i + 1 ] = arr [ i ] + nums [ i ]; } } int sumRange ( int i , int j ) { return arr [ j + 1 ] - arr [ i ]; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj->sumRange(i,j); */","title":"0303. Range Sum Query - Immutable"},{"location":"algo/leetcode/#0304-range-sum-query-2d-immutable","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12 */ class NumMatrix { vector < vector < int >> accum ; public : NumMatrix ( vector < vector < int >>& matrix ) { int nRow = int ( matrix . size ()); if ( nRow == 0 ) { return ; } int nCol = int ( matrix [ 0 ]. size ()); if ( nCol == 0 ) { return ; } accum . resize ( nRow , vector < int > ( nCol + 1 , 0 )); for ( int i = 0 ; i < nRow ; i ++ ) { for ( int j = 0 ; j < nCol ; j ++ ) { accum [ i ][ j + 1 ] = accum [ i ][ j ] + matrix [ i ][ j ]; } } } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { int ans = 0 ; for ( int i = row1 ; i <= row2 ; i ++ ) { ans += accum [ i ][ col2 + 1 ] - accum [ i ][ col1 ]; } return ans ; } }; /** * Your NumMatrix object will be instantiated and called as such: * NumMatrix* obj = new NumMatrix(matrix); * int param_1 = obj->sumRegion(row1,col1,row2,col2); */","title":"0304. Range Sum Query 2D - Immutable*"},{"location":"algo/leetcode/#0312-burst-balloons","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 */ class Solution { public : int maxCoins ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return 0 ; } int ** dp = new int * [ n + 2 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { dp [ i ] = new int [ n + 2 ]{}; } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i + 2 ; j <= n + 1 ; j ++ ) { int MAX = 0 ; for ( int k = i + 1 ; k < j ; k ++ ) { int left = ( i == 0 ? 1 : nums [ i - 1 ]); int mid = nums [ k - 1 ]; int right = ( j == n + 1 ? 1 : nums [ j - 1 ]); int prod = left * mid * right ; MAX = max ( MAX , dp [ i ][ k ] + prod + dp [ k ][ j ]); } dp [ i ][ j ] = MAX ; } } int ans = dp [ 0 ][ n + 1 ]; for ( int i = 0 ; i <= n + 1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0312. Burst Balloons*"},{"location":"algo/leetcode/#0331-verify-preorder-serialization-of-a-binary-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # */ class Solution { public : bool isValidSerialization ( string preorder ) { int n = int ( preorder . length ()), i = 0 , numNull = 1 ; if ( n == 0 ) { return true ; } while ( i < n ) { if ( numNull <= 0 ) { return false ; } if ( preorder [ i ] == '#' ) { numNull -- ; i ++ ; } else if ( preorder [ i ] == ',' ) { i ++ ; } else { while ( i < n && preorder [ i ] >= '0' && preorder [ i ] <= '9' ) { i ++ ; } numNull ++ ; } } return numNull == 0 ; } };","title":"0331. Verify Preorder Serialization of a Binary Tree*"},{"location":"algo/leetcode/#0338-counting-bits","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Input: 5 Output: [0,1,1,2,1,2] */ class Solution { public : vector < int > countBits ( int num ) { vector < int > ans ( num + 1 , 0 ); for ( int i = 1 ; i <= num ; i ++ ) { ans [ i ] = ans [ i / 2 ] + i % 2 ; } return ans ; } };","title":"0338. Counting Bits"},{"location":"algo/leetcode/#0341-flatten-nested-list-iterator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. */ /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector<NestedInteger> &getList() const; * }; */ class NestedIterator { vector < int > vals ; vector < int >:: iterator iter ; public : NestedIterator ( vector < NestedInteger > & nestedList ) { dfs ( nestedList ); iter = vals . begin (); } void dfs ( const vector < NestedInteger > & nestedList ) { for ( auto & ni : nestedList ) { if ( ni . isInteger ()) { vals . emplace_back ( ni . getInteger ()); } else { dfs ( ni . getList ()); } } } int next () { if ( hasNext ()) { return * iter ++ ; } else { return - 1 ; } } bool hasNext () { return iter != vals . end (); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout << i.next(); */","title":"0341. Flatten Nested List Iterator*"},{"location":"algo/leetcode/#0343-integer-break","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36. */ class Solution { public : int integerBreak ( int n ) { if ( n < 2 ) { return n ; } if ( n == 2 || n == 3 ) { return n - 1 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { int prod = 1 ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( prod < dp [ j ] * dp [ i - j ]) { prod = dp [ j ] * dp [ i - j ]; } } dp [ i ] = prod ; } int ans = dp [ n ]; delete [] dp ; return ans ; } };","title":"0343. Integer Break"},{"location":"algo/leetcode/#0354-russian-doll-envelopes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). */ class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { int n = int ( envelopes . size ()), len = 1 ; if ( n <= 1 ) { return n ; } sort ( envelopes . begin (), envelopes . end (), []( const auto & e1 , const auto & e2 ) { return e1 [ 0 ] < e2 [ 0 ] || ( e1 [ 0 ] == e2 [ 0 ] && e1 [ 1 ] > e2 [ 1 ]); }); vector < vector < int >> dp ( n + 1 , vector < int > { 0 , 0 }); dp [ len ] = envelopes [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( envelopes [ i ][ 0 ] > dp [ len ][ 0 ] && envelopes [ i ][ 1 ] > dp [ len ][ 1 ]) { dp [ ++ len ] = envelopes [ i ]; } else { int l = 1 , r = len ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( dp [ m ][ 0 ] < envelopes [ i ][ 0 ] && dp [ m ][ 1 ] < envelopes [ i ][ 1 ]) { l = m + 1 ; } else { r = m - 1 ; } } dp [ l ] = envelopes [ i ]; } } return len ; } };","title":"0354. Russian Doll Envelopes*"},{"location":"algo/leetcode/#0365-water-and-jug-problem","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs. If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty. Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 Output: true Explanation: The famous Die Hard example */ class Solution { public : bool canMeasureWater ( int jug1Capacity , int jug2Capacity , int targetCapacity ) { int x = jug1Capacity ; int y = jug2Capacity ; int z = targetCapacity ; if ( z > x + y ) { return false ; } if ( z == x || z == y ) { return true ; } if ( x > y ) { swap ( x , y ); } int diff = y % x ; if ( diff == 0 ) { return z % x == 0 ; } for ( int i = 0 ; i < x ; i ++ ) { if ( diff == z || x + diff == z || y + diff == z || y - x + diff == z ) { return true ; } diff = ( y - ( x - diff )) % x ; } return false ; } };","title":"0365. Water and Jug Problem"},{"location":"algo/leetcode/#0367-valid-perfect-square","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: num = 16 Output: true Input: num = 14 Output: false */ class Solution { public : bool isPerfectSquare ( int num ) { long l = 1 , r = num ; while ( l <= r ) { long m = ( l + r ) >> 1 ; long res = m * m ; if ( res == num ) { return true ; } else if ( res < num ) { l = m + 1 ; } else { r = m - 1 ; } } return false ; } };","title":"0367. Valid Perfect Square"},{"location":"algo/leetcode/#0368-largest-divisible-subset","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies: answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them. Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. */ class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { vector < int > ans ; int n = ( int ) nums . size (); if ( n < 2 ) { return nums ; } sort ( nums . begin (), nums . end ()); vector < int > dp ( n , 1 ); vector < int > par ( n , - 1 ); int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( nums [ i ] % nums [ j ] == 0 && dp [ j ] + 1 > dp [ i ]) { dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); par [ i ] = j ; } } len = max ( len , dp [ i ]); } ans . resize ( len ); for ( int i = n - 1 ; i >= 0 ;) { if ( dp [ i ] == len ) { ans [ -- len ] = nums [ i ]; i = par [ i ]; } else { i -- ; } } return ans ; } };","title":"0368. Largest Divisible Subset"},{"location":"algo/leetcode/#0395-longest-substring-with-at-least-k-repeating-characters","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* Input: s = \"ababbc\", k = 2 Output: 5 Explanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times. */ class Solution { public : int longestSubstring ( string s , int k ) { int n = int ( s . length ()), ans = 0 ; for ( int t = 1 ; t <= 26 ; t ++ ) { int l = 0 , r = 0 , tot = 0 , numLessK = 0 ; int * count = new int [ 26 ]{}; while ( r < n ) { count [ s [ r ] - 'a' ] ++ ; if ( count [ s [ r ] - 'a' ] == 1 ) { tot ++ ; numLessK ++ ; } if ( count [ s [ r ] - 'a' ] == k ) { numLessK -- ; } while ( tot > t ) { count [ s [ l ] - 'a' ] -- ; if ( count [ s [ l ] - 'a' ] == k - 1 ) { numLessK ++ ; } if ( count [ s [ l ] - 'a' ] == 0 ) { numLessK -- ; tot -- ; } l ++ ; } if ( numLessK == 0 ) { ans = max ( ans , r - l + 1 ); } r ++ ; } delete [] count ; } return ans ; } };","title":"0395. Longest Substring with At Least K Repeating Characters*"},{"location":"algo/leetcode/#0403","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* \u4e00\u53ea\u9752\u86d9\u60f3\u8981\u8fc7\u6cb3\u3002 \u5047\u5b9a\u6cb3\u6d41\u88ab\u7b49\u5206\u4e3a\u82e5\u5e72\u4e2a\u5355\u5143\u683c\uff0c\u5e76\u4e14\u5728\u6bcf\u4e00\u4e2a\u5355\u5143\u683c\u5185 \u90fd\u6709\u53ef\u80fd\u653e\u6709\u4e00\u5757\u77f3\u5b50\uff08\u4e5f\u6709\u53ef\u80fd\u6ca1\u6709\uff09\u3002 \u9752\u86d9\u53ef\u4ee5\u8df3\u4e0a\u77f3\u5b50\uff0c\u4f46\u662f\u4e0d\u53ef\u4ee5\u8df3 \u5165\u6c34\u4e2d\u3002 \u7ed9\u4f60\u77f3\u5b50\u7684\u4f4d\u7f6e\u5217\u8868 stones\uff08\u7528\u5355\u5143\u683c\u5e8f\u53f7 \u5347\u5e8f \u8868\u793a\uff09\uff0c \u8bf7\u5224\u5b9a\u9752\u86d9\u80fd \u5426\u6210\u529f\u8fc7\u6cb3\uff08\u5373\u80fd\u5426\u5728\u6700\u540e\u4e00\u6b65\u8df3\u81f3\u6700\u540e\u4e00\u5757\u77f3\u5b50\u4e0a\uff09\u3002 \u5f00\u59cb\u65f6\uff0c \u9752\u86d9\u9ed8\u8ba4\u5df2\u7ad9\u5728\u7b2c\u4e00\u5757\u77f3\u5b50\u4e0a\uff0c\u5e76\u53ef\u4ee5\u5047\u5b9a\u5b83\u7b2c\u4e00\u6b65\u53ea\u80fd\u8df3\u8dc3\u4e00\u4e2a\u5355 \u4f4d\uff08\u5373\u53ea\u80fd\u4ece\u5355\u5143\u683c 1 \u8df3\u81f3\u5355\u5143\u683c 2 \uff09\u3002 \u5982\u679c\u9752\u86d9\u4e0a\u4e00\u6b65\u8df3\u8dc3\u4e86 k \u4e2a\u5355\u4f4d\uff0c\u90a3\u4e48\u5b83\u63a5\u4e0b\u6765\u7684\u8df3\u8dc3\u8ddd\u79bb\u53ea\u80fd\u9009\u62e9\u4e3a k - 1\u3001 k \u6216 k + 1 \u4e2a\u5355\u4f4d\u3002 \u53e6\u8bf7\u6ce8\u610f\uff0c\u9752\u86d9\u53ea\u80fd\u5411\u524d\u65b9\uff08\u7ec8\u70b9\u7684\u65b9\u5411\uff09\u8df3\u8dc3\u3002 \u8f93\u5165\uff1astones = [0,1,3,5,6,8,12,17] \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a\u9752\u86d9\u53ef\u4ee5\u6210\u529f\u8fc7\u6cb3\uff0c\u6309\u7167\u5982\u4e0b\u65b9\u6848\u8df3\u8dc3\uff1a\u8df3 1 \u4e2a\u5355\u4f4d\u5230\u7b2c 2 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 3 \u5757\u77f3\u5b50, \u63a5\u7740 \u8df3 2 \u4e2a\u5355\u4f4d\u5230\u7b2c 4 \u5757\u77f3\u5b50, \u7136\u540e\u8df3 3 \u4e2a\u5355\u4f4d\u5230\u7b2c 6 \u5757\u77f3\u5b50, \u8df3 4 \u4e2a\u5355\u4f4d\u5230\u7b2c 7 \u5757\u77f3\u5b50, \u6700\u540e\uff0c\u8df3 5 \u4e2a\u5355\u4f4d\u5230\u7b2c 8 \u4e2a\u77f3\u5b50\uff08\u5373\u6700\u540e\u4e00\u5757\u77f3\u5b50\uff09\u3002 \u8f93\u5165\uff1astones = [0,1,2,3,4,8,9,11] \u8f93\u51fa\uff1afalse \u89e3\u91ca\uff1a\u8fd9\u662f\u56e0\u4e3a\u7b2c 5 \u548c\u7b2c 6 \u4e2a\u77f3\u5b50\u4e4b\u95f4\u7684\u95f4\u8ddd\u592a\u5927\uff0c\u6ca1\u6709\u53ef\u9009\u7684\u65b9\u6848\u4f9b\u9752\u86d9\u8df3 \u8dc3\u8fc7\u53bb\u3002 */ class Solution { public : bool canCross ( vector < int >& stones ) { unordered_map < int , int > dict ; int n = ( int ) stones . size (); if ( n <= 1 ) { return true ; } vector < vector < int >> dp ( n , vector < int > ( n , 0 )); dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( stones [ i ] - stones [ i - 1 ] > i ) { return false ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { int k = stones [ i ] - stones [ j ]; if ( k > j + 1 ) { break ; } dp [ i ][ k ] = dp [ j ][ k - 1 ] || dp [ j ][ k ] || dp [ j ][ k + 1 ]; if ( i == n - 1 && dp [ i ][ k ]) { return true ; } } } return false ; } };","title":"0403. \u9752\u86d9\u8fc7\u6cb3*"},{"location":"algo/leetcode/#0407-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /* \u7ed9\u4f60\u4e00\u4e2a m x n \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u7684\u503c\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u4e8c\u7ef4\u9ad8\u5ea6\u56fe\u6bcf\u4e2a\u5355 \u5143\u7684\u9ad8\u5ea6\uff0c\u8bf7\u8ba1\u7b97\u56fe\u4e2d\u5f62\u72b6\u6700\u591a\u80fd\u63a5\u591a\u5c11\u4f53\u79ef\u7684\u96e8\u6c34\u3002 \u793a\u4f8b\uff1a \u7ed9\u51fa\u5982\u4e0b 3x6 \u7684\u9ad8\u5ea6\u56fe: [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] \u8fd4\u56de 4 \u3002 */ class Solution { public : int trapRainWater ( vector < vector < int >>& heightMap ) { int nRow = ( int ) heightMap . size (); if ( nRow == 0 ) { return 0 ; } int nCol = ( int ) heightMap [ 0 ]. size (); if ( nCol < 3 ) { return 0 ; } typedef pair < int , pair < int , int >> PIII ; priority_queue < PIII , vector < PIII > , greater < PIII >> heap ; bool ** vis = new bool * [ nRow ]; for ( int i = 0 ; i < nRow ; i ++ ) { vis [ i ] = new bool [ nCol ]{}; heap . push ({ heightMap [ i ][ 0 ], { i , 0 }}); heap . push ({ heightMap [ i ][ nCol - 1 ], { i , nCol - 1 }}); vis [ i ][ 0 ] = vis [ i ][ nCol - 1 ] = true ; } for ( int j = 0 ; j < nCol ; j ++ ) { heap . push ({ heightMap [ 0 ][ j ], { 0 , j }}); heap . push ({ heightMap [ nRow - 1 ][ j ], { nRow - 1 , j }}); vis [ 0 ][ j ] = vis [ nRow - 1 ][ j ] = true ; } int dx [ 4 ] = { - 1 , 0 , 1 , 0 }, dy [ 4 ] = { 0 , - 1 , 0 , 1 }; int ans = 0 ; while ( ! heap . empty ()) { auto cur = heap . top (); heap . pop (); int x = cur . second . first , y = cur . second . second ; int h = cur . first ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx >= 0 && xx < nRow && yy >= 0 && yy < nCol && ! vis [ xx ][ yy ]) { vis [ xx ][ yy ] = true ; ans += max ( h - heightMap [ xx ][ yy ], 0 ); heap . push ({ max ( h , heightMap [ xx ][ yy ]), { xx , yy }}); } } } for ( int i = 0 ; i < nRow ; i ++ ) { delete [] vis [ i ]; } delete [] vis ; return ans ; } };","title":"0407. \u63a5\u96e8\u6c34 II*"},{"location":"algo/leetcode/#0415-add-strings","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* Input: num1 = \"456\", num2 = \"77\" Output: \"533\" */ class Solution { public : string addStrings ( string num1 , string num2 ) { string ans = \"\" ; int len1 = ( int ) num1 . length (), len2 = ( int ) num2 . length (); if ( len1 < len2 ) { swap ( len1 , len2 ); swap ( num1 , num2 ); } int i = len1 - 1 , j = len2 - 1 ; int res = 0 ; while ( j >= 0 ) { int sum = ( num1 [ i ] - '0' ) + ( num2 [ j ] - '0' ) + res ; res = 0 ; if ( sum >= 10 ) { res = 1 ; sum -= 10 ; } char sumChar = sum + '0' ; ans . insert ( 0 , 1 , sumChar ); i -- ; j -- ; } while ( i >= 0 ) { int sum = ( num1 [ i ] - '0' ) + res ; res = 0 ; if ( sum >= 10 ) { res = 1 ; sum -= 10 ; } char sumChar = sum + '0' ; ans . insert ( 0 , 1 , sumChar ); i -- ; } if ( res ) { ans . insert ( 0 , 1 , '1' ); } return ans ; } };","title":"0415. Add Strings"},{"location":"algo/leetcode/#0470-implement-rand10-using-rand7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: n = 3 Output: [3,8,10] */ // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 class Solution { public : int rand10 () { int ans = 0 , i = 0 , j = 0 ; do { i = rand7 (); j = rand7 (); ans = ( i - 1 ) * 7 + j ; } while ( ans > 40 ); return ans % 10 + 1 ; } };","title":"0470. Implement Rand10() Using Rand7()*"},{"location":"algo/leetcode/#0503-next-greater-element-ii","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. */ class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { int n = int ( nums . size ()); if ( n == 0 ) { return vector < int > {}; } vector < int > ans ( n , - 1 ); stack < int > st ; for ( int i = 0 ; i < 2 * n - 1 ; i ++ ) { while ( ! st . empty () && nums [ st . top ()] < nums [ i % n ]) { ans [ st . top ()] = nums [ i % n ]; st . pop (); } st . push ( i % n ); } return ans ; } };","title":"0503. Next Greater Element II*"},{"location":"algo/leetcode/#0516-longest-palindromic-subsequence","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000. Input: \"bbbab\" Output: 4 */ class Solution { public : int longestPalindromeSubseq ( string s ) { int n = int ( s . length ()); if ( n <= 1 ) { return n ; } int ** dp = new int * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new int [ n ]{}; dp [ i ][ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] + 2 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } } } int ans = dp [ 0 ][ n - 1 ]; for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0516. Longest Palindromic Subsequence*"},{"location":"algo/leetcode/#0530-minimum-absolute-difference-in-bst","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 1 \\ 3 / 2 output: 1 */ class Solution { public : int getMinimumDifference ( TreeNode * root ) { TreeNode * last = nullptr ; int ans = INT_MAX ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & diff ) { if ( root != nullptr ) { inOrder ( root -> left , last , diff ); if ( last == nullptr ) { last = root ; } else { diff = min ( diff , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , diff ); } } };","title":"0530. Minimum Absolute Difference in BST"},{"location":"algo/leetcode/#0543-diameter-of-binary-tree","text":"Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. */ class Solution { public : int diameterOfBinaryTree ( TreeNode * root ) { int max = 0 ; getDep ( root , max ); return max ; } int getDep ( TreeNode * root , int & maxLen ) { if ( root == nullptr ) { return 0 ; } int leftDep = getDep ( root -> left , maxLen ); int rightDep = getDep ( root -> right , maxLen ); int curLen = leftDep + rightDep ; maxLen = maxLen > curLen ? maxLen : curLen ; return ( leftDep > rightDep ? leftDep : rightDep ) + 1 ; } };","title":"0543. Diameter of Binary Tree"},{"location":"algo/leetcode/#0554","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u4f60\u7684\u9762\u524d\u6709\u4e00\u5835\u77e9\u5f62\u7684\u3001\u7531 n \u884c\u7816\u5757\u7ec4\u6210\u7684\u7816\u5899\u3002\u8fd9\u4e9b\u7816\u5757\u9ad8\u5ea6\u76f8\u540c\uff08\u4e5f\u5c31\u662f\u4e00\u4e2a\u5355\u4f4d\u9ad8\uff09 \u4f46\u662f\u5bbd\u5ea6\u4e0d\u540c\u3002\u6bcf\u4e00\u884c\u7816\u5757\u7684\u5bbd\u5ea6\u4e4b\u548c\u5e94\u8be5\u76f8\u7b49\u3002 \u4f60\u73b0\u5728\u8981\u753b\u4e00\u6761 \u81ea\u9876\u5411\u4e0b \u7684\u3001\u7a7f\u8fc7 \u6700\u5c11 \u7816\u5757\u7684\u5782\u7ebf\u3002\u5982\u679c\u4f60\u753b\u7684\u7ebf\u53ea\u662f\u4ece\u7816\u5757\u7684\u8fb9\u7f18\u7ecf\u8fc7\uff0c \u5c31\u4e0d\u7b97\u7a7f\u8fc7\u8fd9\u5757\u7816\u3002\u4f60\u4e0d\u80fd\u6cbf\u7740\u5899\u7684\u4e24\u4e2a\u5782\u76f4\u8fb9\u7f18\u4e4b\u4e00\u753b\u7ebf\uff0c\u8fd9\u6837\u663e\u7136\u662f\u6ca1\u6709\u7a7f\u8fc7\u4e00\u5757\u7816\u7684\u3002 \u7ed9\u4f60\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 wall \uff0c\u8be5\u6570\u7ec4\u5305\u542b\u8fd9\u5835\u5899\u7684\u76f8\u5173\u4fe1\u606f\u3002\u5176\u4e2d\uff0cwall[i] \u662f\u4e00\u4e2a\u4ee3\u8868\u4ece\u5de6 \u81f3\u53f3\u6bcf\u5757\u7816\u7684\u5bbd\u5ea6\u7684\u6570\u7ec4\u3002\u4f60\u9700\u8981\u627e\u51fa\u600e\u6837\u753b\u624d\u80fd\u4f7f\u8fd9\u6761\u7ebf \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf\u6700\u5c11 \uff0c\u5e76\u4e14\u8fd4\u56de \u7a7f\u8fc7\u7684\u7816\u5757\u6570\u91cf \u3002 \u8f93\u5165\uff1awall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] \u8f93\u51fa\uff1a2 \u8f93\u5165\uff1awall = [[1],[1],[1]] \u8f93\u51fa\uff1a3 */ class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int n = ( int ) wall . size (); if ( n == 0 ) { return 0 ; } int ans = 0 ; unordered_map < int , int > cnt ; for ( auto arr : wall ) { int len = ( int ) arr . size (); int sum = 0 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { sum += arr [ i ]; cnt [ sum ] ++ ; } } unordered_map < int , int >:: iterator iter ; for ( iter = cnt . begin (); iter != cnt . end (); iter ++ ) { ans = max ( ans , iter -> second ); } return n - ans ; } };","title":"0554. \u7816\u5899*"},{"location":"algo/leetcode/#0633","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 c \uff0c\u4f60\u8981\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6574\u6570 a \u548c b\uff0c\u4f7f\u5f97 a^2 + b^2 = c \u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ac = 5 \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a1 * 1 + 2 * 2 = 5 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ac = 3 \u8f93\u51fa\uff1afalse \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ac = 4 \u8f93\u51fa\uff1atrue \u793a\u4f8b 4\uff1a \u8f93\u5165\uff1ac = 2 \u8f93\u51fa\uff1atrue \u793a\u4f8b 5\uff1a \u8f93\u5165\uff1ac = 1 \u8f93\u51fa\uff1atrue */ class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 , r = ( long ) sqrt ( c ); while ( l <= r ) { long sqaureSum = l * l + r * r ; if ( sqaureSum == c ) { return true ; } else if ( sqaureSum < c ) { l ++ ; } else { r -- ; } } return false ; } };","title":"0633. \u5e73\u65b9\u6570\u4e4b\u548c*"},{"location":"algo/leetcode/#0647-palindromic-substrings","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". */ class Solution { public : int countSubstrings ( string s ) { int n = int ( s . length ()), ans = n ; if ( n == 0 ) { return ans ; } bool ** dp = new bool * [ n ]; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new bool [ n ]{}; dp [ i ][ i ] = true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i - 1 ] == s [ i ]) { dp [ i - 1 ][ i ] = true ; ans ++ ; } } for ( int k = 2 ; k < n ; k ++ ) { for ( int i = 0 ; i < n - k ; i ++ ) { int j = i + k ; if ( s [ i ] == s [ j ] && dp [ i + 1 ][ j - 1 ]) { dp [ i ][ j ] = true ; ans ++ ; } } } for ( int i = 0 ; i < n ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } };","title":"0647. Palindromic Substrings"},{"location":"algo/leetcode/#0690","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* \u7ed9\u5b9a\u4e00\u4e2a\u4fdd\u5b58\u5458\u5de5\u4fe1\u606f\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u5305\u542b\u4e86\u5458\u5de5 \u552f\u4e00\u7684 id \uff0c\u91cd\u8981\u5ea6\u548c\u76f4\u7cfb\u4e0b\u5c5e\u7684 id \u3002 \u6bd4\u5982\uff0c\u5458\u5de5 1 \u662f\u5458\u5de5 2 \u7684\u9886\u5bfc\uff0c\u5458\u5de5 2 \u662f\u5458\u5de5 3 \u7684\u9886\u5bfc\u3002\u4ed6\u4eec\u76f8\u5e94\u7684\u91cd\u8981\u5ea6\u4e3a 15 , 10 , 5 \u3002 \u90a3\u4e48\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u662f [1, 15, [2]] \uff0c\u5458\u5de5 2\u7684 \u6570\u636e\u7ed3\u6784\u662f [2, 10, [3]] \uff0c\u5458\u5de53 \u7684\u6570\u636e\u7ed3\u6784\u662f [3, 5, []] \u3002\u6ce8\u610f\u867d\u7136\u5458\u5de5 3 \u4e5f\u662f\u5458\u5de5 1 \u7684\u4e00\u4e2a\u4e0b\u5c5e\uff0c\u4f46\u662f\u7531\u4e8e \u5e76\u4e0d\u662f\u76f4\u7cfb \u4e0b\u5c5e\uff0c\u56e0\u6b64\u6ca1\u6709\u4f53\u73b0\u5728\u5458\u5de5 1 \u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 \u73b0\u5728\u8f93\u5165\u4e00\u4e2a\u516c\u53f8\u7684\u6240\u6709\u5458\u5de5\u4fe1\u606f\uff0c\u4ee5\u53ca\u5355\u4e2a\u5458\u5de5 id \uff0c\u8fd4\u56de\u8fd9\u4e2a\u5458\u5de5\u548c\u4ed6\u6240\u6709\u4e0b\u5c5e\u7684\u91cd\u8981\u5ea6\u4e4b\u548c\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 \u8f93\u51fa\uff1a11 \u89e3\u91ca\uff1a \u5458\u5de5 1 \u81ea\u8eab\u7684\u91cd\u8981\u5ea6\u662f 5 \uff0c\u4ed6\u6709\u4e24\u4e2a\u76f4\u7cfb\u4e0b\u5c5e 2 \u548c 3 \uff0c\u800c\u4e14 2 \u548c 3 \u7684\u91cd\u8981\u5ea6\u5747\u4e3a 3 \u3002 \u56e0\u6b64\u5458\u5de5 1 \u7684\u603b\u91cd\u8981\u5ea6\u662f 5 + 3 + 3 = 11 \u3002 */ /* // Definition for Employee. class Employee { public: int id; int importance; vector< int> subordinates; }; */ class Solution { public : int dfs ( unordered_set < int > & vis , unordered_map < int , int > & dict , unordered_map < int , vector < int >> & next , int id ) { int ans = 0 ; for ( int sub : next [ id ]) { if ( vis . find ( sub ) == vis . end ()) { vis . insert ( sub ); ans += dfs ( vis , dict , next , sub ); } } return ans + dict [ id ]; } int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , int > dict ; unordered_map < int , vector < int >> next ; unordered_set < int > vis ; for ( auto employee : employees ) { dict [ employee -> id ] = employee -> importance ; next [ employee -> id ] = employee -> subordinates ; } return dfs ( vis , dict , next , id ); } };","title":"0690. \u5458\u5de5\u7684\u91cd\u8981\u6027"},{"location":"algo/leetcode/#0704-binary-search","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 */ class Solution { public : int search ( vector < int >& nums , int target ) { int n = ( int ) nums . size (); if ( n == 0 ) { return - 1 ; } int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( nums [ m ] == target ) { return m ; } else if ( nums [ m ] < target ) { l = m + 1 ; } else { r = m - 1 ; } } return - 1 ; } };","title":"0704. Binary Search"},{"location":"algo/leetcode/#0738-monotone-increasing-digits","text":"Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits. (Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Input: N = 10 Output: 9 Input: N = 1234 Output: 1234 Input: N = 332 Output: 299 */ class Solution { public : int monotoneIncreasingDigits ( int N ) { int ans = 0 ; string str = to_string ( N ); int len = int ( str . length ()), idx = - 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] < str [ i - 1 ]) { idx = i ; break ; } } if ( idx == - 1 ) { return N ; } int pos = idx - 1 ; while ( pos >= 1 && str [ pos ] == str [ pos - 1 ]) { pos -- ; } str [ pos ] -- ; // current position decrease by 1 for ( int i = pos + 1 ; i < len ; i ++ ) { str [ i ] = '9' ; } for ( int i = len - 1 , pow = 1 ; i >= 0 ; i -- , pow *= 10 ) { ans += ( str [ i ] - '0' ) * pow ; } return ans ; } };","title":"0738. Monotone Increasing Digits*"},{"location":"algo/leetcode/#0741-cherry-pickup","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect by following the rules below: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells. When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0. If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected. Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]] Output: 5 Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible. Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 */ class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { int n = int ( grid . size ()); if ( n == 0 ) { return 0 ; } vector < vector < vector < int >>> dp ( n , vector < vector < int >> ( n , vector < int > ( n , - 1 ))); int ans = move ( dp , grid , 0 , 0 , 0 , n ); return max ( 0 , ans ); } int move ( vector < vector < vector < int >>> & dp , vector < vector < int >> & grid , int r1 , int c1 , int c2 , int n ) { int r2 = r1 + c1 - c2 ; if ( r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid [ r1 ][ c1 ] == - 1 || grid [ r2 ][ c2 ] == - 1 ) { return - 2 ; } if ( r1 == n - 1 && c1 == n - 1 ) { return grid [ r1 ][ c1 ]; } if ( dp [ r1 ][ c1 ][ c2 ] != - 1 ) { return dp [ r1 ][ c1 ][ c2 ]; } int ans = move ( dp , grid , r1 , c1 + 1 , c2 + 1 , n ); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 + 1 , n )); ans = max ( ans , move ( dp , grid , r1 , c1 + 1 , c2 , n )); ans = max ( ans , move ( dp , grid , r1 + 1 , c1 , c2 , n )); if ( ans >= 0 ) { ans += grid [ r1 ][ c1 ] + ( c1 != c2 || r1 != r2 ) * grid [ r2 ][ c2 ]; } dp [ r1 ][ c1 ][ c2 ] = ans ; return ans ; } };","title":"0741. Cherry Pickup*"},{"location":"algo/leetcode/#0752-open-the-lock","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\" Output: 6 Explanation: A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\". Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \"0102\". */ class Solution { public : int openLock ( vector < string >& deadends , string target ) { string init = \"0000\" ; int n = int ( init . length ()), ans = 0 ; unordered_set < string > vis ; for ( string & str : deadends ) { vis . insert ( str ); } if ( vis . find ( init ) != vis . end ()) { return - 1 ; } queue < string > qLock ; qLock . push ( init ); while ( ! qLock . empty ()) { int num = int ( qLock . size ()); while ( num -- ) { string str = qLock . front (); qLock . pop (); if ( str == target ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { string tmp = str ; for ( int d = - 1 ; d <= 1 ; d += 2 ) { tmp [ i ] = ( str [ i ] - '0' + 10 + d ) % 10 + '0' ; if ( vis . find ( tmp ) == vis . end ()) { vis . insert ( tmp ); qLock . push ( tmp ); } } } } ans ++ ; } return - 1 ; } };","title":"0752. Open the Lock*"},{"location":"algo/leetcode/#0766-toeplitz-matrix","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 1 2 3 4 5 1 2 3 9 5 1 2 */ class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { int m = int ( matrix . size ()); if ( m == 0 ) { return false ; } int n = int ( matrix [ 0 ]. size ()); if ( n == 0 ) { return false ; } for ( int j = 0 ; j < n ; j ++ ) { int first = matrix [ 0 ][ j ]; for ( int i = 0 ; i < min ( m , n - j ); i ++ ) { if ( first != matrix [ i ][ i + j ]) { return false ; } } } for ( int i = 1 ; i < m ; i ++ ) { int first = matrix [ i ][ 0 ]; for ( int j = 0 ; j < min ( n , m - i ); j ++ ) { if ( first != matrix [ i + j ][ j ]) { return false ; } } } return true ; } };","title":"0766. Toeplitz Matrix"},{"location":"algo/leetcode/#0769-max-chunks-to-make-sorted","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. */ class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 1 , n = ( int ) arr . size (); if ( n <= 1 ) { return ans ; } vector < int > rightMin ( n , 0 ); rightMin [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; i -- ) { rightMin [ i ] = min ( rightMin [ i + 1 ], arr [ i ]); } int leftMax = arr [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { if ( leftMax <= rightMin [ i ]) { ans ++ ; } leftMax = max ( leftMax , arr [ i ]); } return ans ; } };","title":"0769. Max Chunks To Make Sorted*"},{"location":"algo/leetcode/#0781-rabbits-in-forest","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* Examples: Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered \"1\" could both be the same color, say red. The rabbit than answered \"2\" can't be red or the answers would be inconsistent. Say the rabbit that answered \"2\" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't. Input: answers = [10, 10, 10] Output: 11 Input: answers = [] Output: 0 */ class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; unordered_map < int , int > dict ; for ( int & ele : answers ) { dict [ ele ] ++ ; } unordered_map < int , int >:: iterator iter ; for ( iter = dict . begin (); iter != dict . end (); iter ++ ) { if ( iter -> first == 0 ) { ans += iter -> second ; } else { if ( iter -> first + 1 >= iter -> second ) { ans += iter -> first + 1 ; } else { if ( iter -> second % ( iter -> first + 1 ) == 0 ) { ans += iter -> second ; } else { ans += ( iter -> second / ( iter -> first + 1 ) + 1 ) * ( iter -> first + 1 ); } } } } return ans ; } };","title":"0781. Rabbits in Forest"},{"location":"algo/leetcode/#0783-minimum-distance-between-bst-nodes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 4 / \\ 2 6 / \\ 1 5 output: 1 */ class Solution { public : int minDiffInBST ( TreeNode * root ) { int ans = INT_MAX ; TreeNode * last = nullptr ; inOrder ( root , last , ans ); return ans ; } void inOrder ( TreeNode * root , TreeNode *& last , int & ans ) { if ( root != nullptr ) { inOrder ( root -> left , last , ans ); if ( last == nullptr ) { last = root ; } else { ans = min ( ans , abs ( root -> val - last -> val )); } last = root ; inOrder ( root -> right , last , ans ); } } };","title":"0783. Minimum Distance Between BST Nodes"},{"location":"algo/leetcode/#0832-flipping-an-image","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] */ class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { int m = int ( A . size ()), n = int ( A [ 0 ]. size ()); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { swap ( A [ i ][ j ], A [ i ][ n - 1 - j ]); } for ( int j = 0 ; j < n ; j ++ ) { A [ i ][ j ] = 1 - A [ i ][ j ]; } } return A ; } };","title":"0832. Flipping an Image"},{"location":"algo/leetcode/#0845-longest-mountain-in-array","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Input: arr = [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5. */ class Solution { public : int longestMountain ( vector < int >& arr ) { int ans = 0 , n = int ( arr . size ()); if ( n < 3 ) { return 0 ; } vector < int > left ( n , 0 ), right ( n , 0 ); for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ]) { left [ i ] = left [ i - 1 ] + 1 ; } if ( arr [ n - 1 - i ] > arr [ n - i ]) { right [ n - 1 - i ] = right [ n - i ] + 1 ; } } if ( arr [ n - 1 ] > arr [ n - 2 ]) { left [ n - 1 ] = left [ n - 2 ] + 1 ; } if ( arr [ 0 ] > arr [ 1 ]) { right [ 0 ] = right [ 1 ] + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( left [ i ] && right [ i ]) { ans = max ( left [ i ] + right [ i ] + 1 , ans ); } } return ans ; } };","title":"0845. Longest Mountain in Array*"},{"location":"algo/leetcode/#0897-increasing-order-search-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 5 1 / \\ \\ 1 7 5 \\ 7 */ class Solution { public : TreeNode * increasingBST ( TreeNode * root ) { TreeNode * last = nullptr ; TreeNode * head = nullptr ; inOrder ( root , last , head ); return head ; } void inOrder ( TreeNode * root , TreeNode *& last , TreeNode *& head ) { if ( root != nullptr ) { inOrder ( root -> left , last , head ); if ( last != nullptr ) { last -> right = root ; last -> left = nullptr ; root -> left = nullptr ; } else { head = root ; } last = root ; inOrder ( root -> right , last , head ); } } };","title":"0897. Increasing Order Search Tree*"},{"location":"algo/leetcode/#0921-minimum-add-to-make-parentheses-valid","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Input: \"()))((\" Output: 4 */ class Solution { public : int minAddToMakeValid ( string S ) { int left = 0 , ans = 0 ; for ( const char & c : S ) { if ( c == '(' ) { left ++ ; } else { if ( left > 0 ) { left -- ; } else { ans ++ ; } } } return ans + left ; } };","title":"0921. Minimum Add to Make Parentheses Valid*"},{"location":"algo/leetcode/#0938","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 10 / \\ 5 15 / \\ \\ 3 7 18 \u8f93\u5165\uff1aroot = [10,5,15,3,7,null,18], low = 7, high = 15 \u8f93\u51fa\uff1a32 */ class Solution { public : int rangeSumBST ( TreeNode * root , int low , int high ) { if ( root == nullptr ) { return 0 ; } int left = rangeSumBST ( root -> left , low , high ); int val = 0 ; if ( root -> val >= low && root -> val <= high ) { val = root -> val ; } int right = rangeSumBST ( root -> right , low , high ); return left + val + right ; } };","title":"0938. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u8303\u56f4\u548c"},{"location":"algo/leetcode/#1006-clumsy-factorial","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* Input: 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 */ class Solution { public : int clumsy ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 ) { return 2 ; } else if ( N == 3 ) { return 6 ; } else if ( N == 4 ) { return 7 ; } else { if ( N % 4 == 0 ) { return N + 1 ; } else if ( N % 4 == 1 ) { return N + 2 ; } else if ( N % 4 == 2 ) { return N + 2 ; } else { return N - 1 ; } } } };","title":"1006. Clumsy Factorial*"},{"location":"algo/leetcode/#1047-remove-all-adjacent-duplicates-in-string","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". */ class Solution { public : string removeDuplicates ( string S ) { int n = int ( S . length ()); if ( n <= 1 ) { return S ; } string ans = \"\" ; for ( const char & c : S ) { if ( ! ans . empty () && ans . back () == c ) { ans . pop_back (); } else { ans . push_back ( c ); } } return ans ; } };","title":"1047. Remove All Adjacent Duplicates In String"},{"location":"algo/leetcode/#1052-grumpy-bookstore-owner","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16. */ class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int ans = 0 , n = int ( customers . size ()); if ( n == 0 ) { return ans ; } for ( int i = 0 ; i < n ; i ++ ) { if ( grumpy [ i ] == 0 ) { ans += customers [ i ]; } } int add = 0 , maxAdd = 0 ; for ( int i = 0 ; i < X ; i ++ ) { ans += customers [ i ] * grumpy [ i ]; } for ( int i = 1 ; i < n - X + 1 ; i ++ ) { add += - customers [ i - 1 ] * grumpy [ i - 1 ] + customers [ i + X - 1 ] * grumpy [ i + X - 1 ]; if ( maxAdd < add ) { maxAdd = add ; } } return ans + maxAdd ; } };","title":"1052. Grumpy Bookstore Owner"},{"location":"algo/leetcode/#1178-number-of-valid-words-for-each-puzzle","text":"With respect to a given puzzle string, a word is valid if both the following conditions are satisfied: word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\"; while invalid words are \"beefed\" (doesn't include \"a\") and \"based\" (includes \"s\" which isn't in the puzzle). Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"] Output: [1,1,3,2,4,0] Explanation: 1 valid word for \"aboveyz\" : \"aaaa\" 1 valid word for \"abrodyz\" : \"aaaa\" 3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\" 2 valid words for \"absoryz\" : \"aaaa\", \"asas\" 4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\" There're no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'. */ class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { int n = int ( puzzles . size ()); unordered_map < int , int > dict ; for ( const string & word : words ) { int mask = 0 ; for ( const char & c : word ) { mask |= ( 1 << ( c - 'a' )); } if ( __builtin_popcount ( mask ) <= 7 ) { dict [ mask ] ++ ; } } vector < int > ans ; for ( const string & puzzle : puzzles ) { int tot = 0 ; for ( int choose = 0 ; choose < ( 1 << 6 ); choose ++ ) { int mask = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( choose & ( 1 << i )) { mask |= ( 1 << ( puzzle [ i + 1 ] - 'a' )); } } mask |= ( 1 << ( puzzle [ 0 ] - 'a' )); tot += dict [ mask ]; } ans . emplace_back ( tot ); } return ans ; } };","title":"1178. Number of Valid Words for Each Puzzle*"},{"location":"algo/leetcode/#1411-number-of-ways-to-paint-n-3-grid","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. */ class Solution { public : int numOfWays ( int n ) { int aba = 6 , abc = 6 ; /* aba = aba * 3 + abc * 2 abc = aba * 2 + abc * 2; */ const int MOD = 1000000007 ; for ( int i = 1 ; i < n ; i ++ ) { int new_aba = ( aba * 3ll + abc * 2ll ) % MOD ; int new_abc = ( aba * 2ll + abc * 2ll ) % MOD ; aba = new_aba ; abc = new_abc ; } return ( aba + abc ) % MOD ; } };","title":"1411. Number of Ways to Paint N \u00d7 3 Grid"},{"location":"algo/leetcode/#1553-n","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* \u53a8\u623f\u91cc\u603b\u5171\u6709 n \u4e2a\u6a58\u5b50\uff0c\u4f60\u51b3\u5b9a\u6bcf\u4e00\u5929\u9009\u62e9\u5982\u4e0b\u65b9\u5f0f\u4e4b\u4e00\u5403\u8fd9\u4e9b\u6a58\u5b50\uff1a \u5403\u6389\u4e00\u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 2 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 n/2 \u4e2a\u6a58\u5b50\u3002 \u5982\u679c\u5269\u4f59\u6a58\u5b50\u6570 n \u80fd\u88ab 3 \u6574\u9664\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5403\u6389 2*(n/3) \u4e2a\u6a58\u5b50\u3002 \u6bcf\u5929\u4f60\u53ea\u80fd\u4ece\u4ee5\u4e0a 3 \u79cd\u65b9\u6848\u4e2d\u9009\u62e9\u4e00\u79cd\u65b9\u6848\u3002 \u8bf7\u4f60\u8fd4\u56de\u5403\u6389\u6240\u6709 n \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1an = 10 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u4f60\u603b\u5171\u6709 10 \u4e2a\u6a58\u5b50\u3002 \u7b2c 1 \u5929\uff1a\u5403 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 10 - 1 = 9\u3002 \u7b2c 2 \u5929\uff1a\u5403 6 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 9 - 2*(9/3) = 9 - 6 = 3\u3002\uff089 \u53ef\u4ee5\u88ab 3 \u6574\u9664\uff09 \u7b2c 3 \u5929\uff1a\u5403 2 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 3 - 2*(3/3) = 3 - 2 = 1\u3002 \u7b2c 4 \u5929\uff1a\u5403\u6389\u6700\u540e 1 \u4e2a\u6a58\u5b50\uff0c\u5269\u4f59\u6a58\u5b50\u6570 1 - 1 = 0\u3002 \u4f60\u9700\u8981\u81f3\u5c11 4 \u5929\u5403\u6389 10 \u4e2a\u6a58\u5b50\u3002 */ class Solution { public : unordered_map < int , int > dict ; int minDays ( int n ) { if ( n <= 1 ) { return 1 ; } if ( dict . find ( n ) != dict . end ()) { return dict [ n ]; } else { return dict [ n ] = min ( n % 2 + 1 + minDays ( n / 2 ), n % 3 + 1 + minDays ( n / 3 )); } } };","title":"1553. \u5403\u6389 N \u4e2a\u6a58\u5b50\u7684\u6700\u5c11\u5929\u6570*"},{"location":"algo/leetcode/#1585-check-if-string-is-transformable-with-substring-sort-operations","text":"Given two strings s and t, you want to transform string s into string t using the following operation any number of times: Choose a non-empty substring in s and sort it in-place so the characters are in ascending order. For example, applying the operation on the underlined substring in \"14234\" results in \"12344\". Return true if it is possible to transform string s into string t. Otherwise, return false. A substring is a contiguous sequence of characters within a string. Example: Input: s = \"84532\", t = \"34852\" Output: true Explanation: You can transform s into t using the following sort operations: \"84532\" (from index 2 to 3) -> \"84352\" \"84352\" (from index 0 to 2) -> \"34852\" Input: s = \"34521\", t = \"23415\" Output: true Explanation: You can transform s into t using the following sort operations: \"34521\" -> \"23451\" \"23451\" -> \"23415\" Input: s = \"12345\", t = \"12435\" Output: false Input: s = \"1\", t = \"2\" Output: false Constraints: s.length == t.length 1 <= s.length <= 105 s and t only contain digits from '0' to '9'. Solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isTransformable ( string s , string t ) { vector < vector < int >> idx ( 10 ); vector < int > count ( 10 ); for ( int i = 0 ; i < int ( s . length ()); i ++ ) { idx [ s [ i ] - '0' ]. push_back ( i ); } for ( int i = 0 ; i < int ( t . length ()); i ++ ) { int digit = t [ i ] - '0' ; if ( count [ digit ] == idx [ digit ]. size ()) { return false ; } for ( int j = 0 ; j < digit ; j ++ ) { if ( count [ j ] != idx [ j ]. size () && idx [ j ][ count [ j ]] < idx [ digit ][ count [ digit ]]) { return false ; } } count [ digit ] ++ ; } return true ; } };","title":"1585. Check If String Is Transformable With Substring Sort Operations*"},{"location":"algo/math/","text":"\u6700\u5927\u516c\u7ea6\u6570 & \u6700\u5c0f\u516c\u500d\u6570 \u00b6 \u4e24\u6570\u6700\u5927\u516c\u7ea6\u6570 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Brutal force: enumerate all numbers from 1 to min(a, b), save the greatest. */ int GCD_enumerate ( int a , int b ) { int c = ( a < b ? a : b ); int gcd = 1 ; for ( int i = 1 ; i <= c ; i ++ ) { if ( a % i == 0 && b % i == 0 ) { gcd = i ; } } return gcd ; } int GCD_Euclidean_Algorithm_divide ( int a , int b ) { while ( a * b ) { if ( a < b ) { b %= a ; } else { a %= b ; } } return ( a > b ? a : b ); } int GCD_Euclidean_Algorithm_subtract ( int a , int b ) { while ( a * b ) { if ( a < b ) { b -= a ; } else { a -= b ; } } return ( a > b ? a : b ); } \u6570\u7ec4\u7684\u6700\u5927\u516c\u7ea6\u6570 \u00b6 1 2 3 4 5 6 7 8 9 int GCD_Array ( vector < int > arr ) { int n = int ( arr . size ()); if ( n == 1 ) { return arr [ 0 ]; } int gcd = GCD_Euclidean_Algorithm_divide ( arr [ 0 ], arr [ 1 ]); for ( int i = 2 ; i < n ; i ++ ) { gcd = GCD_Euclidean_Algorithm_divide ( gcd , arr [ i ]); } return gcd ; } \u6700\u5c0f\u516c\u500d\u6570 \u00b6 \\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} \\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} 1 2 3 4 int LCM ( int a , int b ) { int gcd = GCD_Euclidean_Algorithm_divide ( a , b ); return ( a * b ) / gcd ; } \u4f4d\u8fd0\u7b97 \u00b6 \u539f\u7801 \u53cd\u7801 \u8865\u7801 \u00b6 \u300c\u539f\u7801\u300d \u7b2c\u4e00\u4f4d\u662f\u7b26\u53f7\u4f4d\uff0c\u5176\u4f59\u8868\u793a\u503c \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} 8 \u4f4d\u4e8c\u8fdb\u5236\u539f\u7801\u7684\u53ef\u4ee5\u8868\u793a\u7684\u8303\u56f4\u662f [1111 111, 0111 111] \u5373 [-127, 127] \u300c\u53cd\u7801\u300d \u6b63\u6570\u7684\u53cd\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u53cd\u7801\u662f\u7b26\u53f7\u4f4d\u4e0d\u53d8\uff0c\u5176\u4f59\u4f4d\u7f6e\u9010\u4e2a\u53d6\u53cd\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \u300c\u8865\u7801\u300d \u6b63\u6570\u7684\u8865\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u8865\u7801\u5728\u5176\u53cd\u7801\u7684\u6700\u540e\u4e00\u4f4d\u52a0 1\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \u300c\u5f15\u5165\u53cd\u7801\u7684\u539f\u56e0\u300d \u8ba1\u7b97\u673a\u4e8c\u8fdb\u5236\u8fd0\u7b97\u505a\u52a0\u51cf\u4e58\u9664\u8ba1\u7b97\u65f6\uff0c\u5e0c\u671b\u5176\u8bbe\u8ba1\u6a21\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u4f46\u662f\u5bf9\u4e8e\u8d1f\u6570\u800c\u8a00\uff0c\u539f\u7801\u5b58\u5728\u7b26\u53f7\u4f4d\uff0c\u5982\u679c\u53c2\u4e0e\u4e8c\u8fdb\u5236\u8ba1\u7b97\u7684\u8bdd\uff0c\u5bb9\u6613\u51fa\u73b0\u9519\u8bef\u7b54\u6848\u3002 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \u6240\u4ee5\u9700\u8981\u5f15\u5165\u53cd\u7801 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \u4e3a\u4e86\u89e3\u51b3 -0 \u95ee\u9898\uff0c\u8865\u7801\u5e94\u8fd0\u800c\u751f \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \u6b64\u5916[1000 0000]\u8868\u793a -128 \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \u56e0\u6b64 8 \u4f4d\u4e8c\u8fdb\u5236\u53ef\u4ee5\u8868\u793a\u7684\u6570\u5b57\u8303\u56f4\u662f [-128, 127]\u3002 XOR \u00b6 \u6309\u4f4d\u5f02\u6216 (XOR) \u5bf9\u4e8e\u4e8c\u8fdb\u5236\u7684\u4e24\u4e2a\u6570a\uff0c b\u5728\u76f8\u540c\u4f4d\u7f6e\u4e0a\u7684\u505a\u4f4d\u8fd0\u7b97\uff1a\u540c\u4e3a 1 \u6216\u8005\u540c\u4e3a 0 \u5219\u4e3a 0\uff1b \u53cd\u4e4b\u4e3a 1\u3002 \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \u4e24\u4e2a\u6027\u8d28 \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \u300c\u9898\u76ee\u300d \u300cLeetcode 1734. \u89e3\u7801\u5f02\u6216\u540e\u7684\u6392\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 perm \uff0c\u5b83\u662f\u524d n \u4e2a\u6b63\u6574\u6570\u7684\u6392\u5217\uff0c\u4e14 n \u662f\u4e2a \u5947\u6570 \u3002 \u5b83\u88ab\u52a0\u5bc6\u6210\u53e6\u4e00\u4e2a\u957f\u5ea6\u4e3a n - 1 \u7684\u6574\u6570\u6570\u7ec4 encoded \uff0c\u6ee1\u8db3 encoded[i] = perm[i] XOR perm[i + 1] \u3002\u6bd4\u65b9\u8bf4\uff0c\u5982\u679c perm = [1,3,2] \uff0c \u90a3\u4e48 encoded = [2,1] \u3002 \u7ed9\u4f60 encoded \u6570\u7ec4\uff0c\u8bf7\u4f60\u8fd4\u56de\u539f\u59cb\u6570\u7ec4 perm \u3002\u9898\u76ee\u4fdd\u8bc1\u7b54\u6848\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aencoded = [3,1] \u8f93\u51fa\uff1a[1,2,3] \u89e3\u91ca\uff1a\u5982\u679c perm = [1,2,3] \uff0c\u90a3\u4e48 encoded = [1 XOR 2,2 XOR 3] = [3,1] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aencoded = [6,5,4,6] \u8f93\u51fa\uff1a[2,4,1,5,3] */ /* perm\u5305\u542b\u4e861-n+1\u7684\u6240\u6709\u6570\u5b57\uff0cn\u4e3aencoded\u7684\u957f\u5ea6 total = perm[0] ^ ... ^ perm[n-1] perm[0] ^ perm[1] = encoded[0] perm[1] ^ perm[2] = encoded[1] perm[2] ^ perm[3] = encoded[2] perm[3] ^ perm[4] = encoded[3] \u6240\u4ee5\uff0cencoded\u6570\u7ec4\u4e2d\u5947\u6570\u4f4d\u7f6e\u7684\u5143\u7d20XOR\uff0c\u5bf9\u5e94\u4e86perm1-n\u7684XOR\uff0c \u7531\u6b64\uff0c\u53ef\u4ee5\u6c42\u5f97perm[0]\u7684\u5927\u5c0f */ vector < int > decode ( vector < int >& encoded ) { int n = ( int ) encoded . size (); vector < int > perm ; int total = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { total ^= i ; } int odd = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { odd ^= encoded [ i ]; } perm . emplace_back ( total ^ odd ); for ( int i = 0 ; i < n ; i ++ ) { perm . emplace_back ( perm . back () ^ encoded [ i ]); } return perm ; } \u300cLeetcode 810. \u9ed1\u677f\u5f02\u6216\u6e38\u620f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* \u9ed1\u677f\u4e0a\u5199\u7740\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums[i] \u3002Alice \u548c Bob \u8f6e\u6d41\u4ece\u9ed1\u677f\u4e0a\u64e6\u6389\u4e00\u4e2a\u6570\u5b57\uff0cAlice \u5148\u624b\u3002 \u5982\u679c\u64e6\u9664\u4e00\u4e2a\u6570\u5b57\u540e\uff0c\u5269\u4f59\u7684\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u51fa\u7684\u7ed3\u679c\u7b49\u4e8e 0 \u7684\u8bdd\uff0c\u5f53\u524d\u73a9\u5bb6\u6e38\u620f\u5931\u8d25\u3002 (\u53e6\u5916\uff0c\u5982\u679c\u53ea\u5269\u4e00\u4e2a\u6570\u5b57\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u5230\u5b83\u672c\u8eab\uff1b\u5982\u679c\u65e0\u6570\u5b57\u5269\u4f59\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u4e3a 0\u3002\uff09 \u6362\u79cd\u8bf4\u6cd5\u5c31\u662f\uff0c\u8f6e\u5230\u67d0\u4e2a\u73a9\u5bb6\u65f6\uff0c\u5982\u679c\u5f53\u524d\u9ed1\u677f\u4e0a\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u7b49\u4e8e 0\uff0c\u8fd9\u4e2a\u73a9\u5bb6\u83b7\u80dc\u3002 \u5047\u8bbe\u4e24\u4e2a\u73a9\u5bb6\u6bcf\u6b65\u90fd\u4f7f\u7528\u6700\u4f18\u89e3\uff0c\u5f53\u4e14\u4ec5\u5f53 Alice \u83b7\u80dc\u65f6\u8fd4\u56de true\u3002 \u793a\u4f8b\uff1a \u8f93\u5165: nums = [1, 1, 2] \u8f93\u51fa: false \u89e3\u91ca: Alice \u6709\u4e24\u4e2a\u9009\u62e9: \u64e6\u6389\u6570\u5b57 1 \u6216 2\u3002 \u5982\u679c\u64e6\u6389 1, \u6570\u7ec4\u53d8\u6210 [1, 2]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 2 = 3\u3002\u90a3\u4e48 Bob \u53ef\u4ee5\u64e6\u6389\u4efb\u610f\u6570\u5b57\uff0c \u56e0\u4e3a Alice \u4f1a\u6210\u4e3a\u64e6\u6389\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u7684\u4eba\uff0c\u5979\u603b\u662f\u4f1a\u8f93\u3002 \u5982\u679c Alice \u64e6\u6389 2\uff0c\u90a3\u4e48\u6570\u7ec4\u53d8\u6210[1, 1]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 1 = 0\u3002Alice \u4ecd\u7136\u4f1a\u8f93 \u6389\u6e38\u620f\u3002 */ /* \u5206\u6790\uff1a \u5728\u67d0\u4e00\u56de\u5408\u4e2d\uff0c\u5f53\u524d\u5269\u4f59\u7684\u4e2a\u6570 n \u662f\u5076\u6570\u7684\u65f6\u5019\uff0c\u4e0d\u8bba Alice \u9009\u53d6\u54ea\u4e00\u4e2a\u503c\uff0c\u5f97\u5230\u7684\u5269\u4f59\u548c\u90fd\u4e0d\u53ef\u80fd\u4e3a 0\uff0c \u5e76\u4e14\u6b64\u65f6\uff0c\u5269\u4f59\u5947\u6570\u4e2a\u6570\u5b57 n-1\uff0c\u90a3\u4e48 Bob \u9762\u5bf9\u7684\u5c40\u9762\u5c31\u662f\uff1a\uff081\uff09\u5f53\u524d\u5f02\u6216\u548c\u4e3a 0 \uff0c\u6216\u8005\uff082\uff09\u8fdb\u5165\u4e0b\u4e00\u56de \u5408\u3002\u5f53\u8fdb\u5165\u4e0b\u4e00\u56de\u5408\u65f6\uff0c Alice \u53c8\u4f1a\u9762\u4e34\u76f8\u540c\u7684\u5c40\u9762\uff0c\u6240\u4ee5\uff0cn \u4e3a\u5076\u6570\u65f6\uff0cAlice \u4e0d\u4f1a\u8f93\u3002 \u5f53 n \u4e3a\u5947\u6570\u65f6\uff0c\u89d2\u8272\u53cd\u8f6c\uff0cBob \u80af\u5b9a\u4f1a\u8d62\u3002 */ bool xorGame ( vector < int >& nums ) { int n = ( int ) nums . size (); if ( n % 2 == 0 ) { return true ; } int sum = 0 ; for ( int num : nums ) { sum ^= num ; } return sum == 0 ; } Brian Kernighan \u7b97\u6cd5 \u00b6 \u8ba1\u7b97\u4e00\u4e2a\u6574\u6570\u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b 1 \u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 int cnt = 0 ; while ( num ) { num &= ( num - 1 ); cnt ++ ; } return cnt ; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(\\log C) O(\\log C) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u5176\u4e2d C \u4e3a\u88ab\u8ba1\u7b97\u7684\u6574\u6570\u503c\u3002 \u6c49\u660e\u8ddd\u79bb \u00b6 \u4e24\u4e2a\u6574\u6570\u4e4b\u95f4\u7684\u6c49\u660e\u8ddd\u79bb\uff08Hamming Distance\uff09\u6307\u7684\u662f\u8fd9\u4e24\u4e2a\u6570\u5b57\u5bf9\u5e94\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u540c\u7684\u4f4d\u7f6e\u7684\u6570\u76ee\u3002 \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \u300c\u5206\u6790\u300d \u6309\u7167\u5b9a\u4e49\uff0c\u6c49\u660e\u8ddd\u79bb\u662f\u4e8c\u8fdb\u5236\u4e0d\u540c\u7684\u4f4d\u7f6e\u6570\u76ee\u548c\uff0c\u8fd9\u4e0e\u5f02\u6216\u8fd0\u7b97\u6070\u597d\u543b\u5408\u3002\u6211\u4eec\u53ef\u4ee5\u7387\u5148\u8ba1\u7b97\u5f02\u6216\u7684\u7ed3\u679c\uff0c\u7136\u540e\u4f7f\u7528 Brian Kernighan \u7b97\u6cd5\u6c42\u8fd9\u6570\u503c\u7684\u4e8c\u8fdb\u5236\u4e2a\u6570\u3002C++ \u4e2d\u6709\u5185\u7f6e\u51fd\u6570 __builtin_popcount() \uff0c\u53ef\u4ee5\u8c03\u7528\u3002 1 2 3 int hammingDistance ( int x , int y ) { return __builtin_popcount ( x ^ y ); } \u300c\u62d3\u5c55\u300d \u5982\u679c\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e 10000\uff0c\u6c42\u6570\u7ec4\u5185\u4efb\u610f\u4e24\u4e2a\u6570\u7684\u6c49\u540d\u8ddd\u79bb\u548c\u3002\u4f8b\u5982 arr = [4, 14, 2], \u5176\u6c49\u660e\u8ddd\u79bb\u548c\u662f\uff084\uff0c14\uff09+\uff084\uff0c2\uff09+\uff0814\uff0c2\uff09= 2 + 2 + 2 = 6 1 2 3 4 5 6 7 8 9 10 11 12 int totalHammingDistance ( vector < int >& nums ) { int n = ( int ) nums . size (); int ans = 0 ; for ( int i = 0 ; i < 30 ; i ++ ) { int cnt = 0 ; for ( int num : nums ) { cnt += ( num >> i ) & 1 ; } ans += cnt * ( n - cnt ); } return ans ; }","title":"\u6570\u5b66"},{"location":"algo/math/#_1","text":"","title":"\u6700\u5927\u516c\u7ea6\u6570 &amp; \u6700\u5c0f\u516c\u500d\u6570"},{"location":"algo/math/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Brutal force: enumerate all numbers from 1 to min(a, b), save the greatest. */ int GCD_enumerate ( int a , int b ) { int c = ( a < b ? a : b ); int gcd = 1 ; for ( int i = 1 ; i <= c ; i ++ ) { if ( a % i == 0 && b % i == 0 ) { gcd = i ; } } return gcd ; } int GCD_Euclidean_Algorithm_divide ( int a , int b ) { while ( a * b ) { if ( a < b ) { b %= a ; } else { a %= b ; } } return ( a > b ? a : b ); } int GCD_Euclidean_Algorithm_subtract ( int a , int b ) { while ( a * b ) { if ( a < b ) { b -= a ; } else { a -= b ; } } return ( a > b ? a : b ); }","title":"\u4e24\u6570\u6700\u5927\u516c\u7ea6\u6570"},{"location":"algo/math/#_3","text":"1 2 3 4 5 6 7 8 9 int GCD_Array ( vector < int > arr ) { int n = int ( arr . size ()); if ( n == 1 ) { return arr [ 0 ]; } int gcd = GCD_Euclidean_Algorithm_divide ( arr [ 0 ], arr [ 1 ]); for ( int i = 2 ; i < n ; i ++ ) { gcd = GCD_Euclidean_Algorithm_divide ( gcd , arr [ i ]); } return gcd ; }","title":"\u6570\u7ec4\u7684\u6700\u5927\u516c\u7ea6\u6570"},{"location":"algo/math/#_4","text":"\\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} \\text{LCM} = \\frac{a * b}{\\text{GCD}(a, b)} 1 2 3 4 int LCM ( int a , int b ) { int gcd = GCD_Euclidean_Algorithm_divide ( a , b ); return ( a * b ) / gcd ; }","title":"\u6700\u5c0f\u516c\u500d\u6570"},{"location":"algo/math/#_5","text":"","title":"\u4f4d\u8fd0\u7b97"},{"location":"algo/math/#_6","text":"\u300c\u539f\u7801\u300d \u7b2c\u4e00\u4f4d\u662f\u7b26\u53f7\u4f4d\uff0c\u5176\u4f59\u8868\u793a\u503c \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} \\begin{matrix} \\text{[ +1 ]}_{\\text{\u539f}} &= \\text{0000 0001} \\\\ \\text{[ -1 ]}_{\\text{\u539f}} &= \\text{1000 0001} \\end{matrix} 8 \u4f4d\u4e8c\u8fdb\u5236\u539f\u7801\u7684\u53ef\u4ee5\u8868\u793a\u7684\u8303\u56f4\u662f [1111 111, 0111 111] \u5373 [-127, 127] \u300c\u53cd\u7801\u300d \u6b63\u6570\u7684\u53cd\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u53cd\u7801\u662f\u7b26\u53f7\u4f4d\u4e0d\u53d8\uff0c\u5176\u4f59\u4f4d\u7f6e\u9010\u4e2a\u53d6\u53cd\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} \\end{matrix} \u300c\u8865\u7801\u300d \u6b63\u6570\u7684\u8865\u7801\u662f\u5176\u672c\u8eab\uff0c\u8d1f\u6570\u7684\u8865\u7801\u5728\u5176\u53cd\u7801\u7684\u6700\u540e\u4e00\u4f4d\u52a0 1\u3002 \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \\begin{matrix} \\text{[ +1 ]} &= \\text{[0000 0001]}_{\\text{\u539f}} &= \\text{[0000 0001]}_{\\text{\u53cd}} &= \\text{[0000 0001]}_{\\text{\u8865}} \\\\ \\text{[ -1 ]} &= \\text{[1000 0001]}_{\\text{\u539f}} &= \\text{[1111 1110]}_{\\text{\u53cd}} &= \\text{[1111 1111]}_{\\text{\u8865}} \\end{matrix} \u300c\u5f15\u5165\u53cd\u7801\u7684\u539f\u56e0\u300d \u8ba1\u7b97\u673a\u4e8c\u8fdb\u5236\u8fd0\u7b97\u505a\u52a0\u51cf\u4e58\u9664\u8ba1\u7b97\u65f6\uff0c\u5e0c\u671b\u5176\u8bbe\u8ba1\u6a21\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u4f46\u662f\u5bf9\u4e8e\u8d1f\u6570\u800c\u8a00\uff0c\u539f\u7801\u5b58\u5728\u7b26\u53f7\u4f4d\uff0c\u5982\u679c\u53c2\u4e0e\u4e8c\u8fdb\u5236\u8ba1\u7b97\u7684\u8bdd\uff0c\u5bb9\u6613\u51fa\u73b0\u9519\u8bef\u7b54\u6848\u3002 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u539f}} + \\text{[1000 0001]}_{\\text{\u539f}} \\\\ &= \\text{[1000 0002]}_{\\text{\u539f}} \\\\ &= -2 \\end{aligned} \u6240\u4ee5\u9700\u8981\u5f15\u5165\u53cd\u7801 \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u53cd}} + \\text{[1111 1110]}_{\\text{\u53cd}} \\\\ &= \\text{[1111 1111]}_{\\text{\u53cd}} = \\text{[1000 0000]}_{\\text{\u539f}} \\\\ &= -0 \\end{aligned} \u4e3a\u4e86\u89e3\u51b3 -0 \u95ee\u9898\uff0c\u8865\u7801\u5e94\u8fd0\u800c\u751f \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \\begin{aligned} \\text{1 - 1} &= \\text{1 + (-1)} \\\\ &= \\text{[0000 0001]}_{\\text{\u8865}} + \\text{[1111 1111]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[0 0000 0000]}_{\\text{\u539f}} \\\\ &= 0 \\end{aligned} \u6b64\u5916[1000 0000]\u8868\u793a -128 \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \\begin{aligned} \\text{-1 - 127} &= \\text{[1111 1111]}_{\\text{\u8865}} + \\text{[1000 0001]}_{\\text{\u8865}} \\\\ &= \\text{[1000 0000]}_{\\text{\u8865}} \\\\ &= \\text{[11 0000 000]}_{\\text{\u539f}} \\\\ &= -128 \\end{aligned} \u56e0\u6b64 8 \u4f4d\u4e8c\u8fdb\u5236\u53ef\u4ee5\u8868\u793a\u7684\u6570\u5b57\u8303\u56f4\u662f [-128, 127]\u3002","title":"\u539f\u7801 \u53cd\u7801 \u8865\u7801"},{"location":"algo/math/#xor","text":"\u6309\u4f4d\u5f02\u6216 (XOR) \u5bf9\u4e8e\u4e8c\u8fdb\u5236\u7684\u4e24\u4e2a\u6570a\uff0c b\u5728\u76f8\u540c\u4f4d\u7f6e\u4e0a\u7684\u505a\u4f4d\u8fd0\u7b97\uff1a\u540c\u4e3a 1 \u6216\u8005\u540c\u4e3a 0 \u5219\u4e3a 0\uff1b \u53cd\u4e4b\u4e3a 1\u3002 \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \\begin{matrix} 4 & = & 0 & 1 & 0 & 0 \\\\ \\text{XOR} & & & & & \\\\ 10 & = & 1 & 0 & 1 & 0 \\\\ \\Downarrow & & & & & \\\\ 14 & = & 1 & 1 & 1 & 0 \\end{matrix} \u4e24\u4e2a\u6027\u8d28 \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \\begin{aligned} & \\text{a XOR a = 0} \\\\ & \\text{a XOR b = c} \\leftrightarrow \\text{a = c XOR b} \\end{aligned} \u300c\u9898\u76ee\u300d \u300cLeetcode 1734. \u89e3\u7801\u5f02\u6216\u540e\u7684\u6392\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 perm \uff0c\u5b83\u662f\u524d n \u4e2a\u6b63\u6574\u6570\u7684\u6392\u5217\uff0c\u4e14 n \u662f\u4e2a \u5947\u6570 \u3002 \u5b83\u88ab\u52a0\u5bc6\u6210\u53e6\u4e00\u4e2a\u957f\u5ea6\u4e3a n - 1 \u7684\u6574\u6570\u6570\u7ec4 encoded \uff0c\u6ee1\u8db3 encoded[i] = perm[i] XOR perm[i + 1] \u3002\u6bd4\u65b9\u8bf4\uff0c\u5982\u679c perm = [1,3,2] \uff0c \u90a3\u4e48 encoded = [2,1] \u3002 \u7ed9\u4f60 encoded \u6570\u7ec4\uff0c\u8bf7\u4f60\u8fd4\u56de\u539f\u59cb\u6570\u7ec4 perm \u3002\u9898\u76ee\u4fdd\u8bc1\u7b54\u6848\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aencoded = [3,1] \u8f93\u51fa\uff1a[1,2,3] \u89e3\u91ca\uff1a\u5982\u679c perm = [1,2,3] \uff0c\u90a3\u4e48 encoded = [1 XOR 2,2 XOR 3] = [3,1] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aencoded = [6,5,4,6] \u8f93\u51fa\uff1a[2,4,1,5,3] */ /* perm\u5305\u542b\u4e861-n+1\u7684\u6240\u6709\u6570\u5b57\uff0cn\u4e3aencoded\u7684\u957f\u5ea6 total = perm[0] ^ ... ^ perm[n-1] perm[0] ^ perm[1] = encoded[0] perm[1] ^ perm[2] = encoded[1] perm[2] ^ perm[3] = encoded[2] perm[3] ^ perm[4] = encoded[3] \u6240\u4ee5\uff0cencoded\u6570\u7ec4\u4e2d\u5947\u6570\u4f4d\u7f6e\u7684\u5143\u7d20XOR\uff0c\u5bf9\u5e94\u4e86perm1-n\u7684XOR\uff0c \u7531\u6b64\uff0c\u53ef\u4ee5\u6c42\u5f97perm[0]\u7684\u5927\u5c0f */ vector < int > decode ( vector < int >& encoded ) { int n = ( int ) encoded . size (); vector < int > perm ; int total = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { total ^= i ; } int odd = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { odd ^= encoded [ i ]; } perm . emplace_back ( total ^ odd ); for ( int i = 0 ; i < n ; i ++ ) { perm . emplace_back ( perm . back () ^ encoded [ i ]); } return perm ; } \u300cLeetcode 810. \u9ed1\u677f\u5f02\u6216\u6e38\u620f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* \u9ed1\u677f\u4e0a\u5199\u7740\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums[i] \u3002Alice \u548c Bob \u8f6e\u6d41\u4ece\u9ed1\u677f\u4e0a\u64e6\u6389\u4e00\u4e2a\u6570\u5b57\uff0cAlice \u5148\u624b\u3002 \u5982\u679c\u64e6\u9664\u4e00\u4e2a\u6570\u5b57\u540e\uff0c\u5269\u4f59\u7684\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u51fa\u7684\u7ed3\u679c\u7b49\u4e8e 0 \u7684\u8bdd\uff0c\u5f53\u524d\u73a9\u5bb6\u6e38\u620f\u5931\u8d25\u3002 (\u53e6\u5916\uff0c\u5982\u679c\u53ea\u5269\u4e00\u4e2a\u6570\u5b57\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u5f97\u5230\u5b83\u672c\u8eab\uff1b\u5982\u679c\u65e0\u6570\u5b57\u5269\u4f59\uff0c\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u4e3a 0\u3002\uff09 \u6362\u79cd\u8bf4\u6cd5\u5c31\u662f\uff0c\u8f6e\u5230\u67d0\u4e2a\u73a9\u5bb6\u65f6\uff0c\u5982\u679c\u5f53\u524d\u9ed1\u677f\u4e0a\u6240\u6709\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u7b49\u4e8e 0\uff0c\u8fd9\u4e2a\u73a9\u5bb6\u83b7\u80dc\u3002 \u5047\u8bbe\u4e24\u4e2a\u73a9\u5bb6\u6bcf\u6b65\u90fd\u4f7f\u7528\u6700\u4f18\u89e3\uff0c\u5f53\u4e14\u4ec5\u5f53 Alice \u83b7\u80dc\u65f6\u8fd4\u56de true\u3002 \u793a\u4f8b\uff1a \u8f93\u5165: nums = [1, 1, 2] \u8f93\u51fa: false \u89e3\u91ca: Alice \u6709\u4e24\u4e2a\u9009\u62e9: \u64e6\u6389\u6570\u5b57 1 \u6216 2\u3002 \u5982\u679c\u64e6\u6389 1, \u6570\u7ec4\u53d8\u6210 [1, 2]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 2 = 3\u3002\u90a3\u4e48 Bob \u53ef\u4ee5\u64e6\u6389\u4efb\u610f\u6570\u5b57\uff0c \u56e0\u4e3a Alice \u4f1a\u6210\u4e3a\u64e6\u6389\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u7684\u4eba\uff0c\u5979\u603b\u662f\u4f1a\u8f93\u3002 \u5982\u679c Alice \u64e6\u6389 2\uff0c\u90a3\u4e48\u6570\u7ec4\u53d8\u6210[1, 1]\u3002\u5269\u4f59\u6570\u5b57\u6309\u4f4d\u5f02\u6216\u5f97\u5230 1 XOR 1 = 0\u3002Alice \u4ecd\u7136\u4f1a\u8f93 \u6389\u6e38\u620f\u3002 */ /* \u5206\u6790\uff1a \u5728\u67d0\u4e00\u56de\u5408\u4e2d\uff0c\u5f53\u524d\u5269\u4f59\u7684\u4e2a\u6570 n \u662f\u5076\u6570\u7684\u65f6\u5019\uff0c\u4e0d\u8bba Alice \u9009\u53d6\u54ea\u4e00\u4e2a\u503c\uff0c\u5f97\u5230\u7684\u5269\u4f59\u548c\u90fd\u4e0d\u53ef\u80fd\u4e3a 0\uff0c \u5e76\u4e14\u6b64\u65f6\uff0c\u5269\u4f59\u5947\u6570\u4e2a\u6570\u5b57 n-1\uff0c\u90a3\u4e48 Bob \u9762\u5bf9\u7684\u5c40\u9762\u5c31\u662f\uff1a\uff081\uff09\u5f53\u524d\u5f02\u6216\u548c\u4e3a 0 \uff0c\u6216\u8005\uff082\uff09\u8fdb\u5165\u4e0b\u4e00\u56de \u5408\u3002\u5f53\u8fdb\u5165\u4e0b\u4e00\u56de\u5408\u65f6\uff0c Alice \u53c8\u4f1a\u9762\u4e34\u76f8\u540c\u7684\u5c40\u9762\uff0c\u6240\u4ee5\uff0cn \u4e3a\u5076\u6570\u65f6\uff0cAlice \u4e0d\u4f1a\u8f93\u3002 \u5f53 n \u4e3a\u5947\u6570\u65f6\uff0c\u89d2\u8272\u53cd\u8f6c\uff0cBob \u80af\u5b9a\u4f1a\u8d62\u3002 */ bool xorGame ( vector < int >& nums ) { int n = ( int ) nums . size (); if ( n % 2 == 0 ) { return true ; } int sum = 0 ; for ( int num : nums ) { sum ^= num ; } return sum == 0 ; }","title":"XOR"},{"location":"algo/math/#brian-kernighan","text":"\u8ba1\u7b97\u4e00\u4e2a\u6574\u6570\u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b 1 \u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 int cnt = 0 ; while ( num ) { num &= ( num - 1 ); cnt ++ ; } return cnt ; \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(\\log C) O(\\log C) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u5176\u4e2d C \u4e3a\u88ab\u8ba1\u7b97\u7684\u6574\u6570\u503c\u3002","title":"Brian Kernighan \u7b97\u6cd5"},{"location":"algo/math/#_7","text":"\u4e24\u4e2a\u6574\u6570\u4e4b\u95f4\u7684\u6c49\u660e\u8ddd\u79bb\uff08Hamming Distance\uff09\u6307\u7684\u662f\u8fd9\u4e24\u4e2a\u6570\u5b57\u5bf9\u5e94\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u540c\u7684\u4f4d\u7f6e\u7684\u6570\u76ee\u3002 \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \\begin{matrix} 1: & ( & 0 & 0 & 0 & 1 &) \\\\ 4: & ( & 0 & 1 & 0 & 0 & ) \\\\ & & & \\Uparrow & & \\Uparrow \\end{matrix} \u300c\u5206\u6790\u300d \u6309\u7167\u5b9a\u4e49\uff0c\u6c49\u660e\u8ddd\u79bb\u662f\u4e8c\u8fdb\u5236\u4e0d\u540c\u7684\u4f4d\u7f6e\u6570\u76ee\u548c\uff0c\u8fd9\u4e0e\u5f02\u6216\u8fd0\u7b97\u6070\u597d\u543b\u5408\u3002\u6211\u4eec\u53ef\u4ee5\u7387\u5148\u8ba1\u7b97\u5f02\u6216\u7684\u7ed3\u679c\uff0c\u7136\u540e\u4f7f\u7528 Brian Kernighan \u7b97\u6cd5\u6c42\u8fd9\u6570\u503c\u7684\u4e8c\u8fdb\u5236\u4e2a\u6570\u3002C++ \u4e2d\u6709\u5185\u7f6e\u51fd\u6570 __builtin_popcount() \uff0c\u53ef\u4ee5\u8c03\u7528\u3002 1 2 3 int hammingDistance ( int x , int y ) { return __builtin_popcount ( x ^ y ); } \u300c\u62d3\u5c55\u300d \u5982\u679c\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e 10000\uff0c\u6c42\u6570\u7ec4\u5185\u4efb\u610f\u4e24\u4e2a\u6570\u7684\u6c49\u540d\u8ddd\u79bb\u548c\u3002\u4f8b\u5982 arr = [4, 14, 2], \u5176\u6c49\u660e\u8ddd\u79bb\u548c\u662f\uff084\uff0c14\uff09+\uff084\uff0c2\uff09+\uff0814\uff0c2\uff09= 2 + 2 + 2 = 6 1 2 3 4 5 6 7 8 9 10 11 12 int totalHammingDistance ( vector < int >& nums ) { int n = ( int ) nums . size (); int ans = 0 ; for ( int i = 0 ; i < 30 ; i ++ ) { int cnt = 0 ; for ( int num : nums ) { cnt += ( num >> i ) & 1 ; } ans += cnt * ( n - cnt ); } return ans ; }","title":"\u6c49\u660e\u8ddd\u79bb"},{"location":"algo/matrix/","text":"\u65b9\u9635\u65cb\u8f6c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u65b9\u9635 n \\times n n \\times n \uff0c\u5c06\u5176\u6309\u7167\u987a\u65f6\u9488\u7684\u65b9\u5411\u65cb\u8f6c 90\u02da\u3002\u8981\u6c42\u4f7f\u7528\u5e38\u6570\u7a7a\u95f4\u3002 \u300c\u5206\u6790\u300d \u76f4\u63a5\u6309\u7167\u9898\u610f\u8fdb\u884c\u6a21\u62df\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u4e00\u6b21\u65cb\u8f6c 90\u02da \u76f8\u5f53\u4e8e\u6240\u6709\u7684\u5143\u7d20\u987a\u65f6\u9488\u8f6c\u52a8\u4e00\u6b21\uff0c\u4f8b\u5982 (0, 0) -> (0, n-1) -> (n-1, n-1) -> (n-1, 0) -> (0, 0)\u3002\u5e76\u4e14\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u5916\u5708\u7684\u5143\u7d20\u5747\u662f\u5982\u6b64\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 void rotate ( vector < vector < int >>& matrix ) { int n = ( int ) matrix . size (); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - i - 1 ; j ++ ) { int tmp = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ n - 1 - j ][ i ]; matrix [ n - 1 - j ][ i ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ j ][ n - 1 - i ]; matrix [ j ][ n - 1 - i ] = tmp ; } } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u77e9\u9635"},{"location":"algo/matrix/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u65b9\u9635 n \\times n n \\times n \uff0c\u5c06\u5176\u6309\u7167\u987a\u65f6\u9488\u7684\u65b9\u5411\u65cb\u8f6c 90\u02da\u3002\u8981\u6c42\u4f7f\u7528\u5e38\u6570\u7a7a\u95f4\u3002 \u300c\u5206\u6790\u300d \u76f4\u63a5\u6309\u7167\u9898\u610f\u8fdb\u884c\u6a21\u62df\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u4e00\u6b21\u65cb\u8f6c 90\u02da \u76f8\u5f53\u4e8e\u6240\u6709\u7684\u5143\u7d20\u987a\u65f6\u9488\u8f6c\u52a8\u4e00\u6b21\uff0c\u4f8b\u5982 (0, 0) -> (0, n-1) -> (n-1, n-1) -> (n-1, 0) -> (0, 0)\u3002\u5e76\u4e14\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u5916\u5708\u7684\u5143\u7d20\u5747\u662f\u5982\u6b64\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 void rotate ( vector < vector < int >>& matrix ) { int n = ( int ) matrix . size (); if ( n <= 1 ) { return ; } for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - i - 1 ; j ++ ) { int tmp = matrix [ i ][ j ]; matrix [ i ][ j ] = matrix [ n - 1 - j ][ i ]; matrix [ n - 1 - j ][ i ] = matrix [ n - 1 - i ][ n - 1 - j ]; matrix [ n - 1 - i ][ n - 1 - j ] = matrix [ j ][ n - 1 - i ]; matrix [ j ][ n - 1 - i ] = tmp ; } } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u65b9\u9635\u65cb\u8f6c"},{"location":"algo/prefix-sum/","text":"\u7b80\u4ecb \u00b6 \u524d\u7f00\u548c\uff0c\u987e\u540d\u601d\u4e49\uff0c\u5c06\u4e00\u4e2a\u5e8f\u5217\u7684\u524d n \u4e2a\u5143\u7d20\u7d2f\u52a0\u8d77\u6765\u3002 \u548c\u4e3aK\u7684\u5b50\u6570\u7ec4 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u548c\u4e00\u4e2a k \u503c\uff0c\u6c42\u6240\u6709\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u7b49\u4e8e k \u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u66b4\u529b\u679a\u4e3e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\u8fbe n^{3} n^{3} \uff0c\u5229\u7528\u524d\u7f00\u548c\u7684\u590d\u6742\u5ea6\u4e5f\u4f1a\u8fbe\u5230 n^{2} n^{2} \uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u524d\u7f00\u548c + \u54c8\u5e0c\u8868\u8fdb\u4e00\u6b65\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 int ans = 0 , sum = 0 ; unordered_map < int , int > cnt ; for ( int num : nums ) { sum += num ; if ( sum == k ) { ans ++ ; } if ( cnt . count ( sum - k )) { ans += cnt [ sum - k ]; } cnt [ sum ] ++ ; } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002 \u5143\u7d20\u548c\u4e3a\u76ee\u6807\u503c\u7684\u5b50\u77e9\u9635\u6570\u91cf \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u77e9\u9635 matrix \uff08 m \\times n m \\times n \uff09 \u548c\u4e00\u4e2a\u76ee\u6807\u503c target\uff0c\u8ba1\u7b97\u51fa\u6240\u6709\u7684\u5b50\u77e9\u9635\u548c\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u9898\u76ee\u8981\u6c42\u662f\u77e9\u9635\u548c\uff0c\u5f88\u5bb9\u6613\u8054\u60f3\u5230\u524d\u7f00\u548c\u3002\u4f46\u662f\u5982\u679c\u5728\u524d\u7f00\u548c\u7684\u57fa\u7840\u4e0a\uff0c\u66b4\u529b\u5faa\u73af\u6c42\u89e3\u7684\u8bdd\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(m^{2}n^{2}) O(m^{2}n^{2}) \uff0c\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u4e3a\u4e86\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u6211\u4eec\u4f7f\u7528\u54c8\u5e0c\u8868\u7684\u65b9\u6cd5\u3002\u5177\u4f53\u5730\uff0c\u4e00\u4e2a\u77e9\u5f62\u6709\u56db\u4e2a\u8fb9\u957f\uff0c\u6211\u4eec\u9996\u5148\u786e\u5b9a\u4e0a\u8fb9\u548c\u4e0b\u8fb9\uff0c\u5728\u4f9d\u6b21\u904d\u5386\u5de6\u8fb9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6b64\u65f6\u7684\u5b50\u77e9\u9635\u7684\u548c\u53ca\u51fa\u73b0\u7684\u9891\u7387\uff0c\u5982\u679c\u540e\u7eed\u7684\u66f4\u5927\u77e9\u9635\u548c\u4e0e\u76ee\u6807\u503c\u7684\u5dee\u503c\u5b58\u5728\u4e0e\u54c8\u5e0c\u8868\u4e2d\uff0c\u90a3\u4e48\u53ef\u4ee5\u5c06\u5177\u6709\u8fd9\u4e9b\u77e9\u9635\u548c\u7684\u4e2a\u6570\u7d2f\u52a0\u8d77\u6765\u3002 \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 vector < vector < int >> sum ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { sum [ i ][ j ] = sum [ i + 1 ][ j ] + sum [ i ][ j + 1 ] - sum [ i + 1 ][ j + 1 ] + matrix [ i ][ j ]; } } for ( int tot = nRow - 1 ; tot >= 0 ; tot -- ) { for ( int bot = nRow - 1 ; bot >= tot ; bot -- ) { unordered_map < int , int > cnt ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { int curSum = sum [ tot ][ j ] - sum [ bot + 1 ][ j ]; if ( curSum == target ) { ans ++ ; } if ( cnt . count ( curSum - target )) { ans += cnt [ curSum - target ]; } cnt [ curSum ] ++ ; } } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{2}n) O(m^{2}n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(mn) O(mn) \uff0cm \u4e3a\u77e9\u9635\u7684\u884c\u6570\uff0cn \u4e3a\u77e9\u9635\u7684\u5217\u6570 \u8fde\u7eed\u7684\u5b50\u6570\u7ec4\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u5982 [23, 2, 4, 6, 7] \u548c\u4e00\u4e2a\u6574\u6570 k \u5982 6\uff0c\u5148\u5224\u65ad\u8fd9\u4e2a\u6570\u7ec4\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\uff0c\u5176\u548c\u662f k \u7684\u6574\u6570\u500d\u3002\u8fd9\u91cc\u8981\u6c42\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u81f3\u5c11\u4e3a 2\u3002 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c\u5bf9 k \u7684\u4f59\u6570 + \u54c8\u5e0c\u8868 \u5b58\u5728\u8fd9\u6837\u4e00\u4e2a\u5173\u7cfb\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u5bf9\u540c\u4e00\u4e2a\u6570 k \u53d6\u4f59\u7684\u503c\u76f8\u540c\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2a\u503c\u7684\u5dee\u503c\u4e00\u5b9a\u662f\u8fd9\u4e2a k \u7684\u6574\u6570\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n = ( int ) nums . size (); if ( n < 2 ) { return false ; } unordered_map < int , int > dict ; int sum = 0 ; dict [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += nums [ i ]; int remainder = sum % k ; if ( dict . count ( remainder )) { if ( i - dict [ remainder ] >= 2 ) { return true ; } } else { dict [ remainder ] = i ; } } return false ; \u6700\u957f01\u7b49\u91cf\u5b50\u4e32 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b0\u548c1\u7684\u5b57\u7b26\u4e32\u5982\"0010011001001010110\"\uff0c\u6c42\u5176\u6700\u957f\u5b50\u4e32\uff0c\u8fd9\u4e2a\u5b50\u4e32\u4e2d0\u548c1\u7684\u4e2a\u6570\u76f8\u7b49\uff0c\u7ed9\u51fa\u7684\u4f8b\u5b50\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\u4e3a 16 \u7684 01 \u5b50\u4e32 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c + \u54c8\u5e0c\u8868 \u6211\u4eec\u6309\u7167\u987a\u5e8f\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u8ba1\u7b97\u5f53\u524d\u65f6\u523b\u7684 01 \u4e2a\u6570\u5dee\u522b\uff0c\u5e76\u5c06\u8fd9\u5dee\u503c\u4fdd\u5b58\u5728\u4e00\u4e2a\u54c8\u5e0c\u8868\u503c\uff0c\u5982\u679c\u540e\u7eed\u518d\u6b21\u51fa\u73b0\u76f8\u540c\u7684\u5dee\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5feb\u901f\u7684\u8ba1\u7b97\u51fa\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u5e76\u4e14\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u5b50\u4e32\u4e00\u5b9a\u662f 01 \u7b49\u957f\u7684\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e0d\u8981\u9057\u5fd8\u7a7a\u5b57\u7b26\u4e32\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getLongest01SubstrLen ( string str ) { int len = 0 , n = ( int ) str . length (); vector < int > dp ( n + 1 , 0 ); unordered_map < int , int > dict ; dict [ 0 ] = n ; int pos = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { dp [ i ] = dp [ i + 1 ] + 1 ; } else { dp [ i ] = dp [ i + 1 ] - 1 ; } if ( dict . find ( dp [ i ]) != dict . end ()) { len = max ( len , dict [ dp [ i ]] - i ); pos = i ; } else { dict [ dp [ i ]] = i ; } } printf ( \"maxLenSubstr = %s \\n \" , str . substr ( pos , len ). c_str ()); return len ; }","title":"\u524d\u7f00\u548c"},{"location":"algo/prefix-sum/#_1","text":"\u524d\u7f00\u548c\uff0c\u987e\u540d\u601d\u4e49\uff0c\u5c06\u4e00\u4e2a\u5e8f\u5217\u7684\u524d n \u4e2a\u5143\u7d20\u7d2f\u52a0\u8d77\u6765\u3002","title":"\u7b80\u4ecb"},{"location":"algo/prefix-sum/#k","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u548c\u4e00\u4e2a k \u503c\uff0c\u6c42\u6240\u6709\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u7b49\u4e8e k \u7684\u4e2a\u6570 \u300c\u5206\u6790\u300d \u66b4\u529b\u679a\u4e3e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\u8fbe n^{3} n^{3} \uff0c\u5229\u7528\u524d\u7f00\u548c\u7684\u590d\u6742\u5ea6\u4e5f\u4f1a\u8fbe\u5230 n^{2} n^{2} \uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u524d\u7f00\u548c + \u54c8\u5e0c\u8868\u8fdb\u4e00\u6b65\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002 1 2 3 4 5 6 7 8 9 10 11 int ans = 0 , sum = 0 ; unordered_map < int , int > cnt ; for ( int num : nums ) { sum += num ; if ( sum == k ) { ans ++ ; } if ( cnt . count ( sum - k )) { ans += cnt [ sum - k ]; } cnt [ sum ] ++ ; } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002","title":"\u548c\u4e3aK\u7684\u5b50\u6570\u7ec4"},{"location":"algo/prefix-sum/#_2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u77e9\u9635 matrix \uff08 m \\times n m \\times n \uff09 \u548c\u4e00\u4e2a\u76ee\u6807\u503c target\uff0c\u8ba1\u7b97\u51fa\u6240\u6709\u7684\u5b50\u77e9\u9635\u548c\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u9898\u76ee\u8981\u6c42\u662f\u77e9\u9635\u548c\uff0c\u5f88\u5bb9\u6613\u8054\u60f3\u5230\u524d\u7f00\u548c\u3002\u4f46\u662f\u5982\u679c\u5728\u524d\u7f00\u548c\u7684\u57fa\u7840\u4e0a\uff0c\u66b4\u529b\u5faa\u73af\u6c42\u89e3\u7684\u8bdd\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(m^{2}n^{2}) O(m^{2}n^{2}) \uff0c\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u4e3a\u4e86\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u6211\u4eec\u4f7f\u7528\u54c8\u5e0c\u8868\u7684\u65b9\u6cd5\u3002\u5177\u4f53\u5730\uff0c\u4e00\u4e2a\u77e9\u5f62\u6709\u56db\u4e2a\u8fb9\u957f\uff0c\u6211\u4eec\u9996\u5148\u786e\u5b9a\u4e0a\u8fb9\u548c\u4e0b\u8fb9\uff0c\u5728\u4f9d\u6b21\u904d\u5386\u5de6\u8fb9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6b64\u65f6\u7684\u5b50\u77e9\u9635\u7684\u548c\u53ca\u51fa\u73b0\u7684\u9891\u7387\uff0c\u5982\u679c\u540e\u7eed\u7684\u66f4\u5927\u77e9\u9635\u548c\u4e0e\u76ee\u6807\u503c\u7684\u5dee\u503c\u5b58\u5728\u4e0e\u54c8\u5e0c\u8868\u4e2d\uff0c\u90a3\u4e48\u53ef\u4ee5\u5c06\u5177\u6709\u8fd9\u4e9b\u77e9\u9635\u548c\u7684\u4e2a\u6570\u7d2f\u52a0\u8d77\u6765\u3002 \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} \\begin{matrix} 0 & 1 & 0 \\\\ 1 & 1 & 1 \\\\ 0 & 1 & 0 \\end{matrix} \\xrightarrow[]{\u524d\u7f00\u548c} \\begin{matrix} j \\\\ \\downarrow \\\\ 0 & 1 & 0 & \\leftarrow & \\text{top} \\\\ 1 & 1 & 1 & \\leftarrow & \\text{bottom} \\\\ 0 & 1 & 0 \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 vector < vector < int >> sum ( nRow + 1 , vector < int > ( nCol + 1 , 0 )); for ( int i = nRow - 1 ; i >= 0 ; i -- ) { for ( int j = nCol - 1 ; j >= 0 ; j -- ) { sum [ i ][ j ] = sum [ i + 1 ][ j ] + sum [ i ][ j + 1 ] - sum [ i + 1 ][ j + 1 ] + matrix [ i ][ j ]; } } for ( int tot = nRow - 1 ; tot >= 0 ; tot -- ) { for ( int bot = nRow - 1 ; bot >= tot ; bot -- ) { unordered_map < int , int > cnt ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { int curSum = sum [ tot ][ j ] - sum [ bot + 1 ][ j ]; if ( curSum == target ) { ans ++ ; } if ( cnt . count ( curSum - target )) { ans += cnt [ curSum - target ]; } cnt [ curSum ] ++ ; } } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m^{2}n) O(m^{2}n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(mn) O(mn) \uff0cm \u4e3a\u77e9\u9635\u7684\u884c\u6570\uff0cn \u4e3a\u77e9\u9635\u7684\u5217\u6570","title":"\u5143\u7d20\u548c\u4e3a\u76ee\u6807\u503c\u7684\u5b50\u77e9\u9635\u6570\u91cf"},{"location":"algo/prefix-sum/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 nums \u5982 [23, 2, 4, 6, 7] \u548c\u4e00\u4e2a\u6574\u6570 k \u5982 6\uff0c\u5148\u5224\u65ad\u8fd9\u4e2a\u6570\u7ec4\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\uff0c\u5176\u548c\u662f k \u7684\u6574\u6570\u500d\u3002\u8fd9\u91cc\u8981\u6c42\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u81f3\u5c11\u4e3a 2\u3002 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c\u5bf9 k \u7684\u4f59\u6570 + \u54c8\u5e0c\u8868 \u5b58\u5728\u8fd9\u6837\u4e00\u4e2a\u5173\u7cfb\uff0c\u5982\u679c\u4e24\u4e2a\u6570\u5bf9\u540c\u4e00\u4e2a\u6570 k \u53d6\u4f59\u7684\u503c\u76f8\u540c\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2a\u503c\u7684\u5dee\u503c\u4e00\u5b9a\u662f\u8fd9\u4e2a k \u7684\u6574\u6570\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n = ( int ) nums . size (); if ( n < 2 ) { return false ; } unordered_map < int , int > dict ; int sum = 0 ; dict [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += nums [ i ]; int remainder = sum % k ; if ( dict . count ( remainder )) { if ( i - dict [ remainder ] >= 2 ) { return true ; } } else { dict [ remainder ] = i ; } } return false ;","title":"\u8fde\u7eed\u7684\u5b50\u6570\u7ec4\u548c"},{"location":"algo/prefix-sum/#01","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b0\u548c1\u7684\u5b57\u7b26\u4e32\u5982\"0010011001001010110\"\uff0c\u6c42\u5176\u6700\u957f\u5b50\u4e32\uff0c\u8fd9\u4e2a\u5b50\u4e32\u4e2d0\u548c1\u7684\u4e2a\u6570\u76f8\u7b49\uff0c\u7ed9\u51fa\u7684\u4f8b\u5b50\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\u4e3a 16 \u7684 01 \u5b50\u4e32 \u300c\u5206\u6790\u300d \u524d\u7f00\u548c + \u54c8\u5e0c\u8868 \u6211\u4eec\u6309\u7167\u987a\u5e8f\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u8ba1\u7b97\u5f53\u524d\u65f6\u523b\u7684 01 \u4e2a\u6570\u5dee\u522b\uff0c\u5e76\u5c06\u8fd9\u5dee\u503c\u4fdd\u5b58\u5728\u4e00\u4e2a\u54c8\u5e0c\u8868\u503c\uff0c\u5982\u679c\u540e\u7eed\u518d\u6b21\u51fa\u73b0\u76f8\u540c\u7684\u5dee\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5feb\u901f\u7684\u8ba1\u7b97\u51fa\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u5e76\u4e14\u8fd9\u4e24\u4e2a\u7d22\u5f15\u4e4b\u95f4\u7684\u5b50\u4e32\u4e00\u5b9a\u662f 01 \u7b49\u957f\u7684\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e0d\u8981\u9057\u5fd8\u7a7a\u5b57\u7b26\u4e32\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getLongest01SubstrLen ( string str ) { int len = 0 , n = ( int ) str . length (); vector < int > dp ( n + 1 , 0 ); unordered_map < int , int > dict ; dict [ 0 ] = n ; int pos = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { dp [ i ] = dp [ i + 1 ] + 1 ; } else { dp [ i ] = dp [ i + 1 ] - 1 ; } if ( dict . find ( dp [ i ]) != dict . end ()) { len = max ( len , dict [ dp [ i ]] - i ); pos = i ; } else { dict [ dp [ i ]] = i ; } } printf ( \"maxLenSubstr = %s \\n \" , str . substr ( pos , len ). c_str ()); return len ; }","title":"\u6700\u957f01\u7b49\u91cf\u5b50\u4e32"},{"location":"algo/search/","text":"DFS \u00b6 \u300c\u7b80\u4ecb\u300d \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08Depth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u5b50\u8282\u70b9\uff0c\u5982\u679c\u53ef\u4ee5\u641c\u7d22\u5230\u76ee\u6807\uff0c\u5373\u505c\u6b62\u6216\u5c06\u7ed3\u679c\u4fdd\u5b58\u8d77\u6765\uff1b\u53cd\u4e4b\uff0c\u56de\u6eaf\u5230\u5206\u53c9\u5904\uff0c\u4f9d\u6b21\u904d\u5386\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002 \u5168\u6392\u5217 \u00b6 \u300c\u5e8f\u5217\u5143\u7d20\u4e0d\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [1, 2, 3] ,\u5143\u7d20\u4e92\u4e0d\u76f8\u540c\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void dfs ( vector < int > & nums , int n , int idx , vector < vector < int >> & ans ) { if ( idx == n ) { ans . emplace_back ( nums ); return ; } for ( int i = idx ; i < n ; i ++ ) { swap ( nums [ i ], nums [ idx ]); dfs ( nums , n , idx + 1 , ans ); swap ( nums [ i ], nums [ idx ]); } } vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } dfs ( nums , n , 0 , ans ); return ans ; } \u300c\u5e8f\u5217\u5143\u7d20\u6709\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [3, 3, 0, 3] \uff0c\u5143\u7d20\u6709\u91cd\u590d\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void dfs ( vector < vector < int >> & ans , vector < int > & nums , int n , int idx , bool * vis , vector < int > & arr ) { if ( idx == n ) { ans . emplace_back ( arr ); return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! vis [ i - 1 ])) { continue ; } vis [ i ] = true ; arr . emplace_back ( nums [ i ]); dfs ( ans , nums , n , idx + 1 , vis , arr ); arr . pop_back (); vis [ i ] = false ; } } vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } sort ( nums . begin (), nums . end ()); vector < int > arr ; bool * vis = new bool [ n ]{}; dfs ( ans , nums , n , 0 , vis , arr ); delete [] vis ; return ans ; } BFS \u00b6 \u300c\u7b80\u4ecb\u300d \u5bbd\u5ea6\u4f18\u5148\u641c\u7d22\uff08Breadth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u6240\u6709\u76f4\u63a5\u90bb\u5c45\u8282\u70b9\uff0c\u4e00\u822c\u800c\u8a00\uff0cBFS \u9002\u7528\u4e8e\u6c42\u89e3\u6700\u77ed\u957f\u5ea6\u7684\u95ee\u9898\u3002\u5728\u6c42\u89e3\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u901a\u5e38\u4f9d\u8d56 queue \u8fd9\u4e00\u6570\u636e\u7ed3\u6784\u3002 BFS \u6709\u5355\u5411\u548c\u53cc\u5411\u4e24\u79cd\u65b9\u5f0f\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u533a\u522b\uff0c\u4f46\u53cc\u5411\u5728\u65f6\u95f4\u6548\u7387\u4e0a\u5177\u6709\u4f18\u52bf\u3002 \u4f8b\u5982\uff0c\u73b0\u6709\u4e00\u5f20\u5730\u56fe\uff0c\u7531 0 \u548c 1 \u7ec4\u6210\uff0c\u6bcf\u6b21\u79fb\u52a8\u53ef\u4ee5\u671d\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u3001\u4e0a\u5de6\u3001\u4e0a\u53f3\u3001\u4e0b\u5de6\u548c\u4e0b\u53f3\u8fd9\u516b\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u5e76\u53ea\u5141\u8bb8\u843d\u5165 0 \u7684\u683c\u5b50\uff0c\u6c42\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u5982\u679c\u4e0d\u80fd\u5230\u8fbe\uff0c\u8fd4\u56de -1\u3002 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \u6700\u77ed\u7684\u957f\u5ea6\u662f 11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int shortestPathBinaryMatrix ( vector < vector < int >>& grid ) { int nRow = ( int ) grid . size (); if ( nRow == 0 ) { return - 1 ; } if ( nRow == 1 ) { return 1 ; } int nCol = ( int ) grid [ 0 ]. size (); int direction [ 8 ][ 2 ] = { { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 }, { 0 , - 1 }, { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 } }; if ( grid [ 0 ][ 0 ] || grid [ nRow - 1 ][ nCol - 1 ]) { return - 1 ; } queue < vector < int >> q1 , q2 ; q1 . push ({ 0 , 0 }); q2 . push ({ nRow - 1 , nCol - 1 }); int ans = 0 ; while ( ! q1 . empty () && ! q2 . empty ()) { int size1 = ( int ) q1 . size (); while ( size1 -- ) { int x = q1 . front ()[ 0 ]; int y = q1 . front ()[ 1 ]; q1 . pop (); if ( grid [ x ][ y ] == 3 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 2 ) { continue ; } grid [ x ][ y ] = 2 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 2 ) { continue ; } q1 . push ({ nx , ny }); } } ans ++ ; int size2 = ( int ) q2 . size (); while ( size2 -- ) { int x = q2 . front ()[ 0 ]; int y = q2 . front ()[ 1 ]; q2 . pop (); if ( grid [ x ][ y ] == 2 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 3 ) { continue ; } grid [ x ][ y ] = 3 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 3 ) { continue ; } q2 . push ({ nx , ny }); } } ans ++ ; } return - 1 ; }","title":"\u641c\u7d22"},{"location":"algo/search/#dfs","text":"\u300c\u7b80\u4ecb\u300d \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08Depth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u5b50\u8282\u70b9\uff0c\u5982\u679c\u53ef\u4ee5\u641c\u7d22\u5230\u76ee\u6807\uff0c\u5373\u505c\u6b62\u6216\u5c06\u7ed3\u679c\u4fdd\u5b58\u8d77\u6765\uff1b\u53cd\u4e4b\uff0c\u56de\u6eaf\u5230\u5206\u53c9\u5904\uff0c\u4f9d\u6b21\u904d\u5386\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002","title":"DFS"},{"location":"algo/search/#_1","text":"\u300c\u5e8f\u5217\u5143\u7d20\u4e0d\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [1, 2, 3] ,\u5143\u7d20\u4e92\u4e0d\u76f8\u540c\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void dfs ( vector < int > & nums , int n , int idx , vector < vector < int >> & ans ) { if ( idx == n ) { ans . emplace_back ( nums ); return ; } for ( int i = idx ; i < n ; i ++ ) { swap ( nums [ i ], nums [ idx ]); dfs ( nums , n , idx + 1 , ans ); swap ( nums [ i ], nums [ idx ]); } } vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } dfs ( nums , n , 0 , ans ); return ans ; } \u300c\u5e8f\u5217\u5143\u7d20\u6709\u91cd\u590d\u300d \u5bf9\u4e00\u4e2a\u5e8f\u5217\u5982 [3, 3, 0, 3] \uff0c\u5143\u7d20\u6709\u91cd\u590d\uff0c\u6c42\u5176\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void dfs ( vector < vector < int >> & ans , vector < int > & nums , int n , int idx , bool * vis , vector < int > & arr ) { if ( idx == n ) { ans . emplace_back ( arr ); return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! vis [ i - 1 ])) { continue ; } vis [ i ] = true ; arr . emplace_back ( nums [ i ]); dfs ( ans , nums , n , idx + 1 , vis , arr ); arr . pop_back (); vis [ i ] = false ; } } vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; int n = ( int ) nums . size (); if ( n == 0 ) { return ans ; } sort ( nums . begin (), nums . end ()); vector < int > arr ; bool * vis = new bool [ n ]{}; dfs ( ans , nums , n , 0 , vis , arr ); delete [] vis ; return ans ; }","title":"\u5168\u6392\u5217"},{"location":"algo/search/#bfs","text":"\u300c\u7b80\u4ecb\u300d \u5bbd\u5ea6\u4f18\u5148\u641c\u7d22\uff08Breadth Ffirst Search\uff09\u662f\u4e00\u79cd\u68c0\u7d22\u65b9\u6cd5\uff0c\u4f18\u5148\u641c\u7d22\u67d0\u4e00\u8282\u70b9\u7684\u6240\u6709\u76f4\u63a5\u90bb\u5c45\u8282\u70b9\uff0c\u4e00\u822c\u800c\u8a00\uff0cBFS \u9002\u7528\u4e8e\u6c42\u89e3\u6700\u77ed\u957f\u5ea6\u7684\u95ee\u9898\u3002\u5728\u6c42\u89e3\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u901a\u5e38\u4f9d\u8d56 queue \u8fd9\u4e00\u6570\u636e\u7ed3\u6784\u3002 BFS \u6709\u5355\u5411\u548c\u53cc\u5411\u4e24\u79cd\u65b9\u5f0f\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u533a\u522b\uff0c\u4f46\u53cc\u5411\u5728\u65f6\u95f4\u6548\u7387\u4e0a\u5177\u6709\u4f18\u52bf\u3002 \u4f8b\u5982\uff0c\u73b0\u6709\u4e00\u5f20\u5730\u56fe\uff0c\u7531 0 \u548c 1 \u7ec4\u6210\uff0c\u6bcf\u6b21\u79fb\u52a8\u53ef\u4ee5\u671d\u4e0a\u3001\u4e0b\u3001\u5de6\u3001\u53f3\u3001\u4e0a\u5de6\u3001\u4e0a\u53f3\u3001\u4e0b\u5de6\u548c\u4e0b\u53f3\u8fd9\u516b\u4e2a\u65b9\u5411\u79fb\u52a8\u4e00\u683c\uff0c\u5e76\u53ea\u5141\u8bb8\u843d\u5165 0 \u7684\u683c\u5b50\uff0c\u6c42\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u5982\u679c\u4e0d\u80fd\u5230\u8fbe\uff0c\u8fd4\u56de -1\u3002 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 0 & 1 \\\\ 0 & 1 & 1 & {\\color{Red} 0} & 1 \\\\ 0 & {\\color{Red} 0} & {\\color{Red} 0} & 1 & 1 \\\\ {\\color{Red} 0} & 1 & 1 & 1 & 0 \\\\ 1 & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} \\end{matrix} \u6700\u77ed\u7684\u957f\u5ea6\u662f 11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int shortestPathBinaryMatrix ( vector < vector < int >>& grid ) { int nRow = ( int ) grid . size (); if ( nRow == 0 ) { return - 1 ; } if ( nRow == 1 ) { return 1 ; } int nCol = ( int ) grid [ 0 ]. size (); int direction [ 8 ][ 2 ] = { { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 }, { 0 , - 1 }, { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 } }; if ( grid [ 0 ][ 0 ] || grid [ nRow - 1 ][ nCol - 1 ]) { return - 1 ; } queue < vector < int >> q1 , q2 ; q1 . push ({ 0 , 0 }); q2 . push ({ nRow - 1 , nCol - 1 }); int ans = 0 ; while ( ! q1 . empty () && ! q2 . empty ()) { int size1 = ( int ) q1 . size (); while ( size1 -- ) { int x = q1 . front ()[ 0 ]; int y = q1 . front ()[ 1 ]; q1 . pop (); if ( grid [ x ][ y ] == 3 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 2 ) { continue ; } grid [ x ][ y ] = 2 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 2 ) { continue ; } q1 . push ({ nx , ny }); } } ans ++ ; int size2 = ( int ) q2 . size (); while ( size2 -- ) { int x = q2 . front ()[ 0 ]; int y = q2 . front ()[ 1 ]; q2 . pop (); if ( grid [ x ][ y ] == 2 ) { return ans ; } if ( grid [ x ][ y ] == 1 || grid [ x ][ y ] == 3 ) { continue ; } grid [ x ][ y ] = 3 ; for ( auto d : direction ) { int nx = x + d [ 0 ]; int ny = y + d [ 1 ]; if ( nx < 0 || nx >= nRow || ny < 0 || ny >= nCol || grid [ nx ][ ny ] == 1 || grid [ nx ][ ny ] == 3 ) { continue ; } q2 . push ({ nx , ny }); } } ans ++ ; } return - 1 ; }","title":"BFS"},{"location":"algo/two-pointers/","text":"\u76f8\u5173\u9898\u76ee \u00b6 \u300cLeetcode 3. \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u4e0d\u542b\u6709\u91cd\u590d\u5b57\u7b26\u7684 \u6700\u957f\u5b50\u4e32 \u7684\u957f\u5ea6\u3002 \u8f93\u5165: s = \"abcabcbb\" \u8f93\u51fa: 3 \u89e3\u91ca: \u56e0\u4e3a\u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u662f \"abc\"\uff0c\u6240\u4ee5\u5176\u957f\u5ea6\u4e3a 3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lengthOfLongestSubstring ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } int i = 0 , j = 0 , maxLen = 0 ; unordered_set < char > hash ; while ( j < n ) { if ( hash . count ( s [ j ])) { hash . erase ( s [ i ++ ]); } else { hash . insert ( s [ j ++ ]); maxLen = max ( maxLen , j - i ); } } return maxLen ; } \u300cLeetcode 15. \u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u4f60\u4e00\u4e2a\u5305\u542b n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums\uff0c\u5224\u65ad nums \u4e2d\u662f\u5426\u5b58\u5728\u4e09\u4e2a\u5143\u7d20a\uff0cb\uff0cc \uff0c\u4f7f\u5f97 a + b + c = 0 \uff1f\u8bf7\u4f60\u627e\u51fa\u6240\u6709\u548c\u4e3a 0 \u4e14\u4e0d\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 \u6ce8\u610f\uff1a\u7b54\u6848\u4e2d\u4e0d\u53ef\u4ee5\u5305\u542b\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < vector < int >> threeSum ( vector < int >& nums ) { int n = int ( nums . size ()); vector < vector < int >> ans ; if ( n < 3 ) { return ans ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) { j ++ ; } else if ( sum > 0 ) { k -- ; } else { while ( i < k && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < k && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( j < k && nums [ k ] == nums [ k - 1 ]) { k -- ; } ans . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); j ++ ; k -- ; } } } return ans ; } \u300cLeetcode 16. \u6700\u63a5\u8fd1\u7684\u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5305\u62ec n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums \u548c \u4e00\u4e2a\u76ee\u6807\u503c target\u3002\u627e\u51fa nums \u4e2d\u7684\u4e09\u4e2a\u6574\u6570\uff0c\u4f7f\u5f97\u5b83\u4eec\u7684\u548c\u4e0e target \u6700\u63a5\u8fd1\u3002\u8fd4\u56de\u8fd9\u4e09\u4e2a\u6570\u7684\u548c\u3002\u5047\u5b9a\u6bcf\u7ec4\u8f93\u5165\u53ea\u5b58\u5728\u552f\u4e00\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int threeSumClosest ( vector < int >& nums , int target ) { int n = int ( nums . size ()), res = 0 , diff = ( 1ll << 31 ) - 1 ; if ( n < 3 ) { return 0 ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i <= n - 3 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( abs ( sum - target ) < diff ) { diff = abs ( sum - target ); res = sum ; } if ( sum < target ) { j ++ ; } else if ( sum > target ) { k -- ; } else { return target ; } } } return res ; }","title":"\u53cc\u6307\u9488"},{"location":"algo/two-pointers/#_1","text":"\u300cLeetcode 3. \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8bf7\u4f60\u627e\u51fa\u5176\u4e2d\u4e0d\u542b\u6709\u91cd\u590d\u5b57\u7b26\u7684 \u6700\u957f\u5b50\u4e32 \u7684\u957f\u5ea6\u3002 \u8f93\u5165: s = \"abcabcbb\" \u8f93\u51fa: 3 \u89e3\u91ca: \u56e0\u4e3a\u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u662f \"abc\"\uff0c\u6240\u4ee5\u5176\u957f\u5ea6\u4e3a 3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lengthOfLongestSubstring ( string s ) { int n = int ( s . length ()); if ( n == 0 ) { return 0 ; } int i = 0 , j = 0 , maxLen = 0 ; unordered_set < char > hash ; while ( j < n ) { if ( hash . count ( s [ j ])) { hash . erase ( s [ i ++ ]); } else { hash . insert ( s [ j ++ ]); maxLen = max ( maxLen , j - i ); } } return maxLen ; } \u300cLeetcode 15. \u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u4f60\u4e00\u4e2a\u5305\u542b n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums\uff0c\u5224\u65ad nums \u4e2d\u662f\u5426\u5b58\u5728\u4e09\u4e2a\u5143\u7d20a\uff0cb\uff0cc \uff0c\u4f7f\u5f97 a + b + c = 0 \uff1f\u8bf7\u4f60\u627e\u51fa\u6240\u6709\u548c\u4e3a 0 \u4e14\u4e0d\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 \u6ce8\u610f\uff1a\u7b54\u6848\u4e2d\u4e0d\u53ef\u4ee5\u5305\u542b\u91cd\u590d\u7684\u4e09\u5143\u7ec4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < vector < int >> threeSum ( vector < int >& nums ) { int n = int ( nums . size ()); vector < vector < int >> ans ; if ( n < 3 ) { return ans ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) { j ++ ; } else if ( sum > 0 ) { k -- ; } else { while ( i < k && nums [ i ] == nums [ i + 1 ]) { i ++ ; } while ( j < k && nums [ j ] == nums [ j + 1 ]) { j ++ ; } while ( j < k && nums [ k ] == nums [ k - 1 ]) { k -- ; } ans . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); j ++ ; k -- ; } } } return ans ; } \u300cLeetcode 16. \u6700\u63a5\u8fd1\u7684\u4e09\u6570\u4e4b\u548c\u300d \u7ed9\u5b9a\u4e00\u4e2a\u5305\u62ec n \u4e2a\u6574\u6570\u7684\u6570\u7ec4 nums \u548c \u4e00\u4e2a\u76ee\u6807\u503c target\u3002\u627e\u51fa nums \u4e2d\u7684\u4e09\u4e2a\u6574\u6570\uff0c\u4f7f\u5f97\u5b83\u4eec\u7684\u548c\u4e0e target \u6700\u63a5\u8fd1\u3002\u8fd4\u56de\u8fd9\u4e09\u4e2a\u6570\u7684\u548c\u3002\u5047\u5b9a\u6bcf\u7ec4\u8f93\u5165\u53ea\u5b58\u5728\u552f\u4e00\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int threeSumClosest ( vector < int >& nums , int target ) { int n = int ( nums . size ()), res = 0 , diff = ( 1ll << 31 ) - 1 ; if ( n < 3 ) { return 0 ; } sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i <= n - 3 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( abs ( sum - target ) < diff ) { diff = abs ( sum - target ); res = sum ; } if ( sum < target ) { j ++ ; } else if ( sum > target ) { k -- ; } else { return target ; } } } return res ; }","title":"\u76f8\u5173\u9898\u76ee"},{"location":"algo/dp/basis/","text":"\u7b80\u4ecb \u00b6 \u52a8\u6001\u89c4\u5212\uff08Dynamic programming\uff0c\u7b80\u79f0 DP\uff09\u5c06\u539f\u95ee\u9898\u62c6\u5206\u6210\u82e5\u5e72\u5b50\u95ee\u9898\uff08\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff09\uff0c\u901a\u8fc7\u5206\u522b\u6c42\u89e3\u5b50\u95ee\u9898\uff0c\u5f97\u5230\u539f\u95ee\u9898\u89e3\u7684\u4e00\u79cd\u7b97\u6cd5\u3002 \u8981\u7d20 \u00b6 \u5982\u679c\u4e00\u4e2a\u95ee\u9898\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7\u52a8\u6001\u89c4\u5212\u7684\u65b9\u6cd5\u6c42\u89e3 \u6700\u4f18\u5b50\u7ed3\u6784\uff08optimal structure\uff09 \u539f\u95ee\u9898\u7684\u89e3\u662f\u53ef\u4ee5\u7531\u5b50\u95ee\u9898\u5f97\u5230\u7684\uff08\u9012\u63a8\u6216\u8005\u9012\u5f52\uff09\uff0c\u53cd\u4e4b\uff0c\u4e0d\u80fd\u79f0\u4e4b\u4e3a\u5177\u6709\u6700\u4f18\u5b50\u7ed3\u6784 \u91cd\u53e0\u5b50\u95ee\u9898\uff08overlap subproblem\uff09 \u5f53\u67d0\u4e9b\u5b50\u95ee\u9898\u88ab\u91cd\u590d\u904d\u5386\uff08\u6216\u8005\u539f\u95ee\u9898\u88ab\u5206\u89e3\u6210\u591a\u4e2a\u76f8\u540c\u7684\u5b50\u95ee\u9898\uff09\u65f6\uff0c\u8fd9\u79cd\u60c5\u51b5\u79f0\u4e3a\u91cd\u53e0\u5b50\u95ee\u9898 \u8ba1\u7b97\u6b65\u9aa4 \u00b6 \uff081\uff09 \u63cf\u8ff0\u6700\u4f18\u89e3\u7684\u7ed3\u6784\uff0c\u5373\u7528\u4e00\u4e2a\u72b6\u6001\u8868\u793a\u6700\u4f18\u89e3 \uff082\uff09 \u4ee5\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u7684\u5f62\u5f0f\uff0c\u9012\u5f52\u5730\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \uff083\uff09 \u81ea\u4e0b\u800c\u4e0a\uff08bottom-top\uff09\u6216\u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u5730\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \uff084\uff09 \u6839\u636e\uff083\uff09\u4e2d\u7684\u8fc7\u7a0b\u503c\uff0c\u6784\u9020\u6700\u4f18\u89e3\uff1b\u5982\u679c\u53ea\u9700\u8981\u6700\u4f18\u89e3\u7684\u503c\uff0c\u5219\u65e0\u9700\u672c\u6b65\u9aa4 \u52a8\u6001\u89c4\u5212\u7684\u7279\u70b9 \u00b6 \u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff1a\u4fdd\u5b58\u4e86\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4e2d\u95f4\u503c\uff0c\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97 \u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u6216\u8005\u9012\u5f52\u662f\u4e00\u79cd\u5907\u5fd8\u5f55\uff08memorization\uff09\u65b9\u6cd5 \u4e25\u683c\u6765\u8bf4\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6709\u81ea\u4e0b\u800c\u4e0a\u7684\u65b9\u5f0f\uff1b\u5982\u679c\u6240\u6709\u7684\u5b50\u95ee\u9898\u90fd\u4f1a\u88ab\u8ba1\u7b97\u4e00\u6b21\uff0c\u90a3\u4e48\u52a8\u6001\u89c4\u5212\u5177\u6709\u4f18\u52bf\uff0c\u53cd\u4e4b\uff08\u526a\u679d\u60c5\u51b5\uff09\uff0c\u5907\u5fd8\u5f55\u6cd5\u5177\u6709\u4f18\u52bf \u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5fc3\u7684\u6bd4\u8f83 \u00b6 \u76f8\u540c\u70b9\uff1a \u5177\u5907\u6700\u4f18\u5b50\u7ed3\u6784 \u4e0d\u540c\u70b9\uff1a \u52a8\u6001\u89c4\u5212\u7684\u5b50\u95ee\u9898\u662f\u91cd\u53e0\u7684\uff0c\u8d2a\u5fc3\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0 \u52a8\u6001\u89c4\u5212\u4e0d\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u7684\u6027\u8d28 \u8d2a\u5fc3\u7684\u524d\u8fdb\u8def\u7ebf\u662f\u4e00\u6761\u7ebf\uff0c\u52a8\u6001\u89c4\u5212\u662f\u4e00\u4e2aDAG M\u4e2a\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6b63\u6574\u6570M\uff0c\u8fd4\u56denums\u6570\u7ec4\u4e2dM\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u5143\u7d20\u6700\u5927\u548c \u4f8b\u5982\uff1anums = [-1, 4, -2, 3, -2, 3]\uff0cM = 2\uff0c\u6700\u5927\u548c\u4e3a8 = [ 4 ] + [3, -2, 3] dp[ i ][ j ]\u8868\u793a\uff0c\u524dj\u4e2a\u5143\u7d20\u5728i\u4e2a\u5b50\u6570\u7ec4\u4e2d\u7684\u6700\u5927\u548c\uff0c\u5176\u4e2dnums[ j ]\u843d\u5728\u7b2ci\u4e2a\u5b50\u6570\u7ec4\uff081 <= i <= M\uff0ci <= j <= n\uff09 \u72b6\u6001\u8f6c\u79fb \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \u6ce8\u610f\u5230\u5f53\u524d\u72b6\u6001dp[ i ][ j ]\u53ea\u4e0edp[ i ][j - 1]\u3001dp[i - 1][ t ]\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u4e3a\u53ef\u4ee5\u4f7f\u7528O(n)\u7684\u7a7a\u95f4\uff0cpre[ j ]\u8868\u793a\u4e0a\u4e00\u5c42\u7684\u72b6\u6001\uff0ccur[ j ]\u8868\u793a\u5f53\u524d\u72b6\u6001 \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int maxMSum ( vector < int > nums , int M ) { int n = ( int ) nums . size (), maxSum = INT_MIN ; vector < int > cur ( n + 1 , 0 ), pre ( n + 1 , 0 ); for ( int i = 1 ; i <= M ; i ++ ) { maxSum = INT_MIN ; for ( int j = i ; j <= n ; j ++ ) { cur [ j ] = max ( pre [ j - 1 ], cur [ j - 1 ]) + nums [ j - 1 ]; pre [ j - 1 ] = maxSum ; maxSum = max ( maxSum , cur [ j ]); } pre [ n ] = maxSum ; } return maxSum ; } \u5f53M = 1\u65f6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < int > getMaxSumEpisode ( vector < int > nums ) { int n = int ( nums . size ()); vector < int > ans ; if ( n == 0 ) { return ans ; } int maxSum = - ( 1ll << 31 ), curSum = 0 ; int left = 0 , right = 0 , begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; begin = i ; } if ( maxSum < curSum ) { maxSum = curSum ; left = begin ; right = i ; } } for ( int i = left ; i <= right ; i ++ ) { ans . push_back ( nums [ i ]); } return ans ; } \u76f8\u4f3c\u9898\u76ee \u300cLeetcode 152. \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4\u300d \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8bf7\u4f60\u627e\u51fa\u6570\u7ec4\u4e2d\u4e58\u79ef\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u8be5\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u6570\u5b57\uff09\uff0c\u5e76\u8fd4\u56de\u8be5\u5b50\u6570\u7ec4\u6240\u5bf9\u5e94\u7684\u4e58\u79ef\u3002 \u8f93\u5165: [2,3,-2,4] \u8f93\u51fa: 6 \u89e3\u91ca: \u5b50\u6570\u7ec4 [2,3] \u6709\u6700\u5927\u4e58\u79ef 6\u3002 1 2 3 4 5 6 7 8 9 10 11 int maxProduct ( vector < int >& nums ) { int n = int ( nums . size ()); int minF = nums [ 0 ], maxF = nums [ 0 ], ans = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _min = minF , _max = maxF ; minF = min ( nums [ i ], min ( _min * nums [ i ], _max * nums [ i ])); maxF = max ( nums [ i ], max ( _min * nums [ i ], _max * nums [ i ])); ans = max ( ans , maxF ); } return ans ; } \u300cLeetcode 1186. \u5220\u9664\u4e00\u6b21\u5f97\u5230\u5b50\u6570\u7ec4\u6700\u5927\u548c\u300d \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u67d0\u4e2a\u975e\u7a7a\u5b50\u6570\u7ec4\uff08\u8fde\u7eed\u5143\u7d20\uff09\u5728\u6267\u884c\u4e00\u6b21\u53ef\u9009\u7684\u5220\u9664\u64cd\u4f5c\u540e\uff0c\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u5143\u7d20\u603b\u548c\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u53ef\u4ee5\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u51fa\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5e76\u53ef\u4ee5\u51b3\u5b9a\u8981\u4e0d\u8981\u4ece\u4e2d\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff08\u53ea\u80fd\u5220\u4e00\u6b21\u54e6\uff09\uff0c\uff08\u5220\u9664\u540e\uff09\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5e94\u5f53\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8be5\u5b50\u6570\u7ec4\uff08\u5269\u4e0b\uff09\u7684\u5143\u7d20\u603b\u548c\u662f\u6240\u6709\u5b50\u6570\u7ec4\u4e4b\u4e2d\u6700\u5927\u7684\u3002\u6ce8\u610f\uff0c\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u5b50\u6570\u7ec4 \u4e0d\u80fd\u4e3a\u7a7a\u3002 \u8bf7\u770b\u793a\u4f8b\uff1a \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aarr = [1,-2,0,3] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u6211\u4eec\u53ef\u4ee5\u9009\u51fa [1, -2, 0, 3]\uff0c\u7136\u540e\u5220\u6389 -2\uff0c\u8fd9\u6837\u5f97\u5230 [1, 0, 3]\uff0c\u548c\u6700\u5927\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aarr = [1,-2,-2,3] \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u6211\u4eec\u76f4\u63a5\u9009\u51fa [3]\uff0c\u8fd9\u5c31\u662f\u6700\u5927\u548c\u3002 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1aarr = [-1,-1,-1,-1] \u8f93\u51fa\uff1a-1 \u89e3\u91ca\uff1a\u6700\u540e\u5f97\u5230\u7684\u5b50\u6570\u7ec4\u4e0d\u80fd\u4e3a\u7a7a\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u9009\u62e9 [-1] \u5e76\u4ece\u4e2d\u5220\u53bb -1 \u6765\u5f97\u5230 0\u3002 \u6211\u4eec\u5e94\u8be5\u76f4\u63a5\u9009\u62e9 [-1]\uff0c\u6216\u8005\u9009\u62e9 [-1, -1] \u518d\u4ece\u4e2d\u5220\u53bb\u4e00\u4e2a -1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maximumSum ( vector < int >& arr ) { int n = ( int ) arr . size (); if ( n == 0 ) { return 0 ; } const int minEle = * min_element ( arr . begin (), arr . end ()); int dp0 = arr [ 0 ], dp1 = minEle , ans = dp0 ; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 + arr [ i ], arr [ i ]); int tmp1 = max ( dp0 , dp1 + arr [ i ]); dp0 = tmp0 ; dp1 = tmp1 ; ans = max ( ans , max ( dp0 , dp1 )); } return ans ; } }; \u5e8f\u5217\u578bDP \u00b6 \u300cLeetcode 740. \u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u4f60\u53ef\u4ee5\u5bf9\u5b83\u8fdb\u884c\u4e00\u4e9b\u64cd\u4f5c\u3002 \u6bcf\u6b21\u64cd\u4f5c\u4e2d\uff0c\u9009\u62e9\u4efb\u610f\u4e00\u4e2a nums[i] \uff0c\u5220\u9664\u5b83\u5e76\u83b7\u5f97 nums[i] \u7684\u70b9\u6570\u3002 \u4e4b\u540e\uff0c\u4f60\u5fc5\u987b\u5220\u9664\u6bcf\u4e2a\u7b49\u4e8e nums[i] - 1 \u6216 nums[i] + 1 \u7684\u5143\u7d20\u3002 \u5f00\u59cb\u4f60\u62e5\u6709 0 \u4e2a\u70b9\u6570\u3002\u8fd4\u56de\u4f60\u80fd\u901a\u8fc7\u8fd9\u4e9b\u64cd\u4f5c\u83b7\u5f97\u7684\u6700\u5927\u70b9\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [3,4,2] \u8f93\u51fa\uff1a6 \u89e3\u91ca\uff1a \u5220\u9664 4 \u83b7\u5f97 4 \u4e2a\u70b9\u6570\uff0c\u56e0\u6b64 3 \u4e5f\u88ab\u5220\u9664\u3002 \u4e4b\u540e\uff0c\u5220\u9664 2 \u83b7\u5f97 2 \u4e2a\u70b9\u6570\u3002\u603b\u5171\u83b7\u5f97 6 \u4e2a\u70b9\u6570\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [2,2,3,3,3,4] \u8f93\u51fa\uff1a9 \u89e3\u91ca\uff1a \u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u63a5\u7740\u8981\u5220\u9664\u4e24\u4e2a 2 \u548c 4 \u3002 \u4e4b\u540e\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\u3002 \u603b\u5171\u83b7\u5f97 9 \u4e2a\u70b9\u6570\u3002 */ class Solution { public : int deleteAndEarn ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } map < int , int >:: iterator iter = ++ cnt . begin (); int lastN = cnt . begin () -> first , lastC = cnt . begin () -> second ; int a = 0 , b = lastN * lastC ; for (; iter != cnt . end (); iter ++ ) { int na = max ( a , b ), nb = iter -> first * iter -> second ; if ( lastN + 1 == iter -> first ) { nb += a ; } else { nb += max ( a , b ); } a = na ; b = nb ; lastN = iter -> first ; } return max ( a , b ); } }; \u533a\u95f4\u5f62DP \u00b6 \u5220\u9664\u5b50\u4e32\u7684\u6700\u5c0f\u64cd\u4f5c\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caaabbcbaa\u201d\uff0c\u6bcf\u4e00\u6b21\u53ef\u4ee5\u5220\u9664\u4e00\u4e2a\u7531\u540c\u4e00\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\uff0c\u5220\u9664\u540e\u5269\u4f59\u90e8\u5206\u81ea\u52a8\u62fc\u63a5\u3002\u91cd\u590d\u8fdb\u884c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u7684\u5220\u9664\u6b21\u6570\u3002\u4e3e\u4f8b\u5982\u4e0b\uff1a \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u5220\u9664\u6709\u76f8\u540c\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\u7684\u6700\u5c0f\u6b21\u6570\u3002\u5982\u679c\u4e24\u7aef\u7684\u5b57\u7b26\u76f8\u540c\uff0c\u90a3\u4e48\u72b6\u6001\u8df3\u8f6c\u5230 s[i : j - 1]\uff1b\u5982\u679c\u4e24\u7aef\u5b57\u7b26\u4e32\u4e0d\u60f3\u7b49\uff0c\u90a3\u4e48\u6211\u4eec\u5bfb\u627e\u4e00\u4e2a\u6700\u4f73\u5207\u5206\u70b9 k \uff0c\u4f7f\u5207\u5206\u51fa\u6765\u7684\u4e24\u6bb5\u548c\u6700\u5c0f\u3002\u7279\u522b\u5730\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5355\u5b57\u7b26\uff0c\u6700\u5c0f\u5207\u5272\u6b21\u6570\u662f 1 \u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < vector < int >> dp ( n , vector < int > ( n , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i ][ j - 1 ]; } else { int _min = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { _min = min ( _min , dp [ i ][ k ] + dp [ k + 1 ][ j ]); } dp [ i ][ j ] = _min ; } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \u5220\u9664\u56de\u6587\u4e32\u7684\u6700\u5c0f\u6b21\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caabc\u201d\uff0c\u6bcf\u4e00\u6b21\u5220\u9664\u4e00\u4e2a\u56de\u6587\u5b50\u4e32\uff0c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u7684\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002\u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\u90fd\u4f1a\u9762\u4e34\u4e0b\u9762\u7684\u4e24\u79cd\u60c5\u51b5 \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} case 1 \u53ea\u5220\u9664\u4e00\u4e2a\u5b57\u7b26\uff0ccase 2 \u5220\u9664\u4e00\u4e2a\u533a\u95f4\u7684\u5b57\u7b26 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 , 0 )); dp [ n - 1 ][ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; dp [ i ][ i + 1 ] = 1 + ( s [ i ] != s [ i + 1 ]); for ( int j = i + 2 ; j < n ; j ++ ) { dp [ i ][ j ] = 1 + dp [ i + 1 ][ j ]; if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], 1 + dp [ i + 2 ][ j ]); } for ( int k = i + 2 ; k <= j ; k ++ ) { if ( s [ i ] == s [ k ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i + 1 ][ k - 1 ] + dp [ k + 1 ][ j ]); } } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2})","title":"\u57fa\u7840"},{"location":"algo/dp/basis/#_1","text":"\u52a8\u6001\u89c4\u5212\uff08Dynamic programming\uff0c\u7b80\u79f0 DP\uff09\u5c06\u539f\u95ee\u9898\u62c6\u5206\u6210\u82e5\u5e72\u5b50\u95ee\u9898\uff08\u5b50\u95ee\u9898\u6709\u91cd\u53e0\uff09\uff0c\u901a\u8fc7\u5206\u522b\u6c42\u89e3\u5b50\u95ee\u9898\uff0c\u5f97\u5230\u539f\u95ee\u9898\u89e3\u7684\u4e00\u79cd\u7b97\u6cd5\u3002","title":"\u7b80\u4ecb"},{"location":"algo/dp/basis/#_2","text":"\u5982\u679c\u4e00\u4e2a\u95ee\u9898\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7\u52a8\u6001\u89c4\u5212\u7684\u65b9\u6cd5\u6c42\u89e3 \u6700\u4f18\u5b50\u7ed3\u6784\uff08optimal structure\uff09 \u539f\u95ee\u9898\u7684\u89e3\u662f\u53ef\u4ee5\u7531\u5b50\u95ee\u9898\u5f97\u5230\u7684\uff08\u9012\u63a8\u6216\u8005\u9012\u5f52\uff09\uff0c\u53cd\u4e4b\uff0c\u4e0d\u80fd\u79f0\u4e4b\u4e3a\u5177\u6709\u6700\u4f18\u5b50\u7ed3\u6784 \u91cd\u53e0\u5b50\u95ee\u9898\uff08overlap subproblem\uff09 \u5f53\u67d0\u4e9b\u5b50\u95ee\u9898\u88ab\u91cd\u590d\u904d\u5386\uff08\u6216\u8005\u539f\u95ee\u9898\u88ab\u5206\u89e3\u6210\u591a\u4e2a\u76f8\u540c\u7684\u5b50\u95ee\u9898\uff09\u65f6\uff0c\u8fd9\u79cd\u60c5\u51b5\u79f0\u4e3a\u91cd\u53e0\u5b50\u95ee\u9898","title":"\u8981\u7d20"},{"location":"algo/dp/basis/#_3","text":"\uff081\uff09 \u63cf\u8ff0\u6700\u4f18\u89e3\u7684\u7ed3\u6784\uff0c\u5373\u7528\u4e00\u4e2a\u72b6\u6001\u8868\u793a\u6700\u4f18\u89e3 \uff082\uff09 \u4ee5\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u7684\u5f62\u5f0f\uff0c\u9012\u5f52\u5730\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \uff083\uff09 \u81ea\u4e0b\u800c\u4e0a\uff08bottom-top\uff09\u6216\u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u5730\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \uff084\uff09 \u6839\u636e\uff083\uff09\u4e2d\u7684\u8fc7\u7a0b\u503c\uff0c\u6784\u9020\u6700\u4f18\u89e3\uff1b\u5982\u679c\u53ea\u9700\u8981\u6700\u4f18\u89e3\u7684\u503c\uff0c\u5219\u65e0\u9700\u672c\u6b65\u9aa4","title":"\u8ba1\u7b97\u6b65\u9aa4"},{"location":"algo/dp/basis/#_4","text":"\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff1a\u4fdd\u5b58\u4e86\u8ba1\u7b97\u8fc7\u7a0b\u7684\u4e2d\u95f4\u503c\uff0c\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97 \u81ea\u4e0a\u800c\u4e0b\uff08bottom-top\uff09\u6216\u8005\u9012\u5f52\u662f\u4e00\u79cd\u5907\u5fd8\u5f55\uff08memorization\uff09\u65b9\u6cd5 \u4e25\u683c\u6765\u8bf4\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6709\u81ea\u4e0b\u800c\u4e0a\u7684\u65b9\u5f0f\uff1b\u5982\u679c\u6240\u6709\u7684\u5b50\u95ee\u9898\u90fd\u4f1a\u88ab\u8ba1\u7b97\u4e00\u6b21\uff0c\u90a3\u4e48\u52a8\u6001\u89c4\u5212\u5177\u6709\u4f18\u52bf\uff0c\u53cd\u4e4b\uff08\u526a\u679d\u60c5\u51b5\uff09\uff0c\u5907\u5fd8\u5f55\u6cd5\u5177\u6709\u4f18\u52bf","title":"\u52a8\u6001\u89c4\u5212\u7684\u7279\u70b9"},{"location":"algo/dp/basis/#_5","text":"\u76f8\u540c\u70b9\uff1a \u5177\u5907\u6700\u4f18\u5b50\u7ed3\u6784 \u4e0d\u540c\u70b9\uff1a \u52a8\u6001\u89c4\u5212\u7684\u5b50\u95ee\u9898\u662f\u91cd\u53e0\u7684\uff0c\u8d2a\u5fc3\u7684\u5b50\u95ee\u9898\u4e0d\u91cd\u53e0 \u52a8\u6001\u89c4\u5212\u4e0d\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u7684\u6027\u8d28 \u8d2a\u5fc3\u7684\u524d\u8fdb\u8def\u7ebf\u662f\u4e00\u6761\u7ebf\uff0c\u52a8\u6001\u89c4\u5212\u662f\u4e00\u4e2aDAG","title":"\u52a8\u6001\u89c4\u5212\u4e0e\u8d2a\u5fc3\u7684\u6bd4\u8f83"},{"location":"algo/dp/basis/#m","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6b63\u6574\u6570M\uff0c\u8fd4\u56denums\u6570\u7ec4\u4e2dM\u4e2a\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u5143\u7d20\u6700\u5927\u548c \u4f8b\u5982\uff1anums = [-1, 4, -2, 3, -2, 3]\uff0cM = 2\uff0c\u6700\u5927\u548c\u4e3a8 = [ 4 ] + [3, -2, 3] dp[ i ][ j ]\u8868\u793a\uff0c\u524dj\u4e2a\u5143\u7d20\u5728i\u4e2a\u5b50\u6570\u7ec4\u4e2d\u7684\u6700\u5927\u548c\uff0c\u5176\u4e2dnums[ j ]\u843d\u5728\u7b2ci\u4e2a\u5b50\u6570\u7ec4\uff081 <= i <= M\uff0ci <= j <= n\uff09 \u72b6\u6001\u8f6c\u79fb \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \\text{dp[ i ][ j ]} = \\max \\begin{cases} \\text{dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ \\max_{t \\in [i-1, j)}(\\text{dp[i - 1][t] + nums[i - 1]}) \\end{cases}, \\text{ where } 1 \\leq i \\leq M \\quad i \\leq j \\leq n \u6ce8\u610f\u5230\u5f53\u524d\u72b6\u6001dp[ i ][ j ]\u53ea\u4e0edp[ i ][j - 1]\u3001dp[i - 1][ t ]\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u4e3a\u53ef\u4ee5\u4f7f\u7528O(n)\u7684\u7a7a\u95f4\uff0cpre[ j ]\u8868\u793a\u4e0a\u4e00\u5c42\u7684\u72b6\u6001\uff0ccur[ j ]\u8868\u793a\u5f53\u524d\u72b6\u6001 \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} \\begin{aligned} & \\text{cur[ j ] = dp[ i ][j - 1] + nums[ i - 1 ]} \\\\ & \\text{pre[ j ] = dp[i - 1][t] + nums[i - 1]} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int maxMSum ( vector < int > nums , int M ) { int n = ( int ) nums . size (), maxSum = INT_MIN ; vector < int > cur ( n + 1 , 0 ), pre ( n + 1 , 0 ); for ( int i = 1 ; i <= M ; i ++ ) { maxSum = INT_MIN ; for ( int j = i ; j <= n ; j ++ ) { cur [ j ] = max ( pre [ j - 1 ], cur [ j - 1 ]) + nums [ j - 1 ]; pre [ j - 1 ] = maxSum ; maxSum = max ( maxSum , cur [ j ]); } pre [ n ] = maxSum ; } return maxSum ; } \u5f53M = 1\u65f6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector < int > getMaxSumEpisode ( vector < int > nums ) { int n = int ( nums . size ()); vector < int > ans ; if ( n == 0 ) { return ans ; } int maxSum = - ( 1ll << 31 ), curSum = 0 ; int left = 0 , right = 0 , begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( curSum >= 0 ) { curSum += nums [ i ]; } else { curSum = nums [ i ]; begin = i ; } if ( maxSum < curSum ) { maxSum = curSum ; left = begin ; right = i ; } } for ( int i = left ; i <= right ; i ++ ) { ans . push_back ( nums [ i ]); } return ans ; } \u76f8\u4f3c\u9898\u76ee \u300cLeetcode 152. \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4\u300d \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8bf7\u4f60\u627e\u51fa\u6570\u7ec4\u4e2d\u4e58\u79ef\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u8be5\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u6570\u5b57\uff09\uff0c\u5e76\u8fd4\u56de\u8be5\u5b50\u6570\u7ec4\u6240\u5bf9\u5e94\u7684\u4e58\u79ef\u3002 \u8f93\u5165: [2,3,-2,4] \u8f93\u51fa: 6 \u89e3\u91ca: \u5b50\u6570\u7ec4 [2,3] \u6709\u6700\u5927\u4e58\u79ef 6\u3002 1 2 3 4 5 6 7 8 9 10 11 int maxProduct ( vector < int >& nums ) { int n = int ( nums . size ()); int minF = nums [ 0 ], maxF = nums [ 0 ], ans = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _min = minF , _max = maxF ; minF = min ( nums [ i ], min ( _min * nums [ i ], _max * nums [ i ])); maxF = max ( nums [ i ], max ( _min * nums [ i ], _max * nums [ i ])); ans = max ( ans , maxF ); } return ans ; } \u300cLeetcode 1186. \u5220\u9664\u4e00\u6b21\u5f97\u5230\u5b50\u6570\u7ec4\u6700\u5927\u548c\u300d \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u67d0\u4e2a\u975e\u7a7a\u5b50\u6570\u7ec4\uff08\u8fde\u7eed\u5143\u7d20\uff09\u5728\u6267\u884c\u4e00\u6b21\u53ef\u9009\u7684\u5220\u9664\u64cd\u4f5c\u540e\uff0c\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u5143\u7d20\u603b\u548c\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u53ef\u4ee5\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u51fa\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5e76\u53ef\u4ee5\u51b3\u5b9a\u8981\u4e0d\u8981\u4ece\u4e2d\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff08\u53ea\u80fd\u5220\u4e00\u6b21\u54e6\uff09\uff0c\uff08\u5220\u9664\u540e\uff09\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5e94\u5f53\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8be5\u5b50\u6570\u7ec4\uff08\u5269\u4e0b\uff09\u7684\u5143\u7d20\u603b\u548c\u662f\u6240\u6709\u5b50\u6570\u7ec4\u4e4b\u4e2d\u6700\u5927\u7684\u3002\u6ce8\u610f\uff0c\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u5b50\u6570\u7ec4 \u4e0d\u80fd\u4e3a\u7a7a\u3002 \u8bf7\u770b\u793a\u4f8b\uff1a \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aarr = [1,-2,0,3] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u6211\u4eec\u53ef\u4ee5\u9009\u51fa [1, -2, 0, 3]\uff0c\u7136\u540e\u5220\u6389 -2\uff0c\u8fd9\u6837\u5f97\u5230 [1, 0, 3]\uff0c\u548c\u6700\u5927\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aarr = [1,-2,-2,3] \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u6211\u4eec\u76f4\u63a5\u9009\u51fa [3]\uff0c\u8fd9\u5c31\u662f\u6700\u5927\u548c\u3002 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1aarr = [-1,-1,-1,-1] \u8f93\u51fa\uff1a-1 \u89e3\u91ca\uff1a\u6700\u540e\u5f97\u5230\u7684\u5b50\u6570\u7ec4\u4e0d\u80fd\u4e3a\u7a7a\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u9009\u62e9 [-1] \u5e76\u4ece\u4e2d\u5220\u53bb -1 \u6765\u5f97\u5230 0\u3002 \u6211\u4eec\u5e94\u8be5\u76f4\u63a5\u9009\u62e9 [-1]\uff0c\u6216\u8005\u9009\u62e9 [-1, -1] \u518d\u4ece\u4e2d\u5220\u53bb\u4e00\u4e2a -1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maximumSum ( vector < int >& arr ) { int n = ( int ) arr . size (); if ( n == 0 ) { return 0 ; } const int minEle = * min_element ( arr . begin (), arr . end ()); int dp0 = arr [ 0 ], dp1 = minEle , ans = dp0 ; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 + arr [ i ], arr [ i ]); int tmp1 = max ( dp0 , dp1 + arr [ i ]); dp0 = tmp0 ; dp1 = tmp1 ; ans = max ( ans , max ( dp0 , dp1 )); } return ans ; } };","title":"M\u4e2a\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c"},{"location":"algo/dp/basis/#dp","text":"\u300cLeetcode 740. \u5220\u9664\u5e76\u83b7\u5f97\u70b9\u6570\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* \u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u4f60\u53ef\u4ee5\u5bf9\u5b83\u8fdb\u884c\u4e00\u4e9b\u64cd\u4f5c\u3002 \u6bcf\u6b21\u64cd\u4f5c\u4e2d\uff0c\u9009\u62e9\u4efb\u610f\u4e00\u4e2a nums[i] \uff0c\u5220\u9664\u5b83\u5e76\u83b7\u5f97 nums[i] \u7684\u70b9\u6570\u3002 \u4e4b\u540e\uff0c\u4f60\u5fc5\u987b\u5220\u9664\u6bcf\u4e2a\u7b49\u4e8e nums[i] - 1 \u6216 nums[i] + 1 \u7684\u5143\u7d20\u3002 \u5f00\u59cb\u4f60\u62e5\u6709 0 \u4e2a\u70b9\u6570\u3002\u8fd4\u56de\u4f60\u80fd\u901a\u8fc7\u8fd9\u4e9b\u64cd\u4f5c\u83b7\u5f97\u7684\u6700\u5927\u70b9\u6570\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1anums = [3,4,2] \u8f93\u51fa\uff1a6 \u89e3\u91ca\uff1a \u5220\u9664 4 \u83b7\u5f97 4 \u4e2a\u70b9\u6570\uff0c\u56e0\u6b64 3 \u4e5f\u88ab\u5220\u9664\u3002 \u4e4b\u540e\uff0c\u5220\u9664 2 \u83b7\u5f97 2 \u4e2a\u70b9\u6570\u3002\u603b\u5171\u83b7\u5f97 6 \u4e2a\u70b9\u6570\u3002 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1anums = [2,2,3,3,3,4] \u8f93\u51fa\uff1a9 \u89e3\u91ca\uff1a \u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u63a5\u7740\u8981\u5220\u9664\u4e24\u4e2a 2 \u548c 4 \u3002 \u4e4b\u540e\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\uff0c\u518d\u6b21\u5220\u9664 3 \u83b7\u5f97 3 \u4e2a\u70b9\u6570\u3002 \u603b\u5171\u83b7\u5f97 9 \u4e2a\u70b9\u6570\u3002 */ class Solution { public : int deleteAndEarn ( vector < int >& nums ) { if ( nums . empty ()) { return 0 ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } map < int , int >:: iterator iter = ++ cnt . begin (); int lastN = cnt . begin () -> first , lastC = cnt . begin () -> second ; int a = 0 , b = lastN * lastC ; for (; iter != cnt . end (); iter ++ ) { int na = max ( a , b ), nb = iter -> first * iter -> second ; if ( lastN + 1 == iter -> first ) { nb += a ; } else { nb += max ( a , b ); } a = na ; b = nb ; lastN = iter -> first ; } return max ( a , b ); } };","title":"\u5e8f\u5217\u578bDP"},{"location":"algo/dp/basis/#dp_1","text":"","title":"\u533a\u95f4\u5f62DP"},{"location":"algo/dp/basis/#_6","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caaabbcbaa\u201d\uff0c\u6bcf\u4e00\u6b21\u53ef\u4ee5\u5220\u9664\u4e00\u4e2a\u7531\u540c\u4e00\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\uff0c\u5220\u9664\u540e\u5269\u4f59\u90e8\u5206\u81ea\u52a8\u62fc\u63a5\u3002\u91cd\u590d\u8fdb\u884c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u7684\u5220\u9664\u6b21\u6570\u3002\u4e3e\u4f8b\u5982\u4e0b\uff1a \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \\begin{matrix} & aaabb\\underline{c}baa \\\\ & \\downarrow \\\\ & aaa\\underline{bbb}aa \\\\ & \\downarrow \\\\ & \\underline{aaaaa} \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u5220\u9664\u6709\u76f8\u540c\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u4e32\u7684\u6700\u5c0f\u6b21\u6570\u3002\u5982\u679c\u4e24\u7aef\u7684\u5b57\u7b26\u76f8\u540c\uff0c\u90a3\u4e48\u72b6\u6001\u8df3\u8f6c\u5230 s[i : j - 1]\uff1b\u5982\u679c\u4e24\u7aef\u5b57\u7b26\u4e32\u4e0d\u60f3\u7b49\uff0c\u90a3\u4e48\u6211\u4eec\u5bfb\u627e\u4e00\u4e2a\u6700\u4f73\u5207\u5206\u70b9 k \uff0c\u4f7f\u5207\u5206\u51fa\u6765\u7684\u4e24\u6bb5\u548c\u6700\u5c0f\u3002\u7279\u522b\u5730\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5355\u5b57\u7b26\uff0c\u6700\u5c0f\u5207\u5272\u6b21\u6570\u662f 1 \u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[ i ][j - 1]}, & \\quad \\text{s[ i ] == s[ j ]} \\\\ \\min_{k \\in [i, j)}(\\text{dp[ i ][ k ] + dp[k + 1][ j ]}), & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector < vector < int >> dp ( n , vector < int > ( n , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i ][ j - 1 ]; } else { int _min = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { _min = min ( _min , dp [ i ][ k ] + dp [ k + 1 ][ j ]); } dp [ i ][ j ] = _min ; } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2})","title":"\u5220\u9664\u5b50\u4e32\u7684\u6700\u5c0f\u64cd\u4f5c\u6570"},{"location":"algo/dp/basis/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u5982\u201caabc\u201d\uff0c\u6bcf\u4e00\u6b21\u5220\u9664\u4e00\u4e2a\u56de\u6587\u5b50\u4e32\uff0c\u76f4\u5230\u5b57\u7b26\u4e32\u4e3a\u7a7a\uff0c\u6c42\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u5b57\u7b26\u4e32 s[i : j] \u7684\u6700\u5c0f\u5220\u9664\u6b21\u6570\u3002\u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\u90fd\u4f1a\u9762\u4e34\u4e0b\u9762\u7684\u4e24\u79cd\u60c5\u51b5 \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} \\begin{matrix} \\text{case 1: } & {\\color{Red} a}xxxx \\\\ \\text{case 2: } & {\\color{Red} a}xx{\\color{Red} a}xxx \\end{matrix} case 1 \u53ea\u5220\u9664\u4e00\u4e2a\u5b57\u7b26\uff0ccase 2 \u5220\u9664\u4e00\u4e2a\u533a\u95f4\u7684\u5b57\u7b26 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{1}, & \\quad i == j \\\\ \\max(\\text{dp[i + 1][ j ] + 1, dp[i + 2][ j ] + 1}), & \\quad \\text{s[ i ] == s[i + 1]} \\\\ \\max_{k \\in [i + 2, j]} (\\text{dp[i + 1][k - 1] + dp[k + 1][ j ]}), & \\quad \\text{s[ i ] == s[ k ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 , 0 )); dp [ n - 1 ][ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ][ i ] = 1 ; dp [ i ][ i + 1 ] = 1 + ( s [ i ] != s [ i + 1 ]); for ( int j = i + 2 ; j < n ; j ++ ) { dp [ i ][ j ] = 1 + dp [ i + 1 ][ j ]; if ( s [ i ] == s [ i + 1 ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], 1 + dp [ i + 2 ][ j ]); } for ( int k = i + 2 ; k <= j ; k ++ ) { if ( s [ i ] == s [ k ]) { dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i + 1 ][ k - 1 ] + dp [ k + 1 ][ j ]); } } } } return dp [ 0 ][ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{3}) O(n^{3}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2})","title":"\u5220\u9664\u56de\u6587\u4e32\u7684\u6700\u5c0f\u6b21\u6570"},{"location":"algo/dp/edit-distance/","text":"\u57fa\u7840 \u00b6 \u83b1\u6587\u65af\u7279\u8ddd\u79bb\uff08Levenshtein distance\uff09\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\u589e\u52a0\u3001\u5220\u9664\u548c\u66ff\u6362 \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} a, b denote two strings to compare. If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 , delete a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 , insert b_{j} b_{j} at a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} , replace a_{i} a_{i} with b_{j} b_{j} \u4f8b\u5982\uff1aword1 = \"horse\", word2 = \"ros\"\uff0c\u83b1\u6587\u65af\u7279\u8ddd\u79bb\u4e3a3 \u89e3\u91ca\uff1a horse -> rorse (\u5c06 'h' \u66ff\u6362\u4e3a 'r') rorse -> rose (\u5220\u9664 'r') rose -> ros (\u5220\u9664 'e') \u300cLevenshtein distance\u7684\u4ee3\u7801\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 void EDprocess ( string s1 , string s2 , int i , int j , int ** dp , string str ) { if ( i == 0 && j == 0 ) { return ; } else if ( i == 0 || ( j > 0 && dp [ i ][ j ] == dp [ i ][ j - 1 ] + 1 )) { string ss = str . substr ( 0 , i ); ss . push_back ( s2 [ j - 1 ]); str = ss + str . substr ( i , str . length () - i ); printf ( \"insert %c: %s \\n \" , s2 [ j - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i , j - 1 , dp , str ); } else if ( j == 0 || ( i > 0 && dp [ i ][ j ] == dp [ i - 1 ][ j ] + 1 )) { string ss = str . substr ( 0 , i - 1 ); str = ss + str . substr ( i , str . length () - i ); printf ( \"delete %c: %s \\n \" , s1 [ i - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i - 1 , j , dp , str ); } else { if ( s1 [ i - 1 ] != s2 [ j - 1 ]) { str [ i - 1 ] = s2 [ j - 1 ]; printf ( \"replace %c with %c: %s \\n \" , s1 [ i - 1 ], s2 [ j - 1 ], str . c_str ()); } EDprocess ( s1 , s2 , i - 1 , j - 1 , dp , str ); } } void printDP ( string s1 , string s2 , int n1 , int n2 , int ** dp ) { for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { printf ( \"%d \\t \" , dp [ i ][ j ]); } printf ( \" \\n \" ); } printf ( \"s1 = %s \\n \" , s1 . c_str ()); EDprocess ( s1 , s2 , n1 , n2 , dp , s1 ); printf ( \"s2 = %s \\n \" , s2 . c_str ()); } int LD ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = i > j ? i : j ; } else { int a = dp [ i - 1 ][ j ] + 1 ; int b = dp [ i ][ j - 1 ] + 1 ; int c = dp [ i - 1 ][ j - 1 ] + ( s1 [ i - 1 ] != s2 [ j - 1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } printDP ( s1 , s2 , n1 , n2 , dp ); int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } /* 0 1 2 3 4 5 6 1 0 1 2 3 4 5 2 1 0 1 2 3 4 3 2 1 1 1 2 3 4 3 2 1 2 2 3 5 4 3 2 2 3 2 6 5 4 3 3 2 3 s1 = ecoles insert e: ecolese replace e with o: ecolose delete o: eclose s2 = eclose Edit distance = 3 */ Damerau-Levenshtein distance \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \u76f8\u4f3c\u9898\u76ee \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 35. \u6700\u5c0f\u7f16\u8f91\u4ee3\u4ef7\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u518d\u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570ic\uff0cdc\u548crc\uff0c\u5206\u522b\u4ee3\u8868\u63d2\u5165\u3001 \u5220\u9664\u548c\u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\u7684\u4ee3\u4ef7\uff0c\u8bf7\u8f93\u51fa\u5c06str1\u7f16\u8f91\u6210str2\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u793a\u4f8b1 \u8f93\u5165 \"abc\",\"adc\",5,3,2 \u8fd4\u56de\u503c 2 \u793a\u4f8b2 \u8f93\u5165 \"abc\",\"adc\",5,3,100 \u8fd4\u56de\u503c 8 */ /** * min edit cost * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @param ic int\u6574\u578b insert cost * @param dc int\u6574\u578b delete cost * @param rc int\u6574\u578b replace cost * @return int\u6574\u578b */ int minEditCost ( string str1 , string str2 , int ic , int dc , int rc ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 ) { dp [ i ][ j ] = ic * j ; } else if ( j == 0 ) { dp [ i ][ j ] = dc * i ; } else { int ist = dp [ i ][ j - 1 ] + ic ; int dlt = dp [ i - 1 ][ j ] + dc ; int rpl = dp [ i - 1 ][ j - 1 ] + rc * ( str1 [ i - 1 ] != str2 [ j - 1 ]); dp [ i ][ j ] = min ( ist , min ( dlt , rpl )); } } } return dp [ n1 ][ n2 ]; }","title":"\u7f16\u8f91\u8ddd\u79bb"},{"location":"algo/dp/edit-distance/#_1","text":"\u83b1\u6587\u65af\u7279\u8ddd\u79bb\uff08Levenshtein distance\uff09\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\u589e\u52a0\u3001\u5220\u9664\u548c\u66ff\u6362 \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} \\text{LD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{LD}_{a, b}(i-1, j) + 1 \\\\ \\text{LD}_{a, b}(i, j-1) + 1 \\\\ \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\text{otherwise} \\end{cases} a, b denote two strings to compare. If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j) + 1 , delete a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i, j-1) + 1 , insert b_{j} b_{j} at a_{i} a_{i} If \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\text{LD}_{a, b}(i, j) = \\text{LD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} , replace a_{i} a_{i} with b_{j} b_{j} \u4f8b\u5982\uff1aword1 = \"horse\", word2 = \"ros\"\uff0c\u83b1\u6587\u65af\u7279\u8ddd\u79bb\u4e3a3 \u89e3\u91ca\uff1a horse -> rorse (\u5c06 'h' \u66ff\u6362\u4e3a 'r') rorse -> rose (\u5220\u9664 'r') rose -> ros (\u5220\u9664 'e') \u300cLevenshtein distance\u7684\u4ee3\u7801\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 void EDprocess ( string s1 , string s2 , int i , int j , int ** dp , string str ) { if ( i == 0 && j == 0 ) { return ; } else if ( i == 0 || ( j > 0 && dp [ i ][ j ] == dp [ i ][ j - 1 ] + 1 )) { string ss = str . substr ( 0 , i ); ss . push_back ( s2 [ j - 1 ]); str = ss + str . substr ( i , str . length () - i ); printf ( \"insert %c: %s \\n \" , s2 [ j - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i , j - 1 , dp , str ); } else if ( j == 0 || ( i > 0 && dp [ i ][ j ] == dp [ i - 1 ][ j ] + 1 )) { string ss = str . substr ( 0 , i - 1 ); str = ss + str . substr ( i , str . length () - i ); printf ( \"delete %c: %s \\n \" , s1 [ i - 1 ], str . c_str ()); EDprocess ( s1 , s2 , i - 1 , j , dp , str ); } else { if ( s1 [ i - 1 ] != s2 [ j - 1 ]) { str [ i - 1 ] = s2 [ j - 1 ]; printf ( \"replace %c with %c: %s \\n \" , s1 [ i - 1 ], s2 [ j - 1 ], str . c_str ()); } EDprocess ( s1 , s2 , i - 1 , j - 1 , dp , str ); } } void printDP ( string s1 , string s2 , int n1 , int n2 , int ** dp ) { for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { printf ( \"%d \\t \" , dp [ i ][ j ]); } printf ( \" \\n \" ); } printf ( \"s1 = %s \\n \" , s1 . c_str ()); EDprocess ( s1 , s2 , n1 , n2 , dp , s1 ); printf ( \"s2 = %s \\n \" , s2 . c_str ()); } int LD ( string s1 , string s2 ) { int n1 = int ( s1 . length ()), n2 = int ( s2 . length ()); int ** dp = new int * [ n1 + 1 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { dp [ i ] = new int [ n2 + 1 ]{}; } for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ][ j ] = i > j ? i : j ; } else { int a = dp [ i - 1 ][ j ] + 1 ; int b = dp [ i ][ j - 1 ] + 1 ; int c = dp [ i - 1 ][ j - 1 ] + ( s1 [ i - 1 ] != s2 [ j - 1 ]); dp [ i ][ j ] = min ( min ( a , b ), c ); } } } printDP ( s1 , s2 , n1 , n2 , dp ); int ans = dp [ n1 ][ n2 ]; for ( int i = 0 ; i <= n1 ; i ++ ) { delete [] dp [ i ]; } delete [] dp ; return ans ; } /* 0 1 2 3 4 5 6 1 0 1 2 3 4 5 2 1 0 1 2 3 4 3 2 1 1 1 2 3 4 3 2 1 2 2 3 5 4 3 2 2 3 2 6 5 4 3 3 2 3 s1 = ecoles insert e: ecolese replace e with o: ecolose delete o: eclose s2 = eclose Edit distance = 3 */ Damerau-Levenshtein distance \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \\text{DLD}_{a, b}(i, j) = \\begin{cases} \\max(i, j), & \\quad \\text{if } \\min(i, j) = 0 \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\\\ \\text{DLD}_{a, b}(i-2, j-2) + 1 \\end{cases}, & \\quad \\text{if } i, j > 1 \\text{ and } a_{i} = b_{j-1} \\text{ and } a_{i-1} = b_{j} \\\\ \\min \\begin{cases} \\text{DLD}_{a, b}(i-1, j) + 1 \\\\ \\text{DLD}_{a, b}(i, j-1) + 1 \\\\ \\text{DLD}_{a, b}(i-1, j-1) + 1_{a_{i} \\neq b_{j}} \\end{cases}, & \\quad \\text{otherwise} \\end{cases} \u76f8\u4f3c\u9898\u76ee \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 35. \u6700\u5c0f\u7f16\u8f91\u4ee3\u4ef7\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u518d\u7ed9\u5b9a\u4e09\u4e2a\u6574\u6570ic\uff0cdc\u548crc\uff0c\u5206\u522b\u4ee3\u8868\u63d2\u5165\u3001 \u5220\u9664\u548c\u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\u7684\u4ee3\u4ef7\uff0c\u8bf7\u8f93\u51fa\u5c06str1\u7f16\u8f91\u6210str2\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u793a\u4f8b1 \u8f93\u5165 \"abc\",\"adc\",5,3,2 \u8fd4\u56de\u503c 2 \u793a\u4f8b2 \u8f93\u5165 \"abc\",\"adc\",5,3,100 \u8fd4\u56de\u503c 8 */ /** * min edit cost * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @param ic int\u6574\u578b insert cost * @param dc int\u6574\u578b delete cost * @param rc int\u6574\u578b replace cost * @return int\u6574\u578b */ int minEditCost ( string str1 , string str2 , int ic , int dc , int rc ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { if ( i == 0 ) { dp [ i ][ j ] = ic * j ; } else if ( j == 0 ) { dp [ i ][ j ] = dc * i ; } else { int ist = dp [ i ][ j - 1 ] + ic ; int dlt = dp [ i - 1 ][ j ] + dc ; int rpl = dp [ i - 1 ][ j - 1 ] + rc * ( str1 [ i - 1 ] != str2 [ j - 1 ]); dp [ i ][ j ] = min ( ist , min ( dlt , rpl )); } } } return dp [ n1 ][ n2 ]; }","title":"\u57fa\u7840"},{"location":"algo/dp/knapsack/","text":"01 \u80cc\u5305 \u00b6 \u4e00\u4e2a\u80cc\u5305\u6709\u4e00\u5b9a\u7684\u627f\u91cd W\uff0c\u6709N\u4ef6\u7269\u54c1\uff0c\u6bcf\u4ef6\u90fd\u6709\u81ea\u5df1\u7684\u4ef7\u503c\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 v \u4e2d\uff0c\u4e5f\u90fd\u6709\u81ea\u5df1\u7684\u91cd\u91cf\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 w \u4e2d\uff0c\u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u9009\u62e9\u8981\u88c5\u5165\u80cc\u5305\u8fd8\u662f\u4e0d\u88c5\u5165\u80cc\u5305\uff0c\u8981\u6c42\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u7684\u524d\u63d0\u4e0b\uff0c\u9009\u51fa\u7269\u54c1\u7684\u603b\u4ef7\u503c\u6700\u5927\u3002\u4f8b\u5982\uff0c \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \u6700\u5927\u7684\u4ef7\u503c\u4e3a 5\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u5728\u80cc\u5305\u5bb9\u91cf\u4e3a j \u4e0b\u7684\u6700\u5927\u4ef7\u503c\u3002\u6b64\u65f6\u7684\u72b6\u6001\u53ea\u4f1a\u6709\u4e24\u4e2a\uff1a\uff081\uff09\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\uff082\uff09\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \uff081\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j\uff1b\uff082\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u4e86\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j - w[ i ]\uff0c\u8fd9\u91cc\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u52a0\u5165\u540e\uff0c\u603b\u91cd\u91cf\u5c06\u4f1a\u8fbe\u5230 j\uff0c\u90a3\u4e48\u52a0\u5165\u4e4b\u524d\u7684\u91cd\u91cf\u81ea\u7136\u5c31\u7b49\u4e8e j - w[ i ]\u3002\u5f53\u7136\uff0c\u5728\u8ba1\u7b97\u7684\u65f6\u5019\u9700\u8981\u5224\u5b9a\uff0c\u5f53\u524d\u7684\u603b\u91cd\u91cf j \u662f\u5426\u5927\u4e8e\u7b2c i \u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u3002 \u300c\u7ebf\u6027\u7a7a\u95f4\u300d \u56e0\u4e3a\u72b6\u6001\u7684\u8f6c\u79fb\u53ea\u53d1\u751f\u5728\u76f8\u90bb\u7269\u54c1\u4e4b\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u5f97\u4ee5\u4f18\u5316\uff0c\u4f46\u7528\u4e00\u7ef4\u7684\u7a7a\u95f4\u65f6\uff0c\u5e94\u5bf9\u5bb9\u91cf w \u8fdb\u884c \u5012\u5e8f\u904d\u5386 \u3002 1 2 3 4 5 6 7 8 9 10 int knapsack01 ( vector < int > v , vector < int > w , int W ) { int N = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\times W) O(N \\times W) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(W) O(W) \uff0cN \u4e3a\u7269\u54c1\u7684\u6570\u76ee\uff0cW \u4e3a\u9650\u5b9a\u7684\u91cd\u91cf \u300c\u91cd\u6784\u6700\u4f18\u89e3\u300d \u9664\u4e86\u5f97\u5230\u6700\u7ec8\u7684\u603b\u4ef7\u503c\uff0c\u6211\u4eec\u4e5f\u5e0c\u671b\u83b7\u77e5\u80cc\u5305\u7684\u65b9\u6848\uff0c\u5373\u6311\u9009\u54ea\u4e9b\u7269\u54c1\u653e\u5165\u80cc\u5305\u4e2d\u3002\u5728\u8fd9\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u4e8c\u7ef4\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e00\u6b65\u7684\u8fed\u4ee3\u3002\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ea\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u52a0\u5165\u80cc\u5305\u548c\u4e0d\u52a0\u5165\u80cc\u5305\uff0c\u5e76\u4e14\uff0c\u5f53\u524d\u7684\u7269\u54c1\u53ea\u4e0e\u540e\uff08\u524d\uff09\u4e00\u4ef6\u7269\u54c1\u6709\u5173\u7cfb\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053 dp[ i ][ j ] \u662f\u7b49\u4e8e dp[i + 1][ j ] \u8fd8\u662f\u7b49\u4e8e dp[i + 1][j - w[ i ]] + v[ i ]\u3002\u5982\u679c\u662f\u540e\u8005\uff0c\u8bf4\u660e\u7b2c i \u4ef6\u7269\u54c1\u88ab\u653e\u5165\uff0c\u53cd\u4e4b\uff0c\u5219\u672a\u88ab\u653e\u5165\u3002\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u54ea\u4e9b\u7269\u54c1\u88ab\u653e\u5165\u5373\u53ef\uff0c\u540c\u65f6\u66f4\u65b0 j\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int knapsack ( vector < int > w , vector < int > v , int W ) { int n = ( int ) w . size (); vector < vector < int >> G ( n + 1 , vector < int > ( W + 1 , 0 )); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } G [ i ] = dp ; } vector < int > idx ; for ( int i = 0 , j = W ; i < n && j >= 0 ; i ++ ) { if ( G [ i ][ j ] == G [ i + 1 ][ j - w [ i ]] + v [ i ]) { idx . emplace_back ( i ); j -= w [ i ]; } } for ( int id : idx ) { printf ( \"w[%d]=%d \\n \" , id , w [ id ]); } return dp [ W ]; } \u300c\u521d\u59cb\u5316\u7ec6\u8282\u300d \u4e00\u4e2a\u5bb9\u91cf\u4e3a W \u7684\u80cc\u5305\uff0c\u6709\u4e24\u79cd\u4e0d\u540c\u7684\u8981\u6c42\uff1a\uff081\uff09\u80cc\u5305\u8981\u88ab\u88c5\u6ee1\u548c\uff082\uff09\u80cc\u5305\u53ef\u4ee5\u4e0d\u6ee1\u3002\u8fd9\u4e24\u79cd\u7684\u521d\u59cb\u5316\u662f\u4e0d\u540c\u7684\u3002 \u5bf9\u4e8e\uff081\uff09\uff0cdp[ 0 ] \u88ab\u8bbe\u7f6e\u4e3a 0\uff0cdp[1 : W] \u88ab\u8bbe\u7f6e\u4e3a -\\infty -\\infty \uff1b\u5bf9\u4e8e\uff082\uff09\uff0cdp[0 : W] \u90fd\u4e3a 0\u3002\u53ef\u4ee5\u8fd9\u6837\u7406\u89e3\uff0c\u6761\u4ef6\uff081\uff09\u8981\u6c42\u80cc\u5305\u88c5\u6ee1\uff0c\u90a3\u4e48 W = 0 \u662f\u6ee1\u8db3\u7684\uff0c\u56e0\u4e3a\u7a7a\u80cc\u5305\u7684\u5bb9\u91cf\u5c31\u662f 0\uff0c\u4f46\u662f\u4e00\u65e6\u80cc\u5305\u7684\u5bb9\u91cf\u4e0d\u662f 0\uff0c\u90a3\u4e48\u672a\u88c5\u4efb\u4f55\u7269\u54c1\uff08\u7a7a\u8f7d\uff09\u662f\u4e0d\u7b26\u5408\u80cc\u5305\u88c5\u6ee1\u7684\u8981\u6c42\uff0c -\\infty -\\infty \u8868\u793a\u65e0\u5408\u6cd5\u7684\u89e3\uff1b\u53cd\u89c2\u6761\u4ef6\uff082\uff09\uff0c\u7a7a\u8f7d\u5bf9\u4e8e\u4efb\u610f\u7684 W \u90fd\u662f\u4e00\u4e2a\u5408\u6cd5\u89e3\uff0c\u56e0\u6b64\u7a7a\u8f7d\u80cc\u5305\u7684\u4ef7\u503c\u5c31\u662f 0\u3002 \u8fd9\u91cc\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0cv = [4, 3, 7, 5]\uff0cw = [2, 3, 5, 7]\uff0cW = 9\u3002\u5982\u679c\u8981\u6c42\u88c5\u6ee1\u80cc\u5305\uff0c\u7ed3\u679c\u662f 9\uff1b\u53cd\u4e4b\u662f 11\u3002 \u76ee\u6807\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4, \u5982 nums = [1, 1, 1, 1, 1] \u548c\u4e00\u4e2a\u76ee\u6807\u503c target = 3\u3002\u5bf9\u4e8e\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u524d\u65b9\u653e\u7f6e\u4e00\u4e2a\u8fd0\u7b97\u7b26 + \u6216\u8005 - \u6765\u6784\u6210\u4e00\u4e2a\u8ba1\u7b97\u8868\u8fbe\u5f0f\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\u7ed3\u679c\u6070\u597d\u4e3a target \u7684\u4e2a\u6570\u4e3a\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u9898\u610f\u53ef\u4ee5\u88ab\u89e3\u91ca\u4e3a\uff0c\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u7ec4\uff0c\u5176\u4e2d\u4e00\u7ec4\u5168\u90e8\u4e3a\u6807\u5fd7\u4e3a\u6b63\u6570\uff0c\u53e6\u4e00\u7ec4\u6807\u5fd7\u4e3a\u8d1f\u6570\uff0c\u8fd9\u6837\u6c42\u548c\u7ed3\u679c\u4e3a target\u3002\u672c\u9898\u662f 01 \u80cc\u5305\u95ee\u9898\u6c42\u65b9\u6848\u6570\u95ee\u9898\u3002\u5047\u8bbe\u6570\u7ec4\u548c\u4e3a sum\uff0c\u6b63\u6570\u7ec4\u7684\u548c\u4e3a pos\uff0c\u8d1f\u6570\u7ec4\u7684\u548c\u4e3a neg\uff08\u7edd\u5bf9\u503c\uff09\uff0c\u53ef\u4ee5\u5f97\u5230\u5982\u4e0b\u5173\u7cfb \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \u6240\u4ee5\uff0csum \u5fc5\u987b\u4e0d\u5c0f\u4e8e target\uff0c\u5e76\u4e14 sum - targte \u5fc5\u987b\u662f\u5076\u6570\u3002 \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5230\u6700\u540e\u4e00\u4e2a\u6570\u4e2d\u6c42\u548c\u7b49\u4e8e j \u7684\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u5173\u6ce8\u8fb9\u754c\u6761\u4ef6\uff1a\u5982\u679c j = 0\uff0c\u5373\u8d1f\u6570\u548c\u7684\u7edd\u5bf9\u503c\u4e3a 0\uff0c\u8868\u660e\u6211\u4eec\u5e94\u8be5\u4e0d\u9009\u53d6\u4efb\u4f55\u5143\u7d20\uff0c\u56e0\u6b64 dp[ i ][ 0 ] = 1\uff0c\u8fd9\u91cc i \u4ece 0 \u5230 n - 1\u3002\u5f53 i == n\uff0c\u5373\u5f53\u524d\u6570\u7ec4\u6ca1\u6709\u5143\u7d20\uff0c\u53ea\u6709 j == 0 \u65f6\uff0c\u65b9\u6848\u6570\u76ee\u624d\u4e3a 1\u3002\u5982\u679c\u4ece\u540e\u5411\u524d\u9012\u63a8\uff0c\u6700\u7ec8\u7684\u7b54\u6848\u662f dp[ 0 ][ target ]\u3002\u4f18\u5316\u540e\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u662f\u7ebf\u6027\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int findTargetSumWays ( vector < int >& nums , int target ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( target > sum || ( sum - target ) % 2 != 0 ) { return 0 ; } int neg = ( sum - target ) >> 1 ; vector < int > dp ( neg + 1 , 0 ); dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int j = neg ; j >= num ; j -- ) { dp [ j ] += dp [ j - num ]; } } return dp [ neg ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(target \\times n) O(target \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(target) O(target) \uff0c\u8fd9\u91cc target \u662f\u76ee\u6807\u503c\u5927\u5c0f\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002 \u5206\u5272\u7b49\u548c\u5b50\u96c6 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6784\u6210\u7684\u6570\u7ec4\uff0c\u5982 nums = [1, 5, 11, 5]\uff0c\u5224\u65ad\u80fd\u5426\u5c06\u6b64\u6570\u7ec4\u5206\u5272\u6210\u4e24\u4e2a\u6570\u7ec4\uff08\u4e0d\u8981\u6c42\u8fde\u7eed\uff09\uff0c\u4f7f\u4e24\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u76f8\u7b49\u3002\u7ed9\u51fa\u7684\u4f8b\u5b50\u53ef\u4ee5\u88ab\u5206\u6210 [1, 5, 5] \u548c [ 11 ] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u6211\u4eec\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u4e2a\u90e8\u5206\uff0c\u53ef\u4ee5\u7406\u89e3\u6210\u9009\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u5176\u548c\u662f\u539f\u6570\u7ec4\u548c\u7684\u4e00\u534a\u3002\u56e0\u6b64\uff0c\u53ef\u4ee5\u5c06\u6b64\u9898\u8f6c\u6362\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\u503c\uff0c\u5176\u548c\u662f\u5426\u7b49\u4e8e j\u3002\u5982\u679c\u539f\u6570\u7ec4\u7684\u548c sum \u662f\u5947\u6570\uff0c\u90a3\u4e48\u76f4\u63a5\u8fd4\u56de false\uff0c\u56e0\u4e3a\u4e24\u4e2a\u76f8\u7b49\u6570\u7684\u548c\u4e00\u5b9a\u662f\u5076\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u5f53 j == 0 \u65f6\uff0c\u8bf4\u660e\u4e24\u4e2a\u6570\u7ec4\u5747\u4e3a\u7a7a\uff0c\u90a3\u4e48\u6574\u4e2a\u6570\u7ec4\u5e94\u8be5\u4e3a\u7a7a\uff0c\u5bf9\u5e94\u7684 i == n \uff08\u4ece\u540e\u5f80\u524d\u9012\u63a8\uff09\u3002\u6700\u540e\u7684\u7b54\u6848\u5e94\u8be5\u4e3a dp[ 0 ][ sum / 2 ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool canPartition ( vector < int >& nums ) { int n = ( int ) nums . size (), sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; vector < vector < bool >> dp ( n + 1 , vector < bool > ( sum + 1 , 0 )); dp [ n ][ 0 ] = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= sum ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= nums [ i ]) { dp [ i ][ j ] = dp [ i ][ j ] || dp [ i + 1 ][ j - nums [ i ]]; } } } return dp [ 0 ][ sum ]; } \u7a7a\u95f4\u4f18\u5316\u540e\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool canPartition ( vector < int >& nums ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; bool * dp = new bool [ sum + 1 ]{}; dp [ 0 ] = true ; for ( int num : nums ) { for ( int j = sum ; j >= num ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - num ]; } } return dp [ sum ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(sum \\times n) O(sum \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(sum) O(sum) \uff0c\u8fd9\u91cc sum \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002 \u6700\u540e\u4e00\u5757\u77f3\u5934\u7684\u91cd\u91cf \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 stones = [2, 7, 4, 1, 8, 1] \u8868\u793a\u4e00\u7ec4\u77f3\u5934\u7684\u91cd\u91cf\u3002\u4ece\u5f53\u524d\u7684\u77f3\u5934\u91cc\u4efb\u53d6\u4e24\u4e2a\uff0c\u8d28\u91cf\u662f x \u548c y\uff0c\u5982\u679c\u4e24\u5757\u8d28\u91cf\u76f8\u7b49\u5373 x = y\uff0c\u90a3\u4e48\u8fd9\u4e24\u5757\u77f3\u5934\u88ab\u79fb\u9664\uff1b\u53cd\u4e4b\uff0c\u79fb\u9664\u8f83\u5c0f\u7684\u90a3\u4e00\u5757\uff0c\u5e76\u4e14\u8f83\u5927\u7684\u90a3\u4e00\u5757\u53d8\u6210\u8fd9\u4e24\u5757\u8d28\u91cf\u7684\u5dee\u503c\uff08\u7edd\u5bf9\u503c\uff09\u3002\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u76f4\u5230\u5269\u4f59\u4e00\u5757\u6216\u8005\u65e0\u5269\u4f59\uff0c\u6c42\u5269\u4f59\u7684\u6700\u5c0f\u8d28\u91cf\u662f\u591a\u5c11\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u53ef\u4ee5\u539f\u6570\u7ec4\u5206\u5272\u6210\u4e24\u7ec4 + \u548c -\uff0c\u6211\u4eec\u7528 + \u8fd9\u4e00\u7ec4\u51cf\u53bb - \u8fd9\u4e00\u7ec4\uff0c\u6240\u5f97\u7ed3\u679c\u7684\u6700\u5c0f\u503c\u662f\u6700\u7ec8\u7ed3\u679c\uff0c\u8fd9\u6837\u95ee\u9898\u8f6c\u5316\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe neg \u4e3a - \u8fd9\u4e00\u7ec4\u7684\u548c\uff0cpos \u4e3a + \u8fd9\u4e00\u7ec4\u7684\u548c\u3002\u6ee1\u8db3\u4e0b\u5217\u65b9\u7a0b\u7ec4 \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u6210\uff0c\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u503c\uff0c\u5176\u548c\u7b49\u4e8e neg\uff0c\u5e76\u4e14\u4f7f\u5f97 \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5b57\u5230\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\uff0c\u5b83\u4eec\u7684\u548c\u5728\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u503c\u662f\u591a\u5c11\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 int lastStoneWeightII ( vector < int >& stones ) { int sum = 0 ; for ( int stone : stones ) { sum += stone ; } int tar = ( sum >> 1 ); vector < int > dp ( tar + 1 , 0 ); for ( int stone : stones ) { for ( int j = tar ; j >= stone ; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - stone ] + stone ); } } return sum - 2 * dp [ tar ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(tar \\times n) O(tar \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(tar) O(tar) \uff0c\u8fd9\u91cc tar \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002 \u76c8\u5229\u8ba1\u5212 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 n \u4ee3\u8868\u4eba\u6570\uff0cminProfit \u4ee3\u8868\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u4e00\u4e32\u5de5\u4f5c\u9700\u8981\u7684\u4eba\u6570 group = [2, 2]\uff0c\u6bcf\u9879\u5de5\u4f5c\u5bf9\u5e94\u7684\u5229\u6da6 profit = [2, 3]\u3002\u8981\u6c42\u5b9e\u73b0\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u5e76\u4e14\u6295\u5165\u7684\u4eba\u6570\u548c\u4e0d\u80fd\u8d85\u8fc7 n\uff0c\u8fd9\u6837\u7684\u5206\u914d\u65b9\u6848\u6570\u76ee\u6709\u591a\u5c11\u4e2a\uff1f \u300c\u5206\u6790\u300d \u5728 01 \u80cc\u5305\u95ee\u9898\u7684\u57fa\u7840\u4e0a\uff0c\u672c\u9898\u589e\u52a0\u4e86\u6700\u4f4e\u76c8\u5229\u989d\u7684\u9650\u5236\u3002\u8bbe dp[ i ][ j ][ k ] \u4e3a\u4ece i \u5f00\u59cb\u7684\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u4e9b\u5de5\u4f5c\u6295\u5165\u4eba\u529b\uff0c\u5728\u6070\u597d j \u4e2a\u4eba\u4e14\u76c8\u5229\u989d\u4e0d\u4f4e\u4e8e k \u7684\u60c5\u51b5\u4e0b\uff0c\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \u8fb9\u754c\u6761\u4ef6 dp[ len ][ 0 ][ 0 ] = 1\uff0c\u8868\u660e\u4e0d\u9009\u4efb\u4f55\u5de5\u4f5c\u65f6\uff0c\u6295\u5165\u7684\u4eba\u6570\u662f 0\uff0c\u6700\u4f4e\u7684\u76c8\u5229\u989d\u4e5f\u662f 0\uff0c\u6b64\u65f6\u4e5f\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\u4e00\u79cd\u65b9\u6848\u3002\u8fdb\u4e00\u6b65\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c\u5f53 k = 0 \u5373\u6700\u4f4e\u76c8\u5229\u989d\u4e3a 0\uff0c\u90a3\u4e48\u4e0d\u8bba i \u548c j \u4e3a\u4f55\u503c\uff0cdp[ i ][ j ][ 0 ] \u5747\u4e3a 1\u3002 \\text{k - profit[ i ]} \\text{k - profit[ i ]} \u4e3a\u8d1f\u6570\uff0c\u8bf4\u660e\u7b2c i \u4e2a\u5de5\u4f5c\u7684\u5229\u6da6\u672c\u8eab\u5c31\u8d85\u8fc7 minProfit\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728\u9009\u62e9\u7b2c i \u4e2a\u5de5\u4f5c\u524d\uff0c\u6700\u4f4e\u76c8\u5229\u53ef\u4ee5\u4e3a 0\uff0c\u8fd9\u4e2a\u65f6\u5019\u53ea\u8981\u6295\u5165\u7684\u4eba\u6570\u4e0d\u8d85\u8fc7 j - group[ i ]\uff0c\u90fd\u88ab\u89c6\u4e3a\u6ee1\u8db3\u8981\u6c42\u7684\u65b9\u6848\u3002\u76f8\u53cd\uff0c\u5982\u679c\u6211\u4eec\u7ea6\u675f \\text{k} \\geq \\text{profit[ i ]} \\text{k} \\geq \\text{profit[ i ]} \uff0c\u6211\u4eec\u6700\u7ec8\u5f97\u5230\u7684\u7ed3\u679c\u662f \u6070\u597d\u7b49\u4e8e minProfit \u7684\u65b9\u6848\u6570\uff0c\u56e0\u4e3a k - profit[ i ] \u53ea\u4f1a\u8f6c\u79fb\u5230\u7b2c\u4e09\u7ef4\u6210\u4e3a 0 \u7684\u72b6\u6001\u3002 \u6700\u7ec8\u7684\u7b54\u6848\u662f\u8003\u5bdf\u6240\u6709\u7684\u5de5\u4f5c\u4e14\u6ee1\u8db3\u6700\u4f4e\u76c8\u5229\u989d\u7684\u6761\u4ef6\u4e0b\uff0c\u5bf9\u6295\u5165\u7684\u4eba\u6570\u904d\u5386 \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); dp [ 0 ][ 0 ] = 1 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = 0 ; k <= minProfit ; k ++ ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } int ans = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { ans += dp [ j ][ minProfit ]; ans %= MOD ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(len \\times n \\times minProfit) O(len \\times n \\times minProfit) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n \\times minProfit) O(n \\times minProfit) \uff0c\u8fd9\u91cc len \u662f\u5de5\u4f5c\u7684\u4e2a\u6570 / \u5229\u6da6\u6570\u7ec4\u7684\u957f\u5ea6\uff0cn \u662f\u603b\u4eba\u6570\uff0cminProfit \u662f\u6700\u4f4e\u76c8\u5229\u989d\u3002 \u8fd9\u4e2a\u9898\u76ee\u4e5f\u53ef\u4ee5\u5b9a\u4e49\u6210 dp[ i ][ j ][ k ] \u4ece\u7b2c i \u4e2a\u5de5\u4f5c\u5230\u6700\u540e\u4e00\u4e2a\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\uff0c\u5728\u6295\u5165\u4e0d\u8d85\u8fc7 j \u4e2a\u4eba\u4e14\u5229\u6da6\u4e0d\u4f4e\u4e8e k \u7684\u6761\u4ef6\u4e0b\u7684\u65b9\u6848\u6570\u76ee\u3002\u5bf9\u5e94\u7684\u521d\u59cb\u5316\u5e94\u8be5\u6539\u6210 dp[ i ][ j ][ 0 ] = 1\uff0c\u6700\u540e\u7684\u7ed3\u679c\u662f dp[ 0 ][ n ][ minProfit ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); for ( int j = 0 ; j <= n ; j ++ ) { dp [ j ][ 0 ] = 1 ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = minProfit ; k >= 0 ; k -- ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } return dp [ n ][ minProfit ]; } \u5b8c\u5168\u80cc\u5305 \u00b6 \u4e00\u4e2a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u662f W\uff0c\u6709 N \u79cd\u7269\u54c1\uff0c\u6bcf\u4e00\u4ef6\u6709\u81ea\u5df1\u7684\u4ef7\u503c v_{i} v_{i} \u548c \u91cd\u91cf w_{i} w_{i} \uff0c\u6bcf\u4e00\u79cd\u7c7b\u7684\u7269\u54c1\u65e0\u9650\u4f9b\u5e94\uff0c\u8bd5\u95ee\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u603b\u91cf\u4e0b\uff0c\u80cc\u5305\u7684\u4ef7\u503c\u6700\u5927\u3002 \u300c\u5206\u6790\u300d \u5b8c\u5168\u80cc\u5305\u95ee\u9898\u79cd\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u7684\u4f9b\u5e94\u662f\u65e0\u9650\u7684\uff0c\u4f46\u56e0\u4e3a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u6709\u9650\uff0c\u53ef\u4ee5\u653e\u5165\u7684\u6570\u76ee\u4f9d\u7136\u6709\u9650 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} \uff0c\u90a3\u4e48\u6211\u4eec\u4f9d\u7136\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u4e2d\u9009\u53d6\u82e5\u5e72\u4ef6\uff0c\u5728\u91cd\u91cf\u548c\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u4ef7\u503c\u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \u5728 01 \u80cc\u5305\u95ee\u9898\u4e2d\uff0cdp[ i ][ j ] \u662f\u7531 dp[i + 1][j - w[ i ]] + v[ i ] \u8f6c\u79fb\u800c\u6765\uff0c\u8868\u8fbe\u4e86\u9996\u6b21\u5c06\u7b2c i \u4ef6\u7269\u54c1\u52a0\u5165\u5230\u80cc\u5305\u4e2d\u3002\u4f46\u662f\u5728\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u91cc\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u662f\u53ef\u4ee5\u591a\u6b21\u653e\u5165\u7684\uff0c\u90a3\u4e48 dp[ i ][j - w[ i ]] + v[ i ] \u5c31\u5df2\u7ecf\u5305\u542b\u4e86 dp[i + 1][j - w[ i ]] + v[ i ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < vector < int >> dp ( n + 1 , vector < int > ( W + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= W ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= w [ i ]) { dp [ i ][ j ] = max ( dp [ i ][ j ], max ( dp [ i + 1 ][ j - w [ i ]], dp [ i ][ j - w [ i ]]) + v [ i ]); } } } return dp [ 0 ][ W ]; } \u7a7a\u95f4\u4e0a\u8fdb\u884c\u4f18\u5316 \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) 1 2 3 4 5 6 7 8 9 10 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = w [ i ]; j <= W ; j ++ ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u8fd9\u91cc\u4e0e 01 \u80cc\u5305\u7684\u4ee3\u7801\u53ea\u6709\u4e00\u884c\u4e0d\u540c\uff0c\u5373 j \u7684\u904d\u5386\u65b9\u5411\u4e0a\u3002\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u662f\u6709\u5c0f\u5230\u5927\u904d\u5386\uff0c\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ef\u4ee5\u88ab\u591a\u6b21\u653e\u5165\uff1b\u53cd\u800c 01 \u80cc\u5305\u95ee\u9898\u5bf9\u4efb\u4e00\u4ef6\u7269\u54c1\u6700\u591a\u53ea\u5141\u8bb8\u653e\u5165\u4e00\u6b21\u3002 \u6362\u96f6\u94b1 I \u00b6 \u7ed9\u5b9a\u4e00\u7ec4\u786c\u5e01\u7684\u9762\u503c coins = [186, 419, 83, 408] \u548c\u4e00\u4e2a\u603b\u91cf amount = 6249\uff0c\u8bd5\u95ee\u7528\u6700\u5c11\u7684\u786c\u5e01\u4e2a\u6570\u53ef\u4ee5\u7ec4\u6210\u8fd9\u4e2a amount\u3002\u5982\u679c\u4e0d\u80fd\u627e\u5230\u96f6\u94b1\u7ec4\u5408\uff0c\u8fd4\u56de -1\u3002 \u300c\u5206\u6790\u300d \u672c\u9898\u53ef\u4ee5\u88ab\u7406\u89e3\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u6bcf\u4e00\u679a\u786c\u5e01\u7684\u4ef7\u503c\u4e3a 1\uff0c\u6c42\u6700\u5c0f\u7684\u4ef7\u503c\u3002\u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u6784\u6210 j \u6570\u989d\u7684\u6700\u5c11\u786c\u5e01\u4e2a\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \u56e0\u4e3a\u6c42\u89e3\u7684\u662f\u6700\u5c0f\u4e2a\u6570\uff0c\u90a3\u4e48\u6570\u7ec4\u521d\u59cb\u5316\u6210\u6700\u5927\u503c\uff0c\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528 amount + 1 \u4f5c\u4e3a\u6700\u5927\u503c\uff0c\u56e0\u4e3a\uff0c\u6700\u5c0f\u7684\u96f6\u94b1\u662f 1\u3002\u90a3\u4e48\u6700\u591a\u7684\u786c\u5e01\u4e2a\u6570\u4e5f\u4e0d\u4f1a\u8d85\u8fc7 amount\u3002\u5f53 anount = 0 \u65f6\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u786c\u5e01\uff0c\u5373 0\u3002 1 2 3 4 5 6 7 8 9 10 int coinChange ( vector < int >& coins , int amount ) { vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - coin ] + 1 ); } } return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002 \u6362\u96f6\u94b1 II \u00b6 \u540c\u4e0a\u9898\u80cc\u666f\uff0c\u6c42\u80fd\u591f\u7ec4\u5408\u51fa\u7ed9\u5b9a\u91d1\u989d\u7684\u96f6\u94b1\u65b9\u6848\u6570\u76ee \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u7ec4\u6210\u91d1\u989d\u662f j \u7684\u65b9\u6848\u6570\u76ee \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 int coinChange ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] += dp [ j - coin ]; } } return dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(\\text{n} \\times \\text{amount}) O(\\text{n} \\times \\text{amount}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(\\text{amount}) O(\\text{amount}) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002 \u6362\u96f6\u94b1 III \u00b6 \u540c\u4e0a\u9898\u80cc\u666f\uff0c\u4f9d\u7136\u6c42\u65b9\u6848\u6570\u76ee\uff0c\u4f46\u8981\u6c42\u786c\u5e01\u5177\u6709\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982 coins = [1, 2, 3]\uff0c\u7ec4\u6210 amount = 3 \u7684\u65b9\u6848\u6709 [1, 1, 1]\uff0c[1, 2]\uff0c[2, 1]\uff0c[ 3 ] 4 \u79cd\uff0c\u6ce8\u610f\u5230 [1, 2] \u548c [2, 1] \u662f\u4e0d\u4e00\u6837\u7684\u65b9\u6848\u3002 \u300c\u5206\u6790\u300d \u540c\u4e0a\u9898\uff0c\u8bbe dp[ j ] \u4e3a \u91d1\u989d\u4e3a j \u7684\u65b9\u6848\u6570\u76ee\u3002\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u4e24\u5c42\u5faa\u73af\u7684\u4f4d\u7f6e\u3002 \u7269\u54c1\u5faa\u73af\u5728\u5916\u4fa7\uff0c\u6570\u91cf\u5faa\u73af\u5728\u5185\u6d4b\u65f6\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u7ec4\u5408\u60c5\u51b5\uff1b\u53cd\u4e4b\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u6392\u5217\u60c5\u51b5 1 2 3 4 5 6 7 8 9 10 int combinationSum41 ( vector < int >& coins , int amount ) { vector < unsigned int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] += dp [ j - coin ]; } } return ( int ) dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002 \u5e73\u65b9\u6570\u7684\u6700\u5c0f\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6570 n = 13\uff0c\u5b83\u53ef\u4ee5\u7531\u82e5\u5e72\u4e2a\u5e73\u65b9\u6570\u76f8\u52a0\u800c\u5f97\uff0c\u8fd4\u56de\u8fd9\u4e9b\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u7684\u6700\u5c0f\u503c\u300213 = 4 + 9\uff0c\u5373\u6700\u5c0f\u503c\u4e3a 2. \u300c\u5206\u6790\u300d \u65b9\u6cd5 1\uff1a\u8f6c\u5316\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u7edf\u8ba1 1 - n \u4e4b\u95f4\u6240\u6709\u7684\u5e73\u65b9\u6570\uff0c\u4e4b\u540e\u6309\u7167\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u89e3\u6cd5\u6c42\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int numSquares ( int n ) { if ( n <= 0 ) { return 0 ; } vector < int > square ; for ( int i = 1 ; i <= n ; i ++ ) { int root = ( int ) sqrt ( i ); if ( root * root == i ) { square . emplace_back ( i ); } } vector < int > dp ( n + 1 , n + 1 ); dp [ 0 ] = 0 ; for ( int s : square ) { for ( int j = s ; j <= n ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - s ] + 1 ); } } return dp [ n ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\sqrt{n}) O(n \\sqrt{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002 \u65b9\u6cd5 2\uff1a\u8bbe dp[ i ] \u4e3a\u6784\u6210 i \u7684\u6700\u5c0f\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u3002 \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int numSquares ( int n ) { if ( n < 1 ) { return 0 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i <= n ) { dp [ i * i ] = 1 ; } if ( dp [ i ]) { continue ; } int min = INT_MAX ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( min > dp [ j ] + dp [ i - j ]) { min = dp [ j ] + dp [ i - j ]; } } dp [ i ] = min ; } int ans = dp [ n ]; delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002","title":"\u80cc\u5305\u95ee\u9898"},{"location":"algo/dp/knapsack/#01","text":"\u4e00\u4e2a\u80cc\u5305\u6709\u4e00\u5b9a\u7684\u627f\u91cd W\uff0c\u6709N\u4ef6\u7269\u54c1\uff0c\u6bcf\u4ef6\u90fd\u6709\u81ea\u5df1\u7684\u4ef7\u503c\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 v \u4e2d\uff0c\u4e5f\u90fd\u6709\u81ea\u5df1\u7684\u91cd\u91cf\uff0c\u8bb0\u5f55\u5728\u6570\u7ec4 w \u4e2d\uff0c\u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u9009\u62e9\u8981\u88c5\u5165\u80cc\u5305\u8fd8\u662f\u4e0d\u88c5\u5165\u80cc\u5305\uff0c\u8981\u6c42\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u7684\u524d\u63d0\u4e0b\uff0c\u9009\u51fa\u7269\u54c1\u7684\u603b\u4ef7\u503c\u6700\u5927\u3002\u4f8b\u5982\uff0c \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \\begin{aligned} & \\text{v = [1, 2, 3]} \\\\ & \\text{w = [1, 2, 4]} \\\\ & \\text{W = 6} \\end{aligned} \u6700\u5927\u7684\u4ef7\u503c\u4e3a 5\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u5728\u80cc\u5305\u5bb9\u91cf\u4e3a j \u4e0b\u7684\u6700\u5927\u4ef7\u503c\u3002\u6b64\u65f6\u7684\u72b6\u6001\u53ea\u4f1a\u6709\u4e24\u4e2a\uff1a\uff081\uff09\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\uff082\uff09\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1]][ j ], dp[i + 1][j - w[ i ]]} + v[ i ]) \uff081\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u6ca1\u6709\u88ab\u9009\u4e2d\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j\uff1b\uff082\uff09\u5982\u679c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u9009\u4e2d\u4e86\uff0c\u90a3\u4e48\u7b2c i + 1 \u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u5c31\u662f j - w[ i ]\uff0c\u8fd9\u91cc\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u7b2c i \u4ef6\u7269\u54c1\u88ab\u52a0\u5165\u540e\uff0c\u603b\u91cd\u91cf\u5c06\u4f1a\u8fbe\u5230 j\uff0c\u90a3\u4e48\u52a0\u5165\u4e4b\u524d\u7684\u91cd\u91cf\u81ea\u7136\u5c31\u7b49\u4e8e j - w[ i ]\u3002\u5f53\u7136\uff0c\u5728\u8ba1\u7b97\u7684\u65f6\u5019\u9700\u8981\u5224\u5b9a\uff0c\u5f53\u524d\u7684\u603b\u91cd\u91cf j \u662f\u5426\u5927\u4e8e\u7b2c i \u4ef6\u7269\u54c1\u7684\u91cd\u91cf\u3002 \u300c\u7ebf\u6027\u7a7a\u95f4\u300d \u56e0\u4e3a\u72b6\u6001\u7684\u8f6c\u79fb\u53ea\u53d1\u751f\u5728\u76f8\u90bb\u7269\u54c1\u4e4b\u95f4\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u5f97\u4ee5\u4f18\u5316\uff0c\u4f46\u7528\u4e00\u7ef4\u7684\u7a7a\u95f4\u65f6\uff0c\u5e94\u5bf9\u5bb9\u91cf w \u8fdb\u884c \u5012\u5e8f\u904d\u5386 \u3002 1 2 3 4 5 6 7 8 9 10 int knapsack01 ( vector < int > v , vector < int > w , int W ) { int N = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\times W) O(N \\times W) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(W) O(W) \uff0cN \u4e3a\u7269\u54c1\u7684\u6570\u76ee\uff0cW \u4e3a\u9650\u5b9a\u7684\u91cd\u91cf \u300c\u91cd\u6784\u6700\u4f18\u89e3\u300d \u9664\u4e86\u5f97\u5230\u6700\u7ec8\u7684\u603b\u4ef7\u503c\uff0c\u6211\u4eec\u4e5f\u5e0c\u671b\u83b7\u77e5\u80cc\u5305\u7684\u65b9\u6848\uff0c\u5373\u6311\u9009\u54ea\u4e9b\u7269\u54c1\u653e\u5165\u80cc\u5305\u4e2d\u3002\u5728\u8fd9\u4e00\u6b65\uff0c\u6211\u4eec\u9700\u8981\u4e8c\u7ef4\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e00\u6b65\u7684\u8fed\u4ee3\u3002\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ea\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u52a0\u5165\u80cc\u5305\u548c\u4e0d\u52a0\u5165\u80cc\u5305\uff0c\u5e76\u4e14\uff0c\u5f53\u524d\u7684\u7269\u54c1\u53ea\u4e0e\u540e\uff08\u524d\uff09\u4e00\u4ef6\u7269\u54c1\u6709\u5173\u7cfb\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053 dp[ i ][ j ] \u662f\u7b49\u4e8e dp[i + 1][ j ] \u8fd8\u662f\u7b49\u4e8e dp[i + 1][j - w[ i ]] + v[ i ]\u3002\u5982\u679c\u662f\u540e\u8005\uff0c\u8bf4\u660e\u7b2c i \u4ef6\u7269\u54c1\u88ab\u653e\u5165\uff0c\u53cd\u4e4b\uff0c\u5219\u672a\u88ab\u653e\u5165\u3002\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u54ea\u4e9b\u7269\u54c1\u88ab\u653e\u5165\u5373\u53ef\uff0c\u540c\u65f6\u66f4\u65b0 j\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int knapsack ( vector < int > w , vector < int > v , int W ) { int n = ( int ) w . size (); vector < vector < int >> G ( n + 1 , vector < int > ( W + 1 , 0 )); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = W ; j >= w [ i ]; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } G [ i ] = dp ; } vector < int > idx ; for ( int i = 0 , j = W ; i < n && j >= 0 ; i ++ ) { if ( G [ i ][ j ] == G [ i + 1 ][ j - w [ i ]] + v [ i ]) { idx . emplace_back ( i ); j -= w [ i ]; } } for ( int id : idx ) { printf ( \"w[%d]=%d \\n \" , id , w [ id ]); } return dp [ W ]; } \u300c\u521d\u59cb\u5316\u7ec6\u8282\u300d \u4e00\u4e2a\u5bb9\u91cf\u4e3a W \u7684\u80cc\u5305\uff0c\u6709\u4e24\u79cd\u4e0d\u540c\u7684\u8981\u6c42\uff1a\uff081\uff09\u80cc\u5305\u8981\u88ab\u88c5\u6ee1\u548c\uff082\uff09\u80cc\u5305\u53ef\u4ee5\u4e0d\u6ee1\u3002\u8fd9\u4e24\u79cd\u7684\u521d\u59cb\u5316\u662f\u4e0d\u540c\u7684\u3002 \u5bf9\u4e8e\uff081\uff09\uff0cdp[ 0 ] \u88ab\u8bbe\u7f6e\u4e3a 0\uff0cdp[1 : W] \u88ab\u8bbe\u7f6e\u4e3a -\\infty -\\infty \uff1b\u5bf9\u4e8e\uff082\uff09\uff0cdp[0 : W] \u90fd\u4e3a 0\u3002\u53ef\u4ee5\u8fd9\u6837\u7406\u89e3\uff0c\u6761\u4ef6\uff081\uff09\u8981\u6c42\u80cc\u5305\u88c5\u6ee1\uff0c\u90a3\u4e48 W = 0 \u662f\u6ee1\u8db3\u7684\uff0c\u56e0\u4e3a\u7a7a\u80cc\u5305\u7684\u5bb9\u91cf\u5c31\u662f 0\uff0c\u4f46\u662f\u4e00\u65e6\u80cc\u5305\u7684\u5bb9\u91cf\u4e0d\u662f 0\uff0c\u90a3\u4e48\u672a\u88c5\u4efb\u4f55\u7269\u54c1\uff08\u7a7a\u8f7d\uff09\u662f\u4e0d\u7b26\u5408\u80cc\u5305\u88c5\u6ee1\u7684\u8981\u6c42\uff0c -\\infty -\\infty \u8868\u793a\u65e0\u5408\u6cd5\u7684\u89e3\uff1b\u53cd\u89c2\u6761\u4ef6\uff082\uff09\uff0c\u7a7a\u8f7d\u5bf9\u4e8e\u4efb\u610f\u7684 W \u90fd\u662f\u4e00\u4e2a\u5408\u6cd5\u89e3\uff0c\u56e0\u6b64\u7a7a\u8f7d\u80cc\u5305\u7684\u4ef7\u503c\u5c31\u662f 0\u3002 \u8fd9\u91cc\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0cv = [4, 3, 7, 5]\uff0cw = [2, 3, 5, 7]\uff0cW = 9\u3002\u5982\u679c\u8981\u6c42\u88c5\u6ee1\u80cc\u5305\uff0c\u7ed3\u679c\u662f 9\uff1b\u53cd\u4e4b\u662f 11\u3002","title":"01 \u80cc\u5305"},{"location":"algo/dp/knapsack/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4, \u5982 nums = [1, 1, 1, 1, 1] \u548c\u4e00\u4e2a\u76ee\u6807\u503c target = 3\u3002\u5bf9\u4e8e\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u524d\u65b9\u653e\u7f6e\u4e00\u4e2a\u8fd0\u7b97\u7b26 + \u6216\u8005 - \u6765\u6784\u6210\u4e00\u4e2a\u8ba1\u7b97\u8868\u8fbe\u5f0f\uff0c\u8bd5\u95ee\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\u7ed3\u679c\u6070\u597d\u4e3a target \u7684\u4e2a\u6570\u4e3a\u591a\u5c11\uff1f \u300c\u5206\u6790\u300d \u9898\u610f\u53ef\u4ee5\u88ab\u89e3\u91ca\u4e3a\uff0c\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u7ec4\uff0c\u5176\u4e2d\u4e00\u7ec4\u5168\u90e8\u4e3a\u6807\u5fd7\u4e3a\u6b63\u6570\uff0c\u53e6\u4e00\u7ec4\u6807\u5fd7\u4e3a\u8d1f\u6570\uff0c\u8fd9\u6837\u6c42\u548c\u7ed3\u679c\u4e3a target\u3002\u672c\u9898\u662f 01 \u80cc\u5305\u95ee\u9898\u6c42\u65b9\u6848\u6570\u95ee\u9898\u3002\u5047\u8bbe\u6570\u7ec4\u548c\u4e3a sum\uff0c\u6b63\u6570\u7ec4\u7684\u548c\u4e3a pos\uff0c\u8d1f\u6570\u7ec4\u7684\u548c\u4e3a neg\uff08\u7edd\u5bf9\u503c\uff09\uff0c\u53ef\u4ee5\u5f97\u5230\u5982\u4e0b\u5173\u7cfb \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = target} \\end{aligned} \\Rightarrow 2 \\times \\text{neg = sum - target} \u6240\u4ee5\uff0csum \u5fc5\u987b\u4e0d\u5c0f\u4e8e target\uff0c\u5e76\u4e14 sum - targte \u5fc5\u987b\u662f\u5076\u6570\u3002 \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5230\u6700\u540e\u4e00\u4e2a\u6570\u4e2d\u6c42\u548c\u7b49\u4e8e j \u7684\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, & \\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u5173\u6ce8\u8fb9\u754c\u6761\u4ef6\uff1a\u5982\u679c j = 0\uff0c\u5373\u8d1f\u6570\u548c\u7684\u7edd\u5bf9\u503c\u4e3a 0\uff0c\u8868\u660e\u6211\u4eec\u5e94\u8be5\u4e0d\u9009\u53d6\u4efb\u4f55\u5143\u7d20\uff0c\u56e0\u6b64 dp[ i ][ 0 ] = 1\uff0c\u8fd9\u91cc i \u4ece 0 \u5230 n - 1\u3002\u5f53 i == n\uff0c\u5373\u5f53\u524d\u6570\u7ec4\u6ca1\u6709\u5143\u7d20\uff0c\u53ea\u6709 j == 0 \u65f6\uff0c\u65b9\u6848\u6570\u76ee\u624d\u4e3a 1\u3002\u5982\u679c\u4ece\u540e\u5411\u524d\u9012\u63a8\uff0c\u6700\u7ec8\u7684\u7b54\u6848\u662f dp[ 0 ][ target ]\u3002\u4f18\u5316\u540e\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u662f\u7ebf\u6027\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int findTargetSumWays ( vector < int >& nums , int target ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( target > sum || ( sum - target ) % 2 != 0 ) { return 0 ; } int neg = ( sum - target ) >> 1 ; vector < int > dp ( neg + 1 , 0 ); dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int j = neg ; j >= num ; j -- ) { dp [ j ] += dp [ j - num ]; } } return dp [ neg ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(target \\times n) O(target \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(target) O(target) \uff0c\u8fd9\u91cc target \u662f\u76ee\u6807\u503c\u5927\u5c0f\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002","title":"\u76ee\u6807\u548c"},{"location":"algo/dp/knapsack/#_2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6784\u6210\u7684\u6570\u7ec4\uff0c\u5982 nums = [1, 5, 11, 5]\uff0c\u5224\u65ad\u80fd\u5426\u5c06\u6b64\u6570\u7ec4\u5206\u5272\u6210\u4e24\u4e2a\u6570\u7ec4\uff08\u4e0d\u8981\u6c42\u8fde\u7eed\uff09\uff0c\u4f7f\u4e24\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u76f8\u7b49\u3002\u7ed9\u51fa\u7684\u4f8b\u5b50\u53ef\u4ee5\u88ab\u5206\u6210 [1, 5, 5] \u548c [ 11 ] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u6211\u4eec\u5c06\u4e00\u4e2a\u6570\u7ec4\u5206\u6210\u4e24\u4e2a\u90e8\u5206\uff0c\u53ef\u4ee5\u7406\u89e3\u6210\u9009\u53d6\u82e5\u5e72\u4e2a\u6570\uff0c\u5176\u548c\u662f\u539f\u6570\u7ec4\u548c\u7684\u4e00\u534a\u3002\u56e0\u6b64\uff0c\u53ef\u4ee5\u5c06\u6b64\u9898\u8f6c\u6362\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\u503c\uff0c\u5176\u548c\u662f\u5426\u7b49\u4e8e j\u3002\u5982\u679c\u539f\u6570\u7ec4\u7684\u548c sum \u662f\u5947\u6570\uff0c\u90a3\u4e48\u76f4\u63a5\u8fd4\u56de false\uff0c\u56e0\u4e3a\u4e24\u4e2a\u76f8\u7b49\u6570\u7684\u548c\u4e00\u5b9a\u662f\u5076\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{nums[ i ]} \\\\ \\text{dp[i + 1][ j ] or dp[i + 1][j - nums[ i ]]}, &\\quad \\text{j } \\geq \\text{nums[ i ]} \\end{cases} \u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u5f53 j == 0 \u65f6\uff0c\u8bf4\u660e\u4e24\u4e2a\u6570\u7ec4\u5747\u4e3a\u7a7a\uff0c\u90a3\u4e48\u6574\u4e2a\u6570\u7ec4\u5e94\u8be5\u4e3a\u7a7a\uff0c\u5bf9\u5e94\u7684 i == n \uff08\u4ece\u540e\u5f80\u524d\u9012\u63a8\uff09\u3002\u6700\u540e\u7684\u7b54\u6848\u5e94\u8be5\u4e3a dp[ 0 ][ sum / 2 ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool canPartition ( vector < int >& nums ) { int n = ( int ) nums . size (), sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; vector < vector < bool >> dp ( n + 1 , vector < bool > ( sum + 1 , 0 )); dp [ n ][ 0 ] = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= sum ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= nums [ i ]) { dp [ i ][ j ] = dp [ i ][ j ] || dp [ i + 1 ][ j - nums [ i ]]; } } } return dp [ 0 ][ sum ]; } \u7a7a\u95f4\u4f18\u5316\u540e\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool canPartition ( vector < int >& nums ) { int sum = 0 ; for ( int num : nums ) { sum += num ; } if ( sum % 2 != 0 ) { return false ; } sum /= 2 ; bool * dp = new bool [ sum + 1 ]{}; dp [ 0 ] = true ; for ( int num : nums ) { for ( int j = sum ; j >= num ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - num ]; } } return dp [ sum ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(sum \\times n) O(sum \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(sum) O(sum) \uff0c\u8fd9\u91cc sum \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002","title":"\u5206\u5272\u7b49\u548c\u5b50\u96c6"},{"location":"algo/dp/knapsack/#_3","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 stones = [2, 7, 4, 1, 8, 1] \u8868\u793a\u4e00\u7ec4\u77f3\u5934\u7684\u91cd\u91cf\u3002\u4ece\u5f53\u524d\u7684\u77f3\u5934\u91cc\u4efb\u53d6\u4e24\u4e2a\uff0c\u8d28\u91cf\u662f x \u548c y\uff0c\u5982\u679c\u4e24\u5757\u8d28\u91cf\u76f8\u7b49\u5373 x = y\uff0c\u90a3\u4e48\u8fd9\u4e24\u5757\u77f3\u5934\u88ab\u79fb\u9664\uff1b\u53cd\u4e4b\uff0c\u79fb\u9664\u8f83\u5c0f\u7684\u90a3\u4e00\u5757\uff0c\u5e76\u4e14\u8f83\u5927\u7684\u90a3\u4e00\u5757\u53d8\u6210\u8fd9\u4e24\u5757\u8d28\u91cf\u7684\u5dee\u503c\uff08\u7edd\u5bf9\u503c\uff09\u3002\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u76f4\u5230\u5269\u4f59\u4e00\u5757\u6216\u8005\u65e0\u5269\u4f59\uff0c\u6c42\u5269\u4f59\u7684\u6700\u5c0f\u8d28\u91cf\u662f\u591a\u5c11\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u53ef\u4ee5\u539f\u6570\u7ec4\u5206\u5272\u6210\u4e24\u7ec4 + \u548c -\uff0c\u6211\u4eec\u7528 + \u8fd9\u4e00\u7ec4\u51cf\u53bb - \u8fd9\u4e00\u7ec4\uff0c\u6240\u5f97\u7ed3\u679c\u7684\u6700\u5c0f\u503c\u662f\u6700\u7ec8\u7ed3\u679c\uff0c\u8fd9\u6837\u95ee\u9898\u8f6c\u5316\u6210 01 \u80cc\u5305\u95ee\u9898\u3002\u8bbe neg \u4e3a - \u8fd9\u4e00\u7ec4\u7684\u548c\uff0cpos \u4e3a + \u8fd9\u4e00\u7ec4\u7684\u548c\u3002\u6ee1\u8db3\u4e0b\u5217\u65b9\u7a0b\u7ec4 \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \\begin{aligned} & \\text{pos + neg = sum} \\\\ & \\text{pos - neg = res} \\end{aligned} \\quad \\Rightarrow \\quad 2 \\times \\text{neg = sum - res} \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor 0 \\leq \\text{neg} \\leq \\left \\lfloor \\frac{\\text{sum}}{2} \\right \\rfloor \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u6210\uff0c\u4ece\u539f\u6570\u7ec4\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u503c\uff0c\u5176\u548c\u7b49\u4e8e neg\uff0c\u5e76\u4e14\u4f7f\u5f97 \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \\arg \\min_{\\text{neg}} \\text{(sum} - \\text{neg} \\times \\text{2)} \u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4e2a\u6570\u5b57\u5230\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\uff0c\u5b83\u4eec\u7684\u548c\u5728\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u503c\u662f\u591a\u5c11\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{stones[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[i + 1][j - stones[ i ]] + stones[ i ]]} \\end{cases} , &\\quad \\text{j } \\geq \\text{stones[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 int lastStoneWeightII ( vector < int >& stones ) { int sum = 0 ; for ( int stone : stones ) { sum += stone ; } int tar = ( sum >> 1 ); vector < int > dp ( tar + 1 , 0 ); for ( int stone : stones ) { for ( int j = tar ; j >= stone ; j -- ) { dp [ j ] = max ( dp [ j ], dp [ j - stone ] + stone ); } } return sum - 2 * dp [ tar ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(tar \\times n) O(tar \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(tar) O(tar) \uff0c\u8fd9\u91cc tar \u662f\u539f\u6570\u7ec4\u7684\u548c\u7684\u4e00\u534a\uff0cn \u662f\u6570\u7ec4\u957f\u5ea6\u3002","title":"\u6700\u540e\u4e00\u5757\u77f3\u5934\u7684\u91cd\u91cf"},{"location":"algo/dp/knapsack/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570 n \u4ee3\u8868\u4eba\u6570\uff0cminProfit \u4ee3\u8868\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u4e00\u4e32\u5de5\u4f5c\u9700\u8981\u7684\u4eba\u6570 group = [2, 2]\uff0c\u6bcf\u9879\u5de5\u4f5c\u5bf9\u5e94\u7684\u5229\u6da6 profit = [2, 3]\u3002\u8981\u6c42\u5b9e\u73b0\u6700\u4f4e\u76c8\u5229\u989d\uff0c\u5e76\u4e14\u6295\u5165\u7684\u4eba\u6570\u548c\u4e0d\u80fd\u8d85\u8fc7 n\uff0c\u8fd9\u6837\u7684\u5206\u914d\u65b9\u6848\u6570\u76ee\u6709\u591a\u5c11\u4e2a\uff1f \u300c\u5206\u6790\u300d \u5728 01 \u80cc\u5305\u95ee\u9898\u7684\u57fa\u7840\u4e0a\uff0c\u672c\u9898\u589e\u52a0\u4e86\u6700\u4f4e\u76c8\u5229\u989d\u7684\u9650\u5236\u3002\u8bbe dp[ i ][ j ][ k ] \u4e3a\u4ece i \u5f00\u59cb\u7684\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u4e9b\u5de5\u4f5c\u6295\u5165\u4eba\u529b\uff0c\u5728\u6070\u597d j \u4e2a\u4eba\u4e14\u76c8\u5229\u989d\u4e0d\u4f4e\u4e8e k \u7684\u60c5\u51b5\u4e0b\uff0c\u65b9\u6848\u6570\u76ee\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \\text{dp[ i ][ j ][ k ]} = \\begin{cases} \\text{dp[i + 1][ j ][ k ]}, &\\quad \\text{j } < \\text{group[ i ]} \\\\ \\begin{aligned} & \\text{dp[i + 1][ j ][ k ]} + \\\\ & \\text{dp[i + 1][j - group[ i ]][max(0, k - profit[ i ])]} \\end{aligned} , &\\quad \\text{j } \\geq \\text{group[ i ]} \\end{cases} \u8fb9\u754c\u6761\u4ef6 dp[ len ][ 0 ][ 0 ] = 1\uff0c\u8868\u660e\u4e0d\u9009\u4efb\u4f55\u5de5\u4f5c\u65f6\uff0c\u6295\u5165\u7684\u4eba\u6570\u662f 0\uff0c\u6700\u4f4e\u7684\u76c8\u5229\u989d\u4e5f\u662f 0\uff0c\u6b64\u65f6\u4e5f\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\u4e00\u79cd\u65b9\u6848\u3002\u8fdb\u4e00\u6b65\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c\u5f53 k = 0 \u5373\u6700\u4f4e\u76c8\u5229\u989d\u4e3a 0\uff0c\u90a3\u4e48\u4e0d\u8bba i \u548c j \u4e3a\u4f55\u503c\uff0cdp[ i ][ j ][ 0 ] \u5747\u4e3a 1\u3002 \\text{k - profit[ i ]} \\text{k - profit[ i ]} \u4e3a\u8d1f\u6570\uff0c\u8bf4\u660e\u7b2c i \u4e2a\u5de5\u4f5c\u7684\u5229\u6da6\u672c\u8eab\u5c31\u8d85\u8fc7 minProfit\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728\u9009\u62e9\u7b2c i \u4e2a\u5de5\u4f5c\u524d\uff0c\u6700\u4f4e\u76c8\u5229\u53ef\u4ee5\u4e3a 0\uff0c\u8fd9\u4e2a\u65f6\u5019\u53ea\u8981\u6295\u5165\u7684\u4eba\u6570\u4e0d\u8d85\u8fc7 j - group[ i ]\uff0c\u90fd\u88ab\u89c6\u4e3a\u6ee1\u8db3\u8981\u6c42\u7684\u65b9\u6848\u3002\u76f8\u53cd\uff0c\u5982\u679c\u6211\u4eec\u7ea6\u675f \\text{k} \\geq \\text{profit[ i ]} \\text{k} \\geq \\text{profit[ i ]} \uff0c\u6211\u4eec\u6700\u7ec8\u5f97\u5230\u7684\u7ed3\u679c\u662f \u6070\u597d\u7b49\u4e8e minProfit \u7684\u65b9\u6848\u6570\uff0c\u56e0\u4e3a k - profit[ i ] \u53ea\u4f1a\u8f6c\u79fb\u5230\u7b2c\u4e09\u7ef4\u6210\u4e3a 0 \u7684\u72b6\u6001\u3002 \u6700\u7ec8\u7684\u7b54\u6848\u662f\u8003\u5bdf\u6240\u6709\u7684\u5de5\u4f5c\u4e14\u6ee1\u8db3\u6700\u4f4e\u76c8\u5229\u989d\u7684\u6761\u4ef6\u4e0b\uff0c\u5bf9\u6295\u5165\u7684\u4eba\u6570\u904d\u5386 \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} \\text{ans} = \\sum_{j = 0}^{n} \\text{dp[ 0 ][ j ][ minProfit ]} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); dp [ 0 ][ 0 ] = 1 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = 0 ; k <= minProfit ; k ++ ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } int ans = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { ans += dp [ j ][ minProfit ]; ans %= MOD ; } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(len \\times n \\times minProfit) O(len \\times n \\times minProfit) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n \\times minProfit) O(n \\times minProfit) \uff0c\u8fd9\u91cc len \u662f\u5de5\u4f5c\u7684\u4e2a\u6570 / \u5229\u6da6\u6570\u7ec4\u7684\u957f\u5ea6\uff0cn \u662f\u603b\u4eba\u6570\uff0cminProfit \u662f\u6700\u4f4e\u76c8\u5229\u989d\u3002 \u8fd9\u4e2a\u9898\u76ee\u4e5f\u53ef\u4ee5\u5b9a\u4e49\u6210 dp[ i ][ j ][ k ] \u4ece\u7b2c i \u4e2a\u5de5\u4f5c\u5230\u6700\u540e\u4e00\u4e2a\u5de5\u4f5c\u4e2d\u9009\u53d6\u67d0\u51e0\u4e2a\uff0c\u5728\u6295\u5165\u4e0d\u8d85\u8fc7 j \u4e2a\u4eba\u4e14\u5229\u6da6\u4e0d\u4f4e\u4e8e k \u7684\u6761\u4ef6\u4e0b\u7684\u65b9\u6848\u6570\u76ee\u3002\u5bf9\u5e94\u7684\u521d\u59cb\u5316\u5e94\u8be5\u6539\u6210 dp[ i ][ j ][ 0 ] = 1\uff0c\u6700\u540e\u7684\u7ed3\u679c\u662f dp[ 0 ][ n ][ minProfit ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int profitableSchemes ( int n , int minProfit , vector < int >& group , vector < int >& profit ) { int len = ( int ) group . size (), MOD = 1000000007 ; vector < vector < int >> dp ( n + 1 , vector < int > ( minProfit + 1 , 0 )); for ( int j = 0 ; j <= n ; j ++ ) { dp [ j ][ 0 ] = 1 ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = n ; j >= group [ i ]; j -- ) { for ( int k = minProfit ; k >= 0 ; k -- ) { dp [ j ][ k ] += dp [ j - group [ i ]][ max ( 0 , k - profit [ i ])]; dp [ j ][ k ] %= MOD ; } } } return dp [ n ][ minProfit ]; }","title":"\u76c8\u5229\u8ba1\u5212"},{"location":"algo/dp/knapsack/#_5","text":"\u4e00\u4e2a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u662f W\uff0c\u6709 N \u79cd\u7269\u54c1\uff0c\u6bcf\u4e00\u4ef6\u6709\u81ea\u5df1\u7684\u4ef7\u503c v_{i} v_{i} \u548c \u91cd\u91cf w_{i} w_{i} \uff0c\u6bcf\u4e00\u79cd\u7c7b\u7684\u7269\u54c1\u65e0\u9650\u4f9b\u5e94\uff0c\u8bd5\u95ee\u5728\u4e0d\u8d85\u8fc7\u80cc\u5305\u627f\u91cd\u603b\u91cf\u4e0b\uff0c\u80cc\u5305\u7684\u4ef7\u503c\u6700\u5927\u3002 \u300c\u5206\u6790\u300d \u5b8c\u5168\u80cc\u5305\u95ee\u9898\u79cd\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u7684\u4f9b\u5e94\u662f\u65e0\u9650\u7684\uff0c\u4f46\u56e0\u4e3a\u80cc\u5305\u627f\u91cd\u603b\u91cf\u6709\u9650\uff0c\u53ef\u4ee5\u653e\u5165\u7684\u6570\u76ee\u4f9d\u7136\u6709\u9650 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} 0 \\leq c_{i} \\leq \\frac{W}{w_{i}} \uff0c\u90a3\u4e48\u6211\u4eec\u4f9d\u7136\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\u7b2c i \u4ef6\u7269\u54c1\u5230\u6700\u540e\u4e00\u4ef6\u7269\u54c1\u4e2d\u9009\u53d6\u82e5\u5e72\u4ef6\uff0c\u5728\u91cd\u91cf\u548c\u4e0d\u8d85\u8fc7 j \u7684\u60c5\u51b5\u4e0b\u6700\u5927\u4ef7\u503c\u3002 \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{w[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - w[ i ]] + v[ i ]} \\end{cases}, &\\quad \\text{j } \\geq \\text{w[ i ]} \\end{cases} \u5728 01 \u80cc\u5305\u95ee\u9898\u4e2d\uff0cdp[ i ][ j ] \u662f\u7531 dp[i + 1][j - w[ i ]] + v[ i ] \u8f6c\u79fb\u800c\u6765\uff0c\u8868\u8fbe\u4e86\u9996\u6b21\u5c06\u7b2c i \u4ef6\u7269\u54c1\u52a0\u5165\u5230\u80cc\u5305\u4e2d\u3002\u4f46\u662f\u5728\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u91cc\uff0c\u6bcf\u4e00\u4ef6\u7269\u54c1\u662f\u53ef\u4ee5\u591a\u6b21\u653e\u5165\u7684\uff0c\u90a3\u4e48 dp[ i ][j - w[ i ]] + v[ i ] \u5c31\u5df2\u7ecf\u5305\u542b\u4e86 dp[i + 1][j - w[ i ]] + v[ i ]\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < vector < int >> dp ( n + 1 , vector < int > ( W + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= W ; j ++ ) { dp [ i ][ j ] = dp [ i + 1 ][ j ]; if ( j >= w [ i ]) { dp [ i ][ j ] = max ( dp [ i ][ j ], max ( dp [ i + 1 ][ j - w [ i ]], dp [ i ][ j - w [ i ]]) + v [ i ]); } } } return dp [ 0 ][ W ]; } \u7a7a\u95f4\u4e0a\u8fdb\u884c\u4f18\u5316 \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) \\text{dp[ j ]} = \\max(\\text{dp[ j ], dp[j - w[ i ]] + v[ i ]}) 1 2 3 4 5 6 7 8 9 10 int completeKnapsack ( vector < int > v , vector < int > w , int W ) { int n = ( int ) v . size (); vector < int > dp ( W + 1 , 0 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = w [ i ]; j <= W ; j ++ ) { dp [ j ] = max ( dp [ j ], dp [ j - w [ i ]] + v [ i ]); } } return dp [ W ]; } \u8fd9\u91cc\u4e0e 01 \u80cc\u5305\u7684\u4ee3\u7801\u53ea\u6709\u4e00\u884c\u4e0d\u540c\uff0c\u5373 j \u7684\u904d\u5386\u65b9\u5411\u4e0a\u3002\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u662f\u6709\u5c0f\u5230\u5927\u904d\u5386\uff0c\u56e0\u4e3a\u67d0\u4e00\u4ef6\u7269\u54c1\u53ef\u4ee5\u88ab\u591a\u6b21\u653e\u5165\uff1b\u53cd\u800c 01 \u80cc\u5305\u95ee\u9898\u5bf9\u4efb\u4e00\u4ef6\u7269\u54c1\u6700\u591a\u53ea\u5141\u8bb8\u653e\u5165\u4e00\u6b21\u3002","title":"\u5b8c\u5168\u80cc\u5305"},{"location":"algo/dp/knapsack/#i","text":"\u7ed9\u5b9a\u4e00\u7ec4\u786c\u5e01\u7684\u9762\u503c coins = [186, 419, 83, 408] \u548c\u4e00\u4e2a\u603b\u91cf amount = 6249\uff0c\u8bd5\u95ee\u7528\u6700\u5c11\u7684\u786c\u5e01\u4e2a\u6570\u53ef\u4ee5\u7ec4\u6210\u8fd9\u4e2a amount\u3002\u5982\u679c\u4e0d\u80fd\u627e\u5230\u96f6\u94b1\u7ec4\u5408\uff0c\u8fd4\u56de -1\u3002 \u300c\u5206\u6790\u300d \u672c\u9898\u53ef\u4ee5\u88ab\u7406\u89e3\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u6bcf\u4e00\u679a\u786c\u5e01\u7684\u4ef7\u503c\u4e3a 1\uff0c\u6c42\u6700\u5c0f\u7684\u4ef7\u503c\u3002\u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u6784\u6210 j \u6570\u989d\u7684\u6700\u5c11\u786c\u5e01\u4e2a\u6570\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\max \\begin{cases} \\text{dp[i + 1][ j ]} \\\\ \\text{dp[ i ][j - coins[ i ]] + 1} \\end{cases} , &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \u56e0\u4e3a\u6c42\u89e3\u7684\u662f\u6700\u5c0f\u4e2a\u6570\uff0c\u90a3\u4e48\u6570\u7ec4\u521d\u59cb\u5316\u6210\u6700\u5927\u503c\uff0c\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528 amount + 1 \u4f5c\u4e3a\u6700\u5927\u503c\uff0c\u56e0\u4e3a\uff0c\u6700\u5c0f\u7684\u96f6\u94b1\u662f 1\u3002\u90a3\u4e48\u6700\u591a\u7684\u786c\u5e01\u4e2a\u6570\u4e5f\u4e0d\u4f1a\u8d85\u8fc7 amount\u3002\u5f53 anount = 0 \u65f6\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u4efb\u4f55\u786c\u5e01\uff0c\u5373 0\u3002 1 2 3 4 5 6 7 8 9 10 int coinChange ( vector < int >& coins , int amount ) { vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - coin ] + 1 ); } } return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002","title":"\u6362\u96f6\u94b1 I"},{"location":"algo/dp/knapsack/#ii","text":"\u540c\u4e0a\u9898\u80cc\u666f\uff0c\u6c42\u80fd\u591f\u7ec4\u5408\u51fa\u7ed9\u5b9a\u91d1\u989d\u7684\u96f6\u94b1\u65b9\u6848\u6570\u76ee \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4ece\u7b2c i \u4e2a\u5230\u6700\u540e\u4e00\u4e2a\u786c\u5e01\u4e2d\u9009\u53d6\u82e5\u5e72\u4e2a\u7ec4\u6210\u91d1\u989d\u662f j \u7684\u65b9\u6848\u6570\u76ee \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\text{dp[i + 1][ j ]}, &\\quad \\text{j } < \\text{coins[ i ]} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j - coins[ i ]]}, &\\quad \\text{j } \\geq \\text{coins[ i ]} \\end{cases} 1 2 3 4 5 6 7 8 9 10 int coinChange ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] += dp [ j - coin ]; } } return dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(\\text{n} \\times \\text{amount}) O(\\text{n} \\times \\text{amount}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(\\text{amount}) O(\\text{amount}) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002","title":"\u6362\u96f6\u94b1 II"},{"location":"algo/dp/knapsack/#iii","text":"\u540c\u4e0a\u9898\u80cc\u666f\uff0c\u4f9d\u7136\u6c42\u65b9\u6848\u6570\u76ee\uff0c\u4f46\u8981\u6c42\u786c\u5e01\u5177\u6709\u5148\u540e\u987a\u5e8f\uff0c\u4f8b\u5982 coins = [1, 2, 3]\uff0c\u7ec4\u6210 amount = 3 \u7684\u65b9\u6848\u6709 [1, 1, 1]\uff0c[1, 2]\uff0c[2, 1]\uff0c[ 3 ] 4 \u79cd\uff0c\u6ce8\u610f\u5230 [1, 2] \u548c [2, 1] \u662f\u4e0d\u4e00\u6837\u7684\u65b9\u6848\u3002 \u300c\u5206\u6790\u300d \u540c\u4e0a\u9898\uff0c\u8bbe dp[ j ] \u4e3a \u91d1\u989d\u4e3a j \u7684\u65b9\u6848\u6570\u76ee\u3002\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u4e24\u5c42\u5faa\u73af\u7684\u4f4d\u7f6e\u3002 \u7269\u54c1\u5faa\u73af\u5728\u5916\u4fa7\uff0c\u6570\u91cf\u5faa\u73af\u5728\u5185\u6d4b\u65f6\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u7ec4\u5408\u60c5\u51b5\uff1b\u53cd\u4e4b\uff0c\u5f97\u5230\u65b9\u6848\u6570\u7684\u6392\u5217\u60c5\u51b5 1 2 3 4 5 6 7 8 9 10 int combinationSum41 ( vector < int >& coins , int amount ) { vector < unsigned int > dp ( amount + 1 , 0 ); dp [ 0 ] = 1 ; for ( int coin : coins ) { for ( int j = coin ; j <= amount ; j ++ ) { dp [ j ] += dp [ j - coin ]; } } return ( int ) dp [ amount ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\times amount) O(n \\times amount) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(amount) O(amount) \uff0c\u5176\u4e2d\uff0cn \u8868\u793a\u96f6\u94b1\u6570\u7ec4\u7684\u957f\u5ea6\uff0camount \u8868\u793a\u9700\u8981\u7ec4\u6210\u7684\u91d1\u989d\u3002","title":"\u6362\u96f6\u94b1 III"},{"location":"algo/dp/knapsack/#_6","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6570 n = 13\uff0c\u5b83\u53ef\u4ee5\u7531\u82e5\u5e72\u4e2a\u5e73\u65b9\u6570\u76f8\u52a0\u800c\u5f97\uff0c\u8fd4\u56de\u8fd9\u4e9b\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u7684\u6700\u5c0f\u503c\u300213 = 4 + 9\uff0c\u5373\u6700\u5c0f\u503c\u4e3a 2. \u300c\u5206\u6790\u300d \u65b9\u6cd5 1\uff1a\u8f6c\u5316\u6210\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u7edf\u8ba1 1 - n \u4e4b\u95f4\u6240\u6709\u7684\u5e73\u65b9\u6570\uff0c\u4e4b\u540e\u6309\u7167\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u89e3\u6cd5\u6c42\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int numSquares ( int n ) { if ( n <= 0 ) { return 0 ; } vector < int > square ; for ( int i = 1 ; i <= n ; i ++ ) { int root = ( int ) sqrt ( i ); if ( root * root == i ) { square . emplace_back ( i ); } } vector < int > dp ( n + 1 , n + 1 ); dp [ 0 ] = 0 ; for ( int s : square ) { for ( int j = s ; j <= n ; j ++ ) { dp [ j ] = min ( dp [ j ], dp [ j - s ] + 1 ); } } return dp [ n ]; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\sqrt{n}) O(n \\sqrt{n}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002 \u65b9\u6cd5 2\uff1a\u8bbe dp[ i ] \u4e3a\u6784\u6210 i \u7684\u6700\u5c0f\u5e73\u65b9\u6570\u7684\u4e2a\u6570\u3002 \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) \\text{dp[ i ]} = \\min_{k \\in [1, i)} (\\text{dp[ k ] + dp[i - k]}) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int numSquares ( int n ) { if ( n < 1 ) { return 0 ; } int * dp = new int [ n + 1 ]{}; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i <= n ) { dp [ i * i ] = 1 ; } if ( dp [ i ]) { continue ; } int min = INT_MAX ; for ( int j = 1 ; j <= i / 2 ; j ++ ) { if ( min > dp [ j ] + dp [ i - j ]) { min = dp [ j ] + dp [ i - j ]; } } dp [ i ] = min ; } int ans = dp [ n ]; delete [] dp ; return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u7ed9\u5b9a\u7684\u503c\u3002","title":"\u5e73\u65b9\u6570\u7684\u6700\u5c0f\u4e2a\u6570"},{"location":"algo/dp/lcs/","text":"\u5b50\u5e8f\u5217\u8fde\u7eed \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u5e8f\u5217\uff08\u6570\u7ec4\u6216\u5b57\u7b26\u4e32\uff09A = [1, 2, 3, 2, 1]\uff0c B = [3, 2, 1, 4, 7]\uff0c\u90a3\u4e48\u8fd9\u4e24\u8005\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u662f[3, 2, 1]\uff0c\u957f\u5ea6\u4e3a3 \u8bbedp[i][j]\u4e3aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4e5f\u5c31\u662f\u72b6\u6001\uff0c\u4e00\u5171n*m\u4e2a\u3002\u56e0\u4e3a\u8981\u6c42\u5b50\u6570\u7ec4\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u5f53\u524d\u72b6\u6001\u53ea\u4f1a\u4e0e\u4e0b\u4e00\u4e2a\uff08\u6216\u4e0a\u4e00\u4e2a\uff09\u72b6\u6001\u76f8\u5173\uff0c\u7531\u6b64\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002 \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \u5728\u72b6\u6001\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u8bb0\u5f55\u6700\u5927\u957f\u5ea6\u7684\u5927\u5c0f\u4ee5\u53ca\u6700\u5927\u957f\u5ea6\u7684\u4f4d\u7f6e\uff0c\u6700\u7ec8\u53ef\u8f93\u51fa\u6700\u957f\u5b50\u6570\u7ec4\u3002 \u76f8\u4f3c\u9898\u76ee \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 127. \u6700\u957f\u516c\u5171\u5b50\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2,\u8f93\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32 \u9898\u76ee\u4fdd\u8bc1str1\u548cstr2\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b1 \u8f93\u5165 \"1AB2345CD\",\"12345EF\" \u8fd4\u56de\u503c \"2345\" */ class Solution { public : /** * longest common substring * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @return string\u5b57\u7b26\u4e32 */ string LCS ( string str1 , string str2 ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); int len = 1 , pos = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( str1 [ i ] == str2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; if ( len < dp [ i ][ j ]) { len = dp [ i ][ j ]; pos = i ; } } } } return str1 . substr ( pos , len ); } }; \u5b50\u5e8f\u5217\u4e0d\u8fde\u7eed \u00b6 \u5f53\u5b50\u5e8f\u5217\u4e0d\u8981\u6c42\u8fde\u7eed\u65f6\uff0c\u4f9d\u7136\u53ef\u4ee5\u7528dp[i][j]\u8868\u793aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4f46\u662f\u72b6\u6001\u7684\u8f6c\u79fb\u65b9\u7a0b\u53d1\u751f\u6539\u53d8 \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \u5982\u679c\u8981\u6c42\u8f93\u51fa\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u5219\u9700\u8981\u91cd\u65b0\u626b\u9762\u4e00\u904d\u4e24\u4e2a\u5e8f\u5217 1 2 3 4 5 6 7 8 int m = ( int ) A . length (), n = ( int ) B . length (), i = 0 , j = 0 ; while ( i < m && j < n ) { if ( A [ i ] == B [ j ]) { printf ( ' % c ' , A [ i ]); } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } \u300c\u725b\u5ba2\u7f51 \u7a0b\u5e8f\u5458\u4ee3\u7801\u9762\u8bd5\u6307\u5357 31. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u8f93\u51fa\u8fde\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u8fc7\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u8f93\u5165\u63cf\u8ff0: \u8f93\u51fa\u5305\u62ec\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u4ee3\u8868\u5b57\u7b26\u4e32str1\uff0c\u7b2c\u4e8c\u884c\u4ee3\u8868str2\u3002 \u8f93\u51fa\u63cf\u8ff0: \u8f93\u51fa\u4e00\u884c\uff0c\u4ee3\u8868\u4ed6\u4eec\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u679c\u516c\u5171\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u793a\u4f8b1 \u8f93\u5165 1A2C3D4B56 B1D23CA45B6A \u8f93\u51fa 123456 \u8bf4\u660e \"123456\"\u548c\u201c12C4B6\u201d\u90fd\u662f\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u4efb\u610f\u8f93\u51fa\u4e00\u4e2a\u3002 */ #include <iostream> #include <string> #include <vector> using namespace std ; string LCS ( string s1 , string s2 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); string ans = \"\" ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( s1 [ i ] == s2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); } } } int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( s1 [ i ] == s2 [ j ]) { ans . push_back ( s1 [ i ]); i ++ ; j ++ ; } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } return dp [ 0 ][ 0 ] ? ans : \"-1\" ; } int main ( int argc , const char * argv []) { // insert code here... string s1 = \"1A2C3D4B56\" , s2 = \"B1D23CA45B6A\" ; cin >> s1 >> s2 ; printf ( \"%s \\n \" , LCS ( s1 , s2 ). c_str ()); return 0 ; }","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"algo/dp/lcs/#_1","text":"\u7ed9\u5b9a\u4e24\u4e2a\u5e8f\u5217\uff08\u6570\u7ec4\u6216\u5b57\u7b26\u4e32\uff09A = [1, 2, 3, 2, 1]\uff0c B = [3, 2, 1, 4, 7]\uff0c\u90a3\u4e48\u8fd9\u4e24\u8005\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u662f[3, 2, 1]\uff0c\u957f\u5ea6\u4e3a3 \u8bbedp[i][j]\u4e3aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4e5f\u5c31\u662f\u72b6\u6001\uff0c\u4e00\u5171n*m\u4e2a\u3002\u56e0\u4e3a\u8981\u6c42\u5b50\u6570\u7ec4\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u5f53\u524d\u72b6\u6001\u53ea\u4f1a\u4e0e\u4e0b\u4e00\u4e2a\uff08\u6216\u4e0a\u4e00\u4e2a\uff09\u72b6\u6001\u76f8\u5173\uff0c\u7531\u6b64\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002 \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \u5728\u72b6\u6001\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u8bb0\u5f55\u6700\u5927\u957f\u5ea6\u7684\u5927\u5c0f\u4ee5\u53ca\u6700\u5927\u957f\u5ea6\u7684\u4f4d\u7f6e\uff0c\u6700\u7ec8\u53ef\u8f93\u51fa\u6700\u957f\u5b50\u6570\u7ec4\u3002 \u76f8\u4f3c\u9898\u76ee \u300c\u725b\u5ba2\u9898\u9738-\u7b97\u6cd5\u7bc7 127. \u6700\u957f\u516c\u5171\u5b50\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2,\u8f93\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32 \u9898\u76ee\u4fdd\u8bc1str1\u548cstr2\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\u5b58\u5728\u4e14\u552f\u4e00\u3002 \u793a\u4f8b1 \u8f93\u5165 \"1AB2345CD\",\"12345EF\" \u8fd4\u56de\u503c \"2345\" */ class Solution { public : /** * longest common substring * @param str1 string\u5b57\u7b26\u4e32 the string * @param str2 string\u5b57\u7b26\u4e32 the string * @return string\u5b57\u7b26\u4e32 */ string LCS ( string str1 , string str2 ) { // write code here int n1 = ( int ) str1 . length (), n2 = ( int ) str2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); int len = 1 , pos = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( str1 [ i ] == str2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; if ( len < dp [ i ][ j ]) { len = dp [ i ][ j ]; pos = i ; } } } } return str1 . substr ( pos , len ); } };","title":"\u5b50\u5e8f\u5217\u8fde\u7eed"},{"location":"algo/dp/lcs/#_2","text":"\u5f53\u5b50\u5e8f\u5217\u4e0d\u8981\u6c42\u8fde\u7eed\u65f6\uff0c\u4f9d\u7136\u53ef\u4ee5\u7528dp[i][j]\u8868\u793aA[i: ]\u548cB[j: ]\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u516c\u5171\u90e8\u5206\u7684\u957f\u5ea6\uff0c\u4f46\u662f\u72b6\u6001\u7684\u8f6c\u79fb\u65b9\u7a0b\u53d1\u751f\u6539\u53d8 \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ] = } \\begin{cases} 0, &\\quad \\text{i == len(A) or j == len(B)} \\\\ \\text{dp[ i + 1 ][ j + 1] + 1}, &\\quad \\text{A[ i ] == B[ j ]} \\\\ \\max(\\text{dp[i + 1][ j ], dp[ i ][ j + 1 ]}), & \\quad \\text{otherwise} \\end{cases} \u5982\u679c\u8981\u6c42\u8f93\u51fa\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u5219\u9700\u8981\u91cd\u65b0\u626b\u9762\u4e00\u904d\u4e24\u4e2a\u5e8f\u5217 1 2 3 4 5 6 7 8 int m = ( int ) A . length (), n = ( int ) B . length (), i = 0 , j = 0 ; while ( i < m && j < n ) { if ( A [ i ] == B [ j ]) { printf ( ' % c ' , A [ i ]); } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } \u300c\u725b\u5ba2\u7f51 \u7a0b\u5e8f\u5458\u4ee3\u7801\u9762\u8bd5\u6307\u5357 31. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* \u9898\u76ee\u63cf\u8ff0 \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32str1\u548cstr2\uff0c\u8f93\u51fa\u8fde\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u8fc7\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u8f93\u5165\u63cf\u8ff0: \u8f93\u51fa\u5305\u62ec\u4e24\u884c\uff0c\u7b2c\u4e00\u884c\u4ee3\u8868\u5b57\u7b26\u4e32str1\uff0c\u7b2c\u4e8c\u884c\u4ee3\u8868str2\u3002 \u8f93\u51fa\u63cf\u8ff0: \u8f93\u51fa\u4e00\u884c\uff0c\u4ee3\u8868\u4ed6\u4eec\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002\u5982\u679c\u516c\u5171\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa-1\u3002 \u793a\u4f8b1 \u8f93\u5165 1A2C3D4B56 B1D23CA45B6A \u8f93\u51fa 123456 \u8bf4\u660e \"123456\"\u548c\u201c12C4B6\u201d\u90fd\u662f\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u4efb\u610f\u8f93\u51fa\u4e00\u4e2a\u3002 */ #include <iostream> #include <string> #include <vector> using namespace std ; string LCS ( string s1 , string s2 ) { int n1 = ( int ) s1 . length (), n2 = ( int ) s2 . length (); vector < vector < int >> dp ( n1 + 1 , vector < int > ( n2 + 1 , 0 )); string ans = \"\" ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { for ( int j = n2 - 1 ; j >= 0 ; j -- ) { if ( s1 [ i ] == s2 [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]); } } } int i = 0 , j = 0 ; while ( i < n1 && j < n2 ) { if ( s1 [ i ] == s2 [ j ]) { ans . push_back ( s1 [ i ]); i ++ ; j ++ ; } else if ( dp [ i + 1 ][ j ] > dp [ i ][ j + 1 ]) { i ++ ; } else { j ++ ; } } return dp [ 0 ][ 0 ] ? ans : \"-1\" ; } int main ( int argc , const char * argv []) { // insert code here... string s1 = \"1A2C3D4B56\" , s2 = \"B1D23CA45B6A\" ; cin >> s1 >> s2 ; printf ( \"%s \\n \" , LCS ( s1 , s2 ). c_str ()); return 0 ; }","title":"\u5b50\u5e8f\u5217\u4e0d\u8fde\u7eed"},{"location":"algo/dp/matrix/","text":"\u5b50\u77e9\u9635 \u00b6 \u6700\u5927\u6b63\u65b9\u5f62 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u6784\u6210\u7684\u77e9\u9635\uff0c\u6c42\u6700\u5927\u7684\u5168 1 \u5b50\u6b63\u65b9\u5f62\u3002\u4f8b\u5982 \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \u6700\u5927\u9762\u79ef\u4e3a 4\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u77e9\u9635\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ] == '1' ) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans = max ( ans , dp [ j ] * dp [ j ]); } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u7edf\u8ba1\u5168\u4e3a 1 \u7684\u6b63\u65b9\u5f62\u5b50\u77e9\u9635 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u77e9\u9635\uff0c\u73b0\u5728\u7edf\u8ba1\u51fa\u6240\u6709\u53ea\u7531 1 \u6784\u6210\u7684\u5b50\u65b9\u9635\u7684\u4e2a\u6570\u3002 \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \u77e9\u9635\u4e2d\u5171\u6709 15 \u4e2a\u5b50\u65b9\u9635\uff0810 \u4e2a 1 \\times 1 1 \\times 1 \uff0c4 \u4e2a 2 \\times 2 2 \\times 2 \uff0c1 \u4e2a 3 \\times 3 3 \\times 3 \uff09 \u300c\u5206\u6790\u300d \u540c\u4e0a\u4e00\u9898\u76ee\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u7528\u4e00\u4e2a\u6574\u578b\u53d8\u91cf\uff0c\u5728\u904d\u5386\u8fc7\u7a0b\u4e2d\uff0c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u8fb9\u957f\u5927\u4e8e 1 \u7684\u6b63\u65b9\u5f62\uff0c\u5373\u7edf\u8ba1\u5168 1 \u6b63\u65b9\u5f62\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ]) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans += dp [ j ]; } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u6700\u5927\u8fb9\u957f\u5168\u4e3a 0 \u7684\u6b63\u65b9\u5f62 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u65b9\u9635\uff0c\u5148\u6c42\u4e00\u4e2a\u6700\u5927\u7684\u5b50\u65b9\u9635\uff0c\u5176\u56db\u4e2a\u8fb9\u957f\u5168\u90e8\u7531 0 \u6784\u6210\uff0c\u5185\u90e8\u5143\u7d20\u65e0\u8981\u6c42\u3002\u8fd4\u56de\u7ed3\u679c\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u5f62\u5982 {r, c, len}\uff0c\u5176\u4e2d r \u6700\u5c0f\uff0c\u5982\u679c r \u76f8\u7b49\u7684\u60c5\u51b5\u4e0b\uff0c\u53d6 c \u6700\u5c0f\u7684\u89e3\u3002\u5982\u4e0b\u4f8b\u5b50 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dpRight[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u53f3\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\uff0cdpDown[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u4e0b\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\u3002\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \u4f46\u662f\u4e00\u4e2a\u77e9\u9635\u6709\u56db\u6761\u8fb9\uff0c\u6240\u6709\u9700\u8981\u8003\u8651\u4ece\uff08i\uff0cj\uff09\u8fc7\u6e21\u5230\uff08i+len-1\uff0cj+len-1\uff09\u3002\u90a3\u4e48\u5982\u4f55\u786e\u5b9a\u8fb9\u957f len \u5462\uff1f \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \u8fdb\u800c\u786e\u5b9a\u4e86\u5de6\u4e0b\u65b9\u548c\u53f3\u4e0a\u65b9\u7684\u70b9 (i+len-1\uff0cj)\u3001\uff08i\uff0cj+len-1\uff09\u3002\u7d27\u63a5\u7740\uff0c\u4ece\u5de6\u4e0b\u70b9\u5411\u53f3 len - 1 \u4e2a\u5355\u4f4d\u6216\u8005\u4ece\u53f3\u4e0a\u70b9\u5411\u4e0b len - 1 \u4e2a\u5355\u4f4d\u90fd\u4f1a\u5230\u8fbe\uff08i+len-1\uff0cj+len-1\uff09\uff0c\u53ea\u9700\u8981\u786e\u5b9a\u662f\u5426\u5b58\u5728\u8fd9\u6837\u7684 len\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector < int > findSquare ( vector < vector < int >>& matrix ) { vector < int > ans { - 1 , - 1 , 0 }; int n = ( int ) matrix . size (); if ( n == 0 ) { return ans ; } vector < vector < int >> dpRight ( n + 1 , vector < int > ( n + 1 , 0 )); vector < vector < int >> dpDown ( n + 1 , vector < int > ( n + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ] == 1 ) { dpRight [ i ][ j ] = dpDown [ i ][ j ] = 0 ; } else { dpRight [ i ][ j ] = dpRight [ i ][ j + 1 ] + 1 ; dpDown [ i ][ j ] = dpDown [ i + 1 ][ j ] + 1 ; int len = min ( dpRight [ i ][ j ], dpDown [ i ][ j ]); while ( len >= ans [ 2 ]) { if ( dpRight [ i + len - 1 ][ j ] >= len && dpDown [ i ][ j + len - 1 ] >= len ) { ans = { i , j , len }; break ; } len -- ; } } } } return ans [ 0 ] == - 1 && ans [ 1 ] == - 1 ? vector < int > {} : ans ; }","title":"\u77e9\u9635\u95ee\u9898"},{"location":"algo/dp/matrix/#_1","text":"","title":"\u5b50\u77e9\u9635"},{"location":"algo/dp/matrix/#_2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u6784\u6210\u7684\u77e9\u9635\uff0c\u6c42\u6700\u5927\u7684\u5168 1 \u5b50\u6b63\u65b9\u5f62\u3002\u4f8b\u5982 \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \\begin{matrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 1 & {\\color{Red} 1} & {\\color{Red} 1} & 1 \\\\ 1 & 0 & 0 & 1 & 0 \\end{matrix} \u6700\u5927\u9762\u79ef\u4e3a 4\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u77e9\u9635\u5982\u4e0b\uff1a \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} \\max(\\text{dp[i + 1][ j ], dp[ i ][j + 1], dp[i + 1][j + 1]}) + 1, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ 0, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ] == '1' ) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans = max ( ans , dp [ j ] * dp [ j ]); } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6700\u5927\u6b63\u65b9\u5f62"},{"location":"algo/dp/matrix/#1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u77e9\u9635\uff0c\u73b0\u5728\u7edf\u8ba1\u51fa\u6240\u6709\u53ea\u7531 1 \u6784\u6210\u7684\u5b50\u65b9\u9635\u7684\u4e2a\u6570\u3002 \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \\begin{matrix} 0 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{matrix} \u77e9\u9635\u4e2d\u5171\u6709 15 \u4e2a\u5b50\u65b9\u9635\uff0810 \u4e2a 1 \\times 1 1 \\times 1 \uff0c4 \u4e2a 2 \\times 2 2 \\times 2 \uff0c1 \u4e2a 3 \\times 3 3 \\times 3 \uff09 \u300c\u5206\u6790\u300d \u540c\u4e0a\u4e00\u9898\u76ee\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5230\uff08nRow\uff0cnCol\uff09\u7684\u6700\u5927\u6b63\u65b9\u5f62\u8fb9\u957f\uff0c\u7528\u4e00\u4e2a\u6574\u578b\u53d8\u91cf\uff0c\u5728\u904d\u5386\u8fc7\u7a0b\u4e2d\uff0c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u8fb9\u957f\u5927\u4e8e 1 \u7684\u6b63\u65b9\u5f62\uff0c\u5373\u7edf\u8ba1\u5168 1 \u6b63\u65b9\u5f62\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 vector < int > dp ( nCol + 1 , 0 ); int ans = 0 ; for ( int i = nRow - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = nCol - 1 ; j >= 0 ; j -- ) { dp [ j ] = 0 ; if ( matrix [ i ][ j ]) { dp [ j ] = min ( tmp [ j ], min ( dp [ j + 1 ], tmp [ j + 1 ])) + 1 ; } ans += dp [ j ]; } } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u7edf\u8ba1\u5168\u4e3a 1 \u7684\u6b63\u65b9\u5f62\u5b50\u77e9\u9635"},{"location":"algo/dp/matrix/#0","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u65b9\u9635\uff0c\u5148\u6c42\u4e00\u4e2a\u6700\u5927\u7684\u5b50\u65b9\u9635\uff0c\u5176\u56db\u4e2a\u8fb9\u957f\u5168\u90e8\u7531 0 \u6784\u6210\uff0c\u5185\u90e8\u5143\u7d20\u65e0\u8981\u6c42\u3002\u8fd4\u56de\u7ed3\u679c\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u5f62\u5982 {r, c, len}\uff0c\u5176\u4e2d r \u6700\u5c0f\uff0c\u5982\u679c r \u76f8\u7b49\u7684\u60c5\u51b5\u4e0b\uff0c\u53d6 c \u6700\u5c0f\u7684\u89e3\u3002\u5982\u4e0b\u4f8b\u5b50 \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \\begin{matrix} {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & 1 & {\\color{Red} 0} & 1 \\\\ {\\color{Red} 0} & {\\color{Red} 0} & {\\color{Red} 0} & 1 \\\\ 1 & 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u8bbe dpRight[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u53f3\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\uff0cdpDown[ i ][ j ] \u4e3a\uff08i\uff0cj\uff09\u5411\u4e0b\u8fde\u7eed\u4e3a 0 \u7684\u6700\u5927\u957f\u5ea6\u3002\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \\begin{cases} \\text{dpRight[ i ][ j ] = dpDown[ i ][ j ] = 0}, &\\text{matrix[ i ][ j ] == 1} \\\\ \\begin{cases} \\text{dpRight[ i ][ j ] = dpRight[ i ][j + 1] + 1} \\\\ \\text{dpDown[ i ][ j ] = dpDown[i + 1][ j ] + 1} \\end{cases}, & \\text{matrix[ i ][ j ] == 0} \\end{cases} \u4f46\u662f\u4e00\u4e2a\u77e9\u9635\u6709\u56db\u6761\u8fb9\uff0c\u6240\u6709\u9700\u8981\u8003\u8651\u4ece\uff08i\uff0cj\uff09\u8fc7\u6e21\u5230\uff08i+len-1\uff0cj+len-1\uff09\u3002\u90a3\u4e48\u5982\u4f55\u786e\u5b9a\u8fb9\u957f len \u5462\uff1f \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \\text{len = } \\min(\\text{dpRight[ i ][ j ], dpDown[ i ][ j ]}) \u8fdb\u800c\u786e\u5b9a\u4e86\u5de6\u4e0b\u65b9\u548c\u53f3\u4e0a\u65b9\u7684\u70b9 (i+len-1\uff0cj)\u3001\uff08i\uff0cj+len-1\uff09\u3002\u7d27\u63a5\u7740\uff0c\u4ece\u5de6\u4e0b\u70b9\u5411\u53f3 len - 1 \u4e2a\u5355\u4f4d\u6216\u8005\u4ece\u53f3\u4e0a\u70b9\u5411\u4e0b len - 1 \u4e2a\u5355\u4f4d\u90fd\u4f1a\u5230\u8fbe\uff08i+len-1\uff0cj+len-1\uff09\uff0c\u53ea\u9700\u8981\u786e\u5b9a\u662f\u5426\u5b58\u5728\u8fd9\u6837\u7684 len\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector < int > findSquare ( vector < vector < int >>& matrix ) { vector < int > ans { - 1 , - 1 , 0 }; int n = ( int ) matrix . size (); if ( n == 0 ) { return ans ; } vector < vector < int >> dpRight ( n + 1 , vector < int > ( n + 1 , 0 )); vector < vector < int >> dpDown ( n + 1 , vector < int > ( n + 1 , 0 )); for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( matrix [ i ][ j ] == 1 ) { dpRight [ i ][ j ] = dpDown [ i ][ j ] = 0 ; } else { dpRight [ i ][ j ] = dpRight [ i ][ j + 1 ] + 1 ; dpDown [ i ][ j ] = dpDown [ i + 1 ][ j ] + 1 ; int len = min ( dpRight [ i ][ j ], dpDown [ i ][ j ]); while ( len >= ans [ 2 ]) { if ( dpRight [ i + len - 1 ][ j ] >= len && dpDown [ i ][ j + len - 1 ] >= len ) { ans = { i , j , len }; break ; } len -- ; } } } } return ans [ 0 ] == - 1 && ans [ 1 ] == - 1 ? vector < int > {} : ans ; }","title":"\u6700\u5927\u8fb9\u957f\u5168\u4e3a 0 \u7684\u6b63\u65b9\u5f62"},{"location":"algo/dp/path/","text":"\u65e0\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570 \u00b6 \u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u7f51\u683c\uff08i\uff0c j\uff09\uff0c\u80fd\u591f\u5230\u8fbe\u8fd9\u4e2a\u7f51\u683c\u53ea\u6709\u4e24\u4e2a\u4f4d\u7f6e\u5373\uff08i-1\uff0cj\uff09\u548c\uff08i\uff0cj+1\uff09\u3002\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u7684\u8def\u5f84\u6761\u6570\uff0c\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002\u6ce8\u610f\u5230\uff0c\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\u6761\u6570\u4e0e\u4ece\u53f3\u4e0b\u89d2\u5230\u5de6\u4e0a\u89d2\u7684\u8def\u5f84\u6761\u6570\u662f\u7b49\u4ef7\u7684\u3002 \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5f53\u524d\u7f51\u683c\u53ea\u4e0e\u4e0a\u65b9\u7f51\u683c\u548c\u5de6\u8fb9\u7f51\u683c\u6709\u5173\uff0c\u90a3\u4e48\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 1 2 3 4 5 6 7 8 9 10 vector < int > next ( n + 1 , 0 ), cur ( n + 1 , 0 ); next [ n - 1 ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { next [ j ] += cur [ j ] + next [ j + 1 ]; } cur = next ; next = vector < int > ( n + 1 , 0 ); } return cur [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u6709\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570 \u00b6 \u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u67d0\u4e9b\u7f51\u683c\u6709\u969c\u788d\uff0c\u673a\u5668\u4eba\u4e0d\u80fd\u5230\u8fbe\u8fd9\u4e9b\u969c\u788d\u6240\u5728\u7f51\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u540c\u6837\u5730\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u4e4b\u95f4\u5730\u6709\u6548\u8def\u5f84\u6761\u6570\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector < int > dp ( n , 0 ); if ( grid [ 0 ][ 0 ]) { return 0 ; } dp [ 0 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = dp [ j - 1 ] * ( 1 - grid [ 0 ][ j ]); } for ( int i = 1 ; i < m ; i ++ ) { vector < int > pre = dp ; dp [ 0 ] = pre [ 0 ] * ( 1 - grid [ i ][ 0 ]); for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = ( pre [ j ] + dp [ j - 1 ]) * ( 1 - grid [ i ][ j ]); } } return dp [ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u6700\u5c0f\u8def\u5f84\u548c \u00b6 \u4e00\u4e2a\u5305\u542b\u975e\u8d1f\u6574\u6570\u7684 m \\times n m \\times n \u7684\u7f51\u683c\uff0c\u627e\u51fa\u4e00\u6761\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\uff0c\u4f7f\u5f97\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u548c\u6700\u5c0f\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} 1 2 3 4 5 6 7 8 9 vector < int > dp ( n + 1 , INT_MAX ); dp [ n - 1 ] = 0 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = n - 1 ; j >= 0 ; j -- ) { dp [ j ] = min ( tmp [ j ], dp [ j + 1 ]) + grid [ i ][ j ]; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u505c\u5728\u539f\u5730\u7684\u65b9\u6848\u6570 \u00b6 \u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a arrLen \u7684\u6570\u7ec4\uff0c\u5f00\u59cb\u6709\u4e00\u4e2a\u6307\u9488\u5728\u7d22\u5f15 0 \u5904\u3002\u6bcf\u4e00\u6b65\u64cd\u4f5c\u4e2d\uff0c\u4f60\u53ef\u4ee5\u5c06\u6307\u9488\u5411\u5de6\u6216\u5411\u53f3\u79fb\u52a8 1 \u6b65\uff0c\u6216\u8005\u505c\u5728\u539f\u5730\uff08\u6307\u9488\u4e0d\u80fd\u88ab\u79fb\u52a8\u5230\u6570\u7ec4\u8303\u56f4\u5916\uff09\u3002\u6c42\u5728\u6070\u597d\u6267\u884c steps \u6b21\u64cd\u4f5c\u4ee5\u540e\uff0c\u6307\u9488\u4ecd\u7136\u6307\u5411\u7d22\u5f15 0 \u5904\u7684\u65b9\u6848\u6570\u3002\u4f8b\u5982 steps = 3, arrLen = 2\uff0c\u90a3\u4e48 3 \u6b65\u540e\uff0c\u603b\u5171\u6709 4 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5206\u522b\u662f\uff1a \u5411\u53f3\uff0c\u5411\u5de6\uff0c\u4e0d\u52a8 \u4e0d\u52a8\uff0c\u5411\u53f3\uff0c\u5411\u5de6 \u5411\u53f3\uff0c\u4e0d\u52a8\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8\uff0c\u4e0d\u52a8 \u300c\u5206\u6790\u300d \u8bbe dp[ k ][ i ] \u4e3a\u7ecf\u8fc7 k \u6b65\u540e\u8df3\u5230\u7b2c i \u4e2a\u4f4d\u7f6e\u65f6\u7684\u65b9\u6cd5\u6570\uff0c\u72b6\u6001\u8f6c\u79fb\u5982\u4e0b \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u72b6\u6001\u8f6c\u79fb\u53ea\u4f1a\u53d1\u751f\u5728\u76f8\u90bb\u4e24\u6b65\u548c\u76f8\u90bb\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u4e00\u4f4d\u6570\u7ec4\u4ee3\u66ff\u4e8c\u7ef4\u6570\u7ec4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int MOD = 1000000007 ; int n = min ( arrLen , steps / 2 + 1 ); vector < int > dp ( n , 0 ); dp [ 0 ] = 1 ; while ( steps -- ) { vector < int > tmp = dp ; for ( int i = 0 ; i < n ; i ++ ) { long a = i == 0 ? 0 : tmp [ i - 1 ]; long b = i == n - 1 ? 0 : tmp [ i + 1 ]; long c = tmp [ i ]; dp [ i ] = ( a + b + c ) % MOD ; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(k \\times n) O(k \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0ck \u4e3a\u79fb\u52a8\u7684\u6b65\u6570\uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002 \u6768\u8f89\u4e09\u89d2\u8def\u5f84\u6700\u5c0f\u548c \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u627e\u51fa\u81ea\u9876\u5411\u4e0b\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u6bcf\u4e00\u6b65\u53ea\u80fd\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\uff0c\u4e14\u4e0e\u5f53\u524d\u8282\u70b9\u76f8\u90bb\u7684\u8282\u70b9 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \u300c\u5206\u6790\u300d \u6bcf\u4e00\u4e2a\u5185\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e24\u4e2a\u8282\u70b9\u76f8\u8fde\uff0c\u6bcf\u4e00\u4e2a\u8fb9\u754c\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e00\u4e2a\u8282\u70b9\u76f8\u8fde\u3002\u8bbe dp[ i ][ j ] \u8868\u793a\u4ece\u9876\u70b9\u5230\uff08i\uff0cj\uff09\u70b9\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \u6211\u4eec\u53ef\u4ee5\u7531\u4e0a\u5230\u4e0b\u5199\u52a8\u6001\u89c4\u5212\u7684\u65b9\u7a0b\uff0c\u4e5f\u53ef\u4ee5\u53cd\u8fc7\u6765\u9012\u63a8\u3002\u6211\u4eec\u89c2\u5bdf\u5230\u5f53\u524d\u5c42\u53ea\u4e0e\u4e0b\u4e00\u5c42\u7684\u4e24\u4e2a\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u6b64\u53ea\u9700\u8981 O(n) O(n) \u7684\u7a7a\u95f4\u5373\u53ef\uff0c\u4f46\u5982\u679c\u7531\u4e0b\u5230\u4e0a\u9012\u63a8\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u52a9\u4f20\u5165\u77e9\u9635\uff0c\u4e0d\u5fc5\u5f00\u8f9f\u989d\u5916\u7684\u7a7a\u95f4\uff08\u672c\u9898\u8f83\u4e3a\u7279\u6b8a\uff09\u3002 1 2 3 4 5 6 7 8 for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { triangle [ i ][ j ] = min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) + triangle [ i ][ j ]; } } return triangle [ 0 ][ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u8def\u5f84\u95ee\u9898"},{"location":"algo/dp/path/#_1","text":"\u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \\begin{matrix} \\text{start} & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot & \\cdot & \\cdot & \\text{end} \\end{matrix} \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u7f51\u683c\uff08i\uff0c j\uff09\uff0c\u80fd\u591f\u5230\u8fbe\u8fd9\u4e2a\u7f51\u683c\u53ea\u6709\u4e24\u4e2a\u4f4d\u7f6e\u5373\uff08i-1\uff0cj\uff09\u548c\uff08i\uff0cj+1\uff09\u3002\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u7684\u8def\u5f84\u6761\u6570\uff0c\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002\u6ce8\u610f\u5230\uff0c\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\u6761\u6570\u4e0e\u4ece\u53f3\u4e0b\u89d2\u5230\u5de6\u4e0a\u89d2\u7684\u8def\u5f84\u6761\u6570\u662f\u7b49\u4ef7\u7684\u3002 \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \\begin{aligned} & dp[i][1] = 1, \\quad i = 1, 2, ..., m \\\\ & dp[1][j] = 1, \\quad j = 1, 2, ..., n \\\\ & dp[i][j] = dp[i-1][j] + dp[i][j-1], \\quad i = 2, 3, ..., m \\quad j = 2, 3, ..., n \\end{aligned} \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5f53\u524d\u7f51\u683c\u53ea\u4e0e\u4e0a\u65b9\u7f51\u683c\u548c\u5de6\u8fb9\u7f51\u683c\u6709\u5173\uff0c\u90a3\u4e48\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 1 2 3 4 5 6 7 8 9 10 vector < int > next ( n + 1 , 0 ), cur ( n + 1 , 0 ); next [ n - 1 ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { next [ j ] += cur [ j ] + next [ j + 1 ]; } cur = next ; next = vector < int > ( n + 1 , 0 ); } return cur [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u65e0\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570"},{"location":"algo/dp/path/#_2","text":"\u4e00\u4e2a\u673a\u5668\u4eba\u5728 m \\times n m \\times n \u7684\u7f51\u683c\u7684\u5de6\u4e0a\u89d2\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u4f46\u662f\u67d0\u4e9b\u7f51\u683c\u6709\u969c\u788d\uff0c\u673a\u5668\u4eba\u4e0d\u80fd\u5230\u8fbe\u8fd9\u4e9b\u969c\u788d\u6240\u5728\u7f51\u683c\uff0c\u6c42\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570\u3002 \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \\begin{matrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0 \\end{matrix} \u300c\u5206\u6790\u300d \u540c\u6837\u5730\uff0c\u8bbe dp[ i ][ j ] \u4e3a\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u4e4b\u95f4\u5730\u6709\u6548\u8def\u5f84\u6761\u6570\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} \\text{dp[ i ][ j ]} = \\begin{cases} 0, & \\quad \\text{grid[ i ][ j ] == 1} \\\\ \\text{dp[i + 1][ j ] + dp[ i ][j + 1]}, & \\quad \\text{otherwise} \\end{cases} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector < int > dp ( n , 0 ); if ( grid [ 0 ][ 0 ]) { return 0 ; } dp [ 0 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = dp [ j - 1 ] * ( 1 - grid [ 0 ][ j ]); } for ( int i = 1 ; i < m ; i ++ ) { vector < int > pre = dp ; dp [ 0 ] = pre [ 0 ] * ( 1 - grid [ i ][ 0 ]); for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] = ( pre [ j ] + dp [ j - 1 ]) * ( 1 - grid [ i ][ j ]); } } return dp [ n - 1 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6709\u969c\u788d\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6761\u6570"},{"location":"algo/dp/path/#_3","text":"\u4e00\u4e2a\u5305\u542b\u975e\u8d1f\u6574\u6570\u7684 m \\times n m \\times n \u7684\u7f51\u683c\uff0c\u627e\u51fa\u4e00\u6761\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u7684\u8def\u5f84\uff0c\u4f7f\u5f97\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u548c\u6700\u5c0f\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ j ] \u4e3a\u4ece\uff080\uff0c0\uff09\u5230\uff08i\uff0cj\uff09\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} \\text{dp[ i ][ j ]} = \\max(\\text{dp[i - 1][ j ], dp[ i ][j - 1]}) + \\text{grid[ i ][ j ]} 1 2 3 4 5 6 7 8 9 vector < int > dp ( n + 1 , INT_MAX ); dp [ n - 1 ] = 0 ; for ( int i = m - 1 ; i >= 0 ; i -- ) { vector < int > tmp = dp ; for ( int j = n - 1 ; j >= 0 ; j -- ) { dp [ j ] = min ( tmp [ j ], dp [ j + 1 ]) + grid [ i ][ j ]; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(m \\times n) O(m \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6700\u5c0f\u8def\u5f84\u548c"},{"location":"algo/dp/path/#_4","text":"\u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a arrLen \u7684\u6570\u7ec4\uff0c\u5f00\u59cb\u6709\u4e00\u4e2a\u6307\u9488\u5728\u7d22\u5f15 0 \u5904\u3002\u6bcf\u4e00\u6b65\u64cd\u4f5c\u4e2d\uff0c\u4f60\u53ef\u4ee5\u5c06\u6307\u9488\u5411\u5de6\u6216\u5411\u53f3\u79fb\u52a8 1 \u6b65\uff0c\u6216\u8005\u505c\u5728\u539f\u5730\uff08\u6307\u9488\u4e0d\u80fd\u88ab\u79fb\u52a8\u5230\u6570\u7ec4\u8303\u56f4\u5916\uff09\u3002\u6c42\u5728\u6070\u597d\u6267\u884c steps \u6b21\u64cd\u4f5c\u4ee5\u540e\uff0c\u6307\u9488\u4ecd\u7136\u6307\u5411\u7d22\u5f15 0 \u5904\u7684\u65b9\u6848\u6570\u3002\u4f8b\u5982 steps = 3, arrLen = 2\uff0c\u90a3\u4e48 3 \u6b65\u540e\uff0c\u603b\u5171\u6709 4 \u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u505c\u5728\u7d22\u5f15 0 \u5904\u3002 \u5206\u522b\u662f\uff1a \u5411\u53f3\uff0c\u5411\u5de6\uff0c\u4e0d\u52a8 \u4e0d\u52a8\uff0c\u5411\u53f3\uff0c\u5411\u5de6 \u5411\u53f3\uff0c\u4e0d\u52a8\uff0c\u5411\u5de6 \u4e0d\u52a8\uff0c\u4e0d\u52a8\uff0c\u4e0d\u52a8 \u300c\u5206\u6790\u300d \u8bbe dp[ k ][ i ] \u4e3a\u7ecf\u8fc7 k \u6b65\u540e\u8df3\u5230\u7b2c i \u4e2a\u4f4d\u7f6e\u65f6\u7684\u65b9\u6cd5\u6570\uff0c\u72b6\u6001\u8f6c\u79fb\u5982\u4e0b \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \\text{dp[ k ][ i ] = dp[k - 1][i - 1] + dp[k - 1][ i ] + dp[k - 1][i + 1]} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u72b6\u6001\u8f6c\u79fb\u53ea\u4f1a\u53d1\u751f\u5728\u76f8\u90bb\u4e24\u6b65\u548c\u76f8\u90bb\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u4e00\u4f4d\u6570\u7ec4\u4ee3\u66ff\u4e8c\u7ef4\u6570\u7ec4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int MOD = 1000000007 ; int n = min ( arrLen , steps / 2 + 1 ); vector < int > dp ( n , 0 ); dp [ 0 ] = 1 ; while ( steps -- ) { vector < int > tmp = dp ; for ( int i = 0 ; i < n ; i ++ ) { long a = i == 0 ? 0 : tmp [ i - 1 ]; long b = i == n - 1 ? 0 : tmp [ i + 1 ]; long c = tmp [ i ]; dp [ i ] = ( a + b + c ) % MOD ; } } return dp [ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(k \\times n) O(k \\times n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0ck \u4e3a\u79fb\u52a8\u7684\u6b65\u6570\uff0cn \u4e3a\u6570\u7ec4\u7684\u957f\u5ea6\u3002","title":"\u505c\u5728\u539f\u5730\u7684\u65b9\u6848\u6570"},{"location":"algo/dp/path/#_5","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u627e\u51fa\u81ea\u9876\u5411\u4e0b\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u6bcf\u4e00\u6b65\u53ea\u80fd\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\uff0c\u4e14\u4e0e\u5f53\u524d\u8282\u70b9\u76f8\u90bb\u7684\u8282\u70b9 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & & 3 & & 4 \\\\ & & \\wedge & & \\wedge \\\\ & 6 & & 5 & & 7 \\\\ & \\wedge & & \\wedge & & \\wedge \\\\ 4 & & 1 & & 8 & & 3 \\end{matrix} \u300c\u5206\u6790\u300d \u6bcf\u4e00\u4e2a\u5185\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e24\u4e2a\u8282\u70b9\u76f8\u8fde\uff0c\u6bcf\u4e00\u4e2a\u8fb9\u754c\u8282\u70b9\uff08\u975e\u9876\u70b9\uff09\uff0c\u4e0e\u4e0a\u4e00\u5c42\u7684\u4e00\u4e2a\u8282\u70b9\u76f8\u8fde\u3002\u8bbe dp[ i ][ j ] \u8868\u793a\u4ece\u9876\u70b9\u5230\uff08i\uff0cj\uff09\u70b9\u7684\u6700\u5c0f\u8def\u5f84\u548c\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \\text{dp[ i ][ j ]} = \\max(\\text{dp[i + 1][ j ], dp[i + 1][j + 1]}), \\quad i = 0, 1, \\cdots, n - 2 \u6211\u4eec\u53ef\u4ee5\u7531\u4e0a\u5230\u4e0b\u5199\u52a8\u6001\u89c4\u5212\u7684\u65b9\u7a0b\uff0c\u4e5f\u53ef\u4ee5\u53cd\u8fc7\u6765\u9012\u63a8\u3002\u6211\u4eec\u89c2\u5bdf\u5230\u5f53\u524d\u5c42\u53ea\u4e0e\u4e0b\u4e00\u5c42\u7684\u4e24\u4e2a\u4e24\u4e2a\u72b6\u6001\u76f8\u5173\uff0c\u56e0\u6b64\u53ea\u9700\u8981 O(n) O(n) \u7684\u7a7a\u95f4\u5373\u53ef\uff0c\u4f46\u5982\u679c\u7531\u4e0b\u5230\u4e0a\u9012\u63a8\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u52a9\u4f20\u5165\u77e9\u9635\uff0c\u4e0d\u5fc5\u5f00\u8f9f\u989d\u5916\u7684\u7a7a\u95f4\uff08\u672c\u9898\u8f83\u4e3a\u7279\u6b8a\uff09\u3002 1 2 3 4 5 6 7 8 for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { triangle [ i ][ j ] = min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) + triangle [ i ][ j ]; } } return triangle [ 0 ][ 0 ]; \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2}) O(n^{2}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u6768\u8f89\u4e09\u89d2\u8def\u5f84\u6700\u5c0f\u548c"},{"location":"algo/dp/rob/","text":"\u6210\u6392 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4e00\u4e2a\u5c0f\u5077\u53ef\u4ee5\u5077\u53d6\u82e5\u5e72\u623f\u5c4b\u5185\u7684\u6240\u6709\u91d1\u94b1\uff0c\u4f46\u662f\u5077\u7a83\u7684\u623f\u5c4b\u4e0d\u80fd\u76f8\u90bb\uff0c\u6c42\u53ef\u4ee5\u83b7\u5f97\u6700\u5927\u91d1\u989d\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ 0 ] \u8868\u793a\u7b2c i \u4e2a\u623f\u5c4b\u6ca1\u6709\u88ab\u76d7\u7a83\uff0cdp[ i ][ 1 ] \u4e3a\u7b2c i \u4e2a\u623f\u5c4b\u88ab\u76d7\u7a83 \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} 1 2 3 4 5 6 7 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u6210\u73af \u00b6 \u540c\u6837\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4f46\u662f\u6570\u7ec4\u7684\u9996\u5c3e\u662f\u76f8\u8fde\u7684\uff0c\u6c42\u6b64\u65f6\u7684\u6700\u5927\u91d1\u989d \u300c\u5206\u6790\u300d \u6570\u7ec4\u6210\u73af\u7684\u72b6\u6001\u4e0b\uff0c\u9996\u5c3e\u5143\u7d20\u81f3\u5c11\u6709\u4e00\u4e2a\u4e0d\u4f1a\u88ab\u76d7\u7a83\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5206\u6210\u4e24\u79cd\u60c5\u51b5\uff1a\uff081\uff09\u4e0d\u9009\u62e9\u9996\u5143\u7d20\uff0c\uff082\uff09\u4e0d\u9009\u62e9\u5c3e\u5143\u7d20\u3002\u7531\u6b64\uff0c\u5c06\u4e00\u4e2a\u6210\u73af\u95ee\u9898\u8f6c\u6362\u6210\u4e24\u4e2a\u6210\u6392\u95ee\u9898\uff0c\u5404\u81ea\u7684\u89e3\u6cd5\u5982\u4e0a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n - 1 ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } int ans = max ( dp0 , dp1 ); dp0 = 0 ; dp1 = nums [ 1 ]; for ( int i = 2 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } ans = max ( ans , max ( dp0 , dp1 )); return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u6210\u6811 \u00b6 \u8fd9\u6b21\u7684\u623f\u5c4b\u6392\u5217\u6210\u4e00\u9897\u4e8c\u53c9\u6811\uff0c\u76f8\u90bb\u7684\u623f\u5c4b\u4e0d\u80fd\u540c\u65f6\u88ab\u76d7\u7a83\uff0c\u6c42\u6700\u5927\u91d1\u989d\u3002 \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \u6700\u5927\u91d1\u989d\u662f 10\u3002 \u300c\u5206\u6790\u300d \u6784\u6210\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u60c5\u51b5\u4e0b\uff0c\u5f53\u524d\u8282\u70b9\u53ea\u4e0e\u5de6\u53f3\u5b69\u5b50\u76f8\u5173\u8054\uff08\u81ea\u5e95\u5411\u4e0a\u904d\u5386\uff09\uff0c\u8bbe f[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u4e0d\u76d7\u7a83\uff0c t[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u88ab\u76d7\u7a83\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 unordered_map < TreeNode * , int > t , f ; int rob ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } rob ( root -> left ); rob ( root -> right ); t [ root ] = f [ root -> left ] + f [ root -> right ] + root -> val ; f [ root ] = max ( f [ root -> left ], t [ root -> left ]) + max ( f [ root -> right ], t [ root -> right ]); return max ( t [ root ], f [ root ]); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6253\u5bb6\u52ab\u820d"},{"location":"algo/dp/rob/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4e00\u4e2a\u5c0f\u5077\u53ef\u4ee5\u5077\u53d6\u82e5\u5e72\u623f\u5c4b\u5185\u7684\u6240\u6709\u91d1\u94b1\uff0c\u4f46\u662f\u5077\u7a83\u7684\u623f\u5c4b\u4e0d\u80fd\u76f8\u90bb\uff0c\u6c42\u53ef\u4ee5\u83b7\u5f97\u6700\u5927\u91d1\u989d\u6570\u76ee\u3002 \u300c\u5206\u6790\u300d \u8bbe dp[ i ][ 0 ] \u8868\u793a\u7b2c i \u4e2a\u623f\u5c4b\u6ca1\u6709\u88ab\u76d7\u7a83\uff0cdp[ i ][ 1 ] \u4e3a\u7b2c i \u4e2a\u623f\u5c4b\u88ab\u76d7\u7a83 \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ]} = \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ]} = \\text{dp[i - 1][ 0 ] + A[ i ]} \\end{aligned} 1 2 3 4 5 6 7 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u6210\u6392"},{"location":"algo/dp/rob/#_2","text":"\u540c\u6837\u4e00\u4e2a\u975e\u8d1f\u6570\u7ec4\u8868\u793a\u623f\u5c4b\u5185\u7684\u91d1\u989d\uff0c\u4f46\u662f\u6570\u7ec4\u7684\u9996\u5c3e\u662f\u76f8\u8fde\u7684\uff0c\u6c42\u6b64\u65f6\u7684\u6700\u5927\u91d1\u989d \u300c\u5206\u6790\u300d \u6570\u7ec4\u6210\u73af\u7684\u72b6\u6001\u4e0b\uff0c\u9996\u5c3e\u5143\u7d20\u81f3\u5c11\u6709\u4e00\u4e2a\u4e0d\u4f1a\u88ab\u76d7\u7a83\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5206\u6210\u4e24\u79cd\u60c5\u51b5\uff1a\uff081\uff09\u4e0d\u9009\u62e9\u9996\u5143\u7d20\uff0c\uff082\uff09\u4e0d\u9009\u62e9\u5c3e\u5143\u7d20\u3002\u7531\u6b64\uff0c\u5c06\u4e00\u4e2a\u6210\u73af\u95ee\u9898\u8f6c\u6362\u6210\u4e24\u4e2a\u6210\u6392\u95ee\u9898\uff0c\u5404\u81ea\u7684\u89e3\u6cd5\u5982\u4e0a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int dp0 = 0 , dp1 = nums [ 0 ]; for ( int i = 1 ; i < n - 1 ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } int ans = max ( dp0 , dp1 ); dp0 = 0 ; dp1 = nums [ 1 ]; for ( int i = 2 ; i < n ; i ++ ) { int _dp0 = max ( dp0 , dp1 ); int _dp1 = dp0 + nums [ i ]; dp0 = _dp0 ; dp1 = _dp1 ; } ans = max ( ans , max ( dp0 , dp1 )); return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u6210\u73af"},{"location":"algo/dp/rob/#_3","text":"\u8fd9\u6b21\u7684\u623f\u5c4b\u6392\u5217\u6210\u4e00\u9897\u4e8c\u53c9\u6811\uff0c\u76f8\u90bb\u7684\u623f\u5c4b\u4e0d\u80fd\u540c\u65f6\u88ab\u76d7\u7a83\uff0c\u6c42\u6700\u5927\u91d1\u989d\u3002 \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \\begin{matrix} & & & & & 3 \\\\ & & & & & \\wedge \\\\ & & & 4 & & & & & 5 \\\\ & & & \\wedge & & & & & \\wedge \\\\ & & 1 & & 3 & & & 2 & & 1 \\end{matrix} \u6700\u5927\u91d1\u989d\u662f 10\u3002 \u300c\u5206\u6790\u300d \u6784\u6210\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u60c5\u51b5\u4e0b\uff0c\u5f53\u524d\u8282\u70b9\u53ea\u4e0e\u5de6\u53f3\u5b69\u5b50\u76f8\u5173\u8054\uff08\u81ea\u5e95\u5411\u4e0a\u904d\u5386\uff09\uff0c\u8bbe f[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u4e0d\u76d7\u7a83\uff0c t[ root ] \u4e3a\u5f53\u524d\u8282\u70b9\u88ab\u76d7\u7a83\uff0c\u5176\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} \\begin{aligned} & \\text{t[ root ] = } \\max(\\text{f[ root} \\rightarrow \\text{right ], f[ root} \\rightarrow \\text{left ]}) + \\text{root} \\rightarrow \\text{val} \\\\ & \\begin{aligned} \\text{f[ root ] = } & \\max(\\text{f[ root } \\rightarrow \\text{ left ], t[ root } \\rightarrow \\text{ left ]}) \\\\ & + \\max(\\text{f[ root } \\rightarrow \\text{ right ], t[ root } \\rightarrow \\text{ right ]}) \\end{aligned} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 unordered_map < TreeNode * , int > t , f ; int rob ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } rob ( root -> left ); rob ( root -> right ); t [ root ] = f [ root -> left ] + f [ root -> right ] + root -> val ; f [ root ] = max ( f [ root -> left ], t [ root -> left ]) + max ( f [ root -> right ], t [ root -> right ]); return max ( t [ root ], f [ root ]); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6210\u6811"},{"location":"algo/dp/stocks/","text":"\u4e00\u6b21\u4ea4\u6613 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4prices\uff0c\u5b83\u7684\u7b2ci\u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002\u4f60\u53ea\u80fd\u9009\u62e9 \u67d0\u4e00\u5929 \u4e70\u5165\u8fd9\u53ea\u80a1\u7968\uff0c\u5e76\u9009\u62e9\u5728 \u672a\u6765\u7684\u67d0\u4e00\u4e2a\u4e0d\u540c\u7684\u65e5\u5b50 \u5356\u51fa\u8be5\u80a1\u7968\u3002\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u8fd4\u56de\u4f60\u53ef\u4ee5\u4ece\u8fd9\u7b14\u4ea4\u6613\u4e2d\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u5982\u679c\u4f60\u4e0d\u80fd\u83b7\u53d6\u4efb\u4f55\u5229\u6da6\uff0c\u8fd4\u56de 0 \u3002 \u8f93\u5165\uff1a[7, 1, 5, 3, 6, 4] \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a\u5728\u7b2c 2 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 6\uff09\u7684\u65f6\u5019\u5356\u51fa\uff0c\u6700\u5927\u5229\u6da6 = 6-1 = 5 \u3002\u6ce8\u610f\u5229\u6da6\u4e0d\u80fd\u662f 7-1 = 6, \u56e0\u4e3a\u5356\u51fa\u4ef7\u683c\u9700\u8981\u5927\u4e8e\u4e70\u5165\u4ef7\u683c\uff1b\u540c\u65f6\uff0c\u4f60\u4e0d\u80fd\u5728\u4e70\u5165\u524d\u5356\u51fa\u80a1\u7968\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6700\u5927\u5229\u6da6 = \u5356\u51fa\u65f6\u7684\u4ef7\u683c - \u4e70\u5165\u65f6\u7684\u4ef7\u683c\uff0c\u90a3\u4e48\u9488\u5bf9\u6bcf\u4e00\u5929i\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u8fd9\u4e00\u5929\u7684\u6700\u5927\u5229\u6da6 \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \u5f88\u5bb9\u6613\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u65b9\u6cd5\u3002\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2ai\uff0c\u6211\u4eec\u91cd\u590d\u6c42\u89e3i\u4e4b\u524d\u7684\u6700\u5c0f\u80a1\u7968\u4ef7\u683c\uff0c\u8fd9\u4e00\u6b65\u662f\u5197\u4f59\u7684\uff0c\u56e0\u4e3a\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86[0, i)\u7684\u6700\u5c0f\u503cx\uff0c\u90a3\u4e48[0, i]\u7684\u6700\u5c0f\u503c a\u2018 = min(a, stocks[ i ])\uff0c\u4ece\u800c\u907f\u514d\u4e86\u91cd\u590d\u904d\u5386\u3002\u4e8e\u662f\u6211\u4eec\u6709\u4e00\u4e2a\u9ad8\u6548\u7684\u7b97\u6cd5 1 2 3 4 5 6 int minPrice = INT_MAX , maxProfit = INT_MIN ; for ( int stock : stocks ) { minPrice = min ( minPrice , stock ); maxProfit = max ( maxProfit , stock - minPrice ); } return maxProfit ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u591a\u6b21\u4ea4\u6613 \u00b6 \u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\u7684\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u3001\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u672a\u5356\u51fa\u80a1\u7968\u65f6\u4e0d\u5141\u8bb8\u4e70\u5165\uff0c\u4e70\u5165\u548c\u5356\u51fa\u4e0d\u5728\u540c\u4e00\u5929\u3002\u6c42\u6700\u5927\u6536\u76ca\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u67d0\u4e00\u5929 i \uff0c\u6211\u4eec\u4f1a\u6709\u4e24\u79cd\u72b6\u6001\uff1a\u6301\u6709\u80a1\u7968\u548c\u4e0d\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ 0 ] \u8868\u793a i \u5929\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u53d7\u76ca\uff0cdp[ i ][ 1 ] \u8868\u793a i \u5929\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u6536\u76ca\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \u6211\u4eec\u6ce8\u610f\u5230\uff0c\u7b2c i \u5929\u7684\u4e24\u79cd\u72b6\u6001\u53ea\u4e0e\u7b2c i-1 \u5929\u7684\u4e24\u79cd\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5bf9\u65f6\u95f4\u590d\u6742\u5ea6\u8fdb\u884c\u4f18\u5316\u3002\u6700\u540e\u4e00\u5929\uff0c\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u4e00\u5b9a\u9ad8\u4e8e\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u3002 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); int dp0 = 0 , dp1 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 , dp1 + prices [ i ]); int tmp1 = max ( dp0 - prices [ i ], dp1 ); dp0 = tmp0 ; dp1 = tmp1 ; } return dp0 ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u81f3\u591ak\u6b21\u4ea4\u6613 \u00b6 \u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u6700\u591ak\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u56e0\u4e3a\u9898\u76ee\u8981\u6c42\u6301\u6709\u80a1\u7968\u65f6\u4e0d\u80fd\u518d\u4e70\u5165\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f\u4e00\u5929 i \uff0c\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\uff1a\u8fd9\u4e00\u5929\u6709\u80a1\u7968\u548c\u8fd9\u4e00\u5929\u6ca1\u6709\u80a1\u7968\u3002\u518d\u6839\u636e\u4ea4\u6613\u7684\u6b21\u6570\uff0c\u8bbe dp[ i ][ j ][ 0 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u671f\u95f4\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u672a\u6301\u6709\u80a1\u7968\uff0cdp[ i ][ j ][ 1 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u6301\u6709\u80a1\u7968\u3002\u6211\u4eec\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \u5bf9\u4e8e dp[ i ][ j ][ 0 ] \u8fd9\u4e00\u5929\u672a\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u4e00\u5929\u4e5f\u672a\u6301\u6709\u80a1\u7968\uff0c\u6216\u8005(2) i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\u800c\u5728 i \u8fd9\u4e00\u5929\u5356\u51fa\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u6301\u6709\u7684\u80a1\u7968\u4e00\u5b9a\u662f\u7b2c j \u6b21\u4ea4\u6613\u4ea7\u751f\u7684\u3002\u540c\u6837\u5730\uff0c\u5bf9\u4e8e dp[ i ][ j ][ 1 ] \u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u5929\u672a\u6301\u6709\u800c i \u8fd9\u4e00\u5929\u4e70\u5165\u80a1\u7968\u5e76\u4e14 i-1 \u5c5e\u4e8e\u7b2c j-1 \u6b21\u4ea4\u6613\u6216\u8005\uff081\uff09i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u76f4\u63a5\u8fc7\u6e21\u800c\u6765\u3002i = 0 \u8868\u793a\u7684\u662f\u7b2c\u4e00\u5929\u7684\u80a1\u4ef7\uff0c\u5bf9\u4e8e\u7b2c j = 1, 2, ..., k \u6b21\u4ea4\u6613\uff0c\u5982\u679c\u5728 i = 0 \u5904\u53d1\u751f\u5356\u51fa\uff0cdp[ 0 ][ j ][ 1 ] = -prices[ 0 ]\u3002\u6700\u7ec8\u7684\u5229\u6da6\u548c\u53d1\u751f\u5728\u6700\u540e\u4e00\u5929\u4e0d\u6301\u6709\u80a1\u7968\u4e2d\u7684\u67d0\u4e00\u4e2a j \u503c\uff0c\u5373 \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \u6211\u4eec\u8fd8\u53ef\u4ee5\u53d1\u73b0\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4e0e\u7b2c i-1\u5929\u7684\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u4e3a\u5728\u7a7a\u95f4\u4e0a\u53ef\u4ee5\u4f18\u5316\u3002\u8bbe dp0[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u672a\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6\uff0cdp1[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6 \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 int maxProfit ( int k , vector < int >& prices ) { int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } vector < int > dp0 ( k + 1 , 0 ), dp1 ( k + 1 , - prices [ 0 ]); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp0 [ j ] = max ( dp0 [ j ], dp1 [ j ] + prices [ i ]); dp1 [ j ] = max ( dp0 [ j - 1 ] - prices [ i ], dp1 [ j ]); } } return * max_element ( dp0 . begin (), dp0 . end ()); } \u65f6\u95f4\u590d\u6742\u5ea6 O(nk) O(nk) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(k) O(k) \u5e26\u6709\u51b7\u51bb\u671f\u7684\u4ea4\u6613 \u00b6 \u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u4f46\u662f\u6bcf\u4e00\u6b21\u4ea4\u6613\u5b8c\u6210\u540e\u7684\u4e0b\u4e00\u5929\u4e3a\u51b7\u51bb\u671f\uff0c\u4e0d\u80fd\u8d2d\u4e70\u80a1\u7968\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u7b2c i \u5929\u7ed3\u675f\uff0c\u6211\u4eec\u4f1a\u51fa\u73b0\u4e09\u79cd\u72b6\u6001\uff1a\uff081\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4e14\u4e0d\u4f1a\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff082\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4f46\u662f\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff083\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u4f1a\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001 dp[ i ][ 0 ] \u8868\u793a\u72b6\u6001\uff081\uff09\uff0c\u524d\u4e00\u5929 i-1 \u7684\u72b6\u6001\u53ef\u80fd\u662f\uff081\uff09\u548c\uff082\uff09\uff1bdp[ i ][ 1 ] \u8868\u793a\u72b6\u6001\uff082\uff09\uff0c\u524d\u4e00\u5929\u7684\u72b6\u6001\u4e00\u5b9a\u662f\uff083\uff09\uff0c\u5e76\u4e14\u5728\u7b2c i \u5929\u5356\u51fa\u80a1\u7968\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u6837\u624d\u4f1a\u8fdb\u5165\u51b7\u51bb\u671f\uff1bdp[ i ][ 2 ] \u8868\u793a\u72b6\u6001\uff083\uff09\uff0c\u524d\u4e00\u5929\u7684\u53ef\u80fd\u72b6\u6001\u662f\uff081\uff09\u548c\uff083\uff09\uff0c\u56e0\u4e3a\u7b2c i \u5929\u7ed3\u675f\u662f\u8981\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u4e0d\u53ef\u80fd\u662f\u51b7\u51bb\u671f\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \u6211\u4eec\u89c2\u5bdf\u5230\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4f1a\u4e0e\u524d\u4e00\u5929\u7684\u72b6\u6001\u6709\u5173\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4fdd\u7559\u524d\u4e00\u5929\u7684\u72b6\u6001\u5373\u53ef\u3002 \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } int dp0 = 0 , dp1 = 0 , dp2 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { dp2 = max ( dp0 - prices [ i ], dp2 ); dp0 = max ( dp0 , dp1 ); dp1 = dp2 + prices [ i ]; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u5e8f\u5217stocks = [100, 80, 60, 70, 60, 75, 85], \u6c42\u5176\u6bcf\u4e00\u5929\u7684\u80a1\u7968\u8de8\u5ea6\uff08\u4ecei\u5929\u5f00\u59cb\u5411\u524d\u8ba1\u6570\uff0c\u80a1\u7968\u4ef7\u683c\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u4ef7\u683c\uff09\uff0c\u8f93\u51fa\u7ed3\u679c[1, 1, 1, 2, 1, 4, 6] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u7684\u7b97\u6cd5\uff0c\u4f46\u662f\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u67d0\u4e00\u5929\u7684\u80a1\u7968 stocks[ i ]\uff0c\u5fc5\u7136\u4f1a\u9010\u4e2a\u4e0ei\u4e4b\u524d\u7684\u5143\u7d20\u6bd4\u8f83\uff0c\u7ec8\u4e8e\u78b0\u5230\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u6216\u8005\u6ca1\u6709\uff0c\u8fd9\u65f6\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u5bf9\u4e8e\u4e0b\u4e00\u4e2a\u80a1\u4ef7 stocks[i + 1] \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \u5355\u8c03\u6808\u9002\u5408\u89e3\u51b3\u6b64\u7c7b\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 stack < int > stk , cnt ; vector < int > ans ; for ( int s : stocks ) { int num = 1 ; while ( ! stk . empty () && stk . top () <= s ) { num += cnt . top (); cnt . pop (); stk . pop (); } ans . emplace_back ( num ); cnt . push ( num ); stk . push ( s ); } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u80a1\u7968\u4e70\u5356"},{"location":"algo/dp/stocks/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4prices\uff0c\u5b83\u7684\u7b2ci\u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002\u4f60\u53ea\u80fd\u9009\u62e9 \u67d0\u4e00\u5929 \u4e70\u5165\u8fd9\u53ea\u80a1\u7968\uff0c\u5e76\u9009\u62e9\u5728 \u672a\u6765\u7684\u67d0\u4e00\u4e2a\u4e0d\u540c\u7684\u65e5\u5b50 \u5356\u51fa\u8be5\u80a1\u7968\u3002\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u8fd4\u56de\u4f60\u53ef\u4ee5\u4ece\u8fd9\u7b14\u4ea4\u6613\u4e2d\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u5982\u679c\u4f60\u4e0d\u80fd\u83b7\u53d6\u4efb\u4f55\u5229\u6da6\uff0c\u8fd4\u56de 0 \u3002 \u8f93\u5165\uff1a[7, 1, 5, 3, 6, 4] \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a\u5728\u7b2c 2 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 6\uff09\u7684\u65f6\u5019\u5356\u51fa\uff0c\u6700\u5927\u5229\u6da6 = 6-1 = 5 \u3002\u6ce8\u610f\u5229\u6da6\u4e0d\u80fd\u662f 7-1 = 6, \u56e0\u4e3a\u5356\u51fa\u4ef7\u683c\u9700\u8981\u5927\u4e8e\u4e70\u5165\u4ef7\u683c\uff1b\u540c\u65f6\uff0c\u4f60\u4e0d\u80fd\u5728\u4e70\u5165\u524d\u5356\u51fa\u80a1\u7968\u3002 \u300c\u5206\u6790\u300d \u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6700\u5927\u5229\u6da6 = \u5356\u51fa\u65f6\u7684\u4ef7\u683c - \u4e70\u5165\u65f6\u7684\u4ef7\u683c\uff0c\u90a3\u4e48\u9488\u5bf9\u6bcf\u4e00\u5929i\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u8fd9\u4e00\u5929\u7684\u6700\u5927\u5229\u6da6 \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \\text{maxProfit[ i ] = stocks[ i ] - } \\min_{j \\in [0, i)} \\text{stocks[ j ]} \u5f88\u5bb9\u6613\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u65b9\u6cd5\u3002\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2ai\uff0c\u6211\u4eec\u91cd\u590d\u6c42\u89e3i\u4e4b\u524d\u7684\u6700\u5c0f\u80a1\u7968\u4ef7\u683c\uff0c\u8fd9\u4e00\u6b65\u662f\u5197\u4f59\u7684\uff0c\u56e0\u4e3a\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86[0, i)\u7684\u6700\u5c0f\u503cx\uff0c\u90a3\u4e48[0, i]\u7684\u6700\u5c0f\u503c a\u2018 = min(a, stocks[ i ])\uff0c\u4ece\u800c\u907f\u514d\u4e86\u91cd\u590d\u904d\u5386\u3002\u4e8e\u662f\u6211\u4eec\u6709\u4e00\u4e2a\u9ad8\u6548\u7684\u7b97\u6cd5 1 2 3 4 5 6 int minPrice = INT_MAX , maxProfit = INT_MIN ; for ( int stock : stocks ) { minPrice = min ( minPrice , stock ); maxProfit = max ( maxProfit , stock - minPrice ); } return maxProfit ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u4e00\u6b21\u4ea4\u6613"},{"location":"algo/dp/stocks/#_2","text":"\u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\u7684\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u3001\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u672a\u5356\u51fa\u80a1\u7968\u65f6\u4e0d\u5141\u8bb8\u4e70\u5165\uff0c\u4e70\u5165\u548c\u5356\u51fa\u4e0d\u5728\u540c\u4e00\u5929\u3002\u6c42\u6700\u5927\u6536\u76ca\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u67d0\u4e00\u5929 i \uff0c\u6211\u4eec\u4f1a\u6709\u4e24\u79cd\u72b6\u6001\uff1a\u6301\u6709\u80a1\u7968\u548c\u4e0d\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bbe dp[ i ][ 0 ] \u8868\u793a i \u5929\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u53d7\u76ca\uff0cdp[ i ][ 1 ] \u8868\u793a i \u5929\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u6536\u76ca\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ 1 ] = } \\max(\\text{dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 1 ]}) \\end{aligned} \u6211\u4eec\u6ce8\u610f\u5230\uff0c\u7b2c i \u5929\u7684\u4e24\u79cd\u72b6\u6001\u53ea\u4e0e\u7b2c i-1 \u5929\u7684\u4e24\u79cd\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5bf9\u65f6\u95f4\u590d\u6742\u5ea6\u8fdb\u884c\u4f18\u5316\u3002\u6700\u540e\u4e00\u5929\uff0c\u4e0d\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u4e00\u5b9a\u9ad8\u4e8e\u6301\u6709\u80a1\u7968\u7684\u6536\u76ca\u3002 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); int dp0 = 0 , dp1 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { int tmp0 = max ( dp0 , dp1 + prices [ i ]); int tmp1 = max ( dp0 - prices [ i ], dp1 ); dp0 = tmp0 ; dp1 = tmp1 ; } return dp0 ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u591a\u6b21\u4ea4\u6613"},{"location":"algo/dp/stocks/#k","text":"\u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u6700\u591ak\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u56e0\u4e3a\u9898\u76ee\u8981\u6c42\u6301\u6709\u80a1\u7968\u65f6\u4e0d\u80fd\u518d\u4e70\u5165\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f\u4e00\u5929 i \uff0c\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\uff1a\u8fd9\u4e00\u5929\u6709\u80a1\u7968\u548c\u8fd9\u4e00\u5929\u6ca1\u6709\u80a1\u7968\u3002\u518d\u6839\u636e\u4ea4\u6613\u7684\u6b21\u6570\uff0c\u8bbe dp[ i ][ j ][ 0 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u671f\u95f4\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u672a\u6301\u6709\u80a1\u7968\uff0cdp[ i ][ j ][ 1 ] \u4e3a\u7b2c i \u5929\u5904\u4e8e\u7b2c j \u6b21\u4ea4\u6613\u4e14\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u6301\u6709\u80a1\u7968\u3002\u6211\u4eec\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ j ][ 0 ] = } \\max(\\text{dp[i - 1][ j ][ 0 ], dp[i - 1][ j ][ 1 ] + prices[ i ]}) \\\\ & \\text{dp[ i ][ j ][ 1 ] = } \\max(\\text{dp[i - 1][j - 1][ 0 ] - prices[ i ], dp[i - 1][ j ][ 1 ]}) \\end{aligned} \u5bf9\u4e8e dp[ i ][ j ][ 0 ] \u8fd9\u4e00\u5929\u672a\u6301\u6709\u80a1\u7968\uff0c\u90a3\u4e48\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u4e00\u5929\u4e5f\u672a\u6301\u6709\u80a1\u7968\uff0c\u6216\u8005(2) i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\u800c\u5728 i \u8fd9\u4e00\u5929\u5356\u51fa\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u6301\u6709\u7684\u80a1\u7968\u4e00\u5b9a\u662f\u7b2c j \u6b21\u4ea4\u6613\u4ea7\u751f\u7684\u3002\u540c\u6837\u5730\uff0c\u5bf9\u4e8e dp[ i ][ j ][ 1 ] \u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u53ef\u80fd\u7684\u72b6\u6001\u6765\u6e90\u662f(1) i-1 \u8fd9\u5929\u672a\u6301\u6709\u800c i \u8fd9\u4e00\u5929\u4e70\u5165\u80a1\u7968\u5e76\u4e14 i-1 \u5c5e\u4e8e\u7b2c j-1 \u6b21\u4ea4\u6613\u6216\u8005\uff081\uff09i-1\u8fd9\u4e00\u5929\u6301\u6709\u80a1\u7968\uff0c\u76f4\u63a5\u8fc7\u6e21\u800c\u6765\u3002i = 0 \u8868\u793a\u7684\u662f\u7b2c\u4e00\u5929\u7684\u80a1\u4ef7\uff0c\u5bf9\u4e8e\u7b2c j = 1, 2, ..., k \u6b21\u4ea4\u6613\uff0c\u5982\u679c\u5728 i = 0 \u5904\u53d1\u751f\u5356\u51fa\uff0cdp[ 0 ][ j ][ 1 ] = -prices[ 0 ]\u3002\u6700\u7ec8\u7684\u5229\u6da6\u548c\u53d1\u751f\u5728\u6700\u540e\u4e00\u5929\u4e0d\u6301\u6709\u80a1\u7968\u4e2d\u7684\u67d0\u4e00\u4e2a j \u503c\uff0c\u5373 \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \\text{target} = \\max_{j \\in {1, 2, ..., k}} \\text{dp[n - 1][ j ][ 0 ]} \u6211\u4eec\u8fd8\u53ef\u4ee5\u53d1\u73b0\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4e0e\u7b2c i-1\u5929\u7684\u72b6\u6001\u6709\u5173\u7cfb\uff0c\u56e0\u4e3a\u5728\u7a7a\u95f4\u4e0a\u53ef\u4ee5\u4f18\u5316\u3002\u8bbe dp0[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u672a\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6\uff0cdp1[ j ] \u8868\u793a\u7b2c j \u6b21\u4ea4\u6613\u6301\u6709\u80a1\u7968\u7684\u6700\u5927\u5229\u6da6 \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} \\begin{aligned} & \\text{dp0[ j ] = } \\max(\\text{dp0[ j ], dp1[ j ] + prices[ i ]}) \\\\ & \\text{dp1[ j ] = } \\max(\\text{dp0[j - 1] - prices[ i ], dp1[ j ]}) \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 int maxProfit ( int k , vector < int >& prices ) { int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } vector < int > dp0 ( k + 1 , 0 ), dp1 ( k + 1 , - prices [ 0 ]); for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp0 [ j ] = max ( dp0 [ j ], dp1 [ j ] + prices [ i ]); dp1 [ j ] = max ( dp0 [ j - 1 ] - prices [ i ], dp1 [ j ]); } } return * max_element ( dp0 . begin (), dp0 . end ()); } \u65f6\u95f4\u590d\u6742\u5ea6 O(nk) O(nk) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(k) O(k)","title":"\u81f3\u591ak\u6b21\u4ea4\u6613"},{"location":"algo/dp/stocks/#_3","text":"\u5bf9\u4e8e\u4e00\u53ea\u80a1\u7968\uff0c\u5141\u8bb8\u591a\u6b21\u4ea4\u6613\uff08\u4e70\u5165\u548c\u5356\u51fa\u4e3a\u4e00\u6b21\u4ea4\u6613\uff09\uff0c\u4f46\u662f\u6bcf\u4e00\u6b21\u4ea4\u6613\u5b8c\u6210\u540e\u7684\u4e0b\u4e00\u5929\u4e3a\u51b7\u51bb\u671f\uff0c\u4e0d\u80fd\u8d2d\u4e70\u80a1\u7968\uff0c\u6c42\u5176\u6700\u5927\u7684\u5229\u6da6\u3002 \u300c\u5206\u6790\u300d \u5bf9\u4e8e\u7b2c i \u5929\u7ed3\u675f\uff0c\u6211\u4eec\u4f1a\u51fa\u73b0\u4e09\u79cd\u72b6\u6001\uff1a\uff081\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u540e\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4e14\u4e0d\u4f1a\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff082\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u51c6\u5907\u8fdb\u5165\u672a\u6301\u6709\u80a1\u7968\u4f46\u662f\u5904\u4e8e\u51b7\u51bb\u671f\u7684\u72b6\u6001\uff0c\uff083\uff09\u8fd9\u4e00\u5929\u7ed3\u675f\u4f1a\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001 dp[ i ][ 0 ] \u8868\u793a\u72b6\u6001\uff081\uff09\uff0c\u524d\u4e00\u5929 i-1 \u7684\u72b6\u6001\u53ef\u80fd\u662f\uff081\uff09\u548c\uff082\uff09\uff1bdp[ i ][ 1 ] \u8868\u793a\u72b6\u6001\uff082\uff09\uff0c\u524d\u4e00\u5929\u7684\u72b6\u6001\u4e00\u5b9a\u662f\uff083\uff09\uff0c\u5e76\u4e14\u5728\u7b2c i \u5929\u5356\u51fa\u80a1\u7968\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u6837\u624d\u4f1a\u8fdb\u5165\u51b7\u51bb\u671f\uff1bdp[ i ][ 2 ] \u8868\u793a\u72b6\u6001\uff083\uff09\uff0c\u524d\u4e00\u5929\u7684\u53ef\u80fd\u72b6\u6001\u662f\uff081\uff09\u548c\uff083\uff09\uff0c\u56e0\u4e3a\u7b2c i \u5929\u7ed3\u675f\u662f\u8981\u8fdb\u5165\u6301\u6709\u80a1\u7968\u7684\u72b6\u6001\uff0c\u90a3\u4e48\u8fd9\u4e00\u5929\u4e0d\u53ef\u80fd\u662f\u51b7\u51bb\u671f\u3002 \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \\begin{aligned} & \\text{dp[ i ][ 0 ] = } \\max(\\text{dp[i - 1][ 0 ], dp[i - 1][ 1 ]}) \\\\ & \\text{dp[ i ][ 1 ] = dp[i - 1][ 2 ] + prices[ i ]} \\\\ & \\text{dp[ i ][ 2 ] = } \\max(dp[i - 1][ 0 ] - prices[ i ], dp[i - 1][ 2 ]) \\end{aligned} \u6211\u4eec\u89c2\u5bdf\u5230\uff0c\u7b2c i \u5929\u7684\u72b6\u6001\u53ea\u4f1a\u4e0e\u524d\u4e00\u5929\u7684\u72b6\u6001\u6709\u5173\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4fdd\u7559\u524d\u4e00\u5929\u7684\u72b6\u6001\u5373\u53ef\u3002 \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} \\begin{aligned} & \\text{dp0 } \\leftarrow \\max(\\text{dp0, dp1}) \\\\ & \\text{dp1 } \\leftarrow \\text{dp2 + prices[i]} \\\\ & \\text{dp2 } \\leftarrow \\max(\\text{dp0 - prices[ i ], dp2}) \\end{aligned} 1 2 3 4 5 6 7 8 9 int n = ( int ) prices . size (); if ( n == 0 ) { return 0 ; } int dp0 = 0 , dp1 = 0 , dp2 = - prices [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { dp2 = max ( dp0 - prices [ i ], dp2 ); dp0 = max ( dp0 , dp1 ); dp1 = dp2 + prices [ i ]; } return max ( dp0 , dp1 ); \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u5e26\u6709\u51b7\u51bb\u671f\u7684\u4ea4\u6613"},{"location":"algo/dp/stocks/#_4","text":"\u7ed9\u5b9a\u4e00\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u5e8f\u5217stocks = [100, 80, 60, 70, 60, 75, 85], \u6c42\u5176\u6bcf\u4e00\u5929\u7684\u80a1\u7968\u8de8\u5ea6\uff08\u4ecei\u5929\u5f00\u59cb\u5411\u524d\u8ba1\u6570\uff0c\u80a1\u7968\u4ef7\u683c\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u4ef7\u683c\uff09\uff0c\u8f93\u51fa\u7ed3\u679c[1, 1, 1, 2, 1, 4, 6] \u300c\u5206\u6790\u300d \u6309\u7167\u9898\u610f\uff0c\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a O(n^{2}) O(n^{2}) \u7684\u7b97\u6cd5\uff0c\u4f46\u662f\u8fd9\u6837\u4f1a\u8d85\u65f6\u3002\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5bf9\u4e8e\u67d0\u4e00\u5929\u7684\u80a1\u7968 stocks[ i ]\uff0c\u5fc5\u7136\u4f1a\u9010\u4e2a\u4e0ei\u4e4b\u524d\u7684\u5143\u7d20\u6bd4\u8f83\uff0c\u7ec8\u4e8e\u78b0\u5230\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u6216\u8005\u6ca1\u6709\uff0c\u8fd9\u65f6\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u5bf9\u4e8e\u4e0b\u4e00\u4e2a\u80a1\u4ef7 stocks[i + 1] \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \\text{count[ stocks[i + 1] ]} = \\begin{cases} \\text{count[ stocks[ i ] ]} + 1, & \\quad \\text{stocks[ i + 1 ]} \\geq \\text{stocks[ i ]} \\\\ 1, & \\quad \\text{otherwise} \\end{cases} \u5355\u8c03\u6808\u9002\u5408\u89e3\u51b3\u6b64\u7c7b\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 stack < int > stk , cnt ; vector < int > ans ; for ( int s : stocks ) { int num = 1 ; while ( ! stk . empty () && stk . top () <= s ) { num += cnt . top (); cnt . pop (); stk . pop (); } ans . emplace_back ( num ); cnt . push ( num ); stk . push ( s ); } return ans ; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u80a1\u7968\u4ef7\u683c\u7684\u8de8\u5ea6"},{"location":"data-structure/binary-indexed-tree/","text":"\u7b80\u4ecb \u00b6 \u6811\u72b6\u6570\u7ec4\u662f\u4e00\u79cd\u5bf9\u5b58\u50a8\u6570\u5b57\u7684\u5217\u8868\u8fdb\u884c\u9ad8\u6548\u5730\u66f4\u65b0\u53ca\u6c42\u524d\u7f00\u548c\u7684\u6570\u636e\u7ed3\u6784\u3002\u4e3b\u8981\u7684\u64cd\u4f5c\u4e3a\uff1a \u66f4\u65b0\uff08update\uff09 \u6c42\u548c\uff08sum\uff09 \u6811\u72b6\u6570\u7ec4\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u4fdd\u5b58\u6570\u636e\uff0c\u4f46\u67d0\u4e9b\u7ed3\u70b9\u662f\u524d\u65b9\u82e5\u5e72\u7ed3\u70b9\u7684\u603b\u548c \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \u4f8b\u5982\uff0c \u7ed3\u70b9 1\u30013\u30015\u30017 \u53ea\u7ba1\u7406\u4e00\u4e2a\u6570\u503c\uff0c\u7ed3\u70b9 2 \u7ba1\u7406 1\u30012\uff08\u5171\u4e24\u4e2a\uff09\uff0c\u7ed3\u70b9 4 \u7ba1\u7406 1\u30012\u30013\u30014\uff08\u5171\u56db\u4e2a\uff09\u3002\u6b64\u5904\u7684\u6570\u5b57\u5747\u8868\u793a\u6570\u7ec4\u7684\u79e9\uff08\u4ece 1 \u5f00\u59cb\uff09\u3002 \u539f\u7406 \u00b6 lowBit \u00b6 \u82e5\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0c\u6211\u4eec\u6c42\u8fd9\u4e2a\u79e9\u4e0b\u4e00\u5c42\u79e9\uff0c\u5373\u5f53\u524d\u7ed3\u70b9\u53ef\u7ba1\u7406\u7684\u7ed3\u70b9\u6570\u76ee\u3002 1 2 3 int lowBit ( int x ) { return x & ( - x ); } \u6b64\u5904 x \u8868\u793a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0cx & (-x) \u8868\u793a\u6c42 x \u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u7b2c\u4e00\u4e2a 1 \u53ca\u5176\u53f3\u8fb9\u7684\u6240\u6709 0 \u6784\u6210\u7684\u503c\u3002 \u4f8b\u5982\uff0c \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5947\u6570\u7684 lowBit \u4e00\u5b9a\u4e3a 1\uff0c\u5076\u6570\u7684 lowBit \u4e00\u5b9a\u662f\u5076\u6570 \u66f4\u65b0 \u00b6 \u5982\u679c\u6211\u4eec\u60f3\u5bf9\u67d0\u4e00\u4e2a\u6570\u503c\u66f4\u65b0\uff0c\u5982\u7d2f\u52a0\u4e00\u4e2a\u6570\u503c\uff0c\u9700\u8981\u5c06\u5f53\u524d\u7ed3\u70b9\u53ca\u5176\u6240\u6709\u7684\u4e0a\u7ea7\u66f4\u65b0\u3002 1 2 3 4 5 6 7 vector < int > C ; void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } } \u67e5\u8be2 \u00b6 \u82e5\u7ed9\u5b9a\u4e00\u4e2a\u79e9\uff0c\u5e94\u5f53\u8fd4\u56de\u622a\u6b62\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u524d\u7f00\u548c\u3002 1 2 3 4 5 6 7 8 int query ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; } \u521d\u59cb\u5316\u5efa\u6811 \u00b6 \u5982\u679c\u7ed9\u5b9a\u4e86\u4e00\u4e2a\u6570\u7ec4\uff0c\u6211\u4eec\u5e0c\u671b\u6709\u53e6\u4e00\u4e2a\u6570\u7ec4\u5728 O(n) O(n) \u7684\u65f6\u95f4\u4e0b\u5efa\u7acb\u6811\u72b6\u6570\u7ec4\u3002 1 2 3 4 5 for ( int i = 1 ; i <= n ; i ++ ) { C [ i ] += A [ i ]; int j = i + lowBit ( i ); if ( j <= n ) { C [ j ] += C [ i ]; } } \u9898\u76ee \u00b6 \u7edf\u8ba1\u53f3\u4fa7\u5c0f\u4e8e\u5f53\u524d\u5143\u7d20\u7684\u4e2a\u6570 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u5982 nums = [5, 2, 6, 1, 1]\uff0c\u8fd4\u56de\u4e00\u4e2a\u7b49\u957f\u7684\u6570\u7ec4\uff0ccnt = [3, 2, 2, 0, 0]\u3002cnt[ i ] \u8868\u793a\u5728 (i : ] \u8303\u56f4\u5185\u6bd4 nums[ i ] \u5c0f\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u7b97\u6cd5\u662f O(n^{2}) O(n^{2}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u4e24\u5c42\u5faa\u73af\uff0c\u4f46\u662f\u5bb9\u6613\u8d85\u65f6\u3002\u9898\u610f\u8981\u6c42\u662f\u6c42\u5f53\u524d\u5143\u7d20\u5bf9\u5e94\u7684\u7edf\u8ba1\u503c\uff0c\u5f88\u81ea\u7136\u5730\u6211\u4eec\u4f1a\u60f3\u5230\u6876\u6392\uff1a\u7531\u540e\u5411\u524d\u5c06\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u653e\u5230\u6876\u4e2d\uff0c\u8fd9\u91cc\u7684\u6876\u6307\u7684\u662f\u6392\u5217\u540e\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u8fd9\u6837\u505a\u4f9d\u7136\u4e0d\u80fd\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u9898\u76ee\u8981\u6c42\u662f\u7edf\u8ba1\u4e2a\u6570\uff0c\u672c\u8d28\u4e0a\u662f\u6c42\u548c\uff0c\u533a\u522b\u5728\u4e8e\u6bcf\u6b21\u66f4\u65b0\u64cd\u4f5c\u65f6\uff0c\u53ea\u4f1a +1 \u3002\u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6811\u72b6\u6570\u7ec4\u6c42\u89e3\u3002 (1) \u7528 map \u7edf\u8ba1\u6570\u7ec4\u5404\u4e2a\u5143\u7d20\u51fa\u73b0\u7684\u4e2a\u6570 (2) \u6839\u636e\u7edf\u8ba1\u540e\u7684\u7ed3\u679c\u786e\u5b9a\u6811\u72b6\u6570\u7ec4\u7684\u957f\u5ea6 len \uff0c\u5982\u679c\u6709\u91cd\u590d\u5143\u7d20\u51fa\u73b0\uff0c\u8fd9\u4e2a\u5143\u7d20\u5360\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u5982\u679c\u65e0\u91cd\u590d\u5143\u7d20\uff0c\u8fd9\u4e2a\u5143\u7d20\u53ea\u5360\u4e00\u4e2a\u4f4d\u7f6e\u3002\u8fd9\u91cc\u7ed9\u91cd\u590d\u7684\u5143\u7d20\u8bbe\u7f6e\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u4e3a\u4e86\u907f\u514d\u5728\u540e\u7eed\u6c42\u548c\u64cd\u4f5c\u4e2d\u9519\u8bef\u5730\u5c06\u76f8\u7b49\u5143\u7d20\u8ba1\u7b97\u5728\u5185 (3) \u4ece\u540e\u5411\u524d\u904d\u5386\u6570\u7ec4\uff0c\u627e\u5230\u5143\u7d20\u5728\u6811\u72b6\u6570\u7ec4\u7684\u4f4d\u7f6e\uff0c\u5148\u6c42\u548c\uff0c\u518d\u66f4\u65b0\u3002\u5982\u679c\u662f\u91cd\u590d\u5143\u7d20\uff0c\u5b83\u6709\u4e24\u4e2a\u4f4d\u7f6e\uff0c i \u548c i-1\u4e24\u4e2a\u4e3a\u4f4d\u7f6e\uff0c\u6211\u4eec\u7528 i \u6c42\u548c\uff0c\u7528 i-1 \u66f4\u65b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > C ; int lowBit ( int x ) { return x & ( - x ); } void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } } int getSum ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; } vector < int > countSmaller ( vector < int >& nums ) { int n = ( int ) nums . size (), len = 0 ; vector < int > ans ( n , 0 ); if ( n < 2 ) { return ans ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } for ( auto iter = cnt . begin (); iter != cnt . end (); iter ++ ) { len ++ ; if ( iter -> second > 1 ) { len ++ ; } iter -> second = len ; } C . resize ( len + 1 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { ans [ i ] = getSum ( cnt [ nums [ i ]] - 1 ); update ( cnt [ nums [ i ]]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u6811\u72b6\u6570\u7ec4"},{"location":"data-structure/binary-indexed-tree/#_1","text":"\u6811\u72b6\u6570\u7ec4\u662f\u4e00\u79cd\u5bf9\u5b58\u50a8\u6570\u5b57\u7684\u5217\u8868\u8fdb\u884c\u9ad8\u6548\u5730\u66f4\u65b0\u53ca\u6c42\u524d\u7f00\u548c\u7684\u6570\u636e\u7ed3\u6784\u3002\u4e3b\u8981\u7684\u64cd\u4f5c\u4e3a\uff1a \u66f4\u65b0\uff08update\uff09 \u6c42\u548c\uff08sum\uff09 \u6811\u72b6\u6570\u7ec4\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u4fdd\u5b58\u6570\u636e\uff0c\u4f46\u67d0\u4e9b\u7ed3\u70b9\u662f\u524d\u65b9\u82e5\u5e72\u7ed3\u70b9\u7684\u603b\u548c \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \\begin{matrix} & & & & & & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & \\rightarrow & 8\\\\ & & & & & \\nearrow & & & & & & & \\uparrow \\\\ & & & & 4 & & & & & & & & \\uparrow \\\\ & & & \\nearrow & \\uparrow & & & & & & & \\nearrow \\\\ & & 2 & & \\uparrow & & & & & & 6 & & \\uparrow \\\\ & \\nearrow & & & \\uparrow & & & & & \\nearrow & & & \\uparrow \\\\ 1 & & & & 3 & & & & 5 & & & & 7 \\end{matrix} \u4f8b\u5982\uff0c \u7ed3\u70b9 1\u30013\u30015\u30017 \u53ea\u7ba1\u7406\u4e00\u4e2a\u6570\u503c\uff0c\u7ed3\u70b9 2 \u7ba1\u7406 1\u30012\uff08\u5171\u4e24\u4e2a\uff09\uff0c\u7ed3\u70b9 4 \u7ba1\u7406 1\u30012\u30013\u30014\uff08\u5171\u56db\u4e2a\uff09\u3002\u6b64\u5904\u7684\u6570\u5b57\u5747\u8868\u793a\u6570\u7ec4\u7684\u79e9\uff08\u4ece 1 \u5f00\u59cb\uff09\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/binary-indexed-tree/#_2","text":"","title":"\u539f\u7406"},{"location":"data-structure/binary-indexed-tree/#lowbit","text":"\u82e5\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0c\u6211\u4eec\u6c42\u8fd9\u4e2a\u79e9\u4e0b\u4e00\u5c42\u79e9\uff0c\u5373\u5f53\u524d\u7ed3\u70b9\u53ef\u7ba1\u7406\u7684\u7ed3\u70b9\u6570\u76ee\u3002 1 2 3 int lowBit ( int x ) { return x & ( - x ); } \u6b64\u5904 x \u8868\u793a\u4e00\u4e2a\u6570\u7ec4\u7684\u79e9\uff0cx & (-x) \u8868\u793a\u6c42 x \u5728\u4e8c\u8fdb\u5236\u5f62\u5f0f\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u7b2c\u4e00\u4e2a 1 \u53ca\u5176\u53f3\u8fb9\u7684\u6240\u6709 0 \u6784\u6210\u7684\u503c\u3002 \u4f8b\u5982\uff0c \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \\begin{matrix} \\text{x} & = & (6)_{10} & = & (0110)_{2} \\\\ \\text{-x} & = & (-6)_{10} & = & (1001)_{2} \\\\ \\text{x & (-x)} & = & (0010)_{2} & = & 2 \\end{matrix} \u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5947\u6570\u7684 lowBit \u4e00\u5b9a\u4e3a 1\uff0c\u5076\u6570\u7684 lowBit \u4e00\u5b9a\u662f\u5076\u6570","title":"lowBit"},{"location":"data-structure/binary-indexed-tree/#_3","text":"\u5982\u679c\u6211\u4eec\u60f3\u5bf9\u67d0\u4e00\u4e2a\u6570\u503c\u66f4\u65b0\uff0c\u5982\u7d2f\u52a0\u4e00\u4e2a\u6570\u503c\uff0c\u9700\u8981\u5c06\u5f53\u524d\u7ed3\u70b9\u53ca\u5176\u6240\u6709\u7684\u4e0a\u7ea7\u66f4\u65b0\u3002 1 2 3 4 5 6 7 vector < int > C ; void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } }","title":"\u66f4\u65b0"},{"location":"data-structure/binary-indexed-tree/#_4","text":"\u82e5\u7ed9\u5b9a\u4e00\u4e2a\u79e9\uff0c\u5e94\u5f53\u8fd4\u56de\u622a\u6b62\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u524d\u7f00\u548c\u3002 1 2 3 4 5 6 7 8 int query ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; }","title":"\u67e5\u8be2"},{"location":"data-structure/binary-indexed-tree/#_5","text":"\u5982\u679c\u7ed9\u5b9a\u4e86\u4e00\u4e2a\u6570\u7ec4\uff0c\u6211\u4eec\u5e0c\u671b\u6709\u53e6\u4e00\u4e2a\u6570\u7ec4\u5728 O(n) O(n) \u7684\u65f6\u95f4\u4e0b\u5efa\u7acb\u6811\u72b6\u6570\u7ec4\u3002 1 2 3 4 5 for ( int i = 1 ; i <= n ; i ++ ) { C [ i ] += A [ i ]; int j = i + lowBit ( i ); if ( j <= n ) { C [ j ] += C [ i ]; } }","title":"\u521d\u59cb\u5316\u5efa\u6811"},{"location":"data-structure/binary-indexed-tree/#_6","text":"","title":"\u9898\u76ee"},{"location":"data-structure/binary-indexed-tree/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u5982 nums = [5, 2, 6, 1, 1]\uff0c\u8fd4\u56de\u4e00\u4e2a\u7b49\u957f\u7684\u6570\u7ec4\uff0ccnt = [3, 2, 2, 0, 0]\u3002cnt[ i ] \u8868\u793a\u5728 (i : ] \u8303\u56f4\u5185\u6bd4 nums[ i ] \u5c0f\u7684\u4e2a\u6570\u3002 \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u7b97\u6cd5\u662f O(n^{2}) O(n^{2}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u4e24\u5c42\u5faa\u73af\uff0c\u4f46\u662f\u5bb9\u6613\u8d85\u65f6\u3002\u9898\u610f\u8981\u6c42\u662f\u6c42\u5f53\u524d\u5143\u7d20\u5bf9\u5e94\u7684\u7edf\u8ba1\u503c\uff0c\u5f88\u81ea\u7136\u5730\u6211\u4eec\u4f1a\u60f3\u5230\u6876\u6392\uff1a\u7531\u540e\u5411\u524d\u5c06\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u653e\u5230\u6876\u4e2d\uff0c\u8fd9\u91cc\u7684\u6876\u6307\u7684\u662f\u6392\u5217\u540e\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u8fd9\u6837\u505a\u4f9d\u7136\u4e0d\u80fd\u51cf\u5c0f\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u9898\u76ee\u8981\u6c42\u662f\u7edf\u8ba1\u4e2a\u6570\uff0c\u672c\u8d28\u4e0a\u662f\u6c42\u548c\uff0c\u533a\u522b\u5728\u4e8e\u6bcf\u6b21\u66f4\u65b0\u64cd\u4f5c\u65f6\uff0c\u53ea\u4f1a +1 \u3002\u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6811\u72b6\u6570\u7ec4\u6c42\u89e3\u3002 (1) \u7528 map \u7edf\u8ba1\u6570\u7ec4\u5404\u4e2a\u5143\u7d20\u51fa\u73b0\u7684\u4e2a\u6570 (2) \u6839\u636e\u7edf\u8ba1\u540e\u7684\u7ed3\u679c\u786e\u5b9a\u6811\u72b6\u6570\u7ec4\u7684\u957f\u5ea6 len \uff0c\u5982\u679c\u6709\u91cd\u590d\u5143\u7d20\u51fa\u73b0\uff0c\u8fd9\u4e2a\u5143\u7d20\u5360\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u5982\u679c\u65e0\u91cd\u590d\u5143\u7d20\uff0c\u8fd9\u4e2a\u5143\u7d20\u53ea\u5360\u4e00\u4e2a\u4f4d\u7f6e\u3002\u8fd9\u91cc\u7ed9\u91cd\u590d\u7684\u5143\u7d20\u8bbe\u7f6e\u4e24\u4e2a\u4f4d\u7f6e\uff0c\u4e3a\u4e86\u907f\u514d\u5728\u540e\u7eed\u6c42\u548c\u64cd\u4f5c\u4e2d\u9519\u8bef\u5730\u5c06\u76f8\u7b49\u5143\u7d20\u8ba1\u7b97\u5728\u5185 (3) \u4ece\u540e\u5411\u524d\u904d\u5386\u6570\u7ec4\uff0c\u627e\u5230\u5143\u7d20\u5728\u6811\u72b6\u6570\u7ec4\u7684\u4f4d\u7f6e\uff0c\u5148\u6c42\u548c\uff0c\u518d\u66f4\u65b0\u3002\u5982\u679c\u662f\u91cd\u590d\u5143\u7d20\uff0c\u5b83\u6709\u4e24\u4e2a\u4f4d\u7f6e\uff0c i \u548c i-1\u4e24\u4e2a\u4e3a\u4f4d\u7f6e\uff0c\u6211\u4eec\u7528 i \u6c42\u548c\uff0c\u7528 i-1 \u66f4\u65b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > C ; int lowBit ( int x ) { return x & ( - x ); } void update ( int k , int v = 1 ) { while ( k < C . size ()) { C [ k ] += v ; k += lowBit ( k ); } } int getSum ( int k ) { int ans = 0 ; while ( k > 0 ) { ans += C [ k ]; k -= lowBit ( k ); } return ans ; } vector < int > countSmaller ( vector < int >& nums ) { int n = ( int ) nums . size (), len = 0 ; vector < int > ans ( n , 0 ); if ( n < 2 ) { return ans ; } map < int , int > cnt ; for ( int num : nums ) { cnt [ num ] ++ ; } for ( auto iter = cnt . begin (); iter != cnt . end (); iter ++ ) { len ++ ; if ( iter -> second > 1 ) { len ++ ; } iter -> second = len ; } C . resize ( len + 1 ); for ( int i = n - 1 ; i >= 0 ; i -- ) { ans [ i ] = getSum ( cnt [ nums [ i ]] - 1 ); update ( cnt [ nums [ i ]]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u7edf\u8ba1\u53f3\u4fa7\u5c0f\u4e8e\u5f53\u524d\u5143\u7d20\u7684\u4e2a\u6570"},{"location":"data-structure/list/","text":"\u7b80\u4ecb \u00b6 \u94fe\u8868\u662f\u4e00\u79cd\u5bfb\u4f4d\u8bbf\u95ee\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4ee5\u6307\u9488\u7684\u65b9\u5f0f\uff0c\u5c06\u4e24\u5757\u6570\u636e\u8fde\u63a5\u8d77\u6765\u3002\u5b58\u50a8\u7a7a\u95f4\u4e0a\u901a\u5e38\u662f\u4e0d\u8fde\u7eed\u7684\uff0c\u589e\u5220\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \u3002\u901a\u5e38\u800c\u8a00\uff0c\u94fe\u8868\u6709\u5982\u4e0b\u51e0\u79cd \u5355\u94fe\u8868 \u53cc\u94fe\u8868 \u5faa\u73af\u94fe\u8868 \u94fe\u8868\u7ed3\u70b9\u8bbe\u8ba1 \u00b6 \u7ed3\u70b9\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a \u6570\u636e\u57df \u6307\u9488\u57df \u5bf9\u5355\u94fe\u8868\u800c\u8a00\uff0c\u5176\u7ed3\u70b9\u7684\u5b9a\u4e49\u65b9\u5f0f\u5982\u4e0b 1 2 3 4 5 6 7 8 struct ListNode { int val ; ListNode * next ; ListNode () : val ( 0 ), next ( nullptr ) {} ListNode ( int x ) : val ( x ), next ( nullptr ) {} ListNode ( int x , ListNode * next ) : val ( x ), next ( next ) {} }; \u627e\u51fa\u4e24\u4e2a\u94fe\u8868\u7684\u76f8\u4ea4\u7ed3\u70b9 \u00b6 \u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868A\u3001B\uff0c\u627e\u51fa\u4e24\u8005\u76f8\u4ea4\u7684\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u4ea4\uff0c\u8fd4\u56de\u4e3a\u7a7a\u6307\u9488\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u65b9\u6cd5\u662f\u5c06\u8fd9\u4e24\u4e2a\u94fe\u8868\u7528\u6808\u4fdd\u5b58\u8d77\u6765\uff0c\u6bd4\u5bf9\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u540c\uff0c\u5219\u5fc5\u5b9a\u4e0d\u76f8\u4ea4\uff0c\u5982\u679c\u76f8\u540c\uff0c\u53cd\u5411\u904d\u5386\u6808\u5373\u53ef\u627e\u5230\u7b2c\u4e00\u4e2a\u76f8\u4ea4\u7684\u7ed3\u70b9\u3002\u4f46\u662f\u5e38\u6570\u7a7a\u95f4\u7684\u7b97\u6cd5\u662f\u5b58\u5728\u7684\u3002\u95ee\u9898\u7684\u96be\u70b9\u5728\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u4e0d\u4e00\u81f4\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u548c\u662f\u4e00\u5b9a\u7684\uff0c\u5373\u6211\u4eec\u5148\u904d\u5386\u94fe\u8868 pHead1 \u518d\u904d\u5386\u94fe\u8868 pHead2 \u4e0e\u5148\u904d\u5386 pHead2 \u518d\u904d\u5386 pHead1 \u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684\u3002\u90a3\u4e48\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u662f\u5728\u67d0\u4e2a\u7ed3\u70b9\u76f8\u4ea4\u7684\uff0c\u6309\u7167\u4e0a\u8ff0\u7684\u904d\u5386\u65b9\u6cd5\uff0c\u4e24\u4e2a\u6307\u9488\u4e00\u5b9a\u5728\u76f8\u4ea4\u7684\u7ed3\u70b9\u76f8\u4f1a\u3002 \u9996\u5148\uff0c\u521d\u59cb\u72b6\u6001\u4e0b\uff0c\u4e24\u4e2a\u6307\u9488\u5206\u522b\u5904\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u5934\u7ed3\u70b9 \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} p_{1} p_{1} \u548c p_{2} p_{2} \u540c\u65f6\u5411\u540e\u79fb\u52a8\u76f4\u5230\u67d0\u4e00\u4e2a\u7387\u5148\u5230\u8fbe\u672b\u7ed3\u70b9\u3002\u672c\u4f8b\u4e2d\uff0c p_{2} p_{2} \u5148\u5230\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece pHead1 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u540c\u6837\u5730\uff0c p_{1} p_{1} \u4e5f\u4f1a\u5230\u8fbe\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece phead2 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u5c31\u4f1a\u53d1\u73b0\uff0c p_{1} p_{1} \u548c p_{2} p_{2} \u5904\u5728\u76f8\u540c\u4f4d\u7f6e\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u53ef\u4ee5\u540c\u65f6\u8fbe\u5230\u5404\u81ea\u7684\u5c3e\u7ed3\u70b9\u3002 \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \u6700\u7ec8\u53ef\u4ee5\u627e\u5230\u76f8\u4ea4\u4f4d\u7f6e\u5904\u7684\u7ed3\u70b9 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( headA == nullptr || headB == nullptr ) { return nullptr ; } ListNode * p1 = headA , * p2 = headB ; for ( int i = 0 ; i < 3 ; i ++ ) { while ( p1 != nullptr && p2 != nullptr ) { if ( p1 == p2 ) { return p1 ; } p1 = p1 -> next ; p2 = p2 -> next ; } if ( p1 == nullptr ) { p1 = headB ; } if ( p2 == nullptr ) { p2 = headA ; } } return nullptr ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u94fe\u8868"},{"location":"data-structure/list/#_1","text":"\u94fe\u8868\u662f\u4e00\u79cd\u5bfb\u4f4d\u8bbf\u95ee\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4ee5\u6307\u9488\u7684\u65b9\u5f0f\uff0c\u5c06\u4e24\u5757\u6570\u636e\u8fde\u63a5\u8d77\u6765\u3002\u5b58\u50a8\u7a7a\u95f4\u4e0a\u901a\u5e38\u662f\u4e0d\u8fde\u7eed\u7684\uff0c\u589e\u5220\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \uff0c\u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \u3002\u901a\u5e38\u800c\u8a00\uff0c\u94fe\u8868\u6709\u5982\u4e0b\u51e0\u79cd \u5355\u94fe\u8868 \u53cc\u94fe\u8868 \u5faa\u73af\u94fe\u8868","title":"\u7b80\u4ecb"},{"location":"data-structure/list/#_2","text":"\u7ed3\u70b9\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a \u6570\u636e\u57df \u6307\u9488\u57df \u5bf9\u5355\u94fe\u8868\u800c\u8a00\uff0c\u5176\u7ed3\u70b9\u7684\u5b9a\u4e49\u65b9\u5f0f\u5982\u4e0b 1 2 3 4 5 6 7 8 struct ListNode { int val ; ListNode * next ; ListNode () : val ( 0 ), next ( nullptr ) {} ListNode ( int x ) : val ( x ), next ( nullptr ) {} ListNode ( int x , ListNode * next ) : val ( x ), next ( next ) {} };","title":"\u94fe\u8868\u7ed3\u70b9\u8bbe\u8ba1"},{"location":"data-structure/list/#_3","text":"\u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868A\u3001B\uff0c\u627e\u51fa\u4e24\u8005\u76f8\u4ea4\u7684\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u4ea4\uff0c\u8fd4\u56de\u4e3a\u7a7a\u6307\u9488\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u300c\u5206\u6790\u300d \u6734\u7d20\u7684\u65b9\u6cd5\u662f\u5c06\u8fd9\u4e24\u4e2a\u94fe\u8868\u7528\u6808\u4fdd\u5b58\u8d77\u6765\uff0c\u6bd4\u5bf9\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u76f8\u540c\uff0c\u5219\u5fc5\u5b9a\u4e0d\u76f8\u4ea4\uff0c\u5982\u679c\u76f8\u540c\uff0c\u53cd\u5411\u904d\u5386\u6808\u5373\u53ef\u627e\u5230\u7b2c\u4e00\u4e2a\u76f8\u4ea4\u7684\u7ed3\u70b9\u3002\u4f46\u662f\u5e38\u6570\u7a7a\u95f4\u7684\u7b97\u6cd5\u662f\u5b58\u5728\u7684\u3002\u95ee\u9898\u7684\u96be\u70b9\u5728\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u4e0d\u4e00\u81f4\uff0c\u4f46\u662f\u8fd9\u4e24\u4e2a\u94fe\u8868\u7684\u957f\u5ea6\u548c\u662f\u4e00\u5b9a\u7684\uff0c\u5373\u6211\u4eec\u5148\u904d\u5386\u94fe\u8868 pHead1 \u518d\u904d\u5386\u94fe\u8868 pHead2 \u4e0e\u5148\u904d\u5386 pHead2 \u518d\u904d\u5386 pHead1 \u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684\u3002\u90a3\u4e48\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u662f\u5728\u67d0\u4e2a\u7ed3\u70b9\u76f8\u4ea4\u7684\uff0c\u6309\u7167\u4e0a\u8ff0\u7684\u904d\u5386\u65b9\u6cd5\uff0c\u4e24\u4e2a\u6307\u9488\u4e00\u5b9a\u5728\u76f8\u4ea4\u7684\u7ed3\u70b9\u76f8\u4f1a\u3002 \u9996\u5148\uff0c\u521d\u59cb\u72b6\u6001\u4e0b\uff0c\u4e24\u4e2a\u6307\u9488\u5206\u522b\u5904\u4e8e\u4e24\u4e2a\u94fe\u8868\u7684\u5934\u7ed3\u70b9 \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} \\begin{matrix} p_{1} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{2} \\end{matrix} p_{1} p_{1} \u548c p_{2} p_{2} \u540c\u65f6\u5411\u540e\u79fb\u52a8\u76f4\u5230\u67d0\u4e00\u4e2a\u7387\u5148\u5230\u8fbe\u672b\u7ed3\u70b9\u3002\u672c\u4f8b\u4e2d\uff0c p_{2} p_{2} \u5148\u5230\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece pHead1 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow & & & & & & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & & & & & & p_{2} \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \\begin{matrix} p_{2} \\\\ \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & & & & & & p_{1} \\\\ & & & & & & & \\searrow & & & & & & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow & 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\end{matrix} \u540c\u6837\u5730\uff0c p_{1} p_{1} \u4e5f\u4f1a\u5230\u8fbe\u672b\u7ed3\u70b9\uff0c\u8f6c\u800c\u4ece phead2 \u7684\u5934\u7ed3\u70b9\u5f00\u59cb\u904d\u5386\u3002\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u5c31\u4f1a\u53d1\u73b0\uff0c p_{1} p_{1} \u548c p_{2} p_{2} \u5904\u5728\u76f8\u540c\u4f4d\u7f6e\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u53ef\u4ee5\u540c\u65f6\u8fbe\u5230\u5404\u81ea\u7684\u5c3e\u7ed3\u70b9\u3002 \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \\begin{matrix} & & p_{2} \\\\ & & \\Downarrow \\\\ 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 \\\\ & & & & & & & \\searrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 \\\\ & & \\Uparrow \\\\ & & p_{1} \\end{matrix} \u6700\u7ec8\u53ef\u4ee5\u627e\u5230\u76f8\u4ea4\u4f4d\u7f6e\u5904\u7684\u7ed3\u70b9 \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} \\begin{matrix} 1 & \\rightarrow & 2 & \\rightarrow & 3 & \\rightarrow & 4 & & p_{2} \\\\ & & & & & & & \\searrow & \\Downarrow \\\\ & & & & & & & & {\\color{Red} 8} & \\rightarrow & 9 & \\rightarrow 10 \\\\ & & & & & & & \\nearrow & \\Uparrow \\\\ & & 5 & \\rightarrow & 6 & \\rightarrow & 7 & & p_{1} \\end{matrix} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( headA == nullptr || headB == nullptr ) { return nullptr ; } ListNode * p1 = headA , * p2 = headB ; for ( int i = 0 ; i < 3 ; i ++ ) { while ( p1 != nullptr && p2 != nullptr ) { if ( p1 == p2 ) { return p1 ; } p1 = p1 -> next ; p2 = p2 -> next ; } if ( p1 == nullptr ) { p1 = headB ; } if ( p2 == nullptr ) { p2 = headA ; } } return nullptr ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1)","title":"\u627e\u51fa\u4e24\u4e2a\u94fe\u8868\u7684\u76f8\u4ea4\u7ed3\u70b9"},{"location":"data-structure/segment-tree/","text":"\u7b80\u4ecb \u00b6 \u7ebf\u6bb5\u6811\u662f\u4e00\u79cd\u9ad8\u6548\u5730\u7ef4\u62a4\u533a\u95f4\u4fe1\u606f\uff08\u548c\u3001\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u7b49\uff09\u7684\u4e00\u79cd\u6811\u5f62\u7ed3\u6784\u3002\u7ebf\u6bb5\u6811\u6709\u4e24\u4e2a\u4e3b\u8981\u7684\u63a5\u53e3 \u67e5\u8be2\uff08query\uff09\uff0c\u4f8b\u5982\u6c42\u533a\u95f4\u548c \u66f4\u65b0\uff08update\uff09\uff0c\u66f4\u65b0\u67d0\u4e00\u4f4d\u7f6e\u7684\u503c\uff0c\u5bf9\u5e94\u7684\u6240\u6709\u533a\u95f4\u548c\u5c06\u88ab\u66f4\u65b0 \u4e24\u8005\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a O(\\log n) O(\\log n) \u3002 \u539f\u7406 \u00b6 \u5efa\u6811 \u00b6 \u7ebf\u6bb5\u6811\u4e0e\u6700\u5c0f\u5806\u7c7b\u4f3c\uff0c\u4ee5\u4e8c\u53c9\u6811\u6765\u5efa\u7acb\uff0c\u627f\u8f7d\u7684\u5f62\u5f0f\u662f\u4e00\u4e2a\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u7ebf\u6bb5\u6811\u7684\u6839\u7ed3\u70b9\u5bf9\u5e94\u7684\u7d22\u5f15\u662f 1\uff1b\u7ebf\u6bb5\u6811\u662f\u4e00\u9897\u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\uff0c\u6700\u540e\u4e00\u5c42\u9760\u5de6\u6392\u5217\u3002 \u53f6\u5b50\u7ed3\u70b9\u662f\u5947\u6570 \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \u53f6\u5b50\u7ed3\u70b9\u662f\u5076\u6570 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \u5b8c\u6ee1\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u4e0e\u975e\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u6709\u4e00\u4e2a\u5173\u7cfb n_{\\text{leaves}} = n_{non-leaves} + 1 n_{\\text{leaves}} = n_{non-leaves} + 1 \u56e0\u6b64\uff0c\u7ebf\u6bb5\u6811\u5c06\u539f\u6570\u7ec4\u7684\u6bcf\u4e00\u4e2a\u503c\u90fd\u653e\u5728\u53f6\u5b50\u7ed3\u70b9\u4e0a\uff0c\u81ea\u5e95\u5411\u4e0a\u5730\u5efa\u6811\u3002 1 2 3 4 5 6 7 8 9 10 void initialize ( vector < int > nums ) { int n = ( int ) nums . size (); vector < int > A ( n * 2 , 0 ); for ( int j = n , i = 0 ; i < n ; i ++ , j ++ ) { A [ j ] = nums [ i ]; } for ( int j = n - 1 ; j > 0 ; j -- ) { A [ j ] = A [ j * 2 ] + A [ j * 2 + 1 ]; } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u67e5\u8be2 \u00b6 \u7ebf\u6bb5\u6811\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u4fe1\u606f\uff0c\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b\uff0c\u6839\u7ed3\u70b9\u8868\u793a\u6574\u4e2a\u533a\u95f4\u548c\u3002\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5e0c\u671b\u76f4\u63a5\u8fd4\u56de\u4e00\u4e2a\u533a\u95f4\u7684\u548c\uff0c\u4f46\u5f80\u5f80\u7ed9\u51fa\u7684\u533a\u95f4\u8fb9\u754c\u4e0d\u662f\u6070\u597d\u5bf9\u5e94\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06\u8981\u6c42\u7684\u533a\u95f4\u5206\u5272\uff0c\u6c42\u6bcf\u4e00\u4e2a\u5b50\u533a\u95f4\u7684\u548c\uff0c\u5373\u53ef\u5f97\u5230\u6700\u7ec8\u7ed3\u679c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int sumRange ( int left , int right ) { int sum = 0 ; left += n ; right += n ; while ( left <= right ) { if ( left % 2 != 0 ) { sum += A [ left ++ ]; } if ( right % 2 == 0 ) { sum += A [ right -- ]; } left >>= 1 ; right >>= 1 ; } return sum ; } \u66f4\u65b0 \u00b6 \u5f53\u539f\u6570\u7ec4\u7684\u4e00\u4e2a\u6216\u82e5\u5e72\u4e2a\u6570\u503c\u53d1\u751f\u6539\u53d8\u65f6\uff0c\u5bf9\u5e94\u7684\u533a\u95f4\u4fe1\u606f\u4e5f\u8981\u53d1\u751f\u53d8\u5316\uff0c\u4ece\u53f6\u5b50\u7ed3\u70b9\u5f00\u59cb\u66f4\u65b0\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7684\u7ed3\u70b9\u3002\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b 1 2 3 4 5 6 7 8 void update ( int index , int val ) { index += n ; int diff = val - A [ index ]; while ( index ) { A [ index ] += diff ; index >>= 1 ; } } \u9898\u76ee \u00b6","title":"\u7ebf\u6bb5\u6811"},{"location":"data-structure/segment-tree/#_1","text":"\u7ebf\u6bb5\u6811\u662f\u4e00\u79cd\u9ad8\u6548\u5730\u7ef4\u62a4\u533a\u95f4\u4fe1\u606f\uff08\u548c\u3001\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u7b49\uff09\u7684\u4e00\u79cd\u6811\u5f62\u7ed3\u6784\u3002\u7ebf\u6bb5\u6811\u6709\u4e24\u4e2a\u4e3b\u8981\u7684\u63a5\u53e3 \u67e5\u8be2\uff08query\uff09\uff0c\u4f8b\u5982\u6c42\u533a\u95f4\u548c \u66f4\u65b0\uff08update\uff09\uff0c\u66f4\u65b0\u67d0\u4e00\u4f4d\u7f6e\u7684\u503c\uff0c\u5bf9\u5e94\u7684\u6240\u6709\u533a\u95f4\u548c\u5c06\u88ab\u66f4\u65b0 \u4e24\u8005\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a O(\\log n) O(\\log n) \u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/segment-tree/#_2","text":"","title":"\u539f\u7406"},{"location":"data-structure/segment-tree/#_3","text":"\u7ebf\u6bb5\u6811\u4e0e\u6700\u5c0f\u5806\u7c7b\u4f3c\uff0c\u4ee5\u4e8c\u53c9\u6811\u6765\u5efa\u7acb\uff0c\u627f\u8f7d\u7684\u5f62\u5f0f\u662f\u4e00\u4e2a\u6570\u7ec4\u3002\u4f46\u662f\uff0c\u7ebf\u6bb5\u6811\u7684\u6839\u7ed3\u70b9\u5bf9\u5e94\u7684\u7d22\u5f15\u662f 1\uff1b\u7ebf\u6bb5\u6811\u662f\u4e00\u9897\u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\uff0c\u6700\u540e\u4e00\u5c42\u9760\u5de6\u6392\u5217\u3002 \u53f6\u5b50\u7ed3\u70b9\u662f\u5947\u6570 \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & 1 \\\\ & & \\wedge \\\\ & 2 & & {\\color{Red} 3} \\\\ & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} \\\\ \\end{matrix} \\quad \\quad \\quad \\text{3\u30014\u30015 \u662f\u53f6\u5b50\u7ed3\u70b9} \u53f6\u5b50\u7ed3\u70b9\u662f\u5076\u6570 \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \\begin{matrix} & & & 1 \\\\ & & & \\wedge \\\\ & 2 & & & & 3 \\\\ & \\wedge & & & & \\wedge \\\\ {\\color{Red} 4} & & {\\color{Red} 5} & & {\\color{Red} 6} & & {\\color{Red} 7} \\end{matrix} \\quad \\quad \\quad \\text{4\u30015\u30016\u30017 \u662f\u53f6\u5b50\u7ed3\u70b9} \u5b8c\u6ee1\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u4e0e\u975e\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u6709\u4e00\u4e2a\u5173\u7cfb n_{\\text{leaves}} = n_{non-leaves} + 1 n_{\\text{leaves}} = n_{non-leaves} + 1 \u56e0\u6b64\uff0c\u7ebf\u6bb5\u6811\u5c06\u539f\u6570\u7ec4\u7684\u6bcf\u4e00\u4e2a\u503c\u90fd\u653e\u5728\u53f6\u5b50\u7ed3\u70b9\u4e0a\uff0c\u81ea\u5e95\u5411\u4e0a\u5730\u5efa\u6811\u3002 1 2 3 4 5 6 7 8 9 10 void initialize ( vector < int > nums ) { int n = ( int ) nums . size (); vector < int > A ( n * 2 , 0 ); for ( int j = n , i = 0 ; i < n ; i ++ , j ++ ) { A [ j ] = nums [ i ]; } for ( int j = n - 1 ; j > 0 ; j -- ) { A [ j ] = A [ j * 2 ] + A [ j * 2 + 1 ]; } } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u5efa\u6811"},{"location":"data-structure/segment-tree/#_4","text":"\u7ebf\u6bb5\u6811\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u90fd\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u4fe1\u606f\uff0c\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b\uff0c\u6839\u7ed3\u70b9\u8868\u793a\u6574\u4e2a\u533a\u95f4\u548c\u3002\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5e0c\u671b\u76f4\u63a5\u8fd4\u56de\u4e00\u4e2a\u533a\u95f4\u7684\u548c\uff0c\u4f46\u5f80\u5f80\u7ed9\u51fa\u7684\u533a\u95f4\u8fb9\u754c\u4e0d\u662f\u6070\u597d\u5bf9\u5e94\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06\u8981\u6c42\u7684\u533a\u95f4\u5206\u5272\uff0c\u6c42\u6bcf\u4e00\u4e2a\u5b50\u533a\u95f4\u7684\u548c\uff0c\u5373\u53ef\u5f97\u5230\u6700\u7ec8\u7ed3\u679c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int sumRange ( int left , int right ) { int sum = 0 ; left += n ; right += n ; while ( left <= right ) { if ( left % 2 != 0 ) { sum += A [ left ++ ]; } if ( right % 2 == 0 ) { sum += A [ right -- ]; } left >>= 1 ; right >>= 1 ; } return sum ; }","title":"\u67e5\u8be2"},{"location":"data-structure/segment-tree/#_5","text":"\u5f53\u539f\u6570\u7ec4\u7684\u4e00\u4e2a\u6216\u82e5\u5e72\u4e2a\u6570\u503c\u53d1\u751f\u6539\u53d8\u65f6\uff0c\u5bf9\u5e94\u7684\u533a\u95f4\u4fe1\u606f\u4e5f\u8981\u53d1\u751f\u53d8\u5316\uff0c\u4ece\u53f6\u5b50\u7ed3\u70b9\u5f00\u59cb\u66f4\u65b0\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7684\u7ed3\u70b9\u3002\u4ee5\u533a\u95f4\u548c\u4e3a\u4f8b 1 2 3 4 5 6 7 8 void update ( int index , int val ) { index += n ; int diff = val - A [ index ]; while ( index ) { A [ index ] += diff ; index >>= 1 ; } }","title":"\u66f4\u65b0"},{"location":"data-structure/segment-tree/#_6","text":"","title":"\u9898\u76ee"},{"location":"data-structure/string/","text":"\u5339\u914d \u00b6 KMP \u00b6 KMP\u8bb2\u6c42\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u5339\u914d\uff0c\u5f53\u51fa\u73b0\u8bef\u5339\u914d\u7684\u5b57\u7b26\u65f6\uff0c\u5c06\u6a21\u5f0f\u4e32P\u5411\u53f3\u79fb\u52a8\u82e5\u5e72\u8ddd\u79bb\u3002KMP\u501f\u52a9P\u7684\u524d\u7f00\uff08\u5386\u53f2\u5339\u914d\u4fe1\u606f\uff09\u6784\u5efanext\u6570\u7ec4\u3002\u5c06P\u524d\u7f00\u4e2d\u4e0e\u5931\u914d\u5b57\u7b26\u524d\u6700\u5927\u91cd\u5408\u7684\u4f4d\u7f6e\u5bf9\u9f50\u3002P\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u53d1\u751f\u5931\u914d\u65f6\uff0c\u5bf9\u5e94\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u8be5\u662f-1\uff0c\u8868\u793a\u5c06\u6574\u4e2aP\u79fb\u52a8\u5230\u5931\u914d\u5b57\u7b26\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002 \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \u4e3a\u4e86\u66f4\u52a0\u9ad8\u6548\u5730\u79fb\u52a8P\uff0cnext\u6570\u7ec4\u8868\u793a\u5730\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u5f53\u5c3d\u53ef\u80fd\u5730\u5c0f \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) , \u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0cm\u662fP\u7684\u957f\u5ea6\uff0cn\u662fT\u7684\u957f\u5ea6 \u300cLeetcode 28. \u5b9e\u73b0 strStr()\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahaystack = \"hello\", needle = \"ll\" \u8f93\u51fa\uff1a2 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahaystack = \"aaaaa\", needle = \"bba\" \u8f93\u51fa\uff1a-1 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahaystack = \"\", needle = \"\" \u8f93\u51fa\uff1a0 */ int strStr ( string haystack , string needle ) { int n = ( int ) haystack . length (), m = ( int ) needle . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } vector < int > next ( m , - 1 ); int j = 0 , k = - 1 ; while ( j < m - 1 ) { if ( k < 0 || needle [ j ] == needle [ k ]) { j ++ ; k ++ ; next [ j ] = needle [ j ] != needle [ k ] ? k : next [ k ]; } else { k = next [ k ]; } } int i = 0 ; j = 0 ; while ( i < n && j < m ) { if ( j < 0 || haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } return i - j > n - m ? - 1 : i - j ; } \u300cLeetcode 214. \u6700\u77ed\u56de\u6587\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u5728\u5b57\u7b26\u4e32\u524d\u9762\u6dfb\u52a0\u5b57\u7b26\u5c06\u5176\u8f6c\u6362\u4e3a\u56de\u6587\u4e32\u3002 \u627e\u5230\u5e76\u8fd4\u56de\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f\u8f6c\u6362\u7684\u6700\u77ed\u56de\u6587\u4e32\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1as = \"aacecaaa\" \u8f93\u51fa\uff1a\"aaacecaaa\" \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1as = \"abcd\" \u8f93\u51fa\uff1a\"dcbabcd\" */ string shortestPalindrome ( string s ) { int n = ( int ) s . length (); if ( n <= 1 ) { return s ; } vector < int > next ( n , - 1 ); int i = 0 , pos = - 1 ; while ( i < n - 1 ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i ++ ; pos ++ ; next [ i ] = s [ i ] != s [ pos ] ? pos : next [ pos ]; } else { pos = next [ pos ]; } } pos = 0 ; i = n - 1 ; while ( i >= 0 && pos < n ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i -- ; pos ++ ; } else { pos = next [ pos ]; } } string ans = s . substr ( pos , n - pos ); reverse ( ans . begin (), ans . end ()); return ans + s ; } Boyer-Moore \u00b6 \u574f\u5b57\u7b26 \u00b6 \u5f53\u6a21\u5f0f\u4e32P\u4e0e\u6587\u672c\u4e32T\u5728\u67d0\u4ee5\u4f4d\u7f6epos\u53d1\u751f\u4e0d\u5339\u914d\u65f6\uff0cT[pos]\u53eb\u505a\u574f\u5b57\u7b26\u3002 1.1 \u574f\u5b57\u7b26\u54c8\u5e0c\u8868\u7684\u6784\u9020\uff0c\u4e00\u904d\u626b\u63cf\u5c06P\u4e2d\u7684\u5b57\u7b26\u4f4d\u7f6e\u4fdd\u5b58\u5728\u5b57\u5178\u4e2d\uff0ckey\u4e3a\u5b57\u7b26\u672c\u8eab\uff0cvalue\u4e3a\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u3002 1.2 \u5f53\u574f\u5b57\u7b26\u4e0d\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06\u6a21\u5f0f\u4e32\u5168\u90e8\u79fb\u52a8\u5230\u574f\u5b57\u7b26\u540e\u4e00\u4f4d \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} 1.3 \u5f53\u574f\u5b57\u7b26\u51fa\u73b0\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06P\u4e2d\u6700\u8fd1\u7684\u5b57\u7b26\u4e0eT\u4e2d\u7684\u574f\u5b57\u7b26\u5bf9\u5e94 \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \u4f46\u662f\u5982\u679c\u574f\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u5927\u4e8e\u4e0d\u5339\u914d\u7684\u4f4d\u7f6ej\u65f6\uff0c\u79fb\u52a8\u7684\u8ddd\u79bb\u662f\u8d1f\u6570 \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0cBM\u8fd8\u9700\u8981\u597d\u540e\u7f00\u89c4\u5219\u3002 \u597d\u540e\u7f00 \u00b6 \u56e0\u4e3aT\u4e0eP\u7684\u5339\u914d\u662f\u4ece\u5de6\u5230\u53f3\uff08\u79fb\u52a8\u65b9\u5411\u4e00\u76f4\u662f\u5411\u53f3\uff09\uff0c\u5f53\u51fa\u73b0\u574f\u5b57\u7b26\u65f6\uff0cP\u7684\u540e\u534a\u90e8\u5206\uff08\u5982\u679c\u6709\uff09\u4e00\u5b9a\u662f\u5339\u914d\u597d\u7684\uff0c\u8fd9\u90e8\u5206\u53eb\u505a\u597d\u540e\u7f00\u3002 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06P\u7684\u597d\u540e\u7f00\u5339\u914d\u7684\u524d\u7f00\u90e8\u5206\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u7684\u90e8\u5206\uff08\u540e\u7f00\uff09\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06\u90e8\u5206\u540e\u7f00\uff08P\u524d\u7f00\u4e2d\u7684\uff09\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u6ca1\u6709\u51fa\u73b0\uff0c\u5c06P\u6574\u4f53\u79fb\u52a8lenP\uff08P\u7684\u957f\u5ea6\uff09 \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \u597d\u540e\u7f00\u7684\u6784\u9020 \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} k\u8868\u793a\u597d\u540e\u7f00\u7684\u957f\u5ea6\uff08\u4ece1\u5f00\u59cb\uff09\uff0cpos\u8868\u793a\u597d\u540e\u7f00\u5728\u524d\u7f00\u51fa\u73b0\u7684\u4f4d\u7f6e\uff08\u82e5\u4e0d\u5b58\u5728\u4e3a-1\uff09, T/F\u8868\u793a\u957f\u5ea6\u4e3ak\u7684\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u4f8b\u5982 \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \u574f\u5b57\u7b26\u4e0e\u597d\u540e\u7f00\u7ec4\u5408 \u00b6 \u5206\u522b\u8ba1\u7b97\u4e24\u79cd\u89c4\u5219\u4e0b\u79fb\u52a8\u7684\u8ddd\u79bb\uff0c\u53d6\u8f83\u5927\u8005\u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m + \\Sigma) O(m + \\Sigma) \uff1b\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u6700\u597d\u60c5\u51b5\u4e0b O(\\frac{n}{m}) O(\\frac{n}{m}) \uff0c\u6700\u5dee\u60c5\u51b5\u4e0b O(n+m) O(n+m) \u300cBoyerMoore\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BoyerMoore { vector < int > bc ; vector < int > suffix ; bool * prefix ; string T , P ; int nT , nP ; public : const int N = 256 ; BoyerMoore ( string text , string pattern ) { T = text ; P = pattern ; nT = ( int ) T . length (); nP = ( int ) P . length (); } ~ BoyerMoore () { delete [] prefix ; } void buildBadCharacter () { bc . resize ( N , - 1 ); for ( int i = 0 ; i < nP ; i ++ ) { bc [ P [ i ]] = i ; } } void buildGoodSuffix () { suffix . resize ( nP , - 1 ); prefix = new bool [ nP ]{}; for ( int i = 0 ; i < nP - 1 ; i ++ ) { // k\u4ee3\u8868\u540e\u7f00\u7684\u957f\u5ea6 int j = i , k = 0 ; while ( j >= 0 && P [ j ] == P [ nP - 1 - k ]) { k ++ ; j -- ; suffix [ k ] = j + 1 ; } if ( j == - 1 ) { prefix [ k ] = true ; } } } int stepsToMoveWithGoodSuffix ( int idxBC ) { int k = nP - idxBC - 1 ; if ( k == 0 ) { return 0 ; } if ( suffix [ k ] != - 1 ) { return idxBC - suffix [ k ] + 1 ; } for ( int i = k - 1 ; i > 0 ; i -- ) { if ( prefix [ i ]) { return nP - i - suffix [ i ]; } } return nP ; } vector < int > match () { buildBadCharacter (); buildGoodSuffix (); vector < int > ans ; int k = nP - 1 ; while ( k < nT ) { int i = k , j = nP - 1 ; while ( j >= 0 && T [ i ] == P [ j ]) { i -- ; j -- ; } if ( j == - 1 ) { ans . emplace_back ( i + 1 ); k ++ ; continue ; } int stepsWithBC = nP - 1 - bc [ T [ i ]] - ( k - i ); int stepsWithGS = stepsToMoveWithGoodSuffix ( j ); k += max ( stepsWithBC , stepsWithGS ); } return ans ; } bool isMatch () { return ! match (). empty (); } }; /* string T = \"ababab\", P = \"abab\"; // aaabaaabbbabaa,babb: -1 // ababbbbaaabbbaaa,bbbb: 3 BoyerMoore bm(T, P); vector<int> pos = bm.match(); // [0 2] */ Rabin-Karp \u00b6 \u5229\u7528\u54c8\u5e0c\u7684\u65b9\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u6210\u4e00\u4e2a\u6570\u3002\u7531\u6b64\uff0c\u4e24\u5b57\u7b26\u4e32\u4e4b\u95f4\u7684\u6bd4\u8f83\u8f6c\u5316\u4e3a\u4e24\u6570\u5b57\u7684\u6bd4\u8f83\u3002\u5982\u679c\u51fa\u73b0\u6563\u5217\u51b2\u7a81\uff0c\u9010\u4e00\u6bd4\u8f83\u4e24\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u3002 \u300cRabin-Karp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } int key = 0 , value = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { key += P [ i ]; value += T [ i ]; } key += P [ m - 1 ]; for ( int i = m - 1 , j = - 1 ; i < n ; i ++ ) { value += T [ i ]; if ( j >= 0 ) { value -= T [ j ]; } j ++ ; if ( value == key ) { int x = j , y = 0 ; while ( x <= i && y < m && T [ x ] == P [ y ]) { x ++ ; y ++ ; } if ( y == m ) { return j ; } } } return - 1 ; } int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } for ( int i = 0 ; i <= n - m ; i ++ ) { if ( T . substr ( i , m ) == P ) { return i ; } } return - 1 ; }","title":"\u5b57\u7b26\u4e32"},{"location":"data-structure/string/#_1","text":"","title":"\u5339\u914d"},{"location":"data-structure/string/#kmp","text":"KMP\u8bb2\u6c42\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u5339\u914d\uff0c\u5f53\u51fa\u73b0\u8bef\u5339\u914d\u7684\u5b57\u7b26\u65f6\uff0c\u5c06\u6a21\u5f0f\u4e32P\u5411\u53f3\u79fb\u52a8\u82e5\u5e72\u8ddd\u79bb\u3002KMP\u501f\u52a9P\u7684\u524d\u7f00\uff08\u5386\u53f2\u5339\u914d\u4fe1\u606f\uff09\u6784\u5efanext\u6570\u7ec4\u3002\u5c06P\u524d\u7f00\u4e2d\u4e0e\u5931\u914d\u5b57\u7b26\u524d\u6700\u5927\u91cd\u5408\u7684\u4f4d\u7f6e\u5bf9\u9f50\u3002P\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u53d1\u751f\u5931\u914d\u65f6\uff0c\u5bf9\u5e94\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u8be5\u662f-1\uff0c\u8868\u793a\u5c06\u6574\u4e2aP\u79fb\u52a8\u5230\u5931\u914d\u5b57\u7b26\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002 \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \\begin{matrix} a & c & e & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & e & a & c & {\\color{Blue} f} \\\\ & & & & & \\downarrow \\\\ & & & a & c & e & a & c & f \\end{matrix} \u4e3a\u4e86\u66f4\u52a0\u9ad8\u6548\u5730\u79fb\u52a8P\uff0cnext\u6570\u7ec4\u8868\u793a\u5730\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u5e94\u5f53\u5c3d\u53ef\u80fd\u5730\u5c0f \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \\begin{matrix} a & c & f & a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & f & a & c & {\\color{Blue} f} \\\\ & & & & \\downarrow & & & \\\\ & & & a & c & {\\color{Blue} f} & a & c & f \\\\ & & & & \\downarrow & & & \\\\ & & & & & & a & c & f & a & c & f \\end{matrix} \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m) O(m) , \u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(n + m) O(n + m) \uff0cm\u662fP\u7684\u957f\u5ea6\uff0cn\u662fT\u7684\u957f\u5ea6 \u300cLeetcode 28. \u5b9e\u73b0 strStr()\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1ahaystack = \"hello\", needle = \"ll\" \u8f93\u51fa\uff1a2 \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1ahaystack = \"aaaaa\", needle = \"bba\" \u8f93\u51fa\uff1a-1 \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1ahaystack = \"\", needle = \"\" \u8f93\u51fa\uff1a0 */ int strStr ( string haystack , string needle ) { int n = ( int ) haystack . length (), m = ( int ) needle . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } vector < int > next ( m , - 1 ); int j = 0 , k = - 1 ; while ( j < m - 1 ) { if ( k < 0 || needle [ j ] == needle [ k ]) { j ++ ; k ++ ; next [ j ] = needle [ j ] != needle [ k ] ? k : next [ k ]; } else { k = next [ k ]; } } int i = 0 ; j = 0 ; while ( i < n && j < m ) { if ( j < 0 || haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { j = next [ j ]; } } return i - j > n - m ? - 1 : i - j ; } \u300cLeetcode 214. \u6700\u77ed\u56de\u6587\u4e32\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u5728\u5b57\u7b26\u4e32\u524d\u9762\u6dfb\u52a0\u5b57\u7b26\u5c06\u5176\u8f6c\u6362\u4e3a\u56de\u6587\u4e32\u3002 \u627e\u5230\u5e76\u8fd4\u56de\u53ef\u4ee5\u7528\u8fd9\u79cd\u65b9\u5f0f\u8f6c\u6362\u7684\u6700\u77ed\u56de\u6587\u4e32\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1as = \"aacecaaa\" \u8f93\u51fa\uff1a\"aaacecaaa\" \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1as = \"abcd\" \u8f93\u51fa\uff1a\"dcbabcd\" */ string shortestPalindrome ( string s ) { int n = ( int ) s . length (); if ( n <= 1 ) { return s ; } vector < int > next ( n , - 1 ); int i = 0 , pos = - 1 ; while ( i < n - 1 ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i ++ ; pos ++ ; next [ i ] = s [ i ] != s [ pos ] ? pos : next [ pos ]; } else { pos = next [ pos ]; } } pos = 0 ; i = n - 1 ; while ( i >= 0 && pos < n ) { if ( pos < 0 || s [ i ] == s [ pos ]) { i -- ; pos ++ ; } else { pos = next [ pos ]; } } string ans = s . substr ( pos , n - pos ); reverse ( ans . begin (), ans . end ()); return ans + s ; }","title":"KMP"},{"location":"data-structure/string/#boyer-moore","text":"","title":"Boyer-Moore"},{"location":"data-structure/string/#_2","text":"\u5f53\u6a21\u5f0f\u4e32P\u4e0e\u6587\u672c\u4e32T\u5728\u67d0\u4ee5\u4f4d\u7f6epos\u53d1\u751f\u4e0d\u5339\u914d\u65f6\uff0cT[pos]\u53eb\u505a\u574f\u5b57\u7b26\u3002 1.1 \u574f\u5b57\u7b26\u54c8\u5e0c\u8868\u7684\u6784\u9020\uff0c\u4e00\u904d\u626b\u63cf\u5c06P\u4e2d\u7684\u5b57\u7b26\u4f4d\u7f6e\u4fdd\u5b58\u5728\u5b57\u5178\u4e2d\uff0ckey\u4e3a\u5b57\u7b26\u672c\u8eab\uff0cvalue\u4e3a\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u3002 1.2 \u5f53\u574f\u5b57\u7b26\u4e0d\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06\u6a21\u5f0f\u4e32\u5168\u90e8\u79fb\u52a8\u5230\u574f\u5b57\u7b26\u540e\u4e00\u4f4d \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & f & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & & & a & f & d \\end{matrix} 1.3 \u5f53\u574f\u5b57\u7b26\u51fa\u73b0\u5728\u6a21\u5f0f\u4e32\u4e2d\uff0c\u5c06P\u4e2d\u6700\u8fd1\u7684\u5b57\u7b26\u4e0eT\u4e2d\u7684\u574f\u5b57\u7b26\u5bf9\u5e94 \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \\begin{matrix} a & c & {\\color{Red} e} & a & f & d & b & e \\\\ a & c & {\\color{Blue} d} \\\\ & & & & \\downarrow \\\\ & a & e & d \\end{matrix} \u4f46\u662f\u5982\u679c\u574f\u5b57\u7b26\u5728P\u4e2d\u7684\u4f4d\u7f6e\u5927\u4e8e\u4e0d\u5339\u914d\u7684\u4f4d\u7f6ej\u65f6\uff0c\u79fb\u52a8\u7684\u8ddd\u79bb\u662f\u8d1f\u6570 \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \\begin{matrix} & {\\color{Red} a} & c & d & a & f & d & b & e \\\\ & {\\color{Blue} b} & a & d \\\\ & & & & \\downarrow \\\\ {\\color{Blue} b} & a & d \\end{matrix} \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0cBM\u8fd8\u9700\u8981\u597d\u540e\u7f00\u89c4\u5219\u3002","title":"\u574f\u5b57\u7b26"},{"location":"data-structure/string/#_3","text":"\u56e0\u4e3aT\u4e0eP\u7684\u5339\u914d\u662f\u4ece\u5de6\u5230\u53f3\uff08\u79fb\u52a8\u65b9\u5411\u4e00\u76f4\u662f\u5411\u53f3\uff09\uff0c\u5f53\u51fa\u73b0\u574f\u5b57\u7b26\u65f6\uff0cP\u7684\u540e\u534a\u90e8\u5206\uff08\u5982\u679c\u6709\uff09\u4e00\u5b9a\u662f\u5339\u914d\u597d\u7684\uff0c\u8fd9\u90e8\u5206\u53eb\u505a\u597d\u540e\u7f00\u3002 \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06P\u7684\u597d\u540e\u7f00\u5339\u914d\u7684\u524d\u7f00\u90e8\u5206\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & c & {\\color{Red} d} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & f & {\\color{Blue} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u7684\u90e8\u5206\uff08\u540e\u7f00\uff09\u5728P\u7684\u524d\u7f00\u4e2d\u51fa\u73b0\uff0c\u5c06\u90e8\u5206\u540e\u7f00\uff08P\u524d\u7f00\u4e2d\u7684\uff09\u4e0eT\u5bf9\u9f50 \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \\begin{matrix} c & a & {\\color{Red} d} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} & a & d & e & f \\\\ a & e & {\\color{Blue} f} & {\\color{Green} c} & {\\color{Green} e} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & a & {\\color{Green} e} & {\\color{Green} f} & c & e & f \\end{matrix} \u597d\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u6ca1\u6709\u51fa\u73b0\uff0c\u5c06P\u6574\u4f53\u79fb\u52a8lenP\uff08P\u7684\u957f\u5ea6\uff09 \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \\begin{matrix} a & c & {\\color{Red} f} & {\\color{Green} a} & {\\color{Green} f} & d & b & e & c & f\\\\ & c & {\\color{Blue} c} & {\\color{Green} a} & {\\color{Green} f} \\\\ & & & & \\downarrow \\\\ & & & & & c & c & a & f \\end{matrix} \u597d\u540e\u7f00\u7684\u6784\u9020 \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} \\begin{aligned} & \\text{suffix[ k ] = pos} \\\\ & \\text{prefix[ k ] = T/F} \\end{aligned} k\u8868\u793a\u597d\u540e\u7f00\u7684\u957f\u5ea6\uff08\u4ece1\u5f00\u59cb\uff09\uff0cpos\u8868\u793a\u597d\u540e\u7f00\u5728\u524d\u7f00\u51fa\u73b0\u7684\u4f4d\u7f6e\uff08\u82e5\u4e0d\u5b58\u5728\u4e3a-1\uff09, T/F\u8868\u793a\u957f\u5ea6\u4e3ak\u7684\u540e\u7f00\u5728P\u7684\u524d\u7f00\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u4f8b\u5982 \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned} \\begin{aligned} & \\text{P = cefcef} \\\\ & \\text{suffix[1] = 2,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[2] = 1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[3] = 0,} \\quad \\text{prefix[1] = True} \\\\ & \\text{suffix[4] = -1,} \\quad \\text{prefix[1] = False} \\\\ & \\text{suffix[5] = -1,} \\quad \\text{prefix[1] = False} \\\\ \\end{aligned}","title":"\u597d\u540e\u7f00"},{"location":"data-structure/string/#_4","text":"\u5206\u522b\u8ba1\u7b97\u4e24\u79cd\u89c4\u5219\u4e0b\u79fb\u52a8\u7684\u8ddd\u79bb\uff0c\u53d6\u8f83\u5927\u8005\u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a O(m + \\Sigma) O(m + \\Sigma) \uff1b\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u6700\u597d\u60c5\u51b5\u4e0b O(\\frac{n}{m}) O(\\frac{n}{m}) \uff0c\u6700\u5dee\u60c5\u51b5\u4e0b O(n+m) O(n+m) \u300cBoyerMoore\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BoyerMoore { vector < int > bc ; vector < int > suffix ; bool * prefix ; string T , P ; int nT , nP ; public : const int N = 256 ; BoyerMoore ( string text , string pattern ) { T = text ; P = pattern ; nT = ( int ) T . length (); nP = ( int ) P . length (); } ~ BoyerMoore () { delete [] prefix ; } void buildBadCharacter () { bc . resize ( N , - 1 ); for ( int i = 0 ; i < nP ; i ++ ) { bc [ P [ i ]] = i ; } } void buildGoodSuffix () { suffix . resize ( nP , - 1 ); prefix = new bool [ nP ]{}; for ( int i = 0 ; i < nP - 1 ; i ++ ) { // k\u4ee3\u8868\u540e\u7f00\u7684\u957f\u5ea6 int j = i , k = 0 ; while ( j >= 0 && P [ j ] == P [ nP - 1 - k ]) { k ++ ; j -- ; suffix [ k ] = j + 1 ; } if ( j == - 1 ) { prefix [ k ] = true ; } } } int stepsToMoveWithGoodSuffix ( int idxBC ) { int k = nP - idxBC - 1 ; if ( k == 0 ) { return 0 ; } if ( suffix [ k ] != - 1 ) { return idxBC - suffix [ k ] + 1 ; } for ( int i = k - 1 ; i > 0 ; i -- ) { if ( prefix [ i ]) { return nP - i - suffix [ i ]; } } return nP ; } vector < int > match () { buildBadCharacter (); buildGoodSuffix (); vector < int > ans ; int k = nP - 1 ; while ( k < nT ) { int i = k , j = nP - 1 ; while ( j >= 0 && T [ i ] == P [ j ]) { i -- ; j -- ; } if ( j == - 1 ) { ans . emplace_back ( i + 1 ); k ++ ; continue ; } int stepsWithBC = nP - 1 - bc [ T [ i ]] - ( k - i ); int stepsWithGS = stepsToMoveWithGoodSuffix ( j ); k += max ( stepsWithBC , stepsWithGS ); } return ans ; } bool isMatch () { return ! match (). empty (); } }; /* string T = \"ababab\", P = \"abab\"; // aaabaaabbbabaa,babb: -1 // ababbbbaaabbbaaa,bbbb: 3 BoyerMoore bm(T, P); vector<int> pos = bm.match(); // [0 2] */","title":"\u574f\u5b57\u7b26\u4e0e\u597d\u540e\u7f00\u7ec4\u5408"},{"location":"data-structure/string/#rabin-karp","text":"\u5229\u7528\u54c8\u5e0c\u7684\u65b9\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u6210\u4e00\u4e2a\u6570\u3002\u7531\u6b64\uff0c\u4e24\u5b57\u7b26\u4e32\u4e4b\u95f4\u7684\u6bd4\u8f83\u8f6c\u5316\u4e3a\u4e24\u6570\u5b57\u7684\u6bd4\u8f83\u3002\u5982\u679c\u51fa\u73b0\u6563\u5217\u51b2\u7a81\uff0c\u9010\u4e00\u6bd4\u8f83\u4e24\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49\u3002 \u300cRabin-Karp\u300d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } int key = 0 , value = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { key += P [ i ]; value += T [ i ]; } key += P [ m - 1 ]; for ( int i = m - 1 , j = - 1 ; i < n ; i ++ ) { value += T [ i ]; if ( j >= 0 ) { value -= T [ j ]; } j ++ ; if ( value == key ) { int x = j , y = 0 ; while ( x <= i && y < m && T [ x ] == P [ y ]) { x ++ ; y ++ ; } if ( y == m ) { return j ; } } } return - 1 ; } int RabinKarp ( string T , string P ) { int n = ( int ) T . length (), m = ( int ) P . length (); if ( m == 0 ) { return 0 ; } if ( n == 0 ) { return - 1 ; } for ( int i = 0 ; i <= n - m ; i ++ ) { if ( T . substr ( i , m ) == P ) { return i ; } } return - 1 ; }","title":"Rabin-Karp"},{"location":"data-structure/unionset/","text":"\u7b80\u4ecb \u00b6 \u5e76\u67e5\u96c6\u662f\u4e00\u79cd\u6811\u5f62\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u8981\u5904\u7406\u4e0d\u4ea4\u96c6\u7684\u67e5\u8be2\u548c\u5408\u5e76\u95ee\u9898\uff0c\u5b83\u6709\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff1a \u67e5\u627e\uff08Find\uff09\uff1a\u786e\u5b9a\u5f53\u524d\u7ed3\u70b9\u5c5e\u4e8e\u54ea\u4e00\u4e2a\u96c6\u5408 \u5408\u5e76\uff08Union\uff09\uff1a\u5c06\u4e24\u4e2a\u4e0d\u540c\u7684\u96c6\u5408\u5408\u5e76\u5728\u4e00\u8d77 \u6211\u4eec\u901a\u5e38\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4 fa[ x ] \uff0c\u4e0b\u6807 x \u4ee3\u8868\u67d0\u4e00\u4e2a\u7ed3\u70b9\uff0cfa[ x ] \u8868\u793a\u8fd9\u4e2a\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u3002 \u539f\u7406 \u00b6 \u521d\u59cb\u5316 \u00b6 \u8d77\u59cb\u72b6\u6001\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u662f\u81ea\u6210\u4e00\u4e2a\u96c6\u5408 1 2 3 for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } \u67e5\u627e \u00b6 \u6211\u4eec\u5e0c\u671b\u5728\u8fd9\u4e00\u6b65\u53ef\u4ee5\u5feb\u901f\u5730\u627e\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u6839\u7ed3\u70b9 1 2 3 int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } \u8fd9\u91cc\u7528\u5230\u4e86 \u8def\u5f84\u538b\u7f29 \u7684\u65b9\u6cd5\u3002\u5728\u5bfb\u627e\u6839\u7ed3\u70b9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c06\u6240\u6709\u7684\u5b50\u8282\u70b9\u8fde\u63a5\u5230\u6839\u7ed3\u70b9\u3002 \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix} \u5408\u5e76 \u00b6 \u7531\u4e8e\u67d0\u4e9b\u7ea6\u675f\uff0c\u4e24\u4e2a\u539f\u672c\u4e0d\u76f8\u4ea4\u7684\u96c6\u5408\u53d1\u751f\u4e86\u8054\u7cfb\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u9700\u8981\u5c06\u5176\u4e2d\u7684\u4e00\u4e2a\u96c6\u5408\u5408\u5e76\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u3002 \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} 1 2 3 void Union ( int x , int y ) { fa [ find ( x )] = find ( y ); } \u8fd9\u91cc\u6211\u4eec\u5904\u7406\u5730\u6bd4\u8f83\u7b80\u5355\uff0c\u5c06\u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u5f53\u4f5c\u53e6\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u7684\u5b69\u5b50\u3002\u5982\u679c\u6211\u4eec\u8003\u8651\u5c06\u6df1\u5ea6\u5c0f\u7684\u6811\u5408\u5e76\u5230\u6df1\u5ea6\u8f83\u5927\u7684\u6811\u4e0b\uff0c\u67e5\u8be2\u6548\u7387\u4f1a\u63d0\u9ad8\u3002\u8fd9\u79cd\u65b9\u6cd5\u6211\u4eec\u79f0\u4e4b\u4e3a \u6309\u79e9\u5408\u5e76 \u3002 1 2 3 4 5 6 7 8 9 10 11 void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } \u5f53\u7136\uff0c\u9664\u4e86\u6309\u7167\u6df1\u5ea6\u5408\u5e76\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u6309\u7167\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u5408\u5e76\u3002\u56e0\u4e3a\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u548c\u6df1\u5ea6\u4e0d\u603b\u4f1a\u51fa\u73b0\u7684\u540c\u4e00\u4fa7\uff08\u5373\u4e00\u4e2a\u96c6\u5408\u7684\u7ed3\u70b9\u6570\u76ee\u591a\u4e14\u6df1\u5ea6\u5927\uff09\uff0c\u6211\u4eec\u901a\u5e38\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u4f5c\u4e3a\u5408\u5e76\u7684\u4f9d\u636e\u3002 \u9898\u76ee \u00b6 \u670b\u53cb\u5708\u95ee\u9898 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a n \\times n n \\times n \u7684\u77e9\u9635 friends\uff0cfriends[ i ][ j ] = 1 \u8868\u793a i \u548c j \u4e3a\u670b\u53cb\uff0c\u53cd\u4e4b\uff0c\u8868\u793a\u975e\u670b\u53cb\uff0c\u6839\u636e\u8fd9\u4e2a\u77e9\u9635\u627e\u51fa\u5f53\u524d\u8fd9 n \u4e2a\u4eba\u4e2d\u6709\u51e0\u4e2a\u670b\u53cb\u5708\u3002\u4f8b\u5982\uff0cA \u4e0e B \u662f\u670b\u53cb\uff0cB \u4e0e C \u662f\u670b\u53cb\uff0c\u90a3\u4e48A\u3001B\u3001C \u662f\u4e00\u4e2a\u670b\u53cb\u5708\u7684\uff0c\u5373\u4fbf\u662fA \u4e0e C \u4e0d\u662f\u670b\u53cb\u3002 \u300c\u5206\u6790\u300d \u8fd9\u662f\u5178\u578b\u7684\u5e76\u67e5\u96c6\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u5c06\u6bcf\u4e00\u4e2a\u4eba\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u670b\u53cb\u5708\uff0c\u5982\u679c\u4e24\u4eba\u662f\u670b\u53cb\u5c31\u5c06\u8fd9\u4e24\u4eba\u6240\u5728\u7684\u96c6\u5408\u5408\u5e76\uff0c\u6700\u7ec8\u53ea\u9700\u8981\u7edf\u8ba1 fa[ i ] == i \u7684\u4e2a\u6570\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > fa , dep ; int find ( int x ) { if ( x != fa [ x ]) { fa [ x ] = find ( fa [ x ]); dep [ x ] = 1 ; } dep [ fa [ x ]] = 2 ; return fa [ x ]; } void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } int findCircleNum ( vector < vector < int >>& isConnected ) { int n = ( int ) isConnected . size (); if ( n < 2 ) { return n ; } fa . resize ( n , 0 ); dep . resize ( n , 1 ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isConnected [ i ][ j ]) { unify ( i , j ); } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i == fa [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2} \\log n) O(n^{2} \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u5e76\u67e5\u96c6"},{"location":"data-structure/unionset/#_1","text":"\u5e76\u67e5\u96c6\u662f\u4e00\u79cd\u6811\u5f62\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u8981\u5904\u7406\u4e0d\u4ea4\u96c6\u7684\u67e5\u8be2\u548c\u5408\u5e76\u95ee\u9898\uff0c\u5b83\u6709\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff1a \u67e5\u627e\uff08Find\uff09\uff1a\u786e\u5b9a\u5f53\u524d\u7ed3\u70b9\u5c5e\u4e8e\u54ea\u4e00\u4e2a\u96c6\u5408 \u5408\u5e76\uff08Union\uff09\uff1a\u5c06\u4e24\u4e2a\u4e0d\u540c\u7684\u96c6\u5408\u5408\u5e76\u5728\u4e00\u8d77 \u6211\u4eec\u901a\u5e38\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4 fa[ x ] \uff0c\u4e0b\u6807 x \u4ee3\u8868\u67d0\u4e00\u4e2a\u7ed3\u70b9\uff0cfa[ x ] \u8868\u793a\u8fd9\u4e2a\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/unionset/#_2","text":"","title":"\u539f\u7406"},{"location":"data-structure/unionset/#_3","text":"\u8d77\u59cb\u72b6\u6001\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u662f\u81ea\u6210\u4e00\u4e2a\u96c6\u5408 1 2 3 for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; }","title":"\u521d\u59cb\u5316"},{"location":"data-structure/unionset/#_4","text":"\u6211\u4eec\u5e0c\u671b\u5728\u8fd9\u4e00\u6b65\u53ef\u4ee5\u5feb\u901f\u5730\u627e\u5230\u5f53\u524d\u7ed3\u70b9\u7684\u6839\u7ed3\u70b9 1 2 3 int find ( int x ) { return x != fa [ x ] ? fa [ x ] = find ( fa [ x ]) : x ; } \u8fd9\u91cc\u7528\u5230\u4e86 \u8def\u5f84\u538b\u7f29 \u7684\u65b9\u6cd5\u3002\u5728\u5bfb\u627e\u6839\u7ed3\u70b9\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c06\u6240\u6709\u7684\u5b50\u8282\u70b9\u8fde\u63a5\u5230\u6839\u7ed3\u70b9\u3002 \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & \\nearrow & & & & & \\nwarrow \\\\ & & & 2 & & & & & & & 3 \\\\ & & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ & 4 & & & & 5 & & & 6 & & & & & 7 \\\\ & & & & \\nearrow & & \\nwarrow \\\\ & & & 8 & & & & 9 \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u8def\u5f84\u538b\u7f29} \\\\ \\\\ \\begin{matrix} & & 9 & & & 2 & & & 3\\\\ & & & \\searrow & & \\downarrow & & \\swarrow \\\\ & & 8 & \\rightarrow & & 1 & & \\leftarrow & 4 \\\\ & & & \\nearrow && \\uparrow & & \\nwarrow \\\\ & & 7 & & & 6 & & & 5 \\end{matrix} \\end{matrix}","title":"\u67e5\u627e"},{"location":"data-structure/unionset/#_5","text":"\u7531\u4e8e\u67d0\u4e9b\u7ea6\u675f\uff0c\u4e24\u4e2a\u539f\u672c\u4e0d\u76f8\u4ea4\u7684\u96c6\u5408\u53d1\u751f\u4e86\u8054\u7cfb\uff0c\u8fd9\u4e2a\u65f6\u5019\uff0c\u9700\u8981\u5c06\u5176\u4e2d\u7684\u4e00\u4e2a\u96c6\u5408\u5408\u5e76\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u3002 \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} \\begin{matrix} \\begin{matrix} & & & & & & & & & {\\color{Blue} 1} \\\\ & & & & & & & & & \\uparrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\\\ \\\\ \\Downarrow \\text{\u5408\u5e76} \\\\ \\begin{matrix} & & & & & {\\color{Blue} 1} \\\\ & & & \\nearrow & & & & & \\nwarrow \\\\ & & {\\color{Red} 2} & & & & & & & {\\color{Blue} 3} \\\\ & \\nearrow & & \\nwarrow & & & & & \\nearrow & & & \\nwarrow \\\\ {\\color{Red} 4} & & & & {\\color{Red} 5} & & & {\\color{Blue} 6} & & & & & {\\color{Blue} 7} \\\\ \\end{matrix} \\end{matrix} 1 2 3 void Union ( int x , int y ) { fa [ find ( x )] = find ( y ); } \u8fd9\u91cc\u6211\u4eec\u5904\u7406\u5730\u6bd4\u8f83\u7b80\u5355\uff0c\u5c06\u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u5f53\u4f5c\u53e6\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u7ed3\u70b9\u7684\u5b69\u5b50\u3002\u5982\u679c\u6211\u4eec\u8003\u8651\u5c06\u6df1\u5ea6\u5c0f\u7684\u6811\u5408\u5e76\u5230\u6df1\u5ea6\u8f83\u5927\u7684\u6811\u4e0b\uff0c\u67e5\u8be2\u6548\u7387\u4f1a\u63d0\u9ad8\u3002\u8fd9\u79cd\u65b9\u6cd5\u6211\u4eec\u79f0\u4e4b\u4e3a \u6309\u79e9\u5408\u5e76 \u3002 1 2 3 4 5 6 7 8 9 10 11 void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } \u5f53\u7136\uff0c\u9664\u4e86\u6309\u7167\u6df1\u5ea6\u5408\u5e76\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u6309\u7167\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u5408\u5e76\u3002\u56e0\u4e3a\u6811\u7684\u7ed3\u70b9\u6570\u76ee\u548c\u6df1\u5ea6\u4e0d\u603b\u4f1a\u51fa\u73b0\u7684\u540c\u4e00\u4fa7\uff08\u5373\u4e00\u4e2a\u96c6\u5408\u7684\u7ed3\u70b9\u6570\u76ee\u591a\u4e14\u6df1\u5ea6\u5927\uff09\uff0c\u6211\u4eec\u901a\u5e38\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u4f5c\u4e3a\u5408\u5e76\u7684\u4f9d\u636e\u3002","title":"\u5408\u5e76"},{"location":"data-structure/unionset/#_6","text":"","title":"\u9898\u76ee"},{"location":"data-structure/unionset/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a n \\times n n \\times n \u7684\u77e9\u9635 friends\uff0cfriends[ i ][ j ] = 1 \u8868\u793a i \u548c j \u4e3a\u670b\u53cb\uff0c\u53cd\u4e4b\uff0c\u8868\u793a\u975e\u670b\u53cb\uff0c\u6839\u636e\u8fd9\u4e2a\u77e9\u9635\u627e\u51fa\u5f53\u524d\u8fd9 n \u4e2a\u4eba\u4e2d\u6709\u51e0\u4e2a\u670b\u53cb\u5708\u3002\u4f8b\u5982\uff0cA \u4e0e B \u662f\u670b\u53cb\uff0cB \u4e0e C \u662f\u670b\u53cb\uff0c\u90a3\u4e48A\u3001B\u3001C \u662f\u4e00\u4e2a\u670b\u53cb\u5708\u7684\uff0c\u5373\u4fbf\u662fA \u4e0e C \u4e0d\u662f\u670b\u53cb\u3002 \u300c\u5206\u6790\u300d \u8fd9\u662f\u5178\u578b\u7684\u5e76\u67e5\u96c6\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u5c06\u6bcf\u4e00\u4e2a\u4eba\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u670b\u53cb\u5708\uff0c\u5982\u679c\u4e24\u4eba\u662f\u670b\u53cb\u5c31\u5c06\u8fd9\u4e24\u4eba\u6240\u5728\u7684\u96c6\u5408\u5408\u5e76\uff0c\u6700\u7ec8\u53ea\u9700\u8981\u7edf\u8ba1 fa[ i ] == i \u7684\u4e2a\u6570\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 vector < int > fa , dep ; int find ( int x ) { if ( x != fa [ x ]) { fa [ x ] = find ( fa [ x ]); dep [ x ] = 1 ; } dep [ fa [ x ]] = 2 ; return fa [ x ]; } void unify ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( dep [ fx ] < dep [ fy ]) { fa [ fx ] = fy ; dep [ fy ] = max ( dep [ fy ], dep [ fx ] + 1 ); } else { fa [ fy ] = fx ; dep [ fx ] = max ( dep [ fx ], dep [ fy ] + 1 ); } } int findCircleNum ( vector < vector < int >>& isConnected ) { int n = ( int ) isConnected . size (); if ( n < 2 ) { return n ; } fa . resize ( n , 0 ); dep . resize ( n , 1 ); for ( int i = 0 ; i < n ; i ++ ) { fa [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isConnected [ i ][ j ]) { unify ( i , j ); } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i == fa [ i ]); } return ans ; } \u65f6\u95f4\u590d\u6742\u5ea6 O(n^{2} \\log n) O(n^{2} \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"\u670b\u53cb\u5708\u95ee\u9898"},{"location":"data-structure/tree/basis/","text":"\u7b80\u4ecb \u00b6 \u6811\u662f\u4e00\u79cd\u975e\u7ebf\u6027\uff08\u53ef\u9000\u5316\u6210\u7ebf\u6027\uff09\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7531\u9876\u70b9\u548c\u8fb9\u7ec4\u6210\uff0c\u4e0d\u5b58\u5728\u4efb\u4f55\u73af\u3002\u6ca1\u6709\u4efb\u4f55\u7ed3\u70b9\u7684\u6811\u53eb\u505a\u7a7a\u6811\u3002 \u672f\u8bed \u00b6 \u6839\u7ed3\u70b9 \u5b69\u5b50\u7ed3\u70b9 \u7236\u7ed3\u70b9 \u5144\u5f1f\u7ed3\u70b9\uff1a\u540c\u4e00\u4e2a\u7236\u7ed3\u70b9\u7684\u5b69\u5b50\u7ed3\u70b9 \u7956\u5148\uff1a\u4ece\u6839\u7ed3\u70b9\u5230\u8be5\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7ed3\u70b9 \u5b50\u5b59\uff1a\u4ee5\u8be5\u7ed3\u70b9\u4e3a\u6839\u7ed3\u70b9\u7684\u6240\u6709\u7ed3\u70b9 \u53f6\u5b50\u7ed3\u70b9\uff1a\u6ca1\u6709\u5b69\u5b50\u7ed3\u70b9\u6216\u5b69\u5b50\u7ed3\u70b9\u4e3a null \u7684\u7ed3\u70b9 \u5ea6\uff1a\u4e0e\u7ed3\u70b9\u76f8\u8fde\u63a5\u7684\u8fb9\u6570\uff0c\u5206\u4e3a\u51fa\u5ea6\u548c\u5165\u5ea6 \u6df1\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u7ed3\u70b9\u7684\u4e2a\u6570 \u9ad8\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u8fb9\u7684\u4e2a\u6570 \u79cd\u7c7b \u00b6 \u4e8c\u53c9\u6811 \u591a\u53c9\u6811 \u5e73\u8861\u6811 B-\u6811 \u7ea2\u9ed1\u6811","title":"\u57fa\u7840"},{"location":"data-structure/tree/basis/#_1","text":"\u6811\u662f\u4e00\u79cd\u975e\u7ebf\u6027\uff08\u53ef\u9000\u5316\u6210\u7ebf\u6027\uff09\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7531\u9876\u70b9\u548c\u8fb9\u7ec4\u6210\uff0c\u4e0d\u5b58\u5728\u4efb\u4f55\u73af\u3002\u6ca1\u6709\u4efb\u4f55\u7ed3\u70b9\u7684\u6811\u53eb\u505a\u7a7a\u6811\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/tree/basis/#_2","text":"\u6839\u7ed3\u70b9 \u5b69\u5b50\u7ed3\u70b9 \u7236\u7ed3\u70b9 \u5144\u5f1f\u7ed3\u70b9\uff1a\u540c\u4e00\u4e2a\u7236\u7ed3\u70b9\u7684\u5b69\u5b50\u7ed3\u70b9 \u7956\u5148\uff1a\u4ece\u6839\u7ed3\u70b9\u5230\u8be5\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6240\u6709\u7ed3\u70b9 \u5b50\u5b59\uff1a\u4ee5\u8be5\u7ed3\u70b9\u4e3a\u6839\u7ed3\u70b9\u7684\u6240\u6709\u7ed3\u70b9 \u53f6\u5b50\u7ed3\u70b9\uff1a\u6ca1\u6709\u5b69\u5b50\u7ed3\u70b9\u6216\u5b69\u5b50\u7ed3\u70b9\u4e3a null \u7684\u7ed3\u70b9 \u5ea6\uff1a\u4e0e\u7ed3\u70b9\u76f8\u8fde\u63a5\u7684\u8fb9\u6570\uff0c\u5206\u4e3a\u51fa\u5ea6\u548c\u5165\u5ea6 \u6df1\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u7ed3\u70b9\u7684\u4e2a\u6570 \u9ad8\u5ea6\uff1a\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u8fb9\u7684\u4e2a\u6570","title":"\u672f\u8bed"},{"location":"data-structure/tree/basis/#_3","text":"\u4e8c\u53c9\u6811 \u591a\u53c9\u6811 \u5e73\u8861\u6811 B-\u6811 \u7ea2\u9ed1\u6811","title":"\u79cd\u7c7b"},{"location":"data-structure/tree/binary-tree/","text":"\u7b80\u4ecb \u00b6 \u4e8c\u53c9\u6811\u662f\u6811\u7684\u4e00\u79cd\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u6700\u591a\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\u3002 \u6027\u8d28 \u00b6 \u5018\u82e5\u6839\u7ed3\u70b9\u5728\u7b2c 0 \u5c42\uff0c\u90a3\u4e48\u6bcf\u4e00\u5c42\u7684\u7ed3\u70b9\u6570\u76ee\u6700\u591a\u6709 2^{i} 2^{i} \u4e2a\u3002 \u4e00\u68f5\u6811\u7684\u6df1\u5ea6\u4e3a d\uff0c\u90a3\u4e48\u5b83\u6700\u591a\u6709 2^{d} - 1 2^{d} - 1 \u4e2a\u7ed3\u70b9 \u5982\u679c\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u662f n\uff0c\u90a3\u4e48\u6709\u4e24\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9\u4e2a\u6570\u4e3a n - 1 \u5b8c\u5168\u4e8c\u53c9\u6811\u3001\u5b8c\u6ee1\u4e8c\u53c9\u6811\u548c\u5b8c\u7f8e\u4e8c\u53c9\u6811 \u00b6 A Complete Binary Tree\uff08CBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. \u5b8c\u5168\u4e8c\u53c9\u6811\uff08complete binary tree\uff09\u9664\u4e86\u6700\u540e\u4e00\u5c42\u5916\u5168\u90e8\u586b\u6ee1\uff0c\u6700\u540e\u4e00\u5c42\u7684\u7ed3\u70b9\u9760\u5de6\u586b\u5145 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children. \u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u662f 2\u3002 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} A Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2. \u5b8c\u7f8e\u4e8c\u53c9\u6811\uff08perfec binary tree\uff09\u6240\u6709\u7684\u53f6\u5b50\u7ed3\u70b9\u5904\u4e8e\u540c\u4e00\u5c42\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f 2\u3002 \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix}","title":"\u4e8c\u53c9\u6811"},{"location":"data-structure/tree/binary-tree/#_1","text":"\u4e8c\u53c9\u6811\u662f\u6811\u7684\u4e00\u79cd\uff0c\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u6700\u591a\u6709\u4e24\u4e2a\u5b69\u5b50\u7ed3\u70b9\u3002","title":"\u7b80\u4ecb"},{"location":"data-structure/tree/binary-tree/#_2","text":"\u5018\u82e5\u6839\u7ed3\u70b9\u5728\u7b2c 0 \u5c42\uff0c\u90a3\u4e48\u6bcf\u4e00\u5c42\u7684\u7ed3\u70b9\u6570\u76ee\u6700\u591a\u6709 2^{i} 2^{i} \u4e2a\u3002 \u4e00\u68f5\u6811\u7684\u6df1\u5ea6\u4e3a d\uff0c\u90a3\u4e48\u5b83\u6700\u591a\u6709 2^{d} - 1 2^{d} - 1 \u4e2a\u7ed3\u70b9 \u5982\u679c\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u53f6\u5b50\u7ed3\u70b9\u4e2a\u6570\u662f n\uff0c\u90a3\u4e48\u6709\u4e24\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9\u4e2a\u6570\u4e3a n - 1","title":"\u6027\u8d28"},{"location":"data-structure/tree/binary-tree/#_3","text":"A Complete Binary Tree\uff08CBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. \u5b8c\u5168\u4e8c\u53c9\u6811\uff08complete binary tree\uff09\u9664\u4e86\u6700\u540e\u4e00\u5c42\u5916\u5168\u90e8\u586b\u6ee1\uff0c\u6700\u540e\u4e00\u5c42\u7684\u7ed3\u70b9\u9760\u5de6\u586b\u5145 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & \\text{null} \\end{matrix} A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children. \u5b8c\u6ee1\u4e8c\u53c9\u6811\uff08full binary tree\uff09\u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u662f 2\u3002 \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & 1 \\\\ & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & & & & & \\wedge & & & & & & & & \\wedge \\\\ & & & & 8 & & 9 & & & & & & 14 & & 15 \\end{matrix} A Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2. \u5b8c\u7f8e\u4e8c\u53c9\u6811\uff08perfec binary tree\uff09\u6240\u6709\u7684\u53f6\u5b50\u7ed3\u70b9\u5904\u4e8e\u540c\u4e00\u5c42\uff0c\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f 2\u3002 \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix} \\begin{matrix} & & & & & & & 1 \\\\ & & & & & & & \\wedge \\\\ & & & 2 & & & & & & & & 3 \\\\ & & & \\wedge & & & & & & & & \\wedge \\\\ & 4 & & & & 5 & & & & 6 & & & & 7 \\\\ & \\wedge & & & & \\wedge & & & & \\wedge & & & & \\wedge \\\\ 8 & & 9 & & 10 & & 11 & & 12 & & 13 & & 14 & & 15 \\end{matrix}","title":"\u5b8c\u5168\u4e8c\u53c9\u6811\u3001\u5b8c\u6ee1\u4e8c\u53c9\u6811\u548c\u5b8c\u7f8e\u4e8c\u53c9\u6811"},{"location":"machine-learning/decision-tree/","text":"ID3 \u00b6 \\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned} \\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned} C4.5 \u00b6 g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)} g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)} CART \u00b6 \u5206\u7c7b\u6811 \u00b6 \\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned} \\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned} \u51b3\u7b56\u6811 \u00b6","title":"\u51b3\u7b56\u6811"},{"location":"machine-learning/decision-tree/#id3","text":"\\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned} \\begin{aligned} & H(p) = -\\sum_{i=1}^{N} p_{i} \\log p_{i} \\\\ & H(D) = -\\sum_{k=1}^{K} \\frac{C_{k}}{D} \\log \\frac{C_{k}}{D} \\\\ & H(D \\mid A) = \\sum_{i=1}^{N} \\frac{D_{i}}{D} H(D_{i}) = -\\sum_{i=1}^{N} \\frac{D_{i}}{D} \\sum_{k=1}^{K} \\frac{D_{ik}}{D_{i}} \\log \\frac{D_{ik}}{D_{i}} \\\\ & g(D, A) = H(D) - H(D \\mid A) \\end{aligned}","title":"ID3"},{"location":"machine-learning/decision-tree/#c45","text":"g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)} g_{R}(D, A) = \\frac{H(D) - H(D \\mid A)}{H(D)}","title":"C4.5"},{"location":"machine-learning/decision-tree/#cart","text":"","title":"CART"},{"location":"machine-learning/decision-tree/#_1","text":"\\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned} \\begin{aligned} & \\text{Gini}(p) = \\sum_{k=1}^{K} p_{k} (1 - p_{k}) = 1 - \\sum_{k=1}^{K} p_{k}^{2} \\\\ & \\text{Gini}(p) = 2p(1-p) \\\\ & \\text{Gini}(D) = 1 - \\sum_{k=1}^{K} (\\frac{C_{k}}{D})^{2} \\\\ & D_{1} = \\{(x, y) \\in D \\mid A(x) = a\\}, \\quad D_{2} = D - D_{1} \\\\ & \\text{Gini}(D, A) = \\frac{D_{1}}{D} \\text{Gini}(D_{1}) + \\frac{D_{2}}{D} \\text{Gini}(D_{2}) \\end{aligned}","title":"\u5206\u7c7b\u6811"},{"location":"machine-learning/decision-tree/#_2","text":"","title":"\u51b3\u7b56\u6811"},{"location":"machine-learning/roc/","text":"\u7b80\u4ecb \u00b6 \u63a5\u6536\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7dda\uff08receiver operating characteristic curve\uff0c\u7b80\u79f0ROC\uff09\u662f\u4e00\u79cd\u9009\u62e9\u6700\u4f73\u6a21\u578b\u7684\u5750\u6807\u56fe\u5f0f\u5206\u6790\u5de5\u5177\u3002 \u672f\u8bed \u00b6 \u9633\u6027 P\uff08positive\uff09 \u9634\u6027 N \uff08negative\uff09 \u771f\u9633\u6027 TP \uff08true positive\uff09 \u771f\u9634\u6027 TN \uff08true negative\uff09 \u5047\u9633\u6027 FP \uff08false positive\uff09 \u5047\u9634\u6027 FN \uff08false negative\uff09 \u7cbe\u786e\u5ea6 \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \u53ec\u56de\u7387/\u771f\u9633\u6027\u7387 \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \u5047\u9633\u6027\u7387 \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \u51c6\u786e\u5ea6 \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} P N T TP FN F FP TN AUC \u00b6 AUC \u5168\u79f0\u662f area under curve \uff0c\u6307\u7684\u662f\u63a5\u53d7\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7ebf\u4e0b\u7684\u9762\u79ef\u3002 \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix} \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix} \u7269\u7406\u542b\u4e49 \u00b6 \u4efb\u610f\u53d6\u4e00\u4e2a\u6b63\u6837\u672c\u548c\u4e00\u4e2a\u8d1f\u6837\u672c\u7ec4\u6210\u4e00\u4e2a\u6837\u672c\u5bf9 (p_{i}, n_{i}) (p_{i}, n_{i}) \uff0c\u4f7f\u7528\u8bad\u7ec3\u597d\u7684\u6a21\u578b\u5bf9\u8fd9\u4e00\u5bf9\u968f\u673a\u6837\u672c\u8fdb\u884c\u9884\u6d4b\uff0c\u5224\u65ad \u6b63\u6837\u672c p_{i} p_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{1} p_{1} \uff0c\u5224\u65ad\u8d1f\u6837\u672c n_{i} n_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{0} p_{0} \uff0cauc \u7684\u5927\u5c0f\u5373\u4e3a p_{1} p_{1} \u5927\u4e8e p_{0} p_{0} \u7684\u6982\u7387 \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \u5047\u8bbe\u6211\u4eec\u7684\u5206\u7c7b\u5668\u662f\u4e00\u4e2a\u968f\u673a\u5206\u7c7b\u5668\uff0c\u5bf9\u6b63\u8d1f\u6837\u672c\u7684\u5212\u5206\u6982\u7387\u662f\u4e00\u6837\u7684\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5206\u7c7b\u5668\u7684 AUC \u5c31\u662f0.5\u3002 AUC \u4e0d\u53d7\u5212\u5206\u6b63\u8d1f\u6837\u672c\u7684\u9608\u503c\u5f71\u54cd\uff0c\u4e5f\u4e0d\u53d7\u6b63\u8d1f\u6837\u672c\u7684\u4e0d\u5747\u5f71\u54cd\uff0c\u4f46\u662f\u53ea\u9002\u5408\u4e8c\u5206\u7c7b\u7684\u95ee\u9898\u3002 \u8ba1\u7b97\u65b9\u6cd5 \u00b6 \u300c\u6b63\u8d1f\u6837\u672c\u5bf9\u300d \u6211\u4eec\u53ef\u4ee5\u6839\u636eAUC\u7684\u7269\u7406\u542b\u4e49\u6c42\u89e3\uff0c\u7a77\u4e3e\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\u5bf9\uff0c\u7136\u540e\u8ba1\u7b97\u6b63\u6837\u672c\u7684\u9884\u6d4b\u503c\u5927\u4e8e\u8d1f\u6837\u672c\u9884\u6d4b\u503c\u7684\u6982\u7387\u3002 \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 double auc1 ( vector < double > predict , vector < int > label ) { int n = ( int ) predict . size (); int n1 = 0 , n0 = 0 ; double I = 0.0 ; vector < double > p1 , p0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( label [ i ]) { p1 . emplace_back ( predict [ i ]); n1 ++ ; } else { p0 . emplace_back ( predict [ i ]); n0 ++ ; } } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < n0 ; j ++ ) { if ( p1 [ i ] > p0 [ j ]) { I += 1 ; } else if ( p1 [ i ] == p0 [ j ]) { I += 0.5 ; } } } return I / ( n1 * n0 ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n_{1} n_{0}) O(n_{1} n_{0}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n_{1} + n_{0}) O(n_{1} + n_{0}) \uff0c\u5176\u4e2d n_{1} n_{1} \u548c n_{0} n_{0} \u5206\u522b\u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee \u300c\u6392\u5e8f\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u5c06\u9884\u6d4b\u503c\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u6392\u5217\uff0c\u53ef\u4f7f\u7528\u5982\u4e0b\u516c\u5f0f \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \u6211\u4eec\u53ea\u9700\u8981\u8ba1\u7b97\u6b63\u6837\u672c\u5728\u6392\u5e8f\u540e\u7684\u5217\u8868\u91cc\u9762\u7684\u5e8f\u53f7\uff08\u79e9\uff09\uff0c\u4ece 1 \u5f00\u59cb\u3002\u5982\u679c\u51fa\u73b0\u6b63\u8d1f\u6837\u672c\u5177\u6709\u76f8\u540c\u7684\u9884\u6d4b\u5206\u503c\uff0c\u90a3\u4e48\u9700\u8981\u6c42\u8fd9\u4e9b\u6b63\u8d1f\u6837\u672c\u7684\u5e73\u5747\u79e9\u4e58\u4ee5\u540c\u5206\u503c\u4e2d\u6b63\u6837\u672c\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 double auc2 ( vector < double > predict , vector < int > label ) { vector < pair < double , int >> data ; int n = ( int ) predict . size (); for ( int i = 0 ; i < n ; i ++ ) { data . emplace_back ( pair < double , int > { predict [ i ], label [ i ]}); } sort ( data . begin (), data . end (), []( const pair < double , int > & x , pair < double , int > & y ) { return x . first < y . first || ( x . first == y . first && x . second > y . second ); }); int row = 0 , rankPos = 0 , rankNeg = 0 , numPos = 0 , numNeg = 0 , totPosSam = 0 ; double cnt = 0 ; double lastScore = - 0.1 ; // \u6700\u540e\u6dfb\u52a0\u4e00\u4e2a\u6570\u5bf9\u6807\u5fd7\u7ed3\u675f\uff0c\u4e0d\u53c2\u4e0e\u8ba1\u7b97 data . emplace_back ( pair < double , int > { - 0.1 , - 1 }); for ( auto d : data ) { row ++ ; if ( lastScore != d . first && row > 1 ) { lastScore = d . first ; cnt += double ( rankPos + rankNeg ) / ( numPos + numNeg ) * numPos ; rankPos = rankNeg = numPos = numNeg = 0 ; } if ( d . second == 1 ) { rankPos += row ; numPos ++ ; totPosSam ++ ; } else { rankNeg += row ; numNeg ++ ; } } return ( cnt - totPosSam * ( totPosSam + 1 ) / 2.0 ) / ( totPosSam * ( n - totPosSam )); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c \u300c\u5206\u6876\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u6982\u7387\u7684\u8303\u56f4\u662f [0, 1]\uff0c\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528\u5206\u6876\u65b9\u6cd5\u7edf\u8ba1\u6bcf\u4e00\u4e2a\u6837\u672c\u9884\u6d4b\u503c\u843d\u5728\u54ea\u4e2a\u6876\u5185\uff08\u533a\u95f4\uff09\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a hist \u7528\u6765\u7edf\u8ba1\u9884\u6d4b\u503c\u843d\u5728\u67d0\u4e2a\u6876\u5185\u7684\u4e2a\u6570\u3002\u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6982\u7387\u5bf9\uff0c\u5047\u8bbe\u9884\u6d4b\u503c\u4e3a 0.8 \u7684\u6b63\u6837\u672c\u6709 10 \u4e2a\uff0c\u90a3\u4e48\u4f4e\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u603b\u6570\u4e58\u4ee5 10 \u5373\u4e3a\u8fd9\u4e00\u9884\u6d4b\u503c\u7684\u6982\u7387\u5bf9\uff0c\u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u5e94\u8be5\u8ba1\u7b97\u9884\u6d4b\u503c\u7b49\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u6570\uff0c\u5047\u8bbe\u4e3a 8\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6b64\u65f6\u6b63\u8d1f\u6837\u672c\u6982\u7387\u76f8\u7b49\uff0c\u9700\u8981\u53d6\u4e00\u534a\uff0c\u5373 8 * 10 / 2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 double auc3 ( vector < double > predict , vector < int > label , int bins = 100 ) { // \u65f6\u95f4\u590d\u6742\u5ea6O(n) int cnt_pos = 0 , cnt_neg = 0 ; int n = ( int ) predict . size (); vector < int > pos_hist ( bins , 0 ), neg_hist ( bins , 0 ); double width = 1.0 / bins ; for ( int i = 0 ; i < n ; i ++ ) { int nth_bin = ( int )( predict [ i ] / width ); if ( label [ i ]) { cnt_pos ++ ; pos_hist [ nth_bin ] ++ ; } else { cnt_neg ++ ; neg_hist [ nth_bin ] ++ ; } } int accumulated_negative = 0 , satisfied_pair = 0 ; for ( int i = 0 ; i < bins ; i ++ ) { satisfied_pair += pos_hist [ i ] * accumulated_negative + pos_hist [ i ] * neg_hist [ i ] * 0.5 ; accumulated_negative += neg_hist [ i ]; } return satisfied_pair / double ( cnt_pos * cnt_neg ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c","title":"ROC"},{"location":"machine-learning/roc/#_1","text":"\u63a5\u6536\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7dda\uff08receiver operating characteristic curve\uff0c\u7b80\u79f0ROC\uff09\u662f\u4e00\u79cd\u9009\u62e9\u6700\u4f73\u6a21\u578b\u7684\u5750\u6807\u56fe\u5f0f\u5206\u6790\u5de5\u5177\u3002","title":"\u7b80\u4ecb"},{"location":"machine-learning/roc/#_2","text":"\u9633\u6027 P\uff08positive\uff09 \u9634\u6027 N \uff08negative\uff09 \u771f\u9633\u6027 TP \uff08true positive\uff09 \u771f\u9634\u6027 TN \uff08true negative\uff09 \u5047\u9633\u6027 FP \uff08false positive\uff09 \u5047\u9634\u6027 FN \uff08false negative\uff09 \u7cbe\u786e\u5ea6 \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \\text{precision} = \\frac{\\text{TP}}{\\text{TP + FP}} \u53ec\u56de\u7387/\u771f\u9633\u6027\u7387 \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \\text{recall / TPR} = \\frac{\\text{TP}}{\\text{TP + FN}} \u5047\u9633\u6027\u7387 \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \\text{FPR} = \\frac{\\text{FP}}{\\text{FP + TN}} \u51c6\u786e\u5ea6 \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} \\text{accuracy} = \\frac{\\text{TP + TN}}{\\text{TP + TN + FP + FN}} P N T TP FN F FP TN","title":"\u672f\u8bed"},{"location":"machine-learning/roc/#auc","text":"AUC \u5168\u79f0\u662f area under curve \uff0c\u6307\u7684\u662f\u63a5\u53d7\u8005\u64cd\u4f5c\u7279\u5f81\u66f2\u7ebf\u4e0b\u7684\u9762\u79ef\u3002 \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix} \\begin{matrix} \\text{TPR} \\\\ \\wedge \\\\ 1 & & & & & & & & & & & 1 \\\\ | & & & & & & & & & & \\bullet & | \\\\ | & & & & & & & & & \\bullet & & | \\\\ | & & & & & & & & \\bullet & & & | \\\\ | & & & & & & & \\bullet & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & & & & \\bullet & & & & & | \\\\ | & & & \\bullet & \\bullet & \\bullet & & & \\text{AUC} & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & & \\bullet & & & & & & & & & | \\\\ | & \\bullet & & & & & & & & & & | \\\\ 0 & - & - & - & - & - & - & - & - & - & - & 1 & -> \\text{FPR} \\end{matrix}","title":"AUC"},{"location":"machine-learning/roc/#_3","text":"\u4efb\u610f\u53d6\u4e00\u4e2a\u6b63\u6837\u672c\u548c\u4e00\u4e2a\u8d1f\u6837\u672c\u7ec4\u6210\u4e00\u4e2a\u6837\u672c\u5bf9 (p_{i}, n_{i}) (p_{i}, n_{i}) \uff0c\u4f7f\u7528\u8bad\u7ec3\u597d\u7684\u6a21\u578b\u5bf9\u8fd9\u4e00\u5bf9\u968f\u673a\u6837\u672c\u8fdb\u884c\u9884\u6d4b\uff0c\u5224\u65ad \u6b63\u6837\u672c p_{i} p_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{1} p_{1} \uff0c\u5224\u65ad\u8d1f\u6837\u672c n_{i} n_{i} \u4e3a\u6b63\u7684\u6982\u7387\u4e3a p_{0} p_{0} \uff0cauc \u7684\u5927\u5c0f\u5373\u4e3a p_{1} p_{1} \u5927\u4e8e p_{0} p_{0} \u7684\u6982\u7387 \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \\text{AUC} = \\mathbf{P}(p_{1} > p_{0}) \u5047\u8bbe\u6211\u4eec\u7684\u5206\u7c7b\u5668\u662f\u4e00\u4e2a\u968f\u673a\u5206\u7c7b\u5668\uff0c\u5bf9\u6b63\u8d1f\u6837\u672c\u7684\u5212\u5206\u6982\u7387\u662f\u4e00\u6837\u7684\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5206\u7c7b\u5668\u7684 AUC \u5c31\u662f0.5\u3002 AUC \u4e0d\u53d7\u5212\u5206\u6b63\u8d1f\u6837\u672c\u7684\u9608\u503c\u5f71\u54cd\uff0c\u4e5f\u4e0d\u53d7\u6b63\u8d1f\u6837\u672c\u7684\u4e0d\u5747\u5f71\u54cd\uff0c\u4f46\u662f\u53ea\u9002\u5408\u4e8c\u5206\u7c7b\u7684\u95ee\u9898\u3002","title":"\u7269\u7406\u542b\u4e49"},{"location":"machine-learning/roc/#_4","text":"\u300c\u6b63\u8d1f\u6837\u672c\u5bf9\u300d \u6211\u4eec\u53ef\u4ee5\u6839\u636eAUC\u7684\u7269\u7406\u542b\u4e49\u6c42\u89e3\uff0c\u7a77\u4e3e\u6240\u6709\u7684\u6b63\u8d1f\u6837\u672c\u5bf9\uff0c\u7136\u540e\u8ba1\u7b97\u6b63\u6837\u672c\u7684\u9884\u6d4b\u503c\u5927\u4e8e\u8d1f\u6837\u672c\u9884\u6d4b\u503c\u7684\u6982\u7387\u3002 \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} \\begin{aligned} & \\text{AUC} = \\frac{f(P_{\\text{postive}}, P_{\\text{negative}})}{N_{\\text{positive}} \\times N_{\\text{nagetive}}} \\\\ & f(P_{\\text{postive}}, P_{\\text{negative}}) = \\begin{cases} 1, & \\quad P_{\\text{postive}} > P_{\\text{negative}} \\\\ 0.5, & \\quad P_{\\text{postive}} = P_{\\text{negative}} \\\\ 0, & \\quad P_{\\text{postive}} < P_{\\text{negative}} \\end{cases} \\end{aligned} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 double auc1 ( vector < double > predict , vector < int > label ) { int n = ( int ) predict . size (); int n1 = 0 , n0 = 0 ; double I = 0.0 ; vector < double > p1 , p0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( label [ i ]) { p1 . emplace_back ( predict [ i ]); n1 ++ ; } else { p0 . emplace_back ( predict [ i ]); n0 ++ ; } } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < n0 ; j ++ ) { if ( p1 [ i ] > p0 [ j ]) { I += 1 ; } else if ( p1 [ i ] == p0 [ j ]) { I += 0.5 ; } } } return I / ( n1 * n0 ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n_{1} n_{0}) O(n_{1} n_{0}) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n_{1} + n_{0}) O(n_{1} + n_{0}) \uff0c\u5176\u4e2d n_{1} n_{1} \u548c n_{0} n_{0} \u5206\u522b\u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee \u300c\u6392\u5e8f\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u5c06\u9884\u6d4b\u503c\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u6392\u5217\uff0c\u53ef\u4f7f\u7528\u5982\u4e0b\u516c\u5f0f \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \\text{AUC} = \\frac{\\sum_{i \\in \\{+\\}} \\text{rank}_{i} - \\frac{n_{\\text{positive}} \\times (n_{\\text{positive}}+1)}{2}}{n_{\\text{positive}} \\times n_{\\text{negative}}} \u6211\u4eec\u53ea\u9700\u8981\u8ba1\u7b97\u6b63\u6837\u672c\u5728\u6392\u5e8f\u540e\u7684\u5217\u8868\u91cc\u9762\u7684\u5e8f\u53f7\uff08\u79e9\uff09\uff0c\u4ece 1 \u5f00\u59cb\u3002\u5982\u679c\u51fa\u73b0\u6b63\u8d1f\u6837\u672c\u5177\u6709\u76f8\u540c\u7684\u9884\u6d4b\u5206\u503c\uff0c\u90a3\u4e48\u9700\u8981\u6c42\u8fd9\u4e9b\u6b63\u8d1f\u6837\u672c\u7684\u5e73\u5747\u79e9\u4e58\u4ee5\u540c\u5206\u503c\u4e2d\u6b63\u6837\u672c\u7684\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 double auc2 ( vector < double > predict , vector < int > label ) { vector < pair < double , int >> data ; int n = ( int ) predict . size (); for ( int i = 0 ; i < n ; i ++ ) { data . emplace_back ( pair < double , int > { predict [ i ], label [ i ]}); } sort ( data . begin (), data . end (), []( const pair < double , int > & x , pair < double , int > & y ) { return x . first < y . first || ( x . first == y . first && x . second > y . second ); }); int row = 0 , rankPos = 0 , rankNeg = 0 , numPos = 0 , numNeg = 0 , totPosSam = 0 ; double cnt = 0 ; double lastScore = - 0.1 ; // \u6700\u540e\u6dfb\u52a0\u4e00\u4e2a\u6570\u5bf9\u6807\u5fd7\u7ed3\u675f\uff0c\u4e0d\u53c2\u4e0e\u8ba1\u7b97 data . emplace_back ( pair < double , int > { - 0.1 , - 1 }); for ( auto d : data ) { row ++ ; if ( lastScore != d . first && row > 1 ) { lastScore = d . first ; cnt += double ( rankPos + rankNeg ) / ( numPos + numNeg ) * numPos ; rankPos = rankNeg = numPos = numNeg = 0 ; } if ( d . second == 1 ) { rankPos += row ; numPos ++ ; totPosSam ++ ; } else { rankNeg += row ; numNeg ++ ; } } return ( cnt - totPosSam * ( totPosSam + 1 ) / 2.0 ) / ( totPosSam * ( n - totPosSam )); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c \u300c\u5206\u6876\u964d\u4f4e\u590d\u6742\u5ea6\u300d \u6982\u7387\u7684\u8303\u56f4\u662f [0, 1]\uff0c\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528\u5206\u6876\u65b9\u6cd5\u7edf\u8ba1\u6bcf\u4e00\u4e2a\u6837\u672c\u9884\u6d4b\u503c\u843d\u5728\u54ea\u4e2a\u6876\u5185\uff08\u533a\u95f4\uff09\u3002\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a hist \u7528\u6765\u7edf\u8ba1\u9884\u6d4b\u503c\u843d\u5728\u67d0\u4e2a\u6876\u5185\u7684\u4e2a\u6570\u3002\u6211\u4eec\u7684\u76ee\u6807\u662f\u6c42\u6982\u7387\u5bf9\uff0c\u5047\u8bbe\u9884\u6d4b\u503c\u4e3a 0.8 \u7684\u6b63\u6837\u672c\u6709 10 \u4e2a\uff0c\u90a3\u4e48\u4f4e\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u603b\u6570\u4e58\u4ee5 10 \u5373\u4e3a\u8fd9\u4e00\u9884\u6d4b\u503c\u7684\u6982\u7387\u5bf9\uff0c\u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u5e94\u8be5\u8ba1\u7b97\u9884\u6d4b\u503c\u7b49\u4e8e 0.8 \u7684\u8d1f\u6837\u672c\u6570\uff0c\u5047\u8bbe\u4e3a 8\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6b64\u65f6\u6b63\u8d1f\u6837\u672c\u6982\u7387\u76f8\u7b49\uff0c\u9700\u8981\u53d6\u4e00\u534a\uff0c\u5373 8 * 10 / 2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 double auc3 ( vector < double > predict , vector < int > label , int bins = 100 ) { // \u65f6\u95f4\u590d\u6742\u5ea6O(n) int cnt_pos = 0 , cnt_neg = 0 ; int n = ( int ) predict . size (); vector < int > pos_hist ( bins , 0 ), neg_hist ( bins , 0 ); double width = 1.0 / bins ; for ( int i = 0 ; i < n ; i ++ ) { int nth_bin = ( int )( predict [ i ] / width ); if ( label [ i ]) { cnt_pos ++ ; pos_hist [ nth_bin ] ++ ; } else { cnt_neg ++ ; neg_hist [ nth_bin ] ++ ; } } int accumulated_negative = 0 , satisfied_pair = 0 ; for ( int i = 0 ; i < bins ; i ++ ) { satisfied_pair += pos_hist [ i ] * accumulated_negative + pos_hist [ i ] * neg_hist [ i ] * 0.5 ; accumulated_negative += neg_hist [ i ]; } return satisfied_pair / double ( cnt_pos * cnt_neg ); } \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u5176\u4e2d n \u662f\u6b63\u8d1f\u6837\u672c\u7684\u6570\u76ee\u548c","title":"\u8ba1\u7b97\u65b9\u6cd5"}]}